/**
 * \file  memory.c
 * \brief Holds memory functions.
 */

#include "header.h"


void unittest_Firm_calc_production_quantity_Firm_Start_Producer_Role_01()
{
	
	
	//return Firm_calc_production_quantity();
}

void unittest_Firm_set_quantities_zero_Firm_Start_Producer_Role_00b()
{
	
	
	//return Firm_set_quantities_zero();
}

void unittest_Firm_calc_input_demands_01_02()
{
	int rc;
	
	
	rc = MB_Iterator_Create(b_productivity, &i_productivity);
	#ifdef ERRCHECK
	if (rc != MB_SUCCESS)
	{
	   fprintf(stderr, "ERROR: Could not create Iterator for 'productivity'\n");
	   switch(rc) {
	       case MB_ERR_INVALID:
	           fprintf(stderr, "\t reason: 'productivity' board is invalid\n");
	           break;
	       case MB_ERR_LOCKED:
               fprintf(stderr, "\t reason: 'productivity' board is locked\n");
               break;
           case MB_ERR_MEMALLOC:
               fprintf(stderr, "\t reason: out of memory\n");
               break;
           case MB_ERR_INTERNAL:
               fprintf(stderr, "\t reason: internal error. Recompile libmoard in debug mode for more info \n");
               break;
	   }
	}
	#endif
	
	//return Firm_calc_input_demands();
}

void unittest_Firm_calc_production_quantity_2_Firm_End_Financial_Management_Firm_Start_Labour_Role()
{
	
	
	//return Firm_calc_production_quantity_2();
}

void unittest_Firm_send_capital_demand_Firm_End_Labour_Role_11a()
{
	
	
	//return Firm_send_capital_demand();
}

void unittest_Firm_receive_capital_goods_11a_11b()
{
	int rc;
	
	rc = MB_Iterator_CreateFiltered(b_capital_good_delivery, &i_capital_good_delivery, &FLAME_filter_Firm_Firm_receive_capital_goods_11a_11b_capital_good_delivery, current_xmachine_Firm);
	
	#ifdef ERRCHECK
	if (rc != MB_SUCCESS)
	{
	   fprintf(stderr, "ERROR: Could not create Iterator for 'capital_good_delivery'\n");
	   switch(rc) {
	       case MB_ERR_INVALID:
	           fprintf(stderr, "\t reason: 'capital_good_delivery' board is invalid\n");
	           break;
	       case MB_ERR_LOCKED:
               fprintf(stderr, "\t reason: 'capital_good_delivery' board is locked\n");
               break;
           case MB_ERR_MEMALLOC:
               fprintf(stderr, "\t reason: out of memory\n");
               break;
           case MB_ERR_INTERNAL:
               fprintf(stderr, "\t reason: internal error. Recompile libmoard in debug mode for more info \n");
               break;
	   }
	}
	#endif
	
	//return Firm_receive_capital_goods();
}

void unittest_Firm_execute_production_11b_11()
{
	
	
	//return Firm_execute_production();
}

void unittest_Firm_calc_pay_costs_11_12()
{
	
	
	//return Firm_calc_pay_costs();
}

void unittest_Firm_send_goods_to_mall_12_Firm_Start_Seller_Role()
{
	
	
	//return Firm_send_goods_to_mall();
}

void unittest_Firm_calc_revenue_Firm_Start_Seller_Role_Firm_End_Seller_Role()
{
	int rc;
	
	rc = MB_Iterator_CreateFiltered(b_sales, &i_sales, &FLAME_filter_Firm_Firm_calc_revenue_Firm_Start_Seller_Role_Firm_End_Seller_Role_sales, current_xmachine_Firm);
	
	#ifdef ERRCHECK
	if (rc != MB_SUCCESS)
	{
	   fprintf(stderr, "ERROR: Could not create Iterator for 'sales'\n");
	   switch(rc) {
	       case MB_ERR_INVALID:
	           fprintf(stderr, "\t reason: 'sales' board is invalid\n");
	           break;
	       case MB_ERR_LOCKED:
               fprintf(stderr, "\t reason: 'sales' board is locked\n");
               break;
           case MB_ERR_MEMALLOC:
               fprintf(stderr, "\t reason: out of memory\n");
               break;
           case MB_ERR_INTERNAL:
               fprintf(stderr, "\t reason: internal error. Recompile libmoard in debug mode for more info \n");
               break;
	   }
	}
	#endif
	
	//return Firm_calc_revenue();
}

void unittest_idle_14_Firm_End_Financial_Management_Role()
{
	
	
	//return idle();
}

void unittest_Firm_compute_sales_statistics_14_Firm_Start_Financial_Management_Role()
{
	
	
	//return Firm_compute_sales_statistics();
}

void unittest_Firm_update_specific_skills_of_workers_Firm_End_Seller_Role_14()
{
	int rc;
	
	rc = MB_Iterator_CreateFiltered(b_specific_skill_update, &i_specific_skill_update, &FLAME_filter_Firm_Firm_update_specific_skills_of_workers_Firm_End_Seller_Role_14_specific_skill_update, current_xmachine_Firm);
	
	#ifdef ERRCHECK
	if (rc != MB_SUCCESS)
	{
	   fprintf(stderr, "ERROR: Could not create Iterator for 'specific_skill_update'\n");
	   switch(rc) {
	       case MB_ERR_INVALID:
	           fprintf(stderr, "\t reason: 'specific_skill_update' board is invalid\n");
	           break;
	       case MB_ERR_LOCKED:
               fprintf(stderr, "\t reason: 'specific_skill_update' board is locked\n");
               break;
           case MB_ERR_MEMALLOC:
               fprintf(stderr, "\t reason: out of memory\n");
               break;
           case MB_ERR_INTERNAL:
               fprintf(stderr, "\t reason: internal error. Recompile libmoard in debug mode for more info \n");
               break;
	   }
	}
	#endif
	
	//return Firm_update_specific_skills_of_workers();
}

void unittest_idle_Firm_End_Seller_Role_14()
{
	
	
	//return idle();
}

void unittest_Firm_receive_account_interest_Firm_interest_Firm_checks_if_active()
{
	int rc;
	
	
	rc = MB_Iterator_Create(b_account_interest, &i_account_interest);
	#ifdef ERRCHECK
	if (rc != MB_SUCCESS)
	{
	   fprintf(stderr, "ERROR: Could not create Iterator for 'account_interest'\n");
	   switch(rc) {
	       case MB_ERR_INVALID:
	           fprintf(stderr, "\t reason: 'account_interest' board is invalid\n");
	           break;
	       case MB_ERR_LOCKED:
               fprintf(stderr, "\t reason: 'account_interest' board is locked\n");
               break;
           case MB_ERR_MEMALLOC:
               fprintf(stderr, "\t reason: out of memory\n");
               break;
           case MB_ERR_INTERNAL:
               fprintf(stderr, "\t reason: internal error. Recompile libmoard in debug mode for more info \n");
               break;
	   }
	}
	#endif
	
	//return Firm_receive_account_interest();
}

void unittest_Firm_ask_loan_Firm_Start_Credit_Role_Firm_Credit_02()
{
	int rc;
	
	
	rc = MB_Iterator_Create(b_bank_identity, &i_bank_identity);
	#ifdef ERRCHECK
	if (rc != MB_SUCCESS)
	{
	   fprintf(stderr, "ERROR: Could not create Iterator for 'bank_identity'\n");
	   switch(rc) {
	       case MB_ERR_INVALID:
	           fprintf(stderr, "\t reason: 'bank_identity' board is invalid\n");
	           break;
	       case MB_ERR_LOCKED:
               fprintf(stderr, "\t reason: 'bank_identity' board is locked\n");
               break;
           case MB_ERR_MEMALLOC:
               fprintf(stderr, "\t reason: out of memory\n");
               break;
           case MB_ERR_INTERNAL:
               fprintf(stderr, "\t reason: internal error. Recompile libmoard in debug mode for more info \n");
               break;
	   }
	}
	#endif
	
	//return Firm_ask_loan();
}

void unittest_Firm_get_loan_Firm_Credit_02_Firm_End_Credit_Role()
{
	int rc;
	
	rc = MB_Iterator_CreateFiltered(b_loan_conditions, &i_loan_conditions, &FLAME_filter_Firm_Firm_get_loan_Firm_Credit_02_Firm_End_Credit_Role_loan_conditions, current_xmachine_Firm);
	
	#ifdef ERRCHECK
	if (rc != MB_SUCCESS)
	{
	   fprintf(stderr, "ERROR: Could not create Iterator for 'loan_conditions'\n");
	   switch(rc) {
	       case MB_ERR_INVALID:
	           fprintf(stderr, "\t reason: 'loan_conditions' board is invalid\n");
	           break;
	       case MB_ERR_LOCKED:
               fprintf(stderr, "\t reason: 'loan_conditions' board is locked\n");
               break;
           case MB_ERR_MEMALLOC:
               fprintf(stderr, "\t reason: out of memory\n");
               break;
           case MB_ERR_INTERNAL:
               fprintf(stderr, "\t reason: internal error. Recompile libmoard in debug mode for more info \n");
               break;
	   }
	}
	#endif
	
	//return Firm_get_loan();
}

void unittest_Firm_compute_financial_payments_Firm_End_Public_Sector_Role_001()
{
	
	
	//return Firm_compute_financial_payments();
}

void unittest_Firm_compute_income_statement_001_002()
{
	
	
	//return Firm_compute_income_statement();
}

void unittest_Firm_compute_dividends_002_003()
{
	
	
	//return Firm_compute_dividends();
}

void unittest_Firm_compute_total_financial_payments_003_004()
{
	
	
	//return Firm_compute_total_financial_payments();
}

void unittest_Firm_compute_balance_sheet_004_Firm_Bankruptcy_check()
{
	
	
	//return Firm_compute_balance_sheet();
}

void unittest_Firm_set_bankruptcy_insolvency_Firm_Bankruptcy_check_Firm_variables_reset()
{
	
	
	//return Firm_set_bankruptcy_insolvency();
}

void unittest_Firm_bankruptcy_reset_immediately_Firm_variables_reset_Firm_End_Financial_Management_Role()
{
	
	
	//return Firm_bankruptcy_reset_immediately();
}

void unittest_idle_Firm_Bankruptcy_check_Firm_End_Financial_Management_Role()
{
	
	
	//return idle();
}

void unittest_Firm_compute_total_liquidity_needs_02_02b()
{
	
	
	//return Firm_compute_total_liquidity_needs();
}

void unittest_Firm_check_financial_and_bankruptcy_state_Firm_End_Credit_Role_Firm_bankruptcy_checked()
{
	
	
	//return Firm_check_financial_and_bankruptcy_state();
}

void unittest_Firm_set_bankruptcy_illiquidity_Firm_bankruptcy_checked_Firm_variables_reset2()
{
	
	
	//return Firm_set_bankruptcy_illiquidity();
}

void unittest_Firm_bankruptcy_reset_immediately_Firm_variables_reset2_Firm_End_Financial_Management_Role()
{
	
	
	//return Firm_bankruptcy_reset_immediately();
}

void unittest_Firm_set_minsky_state_crisis_Firm_checks_financial_crisis_Firm_resolve_financial_crisis()
{
	
	
	//return Firm_set_minsky_state_crisis();
}

void unittest_Firm_in_financial_crisis_Firm_resolve_financial_crisis_Firm_End_External_Financing()
{
	
	
	//return Firm_in_financial_crisis();
}

void unittest_Firm_not_in_bankruptcy_Firm_bankruptcy_checked_Firm_checks_financial_crisis()
{
	
	
	//return Firm_not_in_bankruptcy();
}

void unittest_idle_Firm_checks_financial_crisis_Firm_End_External_Financing()
{
	
	
	//return idle();
}

void unittest_idle_Firm_Start_Credit_Role_Firm_End_External_Financing()
{
	
	
	//return idle();
}

void unittest_idle_Firm_End_Credit_Role_Firm_End_External_Financing()
{
	
	
	//return idle();
}

void unittest_Firm_execute_financial_payments_Firm_End_External_Financing_Firm_End_Financial_Management()
{
	
	
	//return Firm_execute_financial_payments();
}

void unittest_Firm_send_subsidy_notification_Firm_Start_Financial_Management_Role_005()
{
	
	
	//return Firm_send_subsidy_notification();
}

void unittest_Firm_send_transfer_notification_005_Firm_End_Public_Sector_Role()
{
	
	
	//return Firm_send_transfer_notification();
}

void unittest_Firm_bankruptcy_generic_procedure_Firm_not_active_Firm_bankruptcy_state_0()
{
	
	
	//return Firm_bankruptcy_generic_procedure();
}

void unittest_idle_Firm_not_active_Firm_bankruptcy_state_0()
{
	
	
	//return idle();
}

void unittest_Firm_bankruptcy_rescale_loans_Firm_bankruptcy_state_0_Firm_bankruptcy_state_01()
{
	
	
	//return Firm_bankruptcy_rescale_loans();
}

void unittest_Firm_bankruptcy_reset_delayed_Firm_bankruptcy_state_01_Firm_bankruptcy_state_1()
{
	
	
	//return Firm_bankruptcy_reset_delayed();
}

void unittest_idle_Firm_bankruptcy_state_01_Firm_bankruptcy_state_1()
{
	
	
	//return idle();
}

void unittest_Firm_bankruptcy_idle_counter_Firm_checks_if_active_Firm_not_active()
{
	
	
	//return Firm_bankruptcy_idle_counter();
}

void unittest_idle_Firm_checks_if_active_Firm_is_active()
{
	
	
	//return idle();
}

void unittest_Firm_remains_in_bankruptcy_Firm_bankruptcy_state_1_Firm_bankruptcy_state_4()
{
	
	
	//return Firm_remains_in_bankruptcy();
}

void unittest_Firm_reset_bankruptcy_flags_Firm_bankruptcy_state_4_Firm_Start_Financial_Management_Role()
{
	
	
	//return Firm_reset_bankruptcy_flags();
}

void unittest_idle_Firm_bankruptcy_state_4_Firm_End_Branches()
{
	
	
	//return idle();
}

void unittest_idle_Firm_bankruptcy_state_1_Firm_bankruptcy_state_4()
{
	
	
	//return idle();
}

void unittest_Firm_check_minsky_class_02b_Firm_Start_Credit_Role()
{
	
	
	//return Firm_check_minsky_class();
}

void unittest_Firm_set_minsky_state_bankruptcy_15_16()
{
	
	
	//return Firm_set_minsky_state_bankruptcy();
}

void unittest_Firm_set_labour_market_actions_Firm_Start_Labour_Role_011a()
{
	
	
	//return Firm_set_labour_market_actions();
}

void unittest_Firm_calculate_specific_skills_and_wage_offer_011a_011()
{
	
	
	//return Firm_calculate_specific_skills_and_wage_offer();
}

void unittest_Firm_send_vacancies_04ccc_03()
{
	
	
	//return Firm_send_vacancies();
}

void unittest_Firm_send_redundancies_011_03ccc()
{
	
	
	//return Firm_send_redundancies();
}

void unittest_Firm_idle_011_03ccc()
{
	
	
	//return Firm_idle();
}

void unittest_Firm_read_job_applications_send_job_offer_or_rejection_03_04()
{
	int rc;
	
	rc = MB_Iterator_CreateFiltered(b_job_application, &i_job_application, &FLAME_filter_Firm_Firm_read_job_applications_send_job_offer_or_rejection_03_04_job_application, current_xmachine_Firm);
	
	#ifdef ERRCHECK
	if (rc != MB_SUCCESS)
	{
	   fprintf(stderr, "ERROR: Could not create Iterator for 'job_application'\n");
	   switch(rc) {
	       case MB_ERR_INVALID:
	           fprintf(stderr, "\t reason: 'job_application' board is invalid\n");
	           break;
	       case MB_ERR_LOCKED:
               fprintf(stderr, "\t reason: 'job_application' board is locked\n");
               break;
           case MB_ERR_MEMALLOC:
               fprintf(stderr, "\t reason: out of memory\n");
               break;
           case MB_ERR_INTERNAL:
               fprintf(stderr, "\t reason: internal error. Recompile libmoard in debug mode for more info \n");
               break;
	   }
	}
	#endif
	
	//return Firm_read_job_applications_send_job_offer_or_rejection();
}

void unittest_Firm_read_job_responses_04_05a()
{
	int rc;
	
	rc = MB_Iterator_CreateFiltered(b_job_acceptance, &i_job_acceptance, &FLAME_filter_Firm_Firm_read_job_responses_04_05a_job_acceptance, current_xmachine_Firm);
	
	#ifdef ERRCHECK
	if (rc != MB_SUCCESS)
	{
	   fprintf(stderr, "ERROR: Could not create Iterator for 'job_acceptance'\n");
	   switch(rc) {
	       case MB_ERR_INVALID:
	           fprintf(stderr, "\t reason: 'job_acceptance' board is invalid\n");
	           break;
	       case MB_ERR_LOCKED:
               fprintf(stderr, "\t reason: 'job_acceptance' board is locked\n");
               break;
           case MB_ERR_MEMALLOC:
               fprintf(stderr, "\t reason: out of memory\n");
               break;
           case MB_ERR_INTERNAL:
               fprintf(stderr, "\t reason: internal error. Recompile libmoard in debug mode for more info \n");
               break;
	   }
	}
	#endif
	
	//return Firm_read_job_responses();
}

void unittest_Firm_read_job_quitting_05a_05b()
{
	int rc;
	
	
	rc = MB_Iterator_Create(b_quitting, &i_quitting);
	#ifdef ERRCHECK
	if (rc != MB_SUCCESS)
	{
	   fprintf(stderr, "ERROR: Could not create Iterator for 'quitting'\n");
	   switch(rc) {
	       case MB_ERR_INVALID:
	           fprintf(stderr, "\t reason: 'quitting' board is invalid\n");
	           break;
	       case MB_ERR_LOCKED:
               fprintf(stderr, "\t reason: 'quitting' board is locked\n");
               break;
           case MB_ERR_MEMALLOC:
               fprintf(stderr, "\t reason: out of memory\n");
               break;
           case MB_ERR_INTERNAL:
               fprintf(stderr, "\t reason: internal error. Recompile libmoard in debug mode for more info \n");
               break;
	   }
	}
	#endif
	
	//return Firm_read_job_quitting();
}

void unittest_Firm_read_job_quitting_00b_09c()
{
	int rc;
	
	
	rc = MB_Iterator_Create(b_quitting, &i_quitting);
	#ifdef ERRCHECK
	if (rc != MB_SUCCESS)
	{
	   fprintf(stderr, "ERROR: Could not create Iterator for 'quitting'\n");
	   switch(rc) {
	       case MB_ERR_INVALID:
	           fprintf(stderr, "\t reason: 'quitting' board is invalid\n");
	           break;
	       case MB_ERR_LOCKED:
               fprintf(stderr, "\t reason: 'quitting' board is locked\n");
               break;
           case MB_ERR_MEMALLOC:
               fprintf(stderr, "\t reason: out of memory\n");
               break;
           case MB_ERR_INTERNAL:
               fprintf(stderr, "\t reason: internal error. Recompile libmoard in debug mode for more info \n");
               break;
	   }
	}
	#endif
	
	//return Firm_read_job_quitting();
}

void unittest_Firm_read_job_quitting_03c_03d()
{
	int rc;
	
	
	rc = MB_Iterator_Create(b_quitting, &i_quitting);
	#ifdef ERRCHECK
	if (rc != MB_SUCCESS)
	{
	   fprintf(stderr, "ERROR: Could not create Iterator for 'quitting'\n");
	   switch(rc) {
	       case MB_ERR_INVALID:
	           fprintf(stderr, "\t reason: 'quitting' board is invalid\n");
	           break;
	       case MB_ERR_LOCKED:
               fprintf(stderr, "\t reason: 'quitting' board is locked\n");
               break;
           case MB_ERR_MEMALLOC:
               fprintf(stderr, "\t reason: out of memory\n");
               break;
           case MB_ERR_INTERNAL:
               fprintf(stderr, "\t reason: internal error. Recompile libmoard in debug mode for more info \n");
               break;
	   }
	}
	#endif
	
	//return Firm_read_job_quitting();
}

void unittest_Firm_start_labour_market_03d_06()
{
	
	
	//return Firm_start_labour_market();
}

void unittest_Firm_finish_labour_market_first_round_05b_09a()
{
	
	
	//return Firm_finish_labour_market_first_round();
}

void unittest_Firm_update_wage_offer_05b_06()
{
	
	
	//return Firm_update_wage_offer();
}

void unittest_Firm_send_vacancies_2_06_07()
{
	
	
	//return Firm_send_vacancies_2();
}

void unittest_Firm_read_job_applications_send_job_offer_or_rejection_2_07_08()
{
	int rc;
	
	rc = MB_Iterator_CreateFiltered(b_job_application2, &i_job_application2, &FLAME_filter_Firm_Firm_read_job_applications_send_job_offer_or_rejection_2_07_08_job_application2, current_xmachine_Firm);
	
	#ifdef ERRCHECK
	if (rc != MB_SUCCESS)
	{
	   fprintf(stderr, "ERROR: Could not create Iterator for 'job_application2'\n");
	   switch(rc) {
	       case MB_ERR_INVALID:
	           fprintf(stderr, "\t reason: 'job_application2' board is invalid\n");
	           break;
	       case MB_ERR_LOCKED:
               fprintf(stderr, "\t reason: 'job_application2' board is locked\n");
               break;
           case MB_ERR_MEMALLOC:
               fprintf(stderr, "\t reason: out of memory\n");
               break;
           case MB_ERR_INTERNAL:
               fprintf(stderr, "\t reason: internal error. Recompile libmoard in debug mode for more info \n");
               break;
	   }
	}
	#endif
	
	//return Firm_read_job_applications_send_job_offer_or_rejection_2();
}

void unittest_Firm_read_job_responses_2_08_09a()
{
	int rc;
	
	rc = MB_Iterator_CreateFiltered(b_job_acceptance2, &i_job_acceptance2, &FLAME_filter_Firm_Firm_read_job_responses_2_08_09a_job_acceptance2, current_xmachine_Firm);
	
	#ifdef ERRCHECK
	if (rc != MB_SUCCESS)
	{
	   fprintf(stderr, "ERROR: Could not create Iterator for 'job_acceptance2'\n");
	   switch(rc) {
	       case MB_ERR_INVALID:
	           fprintf(stderr, "\t reason: 'job_acceptance2' board is invalid\n");
	           break;
	       case MB_ERR_LOCKED:
               fprintf(stderr, "\t reason: 'job_acceptance2' board is locked\n");
               break;
           case MB_ERR_MEMALLOC:
               fprintf(stderr, "\t reason: out of memory\n");
               break;
           case MB_ERR_INTERNAL:
               fprintf(stderr, "\t reason: internal error. Recompile libmoard in debug mode for more info \n");
               break;
	   }
	}
	#endif
	
	//return Firm_read_job_responses_2();
}

void unittest_Firm_read_job_quitting_2_09a_09b()
{
	int rc;
	
	
	rc = MB_Iterator_Create(b_quitting2, &i_quitting2);
	#ifdef ERRCHECK
	if (rc != MB_SUCCESS)
	{
	   fprintf(stderr, "ERROR: Could not create Iterator for 'quitting2'\n");
	   switch(rc) {
	       case MB_ERR_INVALID:
	           fprintf(stderr, "\t reason: 'quitting2' board is invalid\n");
	           break;
	       case MB_ERR_LOCKED:
               fprintf(stderr, "\t reason: 'quitting2' board is locked\n");
               break;
           case MB_ERR_MEMALLOC:
               fprintf(stderr, "\t reason: out of memory\n");
               break;
           case MB_ERR_INTERNAL:
               fprintf(stderr, "\t reason: internal error. Recompile libmoard in debug mode for more info \n");
               break;
	   }
	}
	#endif
	
	//return Firm_read_job_quitting_2();
}

void unittest_Firm_read_job_quitting_2_09c_Firm_Start_Seller_Role()
{
	int rc;
	
	
	rc = MB_Iterator_Create(b_quitting2, &i_quitting2);
	#ifdef ERRCHECK
	if (rc != MB_SUCCESS)
	{
	   fprintf(stderr, "ERROR: Could not create Iterator for 'quitting2'\n");
	   switch(rc) {
	       case MB_ERR_INVALID:
	           fprintf(stderr, "\t reason: 'quitting2' board is invalid\n");
	           break;
	       case MB_ERR_LOCKED:
               fprintf(stderr, "\t reason: 'quitting2' board is locked\n");
               break;
           case MB_ERR_MEMALLOC:
               fprintf(stderr, "\t reason: out of memory\n");
               break;
           case MB_ERR_INTERNAL:
               fprintf(stderr, "\t reason: internal error. Recompile libmoard in debug mode for more info \n");
               break;
	   }
	}
	#endif
	
	//return Firm_read_job_quitting_2();
}

void unittest_Firm_update_wage_offer_2_09b_10()
{
	
	
	//return Firm_update_wage_offer_2();
}

void unittest_Firm_idle_09b_10()
{
	
	
	//return Firm_idle();
}

void unittest_Firm_compute_mean_wage_specific_skills_10_Firm_End_Labour_Role()
{
	
	
	//return Firm_compute_mean_wage_specific_skills();
}

void unittest_Firm_send_random_redundancies_03ccc_04ccc()
{
	
	
	//return Firm_send_random_redundancies();
}

void unittest_idle_04ccc_03c()
{
	
	
	//return idle();
}

void unittest_Firm_send_id_to_malls_start_Firm_Firm_initialize()
{
	
	
	//return Firm_send_id_to_malls();
}

void unittest_Firm_initialize_mall_arrays_Firm_initialize_Firm_reset()
{
	int rc;
	
	
	rc = MB_Iterator_Create(b_msg_mall_id_to_firms, &i_msg_mall_id_to_firms);
	#ifdef ERRCHECK
	if (rc != MB_SUCCESS)
	{
	   fprintf(stderr, "ERROR: Could not create Iterator for 'msg_mall_id_to_firms'\n");
	   switch(rc) {
	       case MB_ERR_INVALID:
	           fprintf(stderr, "\t reason: 'msg_mall_id_to_firms' board is invalid\n");
	           break;
	       case MB_ERR_LOCKED:
               fprintf(stderr, "\t reason: 'msg_mall_id_to_firms' board is locked\n");
               break;
           case MB_ERR_MEMALLOC:
               fprintf(stderr, "\t reason: out of memory\n");
               break;
           case MB_ERR_INTERNAL:
               fprintf(stderr, "\t reason: internal error. Recompile libmoard in debug mode for more info \n");
               break;
	   }
	}
	#endif
	
	//return Firm_initialize_mall_arrays();
}

void unittest_idle_start_Firm_Firm_reset()
{
	
	
	//return idle();
}

void unittest_Firm_reset_variables_Firm_reset_Firm_init_01()
{
	
	
	//return Firm_reset_variables();
}

void unittest_idle_Firm_reset_Firm_interest()
{
	
	
	//return idle();
}

void unittest_Firm_receive_data_Firm_init_01_Firm_interest()
{
	int rc;
	
	rc = MB_Iterator_CreateFiltered(b_eurostat_send_specific_skills, &i_eurostat_send_specific_skills, &FLAME_filter_Firm_Firm_receive_data_Firm_init_01_Firm_interest_eurostat_send_specific_skills, current_xmachine_Firm);
	
	#ifdef ERRCHECK
	if (rc != MB_SUCCESS)
	{
	   fprintf(stderr, "ERROR: Could not create Iterator for 'eurostat_send_specific_skills'\n");
	   switch(rc) {
	       case MB_ERR_INVALID:
	           fprintf(stderr, "\t reason: 'eurostat_send_specific_skills' board is invalid\n");
	           break;
	       case MB_ERR_LOCKED:
               fprintf(stderr, "\t reason: 'eurostat_send_specific_skills' board is locked\n");
               break;
           case MB_ERR_MEMALLOC:
               fprintf(stderr, "\t reason: out of memory\n");
               break;
           case MB_ERR_INTERNAL:
               fprintf(stderr, "\t reason: internal error. Recompile libmoard in debug mode for more info \n");
               break;
	   }
	}
	#endif
	
	rc = MB_Iterator_CreateFiltered(b_policy_announcement, &i_policy_announcement, &FLAME_filter_Firm_Firm_receive_data_Firm_init_01_Firm_interest_policy_announcement, current_xmachine_Firm);
	
	#ifdef ERRCHECK
	if (rc != MB_SUCCESS)
	{
	   fprintf(stderr, "ERROR: Could not create Iterator for 'policy_announcement'\n");
	   switch(rc) {
	       case MB_ERR_INVALID:
	           fprintf(stderr, "\t reason: 'policy_announcement' board is invalid\n");
	           break;
	       case MB_ERR_LOCKED:
               fprintf(stderr, "\t reason: 'policy_announcement' board is locked\n");
               break;
           case MB_ERR_MEMALLOC:
               fprintf(stderr, "\t reason: out of memory\n");
               break;
           case MB_ERR_INTERNAL:
               fprintf(stderr, "\t reason: internal error. Recompile libmoard in debug mode for more info \n");
               break;
	   }
	}
	#endif
	
	
	rc = MB_Iterator_Create(b_msg_market_sizes, &i_msg_market_sizes);
	#ifdef ERRCHECK
	if (rc != MB_SUCCESS)
	{
	   fprintf(stderr, "ERROR: Could not create Iterator for 'msg_market_sizes'\n");
	   switch(rc) {
	       case MB_ERR_INVALID:
	           fprintf(stderr, "\t reason: 'msg_market_sizes' board is invalid\n");
	           break;
	       case MB_ERR_LOCKED:
               fprintf(stderr, "\t reason: 'msg_market_sizes' board is locked\n");
               break;
           case MB_ERR_MEMALLOC:
               fprintf(stderr, "\t reason: out of memory\n");
               break;
           case MB_ERR_INTERNAL:
               fprintf(stderr, "\t reason: internal error. Recompile libmoard in debug mode for more info \n");
               break;
	   }
	}
	#endif
	
	
	rc = MB_Iterator_Create(b_quality_price, &i_quality_price);
	#ifdef ERRCHECK
	if (rc != MB_SUCCESS)
	{
	   fprintf(stderr, "ERROR: Could not create Iterator for 'quality_price'\n");
	   switch(rc) {
	       case MB_ERR_INVALID:
	           fprintf(stderr, "\t reason: 'quality_price' board is invalid\n");
	           break;
	       case MB_ERR_LOCKED:
               fprintf(stderr, "\t reason: 'quality_price' board is locked\n");
               break;
           case MB_ERR_MEMALLOC:
               fprintf(stderr, "\t reason: out of memory\n");
               break;
           case MB_ERR_INTERNAL:
               fprintf(stderr, "\t reason: internal error. Recompile libmoard in debug mode for more info \n");
               break;
	   }
	}
	#endif
	
	//return Firm_receive_data();
}

void unittest_idle_Firm_is_active_Firm_Start_Market_Research_Role()
{
	
	
	//return idle();
}

void unittest_idle_Firm_End_Financial_Management_Role_Firm_End_Branches()
{
	
	
	//return idle();
}

void unittest_Firm_send_data_to_Eurostat_Firm_End_Branches_Firm_Send_Data()
{
	
	
	//return Firm_send_data_to_Eurostat();
}

void unittest_Firm_compute_stock_flows_Firm_Send_Data_15()
{
	
	
	//return Firm_compute_stock_flows();
}

void unittest_idle_Firm_End_Branches_15()
{
	
	
	//return idle();
}

void unittest_Firm_send_payments_to_bank_16_end_Firm()
{
	
	
	//return Firm_send_payments_to_bank();
}

void unittest_Firm_draw_sample_MR_0_MR_1()
{
	
	
	//return Firm_draw_sample();
}

void unittest_Firm_send_questionnaire_MR_1_MR_2()
{
	int rc;
	
	rc = MB_Iterator_CreateFiltered(b_interview_positive_response, &i_interview_positive_response, &FLAME_filter_Firm_Firm_send_questionnaire_MR_1_MR_2_interview_positive_response, current_xmachine_Firm);
	
	#ifdef ERRCHECK
	if (rc != MB_SUCCESS)
	{
	   fprintf(stderr, "ERROR: Could not create Iterator for 'interview_positive_response'\n");
	   switch(rc) {
	       case MB_ERR_INVALID:
	           fprintf(stderr, "\t reason: 'interview_positive_response' board is invalid\n");
	           break;
	       case MB_ERR_LOCKED:
               fprintf(stderr, "\t reason: 'interview_positive_response' board is locked\n");
               break;
           case MB_ERR_MEMALLOC:
               fprintf(stderr, "\t reason: out of memory\n");
               break;
           case MB_ERR_INTERNAL:
               fprintf(stderr, "\t reason: internal error. Recompile libmoard in debug mode for more info \n");
               break;
	   }
	}
	#endif
	
	//return Firm_send_questionnaire();
}

void unittest_Firm_analyze_questionnaire_MR_3_MR_4()
{
	
	
	//return Firm_analyze_questionnaire();
}

void unittest_Firm_idle_MR_3_MR_4()
{
	
	
	//return Firm_idle();
}

void unittest_Firm_prepone_vintage_choice_MR_4_MR_4a()
{
	int rc;
	
	
	rc = MB_Iterator_Create(b_productivity, &i_productivity);
	#ifdef ERRCHECK
	if (rc != MB_SUCCESS)
	{
	   fprintf(stderr, "ERROR: Could not create Iterator for 'productivity'\n");
	   switch(rc) {
	       case MB_ERR_INVALID:
	           fprintf(stderr, "\t reason: 'productivity' board is invalid\n");
	           break;
	       case MB_ERR_LOCKED:
               fprintf(stderr, "\t reason: 'productivity' board is locked\n");
               break;
           case MB_ERR_MEMALLOC:
               fprintf(stderr, "\t reason: out of memory\n");
               break;
           case MB_ERR_INTERNAL:
               fprintf(stderr, "\t reason: internal error. Recompile libmoard in debug mode for more info \n");
               break;
	   }
	}
	#endif
	
	//return Firm_prepone_vintage_choice();
}

void unittest_Firm_set_price_MR_4a_MR_5()
{
	
	
	//return Firm_set_price();
}

void unittest_Firm_decide_product_innovation_MR_5_MR_6()
{
	
	
	//return Firm_decide_product_innovation();
}

void unittest_Firm_idle_MR_5_MR_6()
{
	
	
	//return Firm_idle();
}

void unittest_Firm_clean_up_arrays_MR_6_Firm_Start_Producer_Role()
{
	
	
	//return Firm_clean_up_arrays();
}

void unittest_Firm_set_market_research_data_pricing_MR_02_MR_03()
{
	
	
	//return Firm_set_market_research_data_pricing();
}

void unittest_Firm_bypass_setting_if_delayed_MR_02_MR_0()
{
	
	
	//return Firm_bypass_setting_if_delayed();
}

void unittest_Firm_set_market_research_data_innovation_MR_03_MR_0()
{
	
	
	//return Firm_set_market_research_data_innovation();
}

void unittest_Firm_idle_MR_03_MR_0()
{
	
	
	//return Firm_idle();
}

void unittest_Firm_release_new_product_MR_01_MR_02()
{
	
	
	//return Firm_release_new_product();
}

void unittest_Firm_idle_Firm_Start_Market_Research_Role_MR_3()
{
	
	
	//return Firm_idle();
}

void unittest_Firm_idle_Firm_Start_Market_Research_Role_MR_01()
{
	
	
	//return Firm_idle();
}

void unittest_Firm_idle_MR_01_MR_02()
{
	
	
	//return Firm_idle();
}

void unittest_Firm_count_questionnaire_MR_2_MR_3()
{
	int rc;
	
	rc = MB_Iterator_CreateFiltered(b_filled_out_questionnaire_product_innovation, &i_filled_out_questionnaire_product_innovation, &FLAME_filter_Firm_Firm_count_questionnaire_MR_2_MR_3_filled_out_questionnaire_product_innovation, current_xmachine_Firm);
	
	#ifdef ERRCHECK
	if (rc != MB_SUCCESS)
	{
	   fprintf(stderr, "ERROR: Could not create Iterator for 'filled_out_questionnaire_product_innovation'\n");
	   switch(rc) {
	       case MB_ERR_INVALID:
	           fprintf(stderr, "\t reason: 'filled_out_questionnaire_product_innovation' board is invalid\n");
	           break;
	       case MB_ERR_LOCKED:
               fprintf(stderr, "\t reason: 'filled_out_questionnaire_product_innovation' board is locked\n");
               break;
           case MB_ERR_MEMALLOC:
               fprintf(stderr, "\t reason: out of memory\n");
               break;
           case MB_ERR_INTERNAL:
               fprintf(stderr, "\t reason: internal error. Recompile libmoard in debug mode for more info \n");
               break;
	   }
	}
	#endif
	
	//return Firm_count_questionnaire();
}

void unittest_Firm_idle_MR_4_Firm_Start_Producer_Role()
{
	
	
	//return Firm_idle();
}

void unittest_Household_idle_09_15()
{
	
	
	//return Household_idle();
}

void unittest_Household_rank_and_buy_goods_1_09_10()
{
	int rc;
	
	rc = MB_Iterator_CreateFiltered(b_quality_price_info_1, &i_quality_price_info_1, &FLAME_filter_Household_Household_rank_and_buy_goods_1_09_10_quality_price_info_1, current_xmachine_Household);
	
	#ifdef ERRCHECK
	if (rc != MB_SUCCESS)
	{
	   fprintf(stderr, "ERROR: Could not create Iterator for 'quality_price_info_1'\n");
	   switch(rc) {
	       case MB_ERR_INVALID:
	           fprintf(stderr, "\t reason: 'quality_price_info_1' board is invalid\n");
	           break;
	       case MB_ERR_LOCKED:
               fprintf(stderr, "\t reason: 'quality_price_info_1' board is locked\n");
               break;
           case MB_ERR_MEMALLOC:
               fprintf(stderr, "\t reason: out of memory\n");
               break;
           case MB_ERR_INTERNAL:
               fprintf(stderr, "\t reason: internal error. Recompile libmoard in debug mode for more info \n");
               break;
	   }
	}
	#endif
	
	//return Household_rank_and_buy_goods_1();
}

void unittest_Household_receive_goods_read_rationing_10_11()
{
	int rc;
	
	rc = MB_Iterator_CreateFiltered(b_accepted_consumption_1, &i_accepted_consumption_1, &FLAME_filter_Household_Household_receive_goods_read_rationing_10_11_accepted_consumption_1, current_xmachine_Household);
	
	#ifdef ERRCHECK
	if (rc != MB_SUCCESS)
	{
	   fprintf(stderr, "ERROR: Could not create Iterator for 'accepted_consumption_1'\n");
	   switch(rc) {
	       case MB_ERR_INVALID:
	           fprintf(stderr, "\t reason: 'accepted_consumption_1' board is invalid\n");
	           break;
	       case MB_ERR_LOCKED:
               fprintf(stderr, "\t reason: 'accepted_consumption_1' board is locked\n");
               break;
           case MB_ERR_MEMALLOC:
               fprintf(stderr, "\t reason: out of memory\n");
               break;
           case MB_ERR_INTERNAL:
               fprintf(stderr, "\t reason: internal error. Recompile libmoard in debug mode for more info \n");
               break;
	   }
	}
	#endif
	
	//return Household_receive_goods_read_rationing();
}

void unittest_Household_set_values_zero_11_14()
{
	
	
	//return Household_set_values_zero();
}

void unittest_Household_rank_and_buy_goods_2_11_12()
{
	int rc;
	
	rc = MB_Iterator_CreateFiltered(b_quality_price_info_2, &i_quality_price_info_2, &FLAME_filter_Household_Household_rank_and_buy_goods_2_11_12_quality_price_info_2, current_xmachine_Household);
	
	#ifdef ERRCHECK
	if (rc != MB_SUCCESS)
	{
	   fprintf(stderr, "ERROR: Could not create Iterator for 'quality_price_info_2'\n");
	   switch(rc) {
	       case MB_ERR_INVALID:
	           fprintf(stderr, "\t reason: 'quality_price_info_2' board is invalid\n");
	           break;
	       case MB_ERR_LOCKED:
               fprintf(stderr, "\t reason: 'quality_price_info_2' board is locked\n");
               break;
           case MB_ERR_MEMALLOC:
               fprintf(stderr, "\t reason: out of memory\n");
               break;
           case MB_ERR_INTERNAL:
               fprintf(stderr, "\t reason: internal error. Recompile libmoard in debug mode for more info \n");
               break;
	   }
	}
	#endif
	
	//return Household_rank_and_buy_goods_2();
}

void unittest_Household_receive_goods_read_rationing_2_12_14()
{
	int rc;
	
	rc = MB_Iterator_CreateFiltered(b_accepted_consumption_2, &i_accepted_consumption_2, &FLAME_filter_Household_Household_receive_goods_read_rationing_2_12_14_accepted_consumption_2, current_xmachine_Household);
	
	#ifdef ERRCHECK
	if (rc != MB_SUCCESS)
	{
	   fprintf(stderr, "ERROR: Could not create Iterator for 'accepted_consumption_2'\n");
	   switch(rc) {
	       case MB_ERR_INVALID:
	           fprintf(stderr, "\t reason: 'accepted_consumption_2' board is invalid\n");
	           break;
	       case MB_ERR_LOCKED:
               fprintf(stderr, "\t reason: 'accepted_consumption_2' board is locked\n");
               break;
           case MB_ERR_MEMALLOC:
               fprintf(stderr, "\t reason: out of memory\n");
               break;
           case MB_ERR_INTERNAL:
               fprintf(stderr, "\t reason: internal error. Recompile libmoard in debug mode for more info \n");
               break;
	   }
	}
	#endif
	
	//return Household_receive_goods_read_rationing_2();
}

void unittest_Household_handle_leftover_budget_14_15()
{
	
	
	//return Household_handle_leftover_budget();
}

void unittest_Household_send_account_update_15_16()
{
	
	
	//return Household_send_account_update();
}

void unittest_Household_receive_index_info_Household_Start_Financial_Market_Role_AFM_000()
{
	int rc;
	
	
	rc = MB_Iterator_Create(b_index_info, &i_index_info);
	#ifdef ERRCHECK
	if (rc != MB_SUCCESS)
	{
	   fprintf(stderr, "ERROR: Could not create Iterator for 'index_info'\n");
	   switch(rc) {
	       case MB_ERR_INVALID:
	           fprintf(stderr, "\t reason: 'index_info' board is invalid\n");
	           break;
	       case MB_ERR_LOCKED:
               fprintf(stderr, "\t reason: 'index_info' board is locked\n");
               break;
           case MB_ERR_MEMALLOC:
               fprintf(stderr, "\t reason: out of memory\n");
               break;
           case MB_ERR_INTERNAL:
               fprintf(stderr, "\t reason: internal error. Recompile libmoard in debug mode for more info \n");
               break;
	   }
	}
	#endif
	
	//return Household_receive_index_info();
}

void unittest_idle_Household_Start_Financial_Market_Role_AFM_000()
{
	
	
	//return idle();
}

void unittest_Household_receive_index_price_AFM_000_AFM_001()
{
	int rc;
	
	
	rc = MB_Iterator_Create(b_index_price, &i_index_price);
	#ifdef ERRCHECK
	if (rc != MB_SUCCESS)
	{
	   fprintf(stderr, "ERROR: Could not create Iterator for 'index_price'\n");
	   switch(rc) {
	       case MB_ERR_INVALID:
	           fprintf(stderr, "\t reason: 'index_price' board is invalid\n");
	           break;
	       case MB_ERR_LOCKED:
               fprintf(stderr, "\t reason: 'index_price' board is locked\n");
               break;
           case MB_ERR_MEMALLOC:
               fprintf(stderr, "\t reason: out of memory\n");
               break;
           case MB_ERR_INTERNAL:
               fprintf(stderr, "\t reason: internal error. Recompile libmoard in debug mode for more info \n");
               break;
	   }
	}
	#endif
	
	//return Household_receive_index_price();
}

void unittest_Household_revises_expected_portfolio_AFM_001_AFM_002()
{
	
	
	//return Household_revises_expected_portfolio();
}

void unittest_Household_update_portfolio_AFM_002_Household_Start_Labour_Role()
{
	int rc;
	
	rc = MB_Iterator_CreateFiltered(b_order_status, &i_order_status, &FLAME_filter_Household_Household_update_portfolio_AFM_002_Household_Start_Labour_Role_order_status, current_xmachine_Household);
	
	#ifdef ERRCHECK
	if (rc != MB_SUCCESS)
	{
	   fprintf(stderr, "ERROR: Could not create Iterator for 'order_status'\n");
	   switch(rc) {
	       case MB_ERR_INVALID:
	           fprintf(stderr, "\t reason: 'order_status' board is invalid\n");
	           break;
	       case MB_ERR_LOCKED:
               fprintf(stderr, "\t reason: 'order_status' board is locked\n");
               break;
           case MB_ERR_MEMALLOC:
               fprintf(stderr, "\t reason: out of memory\n");
               break;
           case MB_ERR_INTERNAL:
               fprintf(stderr, "\t reason: internal error. Recompile libmoard in debug mode for more info \n");
               break;
	   }
	}
	#endif
	
	//return Household_update_portfolio();
}

void unittest_idle_AFM_000_Household_Start_Labour_Role()
{
	
	
	//return idle();
}

void unittest_Household_read_firing_messages_Household_Start_Labour_Role_01d()
{
	int rc;
	
	rc = MB_Iterator_CreateFiltered(b_firing, &i_firing, &FLAME_filter_Household_Household_read_firing_messages_Household_Start_Labour_Role_01d_firing, current_xmachine_Household);
	
	#ifdef ERRCHECK
	if (rc != MB_SUCCESS)
	{
	   fprintf(stderr, "ERROR: Could not create Iterator for 'firing'\n");
	   switch(rc) {
	       case MB_ERR_INVALID:
	           fprintf(stderr, "\t reason: 'firing' board is invalid\n");
	           break;
	       case MB_ERR_LOCKED:
               fprintf(stderr, "\t reason: 'firing' board is locked\n");
               break;
           case MB_ERR_MEMALLOC:
               fprintf(stderr, "\t reason: out of memory\n");
               break;
           case MB_ERR_INTERNAL:
               fprintf(stderr, "\t reason: internal error. Recompile libmoard in debug mode for more info \n");
               break;
	   }
	}
	#endif
	
	//return Household_read_firing_messages();
}

void unittest_Household_idle_01d_01a()
{
	
	
	//return Household_idle();
}

void unittest_Household_idle_Household_Start_Labour_Role_01a()
{
	
	
	//return Household_idle();
}

void unittest_Household_UNEMPLOYED_read_job_vacancies_and_send_applications_01a_01()
{
	int rc;
	
	
	rc = MB_Iterator_Create(b_vacancies, &i_vacancies);
	#ifdef ERRCHECK
	if (rc != MB_SUCCESS)
	{
	   fprintf(stderr, "ERROR: Could not create Iterator for 'vacancies'\n");
	   switch(rc) {
	       case MB_ERR_INVALID:
	           fprintf(stderr, "\t reason: 'vacancies' board is invalid\n");
	           break;
	       case MB_ERR_LOCKED:
               fprintf(stderr, "\t reason: 'vacancies' board is locked\n");
               break;
           case MB_ERR_MEMALLOC:
               fprintf(stderr, "\t reason: out of memory\n");
               break;
           case MB_ERR_INTERNAL:
               fprintf(stderr, "\t reason: internal error. Recompile libmoard in debug mode for more info \n");
               break;
	   }
	}
	#endif
	
	rc = MB_Iterator_CreateFiltered(b_vacancies_r_and_d_employees, &i_vacancies_r_and_d_employees, &FLAME_filter_Household_Household_UNEMPLOYED_read_job_vacancies_and_send_applications_01a_01_vacancies_r_and_d_employees, current_xmachine_Household);
	
	#ifdef ERRCHECK
	if (rc != MB_SUCCESS)
	{
	   fprintf(stderr, "ERROR: Could not create Iterator for 'vacancies_r_and_d_employees'\n");
	   switch(rc) {
	       case MB_ERR_INVALID:
	           fprintf(stderr, "\t reason: 'vacancies_r_and_d_employees' board is invalid\n");
	           break;
	       case MB_ERR_LOCKED:
               fprintf(stderr, "\t reason: 'vacancies_r_and_d_employees' board is locked\n");
               break;
           case MB_ERR_MEMALLOC:
               fprintf(stderr, "\t reason: out of memory\n");
               break;
           case MB_ERR_INTERNAL:
               fprintf(stderr, "\t reason: internal error. Recompile libmoard in debug mode for more info \n");
               break;
	   }
	}
	#endif
	
	//return Household_UNEMPLOYED_read_job_vacancies_and_send_applications();
}

void unittest_Household_idle_01d_06()
{
	
	
	//return Household_idle();
}

void unittest_Household_read_job_offers_send_response_01_02()
{
	int rc;
	
	rc = MB_Iterator_CreateFiltered(b_job_offer, &i_job_offer, &FLAME_filter_Household_Household_read_job_offers_send_response_01_02_job_offer, current_xmachine_Household);
	
	#ifdef ERRCHECK
	if (rc != MB_SUCCESS)
	{
	   fprintf(stderr, "ERROR: Could not create Iterator for 'job_offer'\n");
	   switch(rc) {
	       case MB_ERR_INVALID:
	           fprintf(stderr, "\t reason: 'job_offer' board is invalid\n");
	           break;
	       case MB_ERR_LOCKED:
               fprintf(stderr, "\t reason: 'job_offer' board is locked\n");
               break;
           case MB_ERR_MEMALLOC:
               fprintf(stderr, "\t reason: out of memory\n");
               break;
           case MB_ERR_INTERNAL:
               fprintf(stderr, "\t reason: internal error. Recompile libmoard in debug mode for more info \n");
               break;
	   }
	}
	#endif
	
	//return Household_read_job_offers_send_response();
}

void unittest_Household_finish_labour_market_02_06()
{
	
	
	//return Household_finish_labour_market();
}

void unittest_Household_read_application_rejection_update_wage_reservation_02_03()
{
	
	
	//return Household_read_application_rejection_update_wage_reservation();
}

void unittest_Household_UNEMPLOYED_read_job_vacancies_and_send_applications_2_03_04()
{
	int rc;
	
	
	rc = MB_Iterator_Create(b_vacancies2, &i_vacancies2);
	#ifdef ERRCHECK
	if (rc != MB_SUCCESS)
	{
	   fprintf(stderr, "ERROR: Could not create Iterator for 'vacancies2'\n");
	   switch(rc) {
	       case MB_ERR_INVALID:
	           fprintf(stderr, "\t reason: 'vacancies2' board is invalid\n");
	           break;
	       case MB_ERR_LOCKED:
               fprintf(stderr, "\t reason: 'vacancies2' board is locked\n");
               break;
           case MB_ERR_MEMALLOC:
               fprintf(stderr, "\t reason: out of memory\n");
               break;
           case MB_ERR_INTERNAL:
               fprintf(stderr, "\t reason: internal error. Recompile libmoard in debug mode for more info \n");
               break;
	   }
	}
	#endif
	
	rc = MB_Iterator_CreateFiltered(b_vacancies_r_and_d_employees2, &i_vacancies_r_and_d_employees2, &FLAME_filter_Household_Household_UNEMPLOYED_read_job_vacancies_and_send_applications_2_03_04_vacancies_r_and_d_employees2, current_xmachine_Household);
	
	#ifdef ERRCHECK
	if (rc != MB_SUCCESS)
	{
	   fprintf(stderr, "ERROR: Could not create Iterator for 'vacancies_r_and_d_employees2'\n");
	   switch(rc) {
	       case MB_ERR_INVALID:
	           fprintf(stderr, "\t reason: 'vacancies_r_and_d_employees2' board is invalid\n");
	           break;
	       case MB_ERR_LOCKED:
               fprintf(stderr, "\t reason: 'vacancies_r_and_d_employees2' board is locked\n");
               break;
           case MB_ERR_MEMALLOC:
               fprintf(stderr, "\t reason: out of memory\n");
               break;
           case MB_ERR_INTERNAL:
               fprintf(stderr, "\t reason: internal error. Recompile libmoard in debug mode for more info \n");
               break;
	   }
	}
	#endif
	
	//return Household_UNEMPLOYED_read_job_vacancies_and_send_applications_2();
}

void unittest_Household_read_job_offers_send_response_2_04_05()
{
	int rc;
	
	rc = MB_Iterator_CreateFiltered(b_job_offer2, &i_job_offer2, &FLAME_filter_Household_Household_read_job_offers_send_response_2_04_05_job_offer2, current_xmachine_Household);
	
	#ifdef ERRCHECK
	if (rc != MB_SUCCESS)
	{
	   fprintf(stderr, "ERROR: Could not create Iterator for 'job_offer2'\n");
	   switch(rc) {
	       case MB_ERR_INVALID:
	           fprintf(stderr, "\t reason: 'job_offer2' board is invalid\n");
	           break;
	       case MB_ERR_LOCKED:
               fprintf(stderr, "\t reason: 'job_offer2' board is locked\n");
               break;
           case MB_ERR_MEMALLOC:
               fprintf(stderr, "\t reason: out of memory\n");
               break;
           case MB_ERR_INTERNAL:
               fprintf(stderr, "\t reason: internal error. Recompile libmoard in debug mode for more info \n");
               break;
	   }
	}
	#endif
	
	//return Household_read_job_offers_send_response_2();
}

void unittest_Household_read_application_rejection_update_wage_reservation_2_05_06()
{
	
	
	//return Household_read_application_rejection_update_wage_reservation_2();
}

void unittest_Household_idle_05_06()
{
	
	
	//return Household_idle();
}

void unittest_Household_receive_dividends_dummy_06_06b()
{
	
	
	//return Household_receive_dividends_dummy();
}

void unittest_Household_idle_06b_09()
{
	
	
	//return Household_idle();
}

void unittest_Household_idle_06b_06c()
{
	
	
	//return Household_idle();
}

void unittest_Household_send_subsidy_notification_06c_06d()
{
	
	
	//return Household_send_subsidy_notification();
}

void unittest_Household_send_transfer_notification_06d_06e()
{
	
	
	//return Household_send_transfer_notification();
}

void unittest_Household_receive_wage_06e_07()
{
	int rc;
	
	rc = MB_Iterator_CreateFiltered(b_wage_payment, &i_wage_payment, &FLAME_filter_Household_Household_receive_wage_06e_07_wage_payment, current_xmachine_Household);
	
	#ifdef ERRCHECK
	if (rc != MB_SUCCESS)
	{
	   fprintf(stderr, "ERROR: Could not create Iterator for 'wage_payment'\n");
	   switch(rc) {
	       case MB_ERR_INVALID:
	           fprintf(stderr, "\t reason: 'wage_payment' board is invalid\n");
	           break;
	       case MB_ERR_LOCKED:
               fprintf(stderr, "\t reason: 'wage_payment' board is locked\n");
               break;
           case MB_ERR_MEMALLOC:
               fprintf(stderr, "\t reason: out of memory\n");
               break;
           case MB_ERR_INTERNAL:
               fprintf(stderr, "\t reason: internal error. Recompile libmoard in debug mode for more info \n");
               break;
	   }
	}
	#endif
	
	//return Household_receive_wage();
}

void unittest_Household_update_specific_skills_07_08()
{
	
	
	//return Household_update_specific_skills();
}

void unittest_Household_send_unemployment_benefit_notification_06e_08()
{
	
	
	//return Household_send_unemployment_benefit_notification();
}

void unittest_Household_send_tax_payment_08_08b()
{
	
	
	//return Household_send_tax_payment();
}

void unittest_Household_determine_consumption_budget_08b_09()
{
	
	
	//return Household_determine_consumption_budget();
}

void unittest_Household_reset_variables_start_Household_Household_initialize()
{
	
	
	//return Household_reset_variables();
}

void unittest_idle_start_Household_Household_initialize()
{
	
	
	//return idle();
}

void unittest_Household_initialization_Household_initialize_Household_Start_Yearly_Loop_Top()
{
	
	
	//return Household_initialization();
}

void unittest_idle_Household_initialize_Household_Start_Yearly_Loop_Top()
{
	
	
	//return idle();
}

void unittest_Household_read_policy_announcements_Household_Start_Yearly_Loop_Top_Pol_01()
{
	int rc;
	
	rc = MB_Iterator_CreateFiltered(b_policy_announcement, &i_policy_announcement, &FLAME_filter_Household_Household_read_policy_announcements_Household_Start_Yearly_Loop_Top_Pol_01_policy_announcement, current_xmachine_Household);
	
	#ifdef ERRCHECK
	if (rc != MB_SUCCESS)
	{
	   fprintf(stderr, "ERROR: Could not create Iterator for 'policy_announcement'\n");
	   switch(rc) {
	       case MB_ERR_INVALID:
	           fprintf(stderr, "\t reason: 'policy_announcement' board is invalid\n");
	           break;
	       case MB_ERR_LOCKED:
               fprintf(stderr, "\t reason: 'policy_announcement' board is locked\n");
               break;
           case MB_ERR_MEMALLOC:
               fprintf(stderr, "\t reason: out of memory\n");
               break;
           case MB_ERR_INTERNAL:
               fprintf(stderr, "\t reason: internal error. Recompile libmoard in debug mode for more info \n");
               break;
	   }
	}
	#endif
	
	rc = MB_Iterator_CreateFiltered(b_human_capital_policy_announcement, &i_human_capital_policy_announcement, &FLAME_filter_Household_Household_read_policy_announcements_Household_Start_Yearly_Loop_Top_Pol_01_human_capital_policy_announcement, current_xmachine_Household);
	
	#ifdef ERRCHECK
	if (rc != MB_SUCCESS)
	{
	   fprintf(stderr, "ERROR: Could not create Iterator for 'human_capital_policy_announcement'\n");
	   switch(rc) {
	       case MB_ERR_INVALID:
	           fprintf(stderr, "\t reason: 'human_capital_policy_announcement' board is invalid\n");
	           break;
	       case MB_ERR_LOCKED:
               fprintf(stderr, "\t reason: 'human_capital_policy_announcement' board is locked\n");
               break;
           case MB_ERR_MEMALLOC:
               fprintf(stderr, "\t reason: out of memory\n");
               break;
           case MB_ERR_INTERNAL:
               fprintf(stderr, "\t reason: internal error. Recompile libmoard in debug mode for more info \n");
               break;
	   }
	}
	#endif
	
	//return Household_read_policy_announcements();
}

void unittest_Household_human_capital_policy_Pol_01_Household_Start_Policy_Data()
{
	int rc;
	
	rc = MB_Iterator_CreateFiltered(b_human_capital_policy_new_general_skill_notification, &i_human_capital_policy_new_general_skill_notification, &FLAME_filter_Household_Household_human_capital_policy_Pol_01_Household_Start_Policy_Data_human_capital_policy_new_general_skill_notification, current_xmachine_Household);
	
	#ifdef ERRCHECK
	if (rc != MB_SUCCESS)
	{
	   fprintf(stderr, "ERROR: Could not create Iterator for 'human_capital_policy_new_general_skill_notification'\n");
	   switch(rc) {
	       case MB_ERR_INVALID:
	           fprintf(stderr, "\t reason: 'human_capital_policy_new_general_skill_notification' board is invalid\n");
	           break;
	       case MB_ERR_LOCKED:
               fprintf(stderr, "\t reason: 'human_capital_policy_new_general_skill_notification' board is locked\n");
               break;
           case MB_ERR_MEMALLOC:
               fprintf(stderr, "\t reason: out of memory\n");
               break;
           case MB_ERR_INTERNAL:
               fprintf(stderr, "\t reason: internal error. Recompile libmoard in debug mode for more info \n");
               break;
	   }
	}
	#endif
	
	//return Household_human_capital_policy();
}

void unittest_Household_idle_Pol_01_Household_Start_Policy_Data()
{
	
	
	//return Household_idle();
}

void unittest_idle_Household_Start_Yearly_Loop_Top_Household_Start_Policy_Data()
{
	
	
	//return idle();
}

void unittest_Household_receive_account_interest_Household_Start_Policy_Data_Household_Start_Market_Research_Role()
{
	int rc;
	
	
	rc = MB_Iterator_Create(b_account_interest, &i_account_interest);
	#ifdef ERRCHECK
	if (rc != MB_SUCCESS)
	{
	   fprintf(stderr, "ERROR: Could not create Iterator for 'account_interest'\n");
	   switch(rc) {
	       case MB_ERR_INVALID:
	           fprintf(stderr, "\t reason: 'account_interest' board is invalid\n");
	           break;
	       case MB_ERR_LOCKED:
               fprintf(stderr, "\t reason: 'account_interest' board is locked\n");
               break;
           case MB_ERR_MEMALLOC:
               fprintf(stderr, "\t reason: out of memory\n");
               break;
           case MB_ERR_INTERNAL:
               fprintf(stderr, "\t reason: internal error. Recompile libmoard in debug mode for more info \n");
               break;
	   }
	}
	#endif
	
	//return Household_receive_account_interest();
}

void unittest_Household_send_data_to_Eurostat_16_17()
{
	
	
	//return Household_send_data_to_Eurostat();
}

void unittest_idle_16_17()
{
	
	
	//return idle();
}

void unittest_idle_17_end_Household()
{
	
	
	//return idle();
}

void unittest_Household_read_data_from_Eurostat_17_end_Household()
{
	int rc;
	
	rc = MB_Iterator_CreateFiltered(b_data_for_government, &i_data_for_government, &FLAME_filter_Household_Household_read_data_from_Eurostat_17_end_Household_data_for_government, current_xmachine_Household);
	
	#ifdef ERRCHECK
	if (rc != MB_SUCCESS)
	{
	   fprintf(stderr, "ERROR: Could not create Iterator for 'data_for_government'\n");
	   switch(rc) {
	       case MB_ERR_INVALID:
	           fprintf(stderr, "\t reason: 'data_for_government' board is invalid\n");
	           break;
	       case MB_ERR_LOCKED:
               fprintf(stderr, "\t reason: 'data_for_government' board is locked\n");
               break;
           case MB_ERR_MEMALLOC:
               fprintf(stderr, "\t reason: out of memory\n");
               break;
           case MB_ERR_INTERNAL:
               fprintf(stderr, "\t reason: internal error. Recompile libmoard in debug mode for more info \n");
               break;
	   }
	}
	#endif
	
	//return Household_read_data_from_Eurostat();
}

void unittest_Household_decide_to_attend_interview_Household_Start_Market_Research_Role_HH_MR_1()
{
	
	
	//return Household_decide_to_attend_interview();
}

void unittest_Household_idle_HH_MR_1_Household_Start_Financial_Market_Role()
{
	
	
	//return Household_idle();
}

void unittest_Household_respond_HH_MR_1_HH_MR_2()
{
	int rc;
	
	rc = MB_Iterator_CreateFiltered(b_interview_request, &i_interview_request, &FLAME_filter_Household_Household_respond_HH_MR_1_HH_MR_2_interview_request, current_xmachine_Household);
	
	#ifdef ERRCHECK
	if (rc != MB_SUCCESS)
	{
	   fprintf(stderr, "ERROR: Could not create Iterator for 'interview_request'\n");
	   switch(rc) {
	       case MB_ERR_INVALID:
	           fprintf(stderr, "\t reason: 'interview_request' board is invalid\n");
	           break;
	       case MB_ERR_LOCKED:
               fprintf(stderr, "\t reason: 'interview_request' board is locked\n");
               break;
           case MB_ERR_MEMALLOC:
               fprintf(stderr, "\t reason: out of memory\n");
               break;
           case MB_ERR_INTERNAL:
               fprintf(stderr, "\t reason: internal error. Recompile libmoard in debug mode for more info \n");
               break;
	   }
	}
	#endif
	
	//return Household_respond();
}

void unittest_Household_respond_questionnaire_HH_MR_2_Household_Start_Financial_Market_Role()
{
	int rc;
	
	rc = MB_Iterator_CreateFiltered(b_questionnaire_innovation, &i_questionnaire_innovation, &FLAME_filter_Household_Household_respond_questionnaire_HH_MR_2_Household_Start_Financial_Market_Role_questionnaire_innovation, current_xmachine_Household);
	
	#ifdef ERRCHECK
	if (rc != MB_SUCCESS)
	{
	   fprintf(stderr, "ERROR: Could not create Iterator for 'questionnaire_innovation'\n");
	   switch(rc) {
	       case MB_ERR_INVALID:
	           fprintf(stderr, "\t reason: 'questionnaire_innovation' board is invalid\n");
	           break;
	       case MB_ERR_LOCKED:
               fprintf(stderr, "\t reason: 'questionnaire_innovation' board is locked\n");
               break;
           case MB_ERR_MEMALLOC:
               fprintf(stderr, "\t reason: out of memory\n");
               break;
           case MB_ERR_INTERNAL:
               fprintf(stderr, "\t reason: internal error. Recompile libmoard in debug mode for more info \n");
               break;
	   }
	}
	#endif
	
	//return Household_respond_questionnaire();
}

void unittest_Mall_reset_export_data_001_01()
{
	
	
	//return Mall_reset_export_data();
}

void unittest_idle_001_01()
{
	
	
	//return idle();
}

void unittest_Mall_update_mall_stock_01_02()
{
	int rc;
	
	
	rc = MB_Iterator_Create(b_update_mall_stock, &i_update_mall_stock);
	#ifdef ERRCHECK
	if (rc != MB_SUCCESS)
	{
	   fprintf(stderr, "ERROR: Could not create Iterator for 'update_mall_stock'\n");
	   switch(rc) {
	       case MB_ERR_INVALID:
	           fprintf(stderr, "\t reason: 'update_mall_stock' board is invalid\n");
	           break;
	       case MB_ERR_LOCKED:
               fprintf(stderr, "\t reason: 'update_mall_stock' board is locked\n");
               break;
           case MB_ERR_MEMALLOC:
               fprintf(stderr, "\t reason: out of memory\n");
               break;
           case MB_ERR_INTERNAL:
               fprintf(stderr, "\t reason: internal error. Recompile libmoard in debug mode for more info \n");
               break;
	   }
	}
	#endif
	
	
	rc = MB_Iterator_Create(b_bankruptcy_illiquidity, &i_bankruptcy_illiquidity);
	#ifdef ERRCHECK
	if (rc != MB_SUCCESS)
	{
	   fprintf(stderr, "ERROR: Could not create Iterator for 'bankruptcy_illiquidity'\n");
	   switch(rc) {
	       case MB_ERR_INVALID:
	           fprintf(stderr, "\t reason: 'bankruptcy_illiquidity' board is invalid\n");
	           break;
	       case MB_ERR_LOCKED:
               fprintf(stderr, "\t reason: 'bankruptcy_illiquidity' board is locked\n");
               break;
           case MB_ERR_MEMALLOC:
               fprintf(stderr, "\t reason: out of memory\n");
               break;
           case MB_ERR_INTERNAL:
               fprintf(stderr, "\t reason: internal error. Recompile libmoard in debug mode for more info \n");
               break;
	   }
	}
	#endif
	
	//return Mall_update_mall_stock();
}

void unittest_Mall_send_quality_price_info_1_02_03()
{
	
	
	//return Mall_send_quality_price_info_1();
}

void unittest_Mall_update_mall_stocks_sales_rationing_1_03_04()
{
	int rc;
	
	rc = MB_Iterator_CreateFiltered(b_consumption_request_1, &i_consumption_request_1, &FLAME_filter_Mall_Mall_update_mall_stocks_sales_rationing_1_03_04_consumption_request_1, current_xmachine_Mall);
	
	#ifdef ERRCHECK
	if (rc != MB_SUCCESS)
	{
	   fprintf(stderr, "ERROR: Could not create Iterator for 'consumption_request_1'\n");
	   switch(rc) {
	       case MB_ERR_INVALID:
	           fprintf(stderr, "\t reason: 'consumption_request_1' board is invalid\n");
	           break;
	       case MB_ERR_LOCKED:
               fprintf(stderr, "\t reason: 'consumption_request_1' board is locked\n");
               break;
           case MB_ERR_MEMALLOC:
               fprintf(stderr, "\t reason: out of memory\n");
               break;
           case MB_ERR_INTERNAL:
               fprintf(stderr, "\t reason: internal error. Recompile libmoard in debug mode for more info \n");
               break;
	   }
	}
	#endif
	
	//return Mall_update_mall_stocks_sales_rationing_1();
}

void unittest_Mall_update_mall_stocks_sales_rationing_2_04_05()
{
	int rc;
	
	rc = MB_Iterator_CreateFiltered(b_consumption_request_2, &i_consumption_request_2, &FLAME_filter_Mall_Mall_update_mall_stocks_sales_rationing_2_04_05_consumption_request_2, current_xmachine_Mall);
	
	#ifdef ERRCHECK
	if (rc != MB_SUCCESS)
	{
	   fprintf(stderr, "ERROR: Could not create Iterator for 'consumption_request_2'\n");
	   switch(rc) {
	       case MB_ERR_INVALID:
	           fprintf(stderr, "\t reason: 'consumption_request_2' board is invalid\n");
	           break;
	       case MB_ERR_LOCKED:
               fprintf(stderr, "\t reason: 'consumption_request_2' board is locked\n");
               break;
           case MB_ERR_MEMALLOC:
               fprintf(stderr, "\t reason: out of memory\n");
               break;
           case MB_ERR_INTERNAL:
               fprintf(stderr, "\t reason: internal error. Recompile libmoard in debug mode for more info \n");
               break;
	   }
	}
	#endif
	
	//return Mall_update_mall_stocks_sales_rationing_2();
}

void unittest_Mall_pay_firm_05_05a()
{
	
	
	//return Mall_pay_firm();
}

void unittest_Mall_send_export_data_06_end_Mall()
{
	
	
	//return Mall_send_export_data();
}

void unittest_idle_06_end_Mall()
{
	
	
	//return idle();
}

void unittest_Mall_read_insolvency_bankruptcy_05a_06()
{
	int rc;
	
	
	rc = MB_Iterator_Create(b_bankruptcy_insolvency, &i_bankruptcy_insolvency);
	#ifdef ERRCHECK
	if (rc != MB_SUCCESS)
	{
	   fprintf(stderr, "ERROR: Could not create Iterator for 'bankruptcy_insolvency'\n");
	   switch(rc) {
	       case MB_ERR_INVALID:
	           fprintf(stderr, "\t reason: 'bankruptcy_insolvency' board is invalid\n");
	           break;
	       case MB_ERR_LOCKED:
               fprintf(stderr, "\t reason: 'bankruptcy_insolvency' board is locked\n");
               break;
           case MB_ERR_MEMALLOC:
               fprintf(stderr, "\t reason: out of memory\n");
               break;
           case MB_ERR_INTERNAL:
               fprintf(stderr, "\t reason: internal error. Recompile libmoard in debug mode for more info \n");
               break;
	   }
	}
	#endif
	
	//return Mall_read_insolvency_bankruptcy();
}

void unittest_Mall_send_id_to_firms_start_Mall_Mall_initialize()
{
	
	
	//return Mall_send_id_to_firms();
}

void unittest_Mall_initialize_firm_arrays_Mall_initialize_001()
{
	int rc;
	
	
	rc = MB_Iterator_Create(b_msg_firm_id_to_malls, &i_msg_firm_id_to_malls);
	#ifdef ERRCHECK
	if (rc != MB_SUCCESS)
	{
	   fprintf(stderr, "ERROR: Could not create Iterator for 'msg_firm_id_to_malls'\n");
	   switch(rc) {
	       case MB_ERR_INVALID:
	           fprintf(stderr, "\t reason: 'msg_firm_id_to_malls' board is invalid\n");
	           break;
	       case MB_ERR_LOCKED:
               fprintf(stderr, "\t reason: 'msg_firm_id_to_malls' board is locked\n");
               break;
           case MB_ERR_MEMALLOC:
               fprintf(stderr, "\t reason: out of memory\n");
               break;
           case MB_ERR_INTERNAL:
               fprintf(stderr, "\t reason: internal error. Recompile libmoard in debug mode for more info \n");
               break;
	   }
	}
	#endif
	
	//return Mall_initialize_firm_arrays();
}

void unittest_idle_start_Mall_001()
{
	
	
	//return idle();
}

void unittest_IGFirm_receive_account_interest_IGFirm_interest_IGFirm_checks_if_active()
{
	int rc;
	
	
	rc = MB_Iterator_Create(b_account_interest, &i_account_interest);
	#ifdef ERRCHECK
	if (rc != MB_SUCCESS)
	{
	   fprintf(stderr, "ERROR: Could not create Iterator for 'account_interest'\n");
	   switch(rc) {
	       case MB_ERR_INVALID:
	           fprintf(stderr, "\t reason: 'account_interest' board is invalid\n");
	           break;
	       case MB_ERR_LOCKED:
               fprintf(stderr, "\t reason: 'account_interest' board is locked\n");
               break;
           case MB_ERR_MEMALLOC:
               fprintf(stderr, "\t reason: out of memory\n");
               break;
           case MB_ERR_INTERNAL:
               fprintf(stderr, "\t reason: internal error. Recompile libmoard in debug mode for more info \n");
               break;
	   }
	}
	#endif
	
	//return IGFirm_receive_account_interest();
}

void unittest_idle_IGFirm_checks_if_active_IGFirm_is_active()
{
	
	
	//return idle();
}

void unittest_IGFirm_execute_financial_payments_01kk_IGFirm_End_Financial_Management()
{
	
	
	//return IGFirm_execute_financial_payments();
}

void unittest_IGFirm_idle_IGFirm_Start_Financial_Management_Role_IGFirm_End_Financial_Management_Role()
{
	
	
	//return IGFirm_idle();
}

void unittest_IGFirm_send_subsidy_notification_IGFirm_Start_Financial_Management_Role_05()
{
	
	
	//return IGFirm_send_subsidy_notification();
}

void unittest_IGFirm_send_transfer_notification_05_IGFirm_End_Public_Sector_Role()
{
	
	
	//return IGFirm_send_transfer_notification();
}

void unittest_IGFirm_compute_income_statement_IGFirm_End_Public_Sector_Role_002()
{
	
	
	//return IGFirm_compute_income_statement();
}

void unittest_IGFirm_compute_dividends_002_003()
{
	
	
	//return IGFirm_compute_dividends();
}

void unittest_IGFirm_compute_total_financial_payments_003_004()
{
	
	
	//return IGFirm_compute_total_financial_payments();
}

void unittest_IGFirm_compute_balance_sheet_004_IGFirm_End_Financial_Management_Role()
{
	
	
	//return IGFirm_compute_balance_sheet();
}

void unittest_IGFirm_receive_stock_info_dummy_06_07()
{
	
	
	//return IGFirm_receive_stock_info_dummy();
}

void unittest_IGFirm_initialize_variables_Start_IGFirm_Productivity_01a()
{
	
	
	//return IGFirm_initialize_variables();
}

void unittest_idle_Start_IGFirm_Productivity_01a()
{
	
	
	//return idle();
}

void unittest_IGFirm_innovation_process_01a_01()
{
	
	
	//return IGFirm_innovation_process();
}

void unittest_IGFirm_idle_01a_01()
{
	
	
	//return IGFirm_idle();
}

void unittest_IGFirm_set_price_send_info_01_01kk()
{
	
	
	//return IGFirm_set_price_send_info();
}

void unittest_IGFirm_idle_01kk_02()
{
	
	
	//return IGFirm_idle();
}

void unittest_IGFirm_receive_order_delivers_capital_goods_02_03()
{
	int rc;
	
	
	rc = MB_Iterator_Create(b_capital_good_request, &i_capital_good_request);
	#ifdef ERRCHECK
	if (rc != MB_SUCCESS)
	{
	   fprintf(stderr, "ERROR: Could not create Iterator for 'capital_good_request'\n");
	   switch(rc) {
	       case MB_ERR_INVALID:
	           fprintf(stderr, "\t reason: 'capital_good_request' board is invalid\n");
	           break;
	       case MB_ERR_LOCKED:
               fprintf(stderr, "\t reason: 'capital_good_request' board is locked\n");
               break;
           case MB_ERR_MEMALLOC:
               fprintf(stderr, "\t reason: out of memory\n");
               break;
           case MB_ERR_INTERNAL:
               fprintf(stderr, "\t reason: internal error. Recompile libmoard in debug mode for more info \n");
               break;
	   }
	}
	#endif
	
	//return IGFirm_receive_order_delivers_capital_goods();
}

void unittest_IGFirm_calc_revenue_03_IGFirm_Start_Financial_Management_Role()
{
	int rc;
	
	
	rc = MB_Iterator_Create(b_pay_capital_goods, &i_pay_capital_goods);
	#ifdef ERRCHECK
	if (rc != MB_SUCCESS)
	{
	   fprintf(stderr, "ERROR: Could not create Iterator for 'pay_capital_goods'\n");
	   switch(rc) {
	       case MB_ERR_INVALID:
	           fprintf(stderr, "\t reason: 'pay_capital_goods' board is invalid\n");
	           break;
	       case MB_ERR_LOCKED:
               fprintf(stderr, "\t reason: 'pay_capital_goods' board is locked\n");
               break;
           case MB_ERR_MEMALLOC:
               fprintf(stderr, "\t reason: out of memory\n");
               break;
           case MB_ERR_INTERNAL:
               fprintf(stderr, "\t reason: internal error. Recompile libmoard in debug mode for more info \n");
               break;
	   }
	}
	#endif
	
	//return IGFirm_calc_revenue();
}

void unittest_IGFirm_reset_variables_IGFirm_start_IGFirm_init_01()
{
	
	
	//return IGFirm_reset_variables();
}

void unittest_idle_IGFirm_start_IGFirm_interest()
{
	
	
	//return idle();
}

void unittest_IGFirm_receive_data_IGFirm_init_01_IGFirm_interest()
{
	int rc;
	
	rc = MB_Iterator_CreateFiltered(b_eurostat_send_specific_skills, &i_eurostat_send_specific_skills, &FLAME_filter_IGFirm_IGFirm_receive_data_IGFirm_init_01_IGFirm_interest_eurostat_send_specific_skills, current_xmachine_IGFirm);
	
	#ifdef ERRCHECK
	if (rc != MB_SUCCESS)
	{
	   fprintf(stderr, "ERROR: Could not create Iterator for 'eurostat_send_specific_skills'\n");
	   switch(rc) {
	       case MB_ERR_INVALID:
	           fprintf(stderr, "\t reason: 'eurostat_send_specific_skills' board is invalid\n");
	           break;
	       case MB_ERR_LOCKED:
               fprintf(stderr, "\t reason: 'eurostat_send_specific_skills' board is locked\n");
               break;
           case MB_ERR_MEMALLOC:
               fprintf(stderr, "\t reason: out of memory\n");
               break;
           case MB_ERR_INTERNAL:
               fprintf(stderr, "\t reason: internal error. Recompile libmoard in debug mode for more info \n");
               break;
	   }
	}
	#endif
	
	rc = MB_Iterator_CreateFiltered(b_policy_announcement, &i_policy_announcement, &FLAME_filter_IGFirm_IGFirm_receive_data_IGFirm_init_01_IGFirm_interest_policy_announcement, current_xmachine_IGFirm);
	
	#ifdef ERRCHECK
	if (rc != MB_SUCCESS)
	{
	   fprintf(stderr, "ERROR: Could not create Iterator for 'policy_announcement'\n");
	   switch(rc) {
	       case MB_ERR_INVALID:
	           fprintf(stderr, "\t reason: 'policy_announcement' board is invalid\n");
	           break;
	       case MB_ERR_LOCKED:
               fprintf(stderr, "\t reason: 'policy_announcement' board is locked\n");
               break;
           case MB_ERR_MEMALLOC:
               fprintf(stderr, "\t reason: out of memory\n");
               break;
           case MB_ERR_INTERNAL:
               fprintf(stderr, "\t reason: internal error. Recompile libmoard in debug mode for more info \n");
               break;
	   }
	}
	#endif
	
	
	rc = MB_Iterator_Create(b_msg_skills_eurostat_to_igfirm, &i_msg_skills_eurostat_to_igfirm);
	#ifdef ERRCHECK
	if (rc != MB_SUCCESS)
	{
	   fprintf(stderr, "ERROR: Could not create Iterator for 'msg_skills_eurostat_to_igfirm'\n");
	   switch(rc) {
	       case MB_ERR_INVALID:
	           fprintf(stderr, "\t reason: 'msg_skills_eurostat_to_igfirm' board is invalid\n");
	           break;
	       case MB_ERR_LOCKED:
               fprintf(stderr, "\t reason: 'msg_skills_eurostat_to_igfirm' board is locked\n");
               break;
           case MB_ERR_MEMALLOC:
               fprintf(stderr, "\t reason: out of memory\n");
               break;
           case MB_ERR_INTERNAL:
               fprintf(stderr, "\t reason: internal error. Recompile libmoard in debug mode for more info \n");
               break;
	   }
	}
	#endif
	
	//return IGFirm_receive_data();
}

void unittest_idle_IGFirm_is_active_Start_IGFirm_Productivity()
{
	
	
	//return idle();
}

void unittest_idle_IGFirm_End_Financial_Management_Role_IGFirm_End_Branches()
{
	
	
	//return idle();
}

void unittest_IGFirm_send_data_to_Eurostat_IGFirm_End_Branches_IGFirm_Send_Data()
{
	
	
	//return IGFirm_send_data_to_Eurostat();
}

void unittest_IGFirm_compute_stock_flows_IGFirm_Send_Data_06()
{
	
	
	//return IGFirm_compute_stock_flows();
}

void unittest_idle_IGFirm_End_Branches_06()
{
	
	
	//return idle();
}

void unittest_IGFirm_send_payments_to_bank_07_end_IGFirm()
{
	
	
	//return IGFirm_send_payments_to_bank();
}

void unittest_IGFirm_idle_IGFirm_End_Financial_Management_02()
{
	
	
	//return IGFirm_idle();
}

void unittest_Eurostat_send_data_00_01()
{
	
	
	//return Eurostat_send_data();
}

void unittest_Eurostat_idle_00_01()
{
	
	
	//return Eurostat_idle();
}

void unittest_Eurostat_idle_01_Eurostat_Start_Monthly_Loop()
{
	
	
	//return Eurostat_idle();
}

void unittest_Eurostat_calculate_data_01_Eurostat_Start_Monthly_Loop()
{
	int rc;
	
	
	rc = MB_Iterator_Create(b_bankruptcy_illiquidity, &i_bankruptcy_illiquidity);
	#ifdef ERRCHECK
	if (rc != MB_SUCCESS)
	{
	   fprintf(stderr, "ERROR: Could not create Iterator for 'bankruptcy_illiquidity'\n");
	   switch(rc) {
	       case MB_ERR_INVALID:
	           fprintf(stderr, "\t reason: 'bankruptcy_illiquidity' board is invalid\n");
	           break;
	       case MB_ERR_LOCKED:
               fprintf(stderr, "\t reason: 'bankruptcy_illiquidity' board is locked\n");
               break;
           case MB_ERR_MEMALLOC:
               fprintf(stderr, "\t reason: out of memory\n");
               break;
           case MB_ERR_INTERNAL:
               fprintf(stderr, "\t reason: internal error. Recompile libmoard in debug mode for more info \n");
               break;
	   }
	}
	#endif
	
	
	rc = MB_Iterator_Create(b_bankruptcy_insolvency, &i_bankruptcy_insolvency);
	#ifdef ERRCHECK
	if (rc != MB_SUCCESS)
	{
	   fprintf(stderr, "ERROR: Could not create Iterator for 'bankruptcy_insolvency'\n");
	   switch(rc) {
	       case MB_ERR_INVALID:
	           fprintf(stderr, "\t reason: 'bankruptcy_insolvency' board is invalid\n");
	           break;
	       case MB_ERR_LOCKED:
               fprintf(stderr, "\t reason: 'bankruptcy_insolvency' board is locked\n");
               break;
           case MB_ERR_MEMALLOC:
               fprintf(stderr, "\t reason: out of memory\n");
               break;
           case MB_ERR_INTERNAL:
               fprintf(stderr, "\t reason: internal error. Recompile libmoard in debug mode for more info \n");
               break;
	   }
	}
	#endif
	
	
	rc = MB_Iterator_Create(b_firm_send_data, &i_firm_send_data);
	#ifdef ERRCHECK
	if (rc != MB_SUCCESS)
	{
	   fprintf(stderr, "ERROR: Could not create Iterator for 'firm_send_data'\n");
	   switch(rc) {
	       case MB_ERR_INVALID:
	           fprintf(stderr, "\t reason: 'firm_send_data' board is invalid\n");
	           break;
	       case MB_ERR_LOCKED:
               fprintf(stderr, "\t reason: 'firm_send_data' board is locked\n");
               break;
           case MB_ERR_MEMALLOC:
               fprintf(stderr, "\t reason: out of memory\n");
               break;
           case MB_ERR_INTERNAL:
               fprintf(stderr, "\t reason: internal error. Recompile libmoard in debug mode for more info \n");
               break;
	   }
	}
	#endif
	
	
	rc = MB_Iterator_Create(b_household_send_data, &i_household_send_data);
	#ifdef ERRCHECK
	if (rc != MB_SUCCESS)
	{
	   fprintf(stderr, "ERROR: Could not create Iterator for 'household_send_data'\n");
	   switch(rc) {
	       case MB_ERR_INVALID:
	           fprintf(stderr, "\t reason: 'household_send_data' board is invalid\n");
	           break;
	       case MB_ERR_LOCKED:
               fprintf(stderr, "\t reason: 'household_send_data' board is locked\n");
               break;
           case MB_ERR_MEMALLOC:
               fprintf(stderr, "\t reason: out of memory\n");
               break;
           case MB_ERR_INTERNAL:
               fprintf(stderr, "\t reason: internal error. Recompile libmoard in debug mode for more info \n");
               break;
	   }
	}
	#endif
	
	
	rc = MB_Iterator_Create(b_mall_data, &i_mall_data);
	#ifdef ERRCHECK
	if (rc != MB_SUCCESS)
	{
	   fprintf(stderr, "ERROR: Could not create Iterator for 'mall_data'\n");
	   switch(rc) {
	       case MB_ERR_INVALID:
	           fprintf(stderr, "\t reason: 'mall_data' board is invalid\n");
	           break;
	       case MB_ERR_LOCKED:
               fprintf(stderr, "\t reason: 'mall_data' board is locked\n");
               break;
           case MB_ERR_MEMALLOC:
               fprintf(stderr, "\t reason: out of memory\n");
               break;
           case MB_ERR_INTERNAL:
               fprintf(stderr, "\t reason: internal error. Recompile libmoard in debug mode for more info \n");
               break;
	   }
	}
	#endif
	
	
	rc = MB_Iterator_Create(b_total_subsidies, &i_total_subsidies);
	#ifdef ERRCHECK
	if (rc != MB_SUCCESS)
	{
	   fprintf(stderr, "ERROR: Could not create Iterator for 'total_subsidies'\n");
	   switch(rc) {
	       case MB_ERR_INVALID:
	           fprintf(stderr, "\t reason: 'total_subsidies' board is invalid\n");
	           break;
	       case MB_ERR_LOCKED:
               fprintf(stderr, "\t reason: 'total_subsidies' board is locked\n");
               break;
           case MB_ERR_MEMALLOC:
               fprintf(stderr, "\t reason: out of memory\n");
               break;
           case MB_ERR_INTERNAL:
               fprintf(stderr, "\t reason: internal error. Recompile libmoard in debug mode for more info \n");
               break;
	   }
	}
	#endif
	
	
	rc = MB_Iterator_Create(b_government_send_data, &i_government_send_data);
	#ifdef ERRCHECK
	if (rc != MB_SUCCESS)
	{
	   fprintf(stderr, "ERROR: Could not create Iterator for 'government_send_data'\n");
	   switch(rc) {
	       case MB_ERR_INVALID:
	           fprintf(stderr, "\t reason: 'government_send_data' board is invalid\n");
	           break;
	       case MB_ERR_LOCKED:
               fprintf(stderr, "\t reason: 'government_send_data' board is locked\n");
               break;
           case MB_ERR_MEMALLOC:
               fprintf(stderr, "\t reason: out of memory\n");
               break;
           case MB_ERR_INTERNAL:
               fprintf(stderr, "\t reason: internal error. Recompile libmoard in debug mode for more info \n");
               break;
	   }
	}
	#endif
	
	//return Eurostat_calculate_data();
}

void unittest_Eurostat_store_history_monthly_Eurostat_Start_Monthly_Loop_02()
{
	
	
	//return Eurostat_store_history_monthly();
}

void unittest_Eurostat_compute_growth_rates_monthly_02_Eurostat_Start_Quarterly_Loop()
{
	
	
	//return Eurostat_compute_growth_rates_monthly();
}

void unittest_Eurostat_idle_Eurostat_Start_Monthly_Loop_Eurostat_Start_Quarterly_Loop()
{
	
	
	//return Eurostat_idle();
}

void unittest_Eurostat_store_history_quarterly_Eurostat_Start_Quarterly_Loop_04()
{
	
	
	//return Eurostat_store_history_quarterly();
}

void unittest_Eurostat_compute_growth_rates_quarterly_04_05()
{
	
	
	//return Eurostat_compute_growth_rates_quarterly();
}

void unittest_Eurostat_measure_recession_05_Eurostat_Start_EndOfYear_Loop()
{
	
	
	//return Eurostat_measure_recession();
}

void unittest_Eurostat_idle_Eurostat_Start_Quarterly_Loop_Eurostat_Start_EndOfYear_Loop()
{
	
	
	//return Eurostat_idle();
}

void unittest_Eurostat_idle_Eurostat_Start_EndOfYear_Loop_end_Eurostat()
{
	
	
	//return Eurostat_idle();
}

void unittest_idle_Eurostat_Start_EndOfYear_Loop_end_Eurostat()
{
	
	
	//return idle();
}

void unittest_Eurostat_initialization_start_Eurostat_00()
{
	
	
	//return Eurostat_initialization();
}

void unittest_idle_start_Eurostat_00()
{
	
	
	//return idle();
}

void unittest_Bank_read_policy_rate_Bank_update_policy_rate_Bank_start_credit_market_role()
{
	int rc;
	
	
	rc = MB_Iterator_Create(b_policy_rate, &i_policy_rate);
	#ifdef ERRCHECK
	if (rc != MB_SUCCESS)
	{
	   fprintf(stderr, "ERROR: Could not create Iterator for 'policy_rate'\n");
	   switch(rc) {
	       case MB_ERR_INVALID:
	           fprintf(stderr, "\t reason: 'policy_rate' board is invalid\n");
	           break;
	       case MB_ERR_LOCKED:
               fprintf(stderr, "\t reason: 'policy_rate' board is locked\n");
               break;
           case MB_ERR_MEMALLOC:
               fprintf(stderr, "\t reason: out of memory\n");
               break;
           case MB_ERR_INTERNAL:
               fprintf(stderr, "\t reason: internal error. Recompile libmoard in debug mode for more info \n");
               break;
	   }
	}
	#endif
	
	//return Bank_read_policy_rate();
}

void unittest_idle_Bank_update_policy_rate_Bank_start_credit_market_role()
{
	
	
	//return idle();
}

void unittest_Bank_communicate_identity_Bank_start_credit_market_role_Bank_01()
{
	
	
	//return Bank_communicate_identity();
}

void unittest_Bank_send_dividend_payment_Bank_01_Bank_01b()
{
	
	
	//return Bank_send_dividend_payment();
}

void unittest_Bank_set_quantities_zero_Bank_01_Bank_01b()
{
	
	
	//return Bank_set_quantities_zero();
}

void unittest_Bank_send_account_interest_Bank_01b_Bank_02()
{
	
	
	//return Bank_send_account_interest();
}

void unittest_Bank_rank_credit_requests_Bank_02_Bank_021()
{
	int rc;
	
	rc = MB_Iterator_CreateFiltered(b_loan_request, &i_loan_request, &FLAME_filter_Bank_Bank_rank_credit_requests_Bank_02_Bank_021_loan_request, current_xmachine_Bank);
	
	#ifdef ERRCHECK
	if (rc != MB_SUCCESS)
	{
	   fprintf(stderr, "ERROR: Could not create Iterator for 'loan_request'\n");
	   switch(rc) {
	       case MB_ERR_INVALID:
	           fprintf(stderr, "\t reason: 'loan_request' board is invalid\n");
	           break;
	       case MB_ERR_LOCKED:
               fprintf(stderr, "\t reason: 'loan_request' board is locked\n");
               break;
           case MB_ERR_MEMALLOC:
               fprintf(stderr, "\t reason: out of memory\n");
               break;
           case MB_ERR_INTERNAL:
               fprintf(stderr, "\t reason: internal error. Recompile libmoard in debug mode for more info \n");
               break;
	   }
	}
	#endif
	
	//return Bank_rank_credit_requests();
}

void unittest_Bank_decide_credit_conditions_Bank_021_Bank_03()
{
	int rc;
	
	rc = MB_Iterator_CreateFiltered(b_loan_request_ranked, &i_loan_request_ranked, &FLAME_filter_Bank_Bank_decide_credit_conditions_Bank_021_Bank_03_loan_request_ranked, current_xmachine_Bank);
	
	#ifdef ERRCHECK
	if (rc != MB_SUCCESS)
	{
	   fprintf(stderr, "ERROR: Could not create Iterator for 'loan_request_ranked'\n");
	   switch(rc) {
	       case MB_ERR_INVALID:
	           fprintf(stderr, "\t reason: 'loan_request_ranked' board is invalid\n");
	           break;
	       case MB_ERR_LOCKED:
               fprintf(stderr, "\t reason: 'loan_request_ranked' board is locked\n");
               break;
           case MB_ERR_MEMALLOC:
               fprintf(stderr, "\t reason: out of memory\n");
               break;
           case MB_ERR_INTERNAL:
               fprintf(stderr, "\t reason: internal error. Recompile libmoard in debug mode for more info \n");
               break;
	   }
	}
	#endif
	
	//return Bank_decide_credit_conditions();
}

void unittest_Bank_give_loan_Bank_03_Bank_04()
{
	int rc;
	
	rc = MB_Iterator_CreateFiltered(b_loan_acceptance, &i_loan_acceptance, &FLAME_filter_Bank_Bank_give_loan_Bank_03_Bank_04_loan_acceptance, current_xmachine_Bank);
	
	#ifdef ERRCHECK
	if (rc != MB_SUCCESS)
	{
	   fprintf(stderr, "ERROR: Could not create Iterator for 'loan_acceptance'\n");
	   switch(rc) {
	       case MB_ERR_INVALID:
	           fprintf(stderr, "\t reason: 'loan_acceptance' board is invalid\n");
	           break;
	       case MB_ERR_LOCKED:
               fprintf(stderr, "\t reason: 'loan_acceptance' board is locked\n");
               break;
           case MB_ERR_MEMALLOC:
               fprintf(stderr, "\t reason: out of memory\n");
               break;
           case MB_ERR_INTERNAL:
               fprintf(stderr, "\t reason: internal error. Recompile libmoard in debug mode for more info \n");
               break;
	   }
	}
	#endif
	
	//return Bank_give_loan();
}

void unittest_idle_Bank_02_Bank_04()
{
	
	
	//return idle();
}

void unittest_Bank_receive_installment_Bank_04_Bank_05()
{
	int rc;
	
	
	rc = MB_Iterator_Create(b_installment, &i_installment);
	#ifdef ERRCHECK
	if (rc != MB_SUCCESS)
	{
	   fprintf(stderr, "ERROR: Could not create Iterator for 'installment'\n");
	   switch(rc) {
	       case MB_ERR_INVALID:
	           fprintf(stderr, "\t reason: 'installment' board is invalid\n");
	           break;
	       case MB_ERR_LOCKED:
               fprintf(stderr, "\t reason: 'installment' board is locked\n");
               break;
           case MB_ERR_MEMALLOC:
               fprintf(stderr, "\t reason: out of memory\n");
               break;
           case MB_ERR_INTERNAL:
               fprintf(stderr, "\t reason: internal error. Recompile libmoard in debug mode for more info \n");
               break;
	   }
	}
	#endif
	
	
	rc = MB_Iterator_Create(b_bankruptcy, &i_bankruptcy);
	#ifdef ERRCHECK
	if (rc != MB_SUCCESS)
	{
	   fprintf(stderr, "ERROR: Could not create Iterator for 'bankruptcy'\n");
	   switch(rc) {
	       case MB_ERR_INVALID:
	           fprintf(stderr, "\t reason: 'bankruptcy' board is invalid\n");
	           break;
	       case MB_ERR_LOCKED:
               fprintf(stderr, "\t reason: 'bankruptcy' board is locked\n");
               break;
           case MB_ERR_MEMALLOC:
               fprintf(stderr, "\t reason: out of memory\n");
               break;
           case MB_ERR_INTERNAL:
               fprintf(stderr, "\t reason: internal error. Recompile libmoard in debug mode for more info \n");
               break;
	   }
	}
	#endif
	
	//return Bank_receive_installment();
}

void unittest_Bank_account_update_deposits_Bank_05_Bank_06()
{
	int rc;
	
	rc = MB_Iterator_CreateFiltered(b_bank_account_update, &i_bank_account_update, &FLAME_filter_Bank_Bank_account_update_deposits_Bank_05_Bank_06_bank_account_update, current_xmachine_Bank);
	
	#ifdef ERRCHECK
	if (rc != MB_SUCCESS)
	{
	   fprintf(stderr, "ERROR: Could not create Iterator for 'bank_account_update'\n");
	   switch(rc) {
	       case MB_ERR_INVALID:
	           fprintf(stderr, "\t reason: 'bank_account_update' board is invalid\n");
	           break;
	       case MB_ERR_LOCKED:
               fprintf(stderr, "\t reason: 'bank_account_update' board is locked\n");
               break;
           case MB_ERR_MEMALLOC:
               fprintf(stderr, "\t reason: out of memory\n");
               break;
           case MB_ERR_INTERNAL:
               fprintf(stderr, "\t reason: internal error. Recompile libmoard in debug mode for more info \n");
               break;
	   }
	}
	#endif
	
	rc = MB_Iterator_CreateFiltered(b_credit_var_update, &i_credit_var_update, &FLAME_filter_Bank_Bank_account_update_deposits_Bank_05_Bank_06_credit_var_update, current_xmachine_Bank);
	
	#ifdef ERRCHECK
	if (rc != MB_SUCCESS)
	{
	   fprintf(stderr, "ERROR: Could not create Iterator for 'credit_var_update'\n");
	   switch(rc) {
	       case MB_ERR_INVALID:
	           fprintf(stderr, "\t reason: 'credit_var_update' board is invalid\n");
	           break;
	       case MB_ERR_LOCKED:
               fprintf(stderr, "\t reason: 'credit_var_update' board is locked\n");
               break;
           case MB_ERR_MEMALLOC:
               fprintf(stderr, "\t reason: out of memory\n");
               break;
           case MB_ERR_INTERNAL:
               fprintf(stderr, "\t reason: internal error. Recompile libmoard in debug mode for more info \n");
               break;
	   }
	}
	#endif
	
	//return Bank_account_update_deposits();
}

void unittest_Bank_accounting_Bank_06_Bank_07()
{
	
	
	//return Bank_accounting();
}

void unittest_Bank_idle_Bank_06_Bank_07()
{
	
	
	//return Bank_idle();
}

void unittest_Bank_update_ecb_account_Bank_07_Bank_08()
{
	
	
	//return Bank_update_ecb_account();
}

void unittest_Bank_stocks_and_flows_Bank_08_end_Bank()
{
	
	
	//return Bank_stocks_and_flows();
}

void unittest_idle_start_Bank_Bank_update_policy_rate()
{
	
	
	//return idle();
}

void unittest_Bank_read_policy_announcements_start_Bank_Bank_reset()
{
	int rc;
	
	rc = MB_Iterator_CreateFiltered(b_policy_announcement, &i_policy_announcement, &FLAME_filter_Bank_Bank_read_policy_announcements_start_Bank_Bank_reset_policy_announcement, current_xmachine_Bank);
	
	#ifdef ERRCHECK
	if (rc != MB_SUCCESS)
	{
	   fprintf(stderr, "ERROR: Could not create Iterator for 'policy_announcement'\n");
	   switch(rc) {
	       case MB_ERR_INVALID:
	           fprintf(stderr, "\t reason: 'policy_announcement' board is invalid\n");
	           break;
	       case MB_ERR_LOCKED:
               fprintf(stderr, "\t reason: 'policy_announcement' board is locked\n");
               break;
           case MB_ERR_MEMALLOC:
               fprintf(stderr, "\t reason: out of memory\n");
               break;
           case MB_ERR_INTERNAL:
               fprintf(stderr, "\t reason: internal error. Recompile libmoard in debug mode for more info \n");
               break;
	   }
	}
	#endif
	
	//return Bank_read_policy_announcements();
}

void unittest_Bank_reset_variables_Bank_reset_Bank_update_policy_rate()
{
	
	
	//return Bank_reset_variables();
}

void unittest_Government_bond_market_dummy_Gov_Start_Bond_Market_Start_Gov_Consumer_Role()
{
	
	
	//return Government_bond_market_dummy();
}

void unittest_Government_initialization_start_Government_Government_Start_Monthly_Loop_Top()
{
	
	
	//return Government_initialization();
}

void unittest_idle_start_Government_Government_Start_Monthly_Loop_Top()
{
	
	
	//return idle();
}

void unittest_Government_monthly_resetting_Government_Start_Monthly_Loop_Top_001()
{
	
	
	//return Government_monthly_resetting();
}

void unittest_Government_read_data_from_Eurostat_001_Government_Start_Yearly_Loop_Top()
{
	int rc;
	
	
	rc = MB_Iterator_Create(b_data_for_government, &i_data_for_government);
	#ifdef ERRCHECK
	if (rc != MB_SUCCESS)
	{
	   fprintf(stderr, "ERROR: Could not create Iterator for 'data_for_government'\n");
	   switch(rc) {
	       case MB_ERR_INVALID:
	           fprintf(stderr, "\t reason: 'data_for_government' board is invalid\n");
	           break;
	       case MB_ERR_LOCKED:
               fprintf(stderr, "\t reason: 'data_for_government' board is locked\n");
               break;
           case MB_ERR_MEMALLOC:
               fprintf(stderr, "\t reason: out of memory\n");
               break;
           case MB_ERR_INTERNAL:
               fprintf(stderr, "\t reason: internal error. Recompile libmoard in debug mode for more info \n");
               break;
	   }
	}
	#endif
	
	
	rc = MB_Iterator_Create(b_eurostat_send_macrodata, &i_eurostat_send_macrodata);
	#ifdef ERRCHECK
	if (rc != MB_SUCCESS)
	{
	   fprintf(stderr, "ERROR: Could not create Iterator for 'eurostat_send_macrodata'\n");
	   switch(rc) {
	       case MB_ERR_INVALID:
	           fprintf(stderr, "\t reason: 'eurostat_send_macrodata' board is invalid\n");
	           break;
	       case MB_ERR_LOCKED:
               fprintf(stderr, "\t reason: 'eurostat_send_macrodata' board is locked\n");
               break;
           case MB_ERR_MEMALLOC:
               fprintf(stderr, "\t reason: out of memory\n");
               break;
           case MB_ERR_INTERNAL:
               fprintf(stderr, "\t reason: internal error. Recompile libmoard in debug mode for more info \n");
               break;
	   }
	}
	#endif
	
	rc = MB_Iterator_CreateFiltered(b_redistributed_subsidies, &i_redistributed_subsidies, &FLAME_filter_Government_Government_read_data_from_Eurostat_001_Government_Start_Yearly_Loop_Top_redistributed_subsidies, current_xmachine_Government);
	
	#ifdef ERRCHECK
	if (rc != MB_SUCCESS)
	{
	   fprintf(stderr, "ERROR: Could not create Iterator for 'redistributed_subsidies'\n");
	   switch(rc) {
	       case MB_ERR_INVALID:
	           fprintf(stderr, "\t reason: 'redistributed_subsidies' board is invalid\n");
	           break;
	       case MB_ERR_LOCKED:
               fprintf(stderr, "\t reason: 'redistributed_subsidies' board is locked\n");
               break;
           case MB_ERR_MEMALLOC:
               fprintf(stderr, "\t reason: out of memory\n");
               break;
           case MB_ERR_INTERNAL:
               fprintf(stderr, "\t reason: internal error. Recompile libmoard in debug mode for more info \n");
               break;
	   }
	}
	#endif
	
	//return Government_read_data_from_Eurostat();
}

void unittest_idle_Government_Start_Monthly_Loop_Top_Government_Start_Yearly_Loop_Top()
{
	
	
	//return idle();
}

void unittest_Government_set_policy_Government_Start_Yearly_Loop_Top_002()
{
	
	
	//return Government_set_policy();
}

void unittest_Government_send_policy_announcements_002_003()
{
	
	
	//return Government_send_policy_announcements();
}

void unittest_Government_install_human_capital_policy_003_003a()
{
	int rc;
	
	rc = MB_Iterator_CreateFiltered(b_human_capital_policy_general_skill_information, &i_human_capital_policy_general_skill_information, &FLAME_filter_Government_Government_install_human_capital_policy_003_003a_human_capital_policy_general_skill_information, current_xmachine_Government);
	
	#ifdef ERRCHECK
	if (rc != MB_SUCCESS)
	{
	   fprintf(stderr, "ERROR: Could not create Iterator for 'human_capital_policy_general_skill_information'\n");
	   switch(rc) {
	       case MB_ERR_INVALID:
	           fprintf(stderr, "\t reason: 'human_capital_policy_general_skill_information' board is invalid\n");
	           break;
	       case MB_ERR_LOCKED:
               fprintf(stderr, "\t reason: 'human_capital_policy_general_skill_information' board is locked\n");
               break;
           case MB_ERR_MEMALLOC:
               fprintf(stderr, "\t reason: out of memory\n");
               break;
           case MB_ERR_INTERNAL:
               fprintf(stderr, "\t reason: internal error. Recompile libmoard in debug mode for more info \n");
               break;
	   }
	}
	#endif
	
	//return Government_install_human_capital_policy();
}

void unittest_Government_idle_003_003a()
{
	
	
	//return Government_idle();
}

void unittest_Government_yearly_resetting_003a_003b()
{
	
	
	//return Government_yearly_resetting();
}

void unittest_Government_migration_003b_Gov_Start_Bond_Market()
{
	
	
	//return Government_migration();
}

void unittest_idle_003b_Gov_Start_Bond_Market()
{
	
	
	//return idle();
}

void unittest_idle_Government_Start_Yearly_Loop_Top_003b()
{
	
	
	//return idle();
}

void unittest_idle_Start_Gov_Consumer_Role_Gov_Cons_1()
{
	
	
	//return idle();
}

void unittest_Government_determine_consumption_budget_Start_Gov_Consumer_Role_Gov_Cons_1()
{
	
	
	//return Government_determine_consumption_budget();
}

void unittest_Government_rank_and_buy_goods_1_Gov_Cons_1_Gov_Cons_2()
{
	int rc;
	
	rc = MB_Iterator_CreateFiltered(b_quality_price_info_1, &i_quality_price_info_1, &FLAME_filter_Government_Government_rank_and_buy_goods_1_Gov_Cons_1_Gov_Cons_2_quality_price_info_1, current_xmachine_Government);
	
	#ifdef ERRCHECK
	if (rc != MB_SUCCESS)
	{
	   fprintf(stderr, "ERROR: Could not create Iterator for 'quality_price_info_1'\n");
	   switch(rc) {
	       case MB_ERR_INVALID:
	           fprintf(stderr, "\t reason: 'quality_price_info_1' board is invalid\n");
	           break;
	       case MB_ERR_LOCKED:
               fprintf(stderr, "\t reason: 'quality_price_info_1' board is locked\n");
               break;
           case MB_ERR_MEMALLOC:
               fprintf(stderr, "\t reason: out of memory\n");
               break;
           case MB_ERR_INTERNAL:
               fprintf(stderr, "\t reason: internal error. Recompile libmoard in debug mode for more info \n");
               break;
	   }
	}
	#endif
	
	//return Government_rank_and_buy_goods_1();
}

void unittest_Government_receive_goods_read_rationing_Gov_Cons_2_Gov_Cons_3()
{
	int rc;
	
	rc = MB_Iterator_CreateFiltered(b_accepted_consumption_1, &i_accepted_consumption_1, &FLAME_filter_Government_Government_receive_goods_read_rationing_Gov_Cons_2_Gov_Cons_3_accepted_consumption_1, current_xmachine_Government);
	
	#ifdef ERRCHECK
	if (rc != MB_SUCCESS)
	{
	   fprintf(stderr, "ERROR: Could not create Iterator for 'accepted_consumption_1'\n");
	   switch(rc) {
	       case MB_ERR_INVALID:
	           fprintf(stderr, "\t reason: 'accepted_consumption_1' board is invalid\n");
	           break;
	       case MB_ERR_LOCKED:
               fprintf(stderr, "\t reason: 'accepted_consumption_1' board is locked\n");
               break;
           case MB_ERR_MEMALLOC:
               fprintf(stderr, "\t reason: out of memory\n");
               break;
           case MB_ERR_INTERNAL:
               fprintf(stderr, "\t reason: internal error. Recompile libmoard in debug mode for more info \n");
               break;
	   }
	}
	#endif
	
	//return Government_receive_goods_read_rationing();
}

void unittest_Government_rank_and_buy_goods_2_Gov_Cons_3_Gov_Cons_4()
{
	int rc;
	
	rc = MB_Iterator_CreateFiltered(b_quality_price_info_2, &i_quality_price_info_2, &FLAME_filter_Government_Government_rank_and_buy_goods_2_Gov_Cons_3_Gov_Cons_4_quality_price_info_2, current_xmachine_Government);
	
	#ifdef ERRCHECK
	if (rc != MB_SUCCESS)
	{
	   fprintf(stderr, "ERROR: Could not create Iterator for 'quality_price_info_2'\n");
	   switch(rc) {
	       case MB_ERR_INVALID:
	           fprintf(stderr, "\t reason: 'quality_price_info_2' board is invalid\n");
	           break;
	       case MB_ERR_LOCKED:
               fprintf(stderr, "\t reason: 'quality_price_info_2' board is locked\n");
               break;
           case MB_ERR_MEMALLOC:
               fprintf(stderr, "\t reason: out of memory\n");
               break;
           case MB_ERR_INTERNAL:
               fprintf(stderr, "\t reason: internal error. Recompile libmoard in debug mode for more info \n");
               break;
	   }
	}
	#endif
	
	//return Government_rank_and_buy_goods_2();
}

void unittest_Government_receive_goods_read_rationing_2_Gov_Cons_4_Gov_Cons_5()
{
	int rc;
	
	rc = MB_Iterator_CreateFiltered(b_accepted_consumption_2, &i_accepted_consumption_2, &FLAME_filter_Government_Government_receive_goods_read_rationing_2_Gov_Cons_4_Gov_Cons_5_accepted_consumption_2, current_xmachine_Government);
	
	#ifdef ERRCHECK
	if (rc != MB_SUCCESS)
	{
	   fprintf(stderr, "ERROR: Could not create Iterator for 'accepted_consumption_2'\n");
	   switch(rc) {
	       case MB_ERR_INVALID:
	           fprintf(stderr, "\t reason: 'accepted_consumption_2' board is invalid\n");
	           break;
	       case MB_ERR_LOCKED:
               fprintf(stderr, "\t reason: 'accepted_consumption_2' board is locked\n");
               break;
           case MB_ERR_MEMALLOC:
               fprintf(stderr, "\t reason: out of memory\n");
               break;
           case MB_ERR_INTERNAL:
               fprintf(stderr, "\t reason: internal error. Recompile libmoard in debug mode for more info \n");
               break;
	   }
	}
	#endif
	
	//return Government_receive_goods_read_rationing_2();
}

void unittest_Government_handle_leftover_budget_Gov_Cons_5_End_Gov_Consumer_Role()
{
	
	
	//return Government_handle_leftover_budget();
}

void unittest_Government_read_tax_payments_End_Gov_Consumer_Role_02()
{
	int rc;
	
	rc = MB_Iterator_CreateFiltered(b_tax_payment, &i_tax_payment, &FLAME_filter_Government_Government_read_tax_payments_End_Gov_Consumer_Role_02_tax_payment, current_xmachine_Government);
	
	#ifdef ERRCHECK
	if (rc != MB_SUCCESS)
	{
	   fprintf(stderr, "ERROR: Could not create Iterator for 'tax_payment'\n");
	   switch(rc) {
	       case MB_ERR_INVALID:
	           fprintf(stderr, "\t reason: 'tax_payment' board is invalid\n");
	           break;
	       case MB_ERR_LOCKED:
               fprintf(stderr, "\t reason: 'tax_payment' board is locked\n");
               break;
           case MB_ERR_MEMALLOC:
               fprintf(stderr, "\t reason: out of memory\n");
               break;
           case MB_ERR_INTERNAL:
               fprintf(stderr, "\t reason: internal error. Recompile libmoard in debug mode for more info \n");
               break;
	   }
	}
	#endif
	
	rc = MB_Iterator_CreateFiltered(b_unemployment_benefit_restitution, &i_unemployment_benefit_restitution, &FLAME_filter_Government_Government_read_tax_payments_End_Gov_Consumer_Role_02_unemployment_benefit_restitution, current_xmachine_Government);
	
	#ifdef ERRCHECK
	if (rc != MB_SUCCESS)
	{
	   fprintf(stderr, "ERROR: Could not create Iterator for 'unemployment_benefit_restitution'\n");
	   switch(rc) {
	       case MB_ERR_INVALID:
	           fprintf(stderr, "\t reason: 'unemployment_benefit_restitution' board is invalid\n");
	           break;
	       case MB_ERR_LOCKED:
               fprintf(stderr, "\t reason: 'unemployment_benefit_restitution' board is locked\n");
               break;
           case MB_ERR_MEMALLOC:
               fprintf(stderr, "\t reason: out of memory\n");
               break;
           case MB_ERR_INTERNAL:
               fprintf(stderr, "\t reason: internal error. Recompile libmoard in debug mode for more info \n");
               break;
	   }
	}
	#endif
	
	//return Government_read_tax_payments();
}

void unittest_Government_read_subsidy_notifications_02_03()
{
	int rc;
	
	rc = MB_Iterator_CreateFiltered(b_hh_subsidy_notification, &i_hh_subsidy_notification, &FLAME_filter_Government_Government_read_subsidy_notifications_02_03_hh_subsidy_notification, current_xmachine_Government);
	
	#ifdef ERRCHECK
	if (rc != MB_SUCCESS)
	{
	   fprintf(stderr, "ERROR: Could not create Iterator for 'hh_subsidy_notification'\n");
	   switch(rc) {
	       case MB_ERR_INVALID:
	           fprintf(stderr, "\t reason: 'hh_subsidy_notification' board is invalid\n");
	           break;
	       case MB_ERR_LOCKED:
               fprintf(stderr, "\t reason: 'hh_subsidy_notification' board is locked\n");
               break;
           case MB_ERR_MEMALLOC:
               fprintf(stderr, "\t reason: out of memory\n");
               break;
           case MB_ERR_INTERNAL:
               fprintf(stderr, "\t reason: internal error. Recompile libmoard in debug mode for more info \n");
               break;
	   }
	}
	#endif
	
	rc = MB_Iterator_CreateFiltered(b_firm_subsidy_notification, &i_firm_subsidy_notification, &FLAME_filter_Government_Government_read_subsidy_notifications_02_03_firm_subsidy_notification, current_xmachine_Government);
	
	#ifdef ERRCHECK
	if (rc != MB_SUCCESS)
	{
	   fprintf(stderr, "ERROR: Could not create Iterator for 'firm_subsidy_notification'\n");
	   switch(rc) {
	       case MB_ERR_INVALID:
	           fprintf(stderr, "\t reason: 'firm_subsidy_notification' board is invalid\n");
	           break;
	       case MB_ERR_LOCKED:
               fprintf(stderr, "\t reason: 'firm_subsidy_notification' board is locked\n");
               break;
           case MB_ERR_MEMALLOC:
               fprintf(stderr, "\t reason: out of memory\n");
               break;
           case MB_ERR_INTERNAL:
               fprintf(stderr, "\t reason: internal error. Recompile libmoard in debug mode for more info \n");
               break;
	   }
	}
	#endif
	
	//return Government_read_subsidy_notifications();
}

void unittest_Government_read_transfer_notifications_03_04()
{
	int rc;
	
	rc = MB_Iterator_CreateFiltered(b_hh_transfer_notification, &i_hh_transfer_notification, &FLAME_filter_Government_Government_read_transfer_notifications_03_04_hh_transfer_notification, current_xmachine_Government);
	
	#ifdef ERRCHECK
	if (rc != MB_SUCCESS)
	{
	   fprintf(stderr, "ERROR: Could not create Iterator for 'hh_transfer_notification'\n");
	   switch(rc) {
	       case MB_ERR_INVALID:
	           fprintf(stderr, "\t reason: 'hh_transfer_notification' board is invalid\n");
	           break;
	       case MB_ERR_LOCKED:
               fprintf(stderr, "\t reason: 'hh_transfer_notification' board is locked\n");
               break;
           case MB_ERR_MEMALLOC:
               fprintf(stderr, "\t reason: out of memory\n");
               break;
           case MB_ERR_INTERNAL:
               fprintf(stderr, "\t reason: internal error. Recompile libmoard in debug mode for more info \n");
               break;
	   }
	}
	#endif
	
	rc = MB_Iterator_CreateFiltered(b_firm_transfer_notification, &i_firm_transfer_notification, &FLAME_filter_Government_Government_read_transfer_notifications_03_04_firm_transfer_notification, current_xmachine_Government);
	
	#ifdef ERRCHECK
	if (rc != MB_SUCCESS)
	{
	   fprintf(stderr, "ERROR: Could not create Iterator for 'firm_transfer_notification'\n");
	   switch(rc) {
	       case MB_ERR_INVALID:
	           fprintf(stderr, "\t reason: 'firm_transfer_notification' board is invalid\n");
	           break;
	       case MB_ERR_LOCKED:
               fprintf(stderr, "\t reason: 'firm_transfer_notification' board is locked\n");
               break;
           case MB_ERR_MEMALLOC:
               fprintf(stderr, "\t reason: out of memory\n");
               break;
           case MB_ERR_INTERNAL:
               fprintf(stderr, "\t reason: internal error. Recompile libmoard in debug mode for more info \n");
               break;
	   }
	}
	#endif
	
	//return Government_read_transfer_notifications();
}

void unittest_Government_read_unemployment_benefit_notifications_04_Gov_Start_Monthly_Loop()
{
	int rc;
	
	rc = MB_Iterator_CreateFiltered(b_unemployment_notification, &i_unemployment_notification, &FLAME_filter_Government_Government_read_unemployment_benefit_notifications_04_Gov_Start_Monthly_Loop_unemployment_notification, current_xmachine_Government);
	
	#ifdef ERRCHECK
	if (rc != MB_SUCCESS)
	{
	   fprintf(stderr, "ERROR: Could not create Iterator for 'unemployment_notification'\n");
	   switch(rc) {
	       case MB_ERR_INVALID:
	           fprintf(stderr, "\t reason: 'unemployment_notification' board is invalid\n");
	           break;
	       case MB_ERR_LOCKED:
               fprintf(stderr, "\t reason: 'unemployment_notification' board is locked\n");
               break;
           case MB_ERR_MEMALLOC:
               fprintf(stderr, "\t reason: out of memory\n");
               break;
           case MB_ERR_INTERNAL:
               fprintf(stderr, "\t reason: internal error. Recompile libmoard in debug mode for more info \n");
               break;
	   }
	}
	#endif
	
	//return Government_read_unemployment_benefit_notifications();
}

void unittest_idle_Gov_Start_Monthly_Loop_06()
{
	
	
	//return idle();
}

void unittest_Government_resolve_unsold_bonds_dummy_Gov_Start_Monthly_Loop_05a()
{
	
	
	//return Government_resolve_unsold_bonds_dummy();
}

void unittest_Government_monthly_budget_accounting_05a_Gov_bonds_decision()
{
	
	
	//return Government_monthly_budget_accounting();
}

void unittest_Government_bonds_issuing_decision_dummy_Gov_bonds_decision_06()
{
	
	
	//return Government_bonds_issuing_decision_dummy();
}

void unittest_idle_Gov_bonds_decision_06()
{
	
	
	//return idle();
}

void unittest_Government_send_account_update_06_07()
{
	
	
	//return Government_send_account_update();
}

void unittest_Government_compute_balance_sheet_07_08()
{
	int rc;
	
	rc = MB_Iterator_CreateFiltered(b_ecb_dividend, &i_ecb_dividend, &FLAME_filter_Government_Government_compute_balance_sheet_07_08_ecb_dividend, current_xmachine_Government);
	
	#ifdef ERRCHECK
	if (rc != MB_SUCCESS)
	{
	   fprintf(stderr, "ERROR: Could not create Iterator for 'ecb_dividend'\n");
	   switch(rc) {
	       case MB_ERR_INVALID:
	           fprintf(stderr, "\t reason: 'ecb_dividend' board is invalid\n");
	           break;
	       case MB_ERR_LOCKED:
               fprintf(stderr, "\t reason: 'ecb_dividend' board is locked\n");
               break;
           case MB_ERR_MEMALLOC:
               fprintf(stderr, "\t reason: out of memory\n");
               break;
           case MB_ERR_INTERNAL:
               fprintf(stderr, "\t reason: internal error. Recompile libmoard in debug mode for more info \n");
               break;
	   }
	}
	#endif
	
	//return Government_compute_balance_sheet();
}

void unittest_Government_send_data_to_Eurostat_08_Gov_Start_Yearly_Loop()
{
	
	
	//return Government_send_data_to_Eurostat();
}

void unittest_idle_08_Gov_Start_Yearly_Loop()
{
	
	
	//return idle();
}

void unittest_idle_Gov_Start_Yearly_Loop_end_Government()
{
	
	
	//return idle();
}

void unittest_Government_yearly_budget_accounting_Gov_Start_Yearly_Loop_end_Government()
{
	
	
	//return Government_yearly_budget_accounting();
}

void unittest_Central_Bank_read_account_update_00_end_Central_Bank()
{
	int rc;
	
	
	rc = MB_Iterator_Create(b_bank_to_central_bank_account_update, &i_bank_to_central_bank_account_update);
	#ifdef ERRCHECK
	if (rc != MB_SUCCESS)
	{
	   fprintf(stderr, "ERROR: Could not create Iterator for 'bank_to_central_bank_account_update'\n");
	   switch(rc) {
	       case MB_ERR_INVALID:
	           fprintf(stderr, "\t reason: 'bank_to_central_bank_account_update' board is invalid\n");
	           break;
	       case MB_ERR_LOCKED:
               fprintf(stderr, "\t reason: 'bank_to_central_bank_account_update' board is locked\n");
               break;
           case MB_ERR_MEMALLOC:
               fprintf(stderr, "\t reason: out of memory\n");
               break;
           case MB_ERR_INTERNAL:
               fprintf(stderr, "\t reason: internal error. Recompile libmoard in debug mode for more info \n");
               break;
	   }
	}
	#endif
	
	
	rc = MB_Iterator_Create(b_gov_to_central_bank_account_update, &i_gov_to_central_bank_account_update);
	#ifdef ERRCHECK
	if (rc != MB_SUCCESS)
	{
	   fprintf(stderr, "ERROR: Could not create Iterator for 'gov_to_central_bank_account_update'\n");
	   switch(rc) {
	       case MB_ERR_INVALID:
	           fprintf(stderr, "\t reason: 'gov_to_central_bank_account_update' board is invalid\n");
	           break;
	       case MB_ERR_LOCKED:
               fprintf(stderr, "\t reason: 'gov_to_central_bank_account_update' board is locked\n");
               break;
           case MB_ERR_MEMALLOC:
               fprintf(stderr, "\t reason: out of memory\n");
               break;
           case MB_ERR_INTERNAL:
               fprintf(stderr, "\t reason: internal error. Recompile libmoard in debug mode for more info \n");
               break;
	   }
	}
	#endif
	
	
	rc = MB_Iterator_Create(b_bank_interest_payment, &i_bank_interest_payment);
	#ifdef ERRCHECK
	if (rc != MB_SUCCESS)
	{
	   fprintf(stderr, "ERROR: Could not create Iterator for 'bank_interest_payment'\n");
	   switch(rc) {
	       case MB_ERR_INVALID:
	           fprintf(stderr, "\t reason: 'bank_interest_payment' board is invalid\n");
	           break;
	       case MB_ERR_LOCKED:
               fprintf(stderr, "\t reason: 'bank_interest_payment' board is locked\n");
               break;
           case MB_ERR_MEMALLOC:
               fprintf(stderr, "\t reason: out of memory\n");
               break;
           case MB_ERR_INTERNAL:
               fprintf(stderr, "\t reason: internal error. Recompile libmoard in debug mode for more info \n");
               break;
	   }
	}
	#endif
	
	//return Central_Bank_read_account_update();
}

void unittest_Central_Bank_reset_variables_start_Central_Bank_CB_reset()
{
	
	
	//return Central_Bank_reset_variables();
}

void unittest_Central_Bank_monetary_policy_CB_reset_CB_market_operations()
{
	int rc;
	
	
	rc = MB_Iterator_Create(b_eurostat_send_macrodata, &i_eurostat_send_macrodata);
	#ifdef ERRCHECK
	if (rc != MB_SUCCESS)
	{
	   fprintf(stderr, "ERROR: Could not create Iterator for 'eurostat_send_macrodata'\n");
	   switch(rc) {
	       case MB_ERR_INVALID:
	           fprintf(stderr, "\t reason: 'eurostat_send_macrodata' board is invalid\n");
	           break;
	       case MB_ERR_LOCKED:
               fprintf(stderr, "\t reason: 'eurostat_send_macrodata' board is locked\n");
               break;
           case MB_ERR_MEMALLOC:
               fprintf(stderr, "\t reason: out of memory\n");
               break;
           case MB_ERR_INTERNAL:
               fprintf(stderr, "\t reason: internal error. Recompile libmoard in debug mode for more info \n");
               break;
	   }
	}
	#endif
	
	//return Central_Bank_monetary_policy();
}

void unittest_idle_start_Central_Bank_CB_market_operations()
{
	
	
	//return idle();
}

void unittest_Central_Bank_read_fiat_money_requests_CB_financial_operations_end_00()
{
	int rc;
	
	
	rc = MB_Iterator_Create(b_request_fiat_money, &i_request_fiat_money);
	#ifdef ERRCHECK
	if (rc != MB_SUCCESS)
	{
	   fprintf(stderr, "ERROR: Could not create Iterator for 'request_fiat_money'\n");
	   switch(rc) {
	       case MB_ERR_INVALID:
	           fprintf(stderr, "\t reason: 'request_fiat_money' board is invalid\n");
	           break;
	       case MB_ERR_LOCKED:
               fprintf(stderr, "\t reason: 'request_fiat_money' board is locked\n");
               break;
           case MB_ERR_MEMALLOC:
               fprintf(stderr, "\t reason: out of memory\n");
               break;
           case MB_ERR_INTERNAL:
               fprintf(stderr, "\t reason: internal error. Recompile libmoard in debug mode for more info \n");
               break;
	   }
	}
	#endif
	
	//return Central_Bank_read_fiat_money_requests();
}

void unittest_idle_CB_financial_operations_end_00()
{
	
	
	//return idle();
}

void unittest_Central_Bank_dummy_CB_market_operations_CB_financial_operations_end()
{
	
	
	//return Central_Bank_dummy();
}

void unittest_ClearingHouse_send_index_info_start_Clearinghouse_AFM_00()
{
	
	
	//return ClearingHouse_send_index_info();
}

void unittest_idle_start_Clearinghouse_AFM_00()
{
	
	
	//return idle();
}

void unittest_ClearingHouse_send_index_price_AFM_00_AFM_01()
{
	
	
	//return ClearingHouse_send_index_price();
}

void unittest_ClearingHouse_receive_orders_AFM_01_AFM_02()
{
	int rc;
	
	
	rc = MB_Iterator_Create(b_order, &i_order);
	#ifdef ERRCHECK
	if (rc != MB_SUCCESS)
	{
	   fprintf(stderr, "ERROR: Could not create Iterator for 'order'\n");
	   switch(rc) {
	       case MB_ERR_INVALID:
	           fprintf(stderr, "\t reason: 'order' board is invalid\n");
	           break;
	       case MB_ERR_LOCKED:
               fprintf(stderr, "\t reason: 'order' board is locked\n");
               break;
           case MB_ERR_MEMALLOC:
               fprintf(stderr, "\t reason: out of memory\n");
               break;
           case MB_ERR_INTERNAL:
               fprintf(stderr, "\t reason: internal error. Recompile libmoard in debug mode for more info \n");
               break;
	   }
	}
	#endif
	
	//return ClearingHouse_receive_orders();
}

void unittest_ClearingHouse_compute_transactions_AFM_02_AFM_03()
{
	
	
	//return ClearingHouse_compute_transactions();
}

void unittest_ClearingHouse_send_transaction_info_AFM_03_AFM_04()
{
	
	
	//return ClearingHouse_send_transaction_info();
}

void unittest_ClearingHouse_receive_dividend_info_AFM_04_AFM_05()
{
	int rc;
	
	
	rc = MB_Iterator_Create(b_dividend_info, &i_dividend_info);
	#ifdef ERRCHECK
	if (rc != MB_SUCCESS)
	{
	   fprintf(stderr, "ERROR: Could not create Iterator for 'dividend_info'\n");
	   switch(rc) {
	       case MB_ERR_INVALID:
	           fprintf(stderr, "\t reason: 'dividend_info' board is invalid\n");
	           break;
	       case MB_ERR_LOCKED:
               fprintf(stderr, "\t reason: 'dividend_info' board is locked\n");
               break;
           case MB_ERR_MEMALLOC:
               fprintf(stderr, "\t reason: out of memory\n");
               break;
           case MB_ERR_INTERNAL:
               fprintf(stderr, "\t reason: internal error. Recompile libmoard in debug mode for more info \n");
               break;
	   }
	}
	#endif
	
	//return ClearingHouse_receive_dividend_info();
}

void unittest_ClearingHouse_update_price_AFM_05_end_Clearinghouse()
{
	
	
	//return ClearingHouse_update_price();
}


void free_messages()
{
	int rc;
	
	    rc = MB_Clear(b_bank_account_update);
	    #ifdef ERRCHECK
	    if (rc != MB_SUCCESS)
	    {
	       fprintf(stderr, "ERROR: Could not clear 'bank_account_update' board\n");
	       switch(rc) {
	           case MB_ERR_INVALID:
	               fprintf(stderr, "\t reason: 'bank_account_update' board is invalid\n");
	               break;
	           case MB_ERR_LOCKED:
	               fprintf(stderr, "\t reason: 'bank_account_update' board is locked\n");
	               break;
	           case MB_ERR_INTERNAL:
	               fprintf(stderr, "\t reason: internal error. Recompile libmoard in debug mode for more info \n");
	               break;
	           default:
                   fprintf(stderr, "\t MB_Clear returned error code: %d (see libmboard docs for details)\n", rc);
                   break;
	       }

	       
       	   exit(rc);
	    }
	    #endif
	
	    rc = MB_Clear(b_bank_to_central_bank_account_update);
	    #ifdef ERRCHECK
	    if (rc != MB_SUCCESS)
	    {
	       fprintf(stderr, "ERROR: Could not clear 'bank_to_central_bank_account_update' board\n");
	       switch(rc) {
	           case MB_ERR_INVALID:
	               fprintf(stderr, "\t reason: 'bank_to_central_bank_account_update' board is invalid\n");
	               break;
	           case MB_ERR_LOCKED:
	               fprintf(stderr, "\t reason: 'bank_to_central_bank_account_update' board is locked\n");
	               break;
	           case MB_ERR_INTERNAL:
	               fprintf(stderr, "\t reason: internal error. Recompile libmoard in debug mode for more info \n");
	               break;
	           default:
                   fprintf(stderr, "\t MB_Clear returned error code: %d (see libmboard docs for details)\n", rc);
                   break;
	       }

	       
       	   exit(rc);
	    }
	    #endif
	
	    rc = MB_Clear(b_gov_to_central_bank_account_update);
	    #ifdef ERRCHECK
	    if (rc != MB_SUCCESS)
	    {
	       fprintf(stderr, "ERROR: Could not clear 'gov_to_central_bank_account_update' board\n");
	       switch(rc) {
	           case MB_ERR_INVALID:
	               fprintf(stderr, "\t reason: 'gov_to_central_bank_account_update' board is invalid\n");
	               break;
	           case MB_ERR_LOCKED:
	               fprintf(stderr, "\t reason: 'gov_to_central_bank_account_update' board is locked\n");
	               break;
	           case MB_ERR_INTERNAL:
	               fprintf(stderr, "\t reason: internal error. Recompile libmoard in debug mode for more info \n");
	               break;
	           default:
                   fprintf(stderr, "\t MB_Clear returned error code: %d (see libmboard docs for details)\n", rc);
                   break;
	       }

	       
       	   exit(rc);
	    }
	    #endif
	
	    rc = MB_Clear(b_wage_payment);
	    #ifdef ERRCHECK
	    if (rc != MB_SUCCESS)
	    {
	       fprintf(stderr, "ERROR: Could not clear 'wage_payment' board\n");
	       switch(rc) {
	           case MB_ERR_INVALID:
	               fprintf(stderr, "\t reason: 'wage_payment' board is invalid\n");
	               break;
	           case MB_ERR_LOCKED:
	               fprintf(stderr, "\t reason: 'wage_payment' board is locked\n");
	               break;
	           case MB_ERR_INTERNAL:
	               fprintf(stderr, "\t reason: internal error. Recompile libmoard in debug mode for more info \n");
	               break;
	           default:
                   fprintf(stderr, "\t MB_Clear returned error code: %d (see libmboard docs for details)\n", rc);
                   break;
	       }

	       
       	   exit(rc);
	    }
	    #endif
	
	    rc = MB_Clear(b_quality_price_info_1);
	    #ifdef ERRCHECK
	    if (rc != MB_SUCCESS)
	    {
	       fprintf(stderr, "ERROR: Could not clear 'quality_price_info_1' board\n");
	       switch(rc) {
	           case MB_ERR_INVALID:
	               fprintf(stderr, "\t reason: 'quality_price_info_1' board is invalid\n");
	               break;
	           case MB_ERR_LOCKED:
	               fprintf(stderr, "\t reason: 'quality_price_info_1' board is locked\n");
	               break;
	           case MB_ERR_INTERNAL:
	               fprintf(stderr, "\t reason: internal error. Recompile libmoard in debug mode for more info \n");
	               break;
	           default:
                   fprintf(stderr, "\t MB_Clear returned error code: %d (see libmboard docs for details)\n", rc);
                   break;
	       }

	       
       	   exit(rc);
	    }
	    #endif
	
	    rc = MB_Clear(b_quality_price_info_2);
	    #ifdef ERRCHECK
	    if (rc != MB_SUCCESS)
	    {
	       fprintf(stderr, "ERROR: Could not clear 'quality_price_info_2' board\n");
	       switch(rc) {
	           case MB_ERR_INVALID:
	               fprintf(stderr, "\t reason: 'quality_price_info_2' board is invalid\n");
	               break;
	           case MB_ERR_LOCKED:
	               fprintf(stderr, "\t reason: 'quality_price_info_2' board is locked\n");
	               break;
	           case MB_ERR_INTERNAL:
	               fprintf(stderr, "\t reason: internal error. Recompile libmoard in debug mode for more info \n");
	               break;
	           default:
                   fprintf(stderr, "\t MB_Clear returned error code: %d (see libmboard docs for details)\n", rc);
                   break;
	       }

	       
       	   exit(rc);
	    }
	    #endif
	
	    rc = MB_Clear(b_update_mall_stock);
	    #ifdef ERRCHECK
	    if (rc != MB_SUCCESS)
	    {
	       fprintf(stderr, "ERROR: Could not clear 'update_mall_stock' board\n");
	       switch(rc) {
	           case MB_ERR_INVALID:
	               fprintf(stderr, "\t reason: 'update_mall_stock' board is invalid\n");
	               break;
	           case MB_ERR_LOCKED:
	               fprintf(stderr, "\t reason: 'update_mall_stock' board is locked\n");
	               break;
	           case MB_ERR_INTERNAL:
	               fprintf(stderr, "\t reason: internal error. Recompile libmoard in debug mode for more info \n");
	               break;
	           default:
                   fprintf(stderr, "\t MB_Clear returned error code: %d (see libmboard docs for details)\n", rc);
                   break;
	       }

	       
       	   exit(rc);
	    }
	    #endif
	
	    rc = MB_Clear(b_consumption_request_1);
	    #ifdef ERRCHECK
	    if (rc != MB_SUCCESS)
	    {
	       fprintf(stderr, "ERROR: Could not clear 'consumption_request_1' board\n");
	       switch(rc) {
	           case MB_ERR_INVALID:
	               fprintf(stderr, "\t reason: 'consumption_request_1' board is invalid\n");
	               break;
	           case MB_ERR_LOCKED:
	               fprintf(stderr, "\t reason: 'consumption_request_1' board is locked\n");
	               break;
	           case MB_ERR_INTERNAL:
	               fprintf(stderr, "\t reason: internal error. Recompile libmoard in debug mode for more info \n");
	               break;
	           default:
                   fprintf(stderr, "\t MB_Clear returned error code: %d (see libmboard docs for details)\n", rc);
                   break;
	       }

	       
       	   exit(rc);
	    }
	    #endif
	
	    rc = MB_Clear(b_consumption_request_2);
	    #ifdef ERRCHECK
	    if (rc != MB_SUCCESS)
	    {
	       fprintf(stderr, "ERROR: Could not clear 'consumption_request_2' board\n");
	       switch(rc) {
	           case MB_ERR_INVALID:
	               fprintf(stderr, "\t reason: 'consumption_request_2' board is invalid\n");
	               break;
	           case MB_ERR_LOCKED:
	               fprintf(stderr, "\t reason: 'consumption_request_2' board is locked\n");
	               break;
	           case MB_ERR_INTERNAL:
	               fprintf(stderr, "\t reason: internal error. Recompile libmoard in debug mode for more info \n");
	               break;
	           default:
                   fprintf(stderr, "\t MB_Clear returned error code: %d (see libmboard docs for details)\n", rc);
                   break;
	       }

	       
       	   exit(rc);
	    }
	    #endif
	
	    rc = MB_Clear(b_accepted_consumption_1);
	    #ifdef ERRCHECK
	    if (rc != MB_SUCCESS)
	    {
	       fprintf(stderr, "ERROR: Could not clear 'accepted_consumption_1' board\n");
	       switch(rc) {
	           case MB_ERR_INVALID:
	               fprintf(stderr, "\t reason: 'accepted_consumption_1' board is invalid\n");
	               break;
	           case MB_ERR_LOCKED:
	               fprintf(stderr, "\t reason: 'accepted_consumption_1' board is locked\n");
	               break;
	           case MB_ERR_INTERNAL:
	               fprintf(stderr, "\t reason: internal error. Recompile libmoard in debug mode for more info \n");
	               break;
	           default:
                   fprintf(stderr, "\t MB_Clear returned error code: %d (see libmboard docs for details)\n", rc);
                   break;
	       }

	       
       	   exit(rc);
	    }
	    #endif
	
	    rc = MB_Clear(b_accepted_consumption_2);
	    #ifdef ERRCHECK
	    if (rc != MB_SUCCESS)
	    {
	       fprintf(stderr, "ERROR: Could not clear 'accepted_consumption_2' board\n");
	       switch(rc) {
	           case MB_ERR_INVALID:
	               fprintf(stderr, "\t reason: 'accepted_consumption_2' board is invalid\n");
	               break;
	           case MB_ERR_LOCKED:
	               fprintf(stderr, "\t reason: 'accepted_consumption_2' board is locked\n");
	               break;
	           case MB_ERR_INTERNAL:
	               fprintf(stderr, "\t reason: internal error. Recompile libmoard in debug mode for more info \n");
	               break;
	           default:
                   fprintf(stderr, "\t MB_Clear returned error code: %d (see libmboard docs for details)\n", rc);
                   break;
	       }

	       
       	   exit(rc);
	    }
	    #endif
	
	    rc = MB_Clear(b_sales);
	    #ifdef ERRCHECK
	    if (rc != MB_SUCCESS)
	    {
	       fprintf(stderr, "ERROR: Could not clear 'sales' board\n");
	       switch(rc) {
	           case MB_ERR_INVALID:
	               fprintf(stderr, "\t reason: 'sales' board is invalid\n");
	               break;
	           case MB_ERR_LOCKED:
	               fprintf(stderr, "\t reason: 'sales' board is locked\n");
	               break;
	           case MB_ERR_INTERNAL:
	               fprintf(stderr, "\t reason: internal error. Recompile libmoard in debug mode for more info \n");
	               break;
	           default:
                   fprintf(stderr, "\t MB_Clear returned error code: %d (see libmboard docs for details)\n", rc);
                   break;
	       }

	       
       	   exit(rc);
	    }
	    #endif
	
	    rc = MB_Clear(b_specific_skill_update);
	    #ifdef ERRCHECK
	    if (rc != MB_SUCCESS)
	    {
	       fprintf(stderr, "ERROR: Could not clear 'specific_skill_update' board\n");
	       switch(rc) {
	           case MB_ERR_INVALID:
	               fprintf(stderr, "\t reason: 'specific_skill_update' board is invalid\n");
	               break;
	           case MB_ERR_LOCKED:
	               fprintf(stderr, "\t reason: 'specific_skill_update' board is locked\n");
	               break;
	           case MB_ERR_INTERNAL:
	               fprintf(stderr, "\t reason: internal error. Recompile libmoard in debug mode for more info \n");
	               break;
	           default:
                   fprintf(stderr, "\t MB_Clear returned error code: %d (see libmboard docs for details)\n", rc);
                   break;
	       }

	       
       	   exit(rc);
	    }
	    #endif
	
	    rc = MB_Clear(b_policy_rate);
	    #ifdef ERRCHECK
	    if (rc != MB_SUCCESS)
	    {
	       fprintf(stderr, "ERROR: Could not clear 'policy_rate' board\n");
	       switch(rc) {
	           case MB_ERR_INVALID:
	               fprintf(stderr, "\t reason: 'policy_rate' board is invalid\n");
	               break;
	           case MB_ERR_LOCKED:
	               fprintf(stderr, "\t reason: 'policy_rate' board is locked\n");
	               break;
	           case MB_ERR_INTERNAL:
	               fprintf(stderr, "\t reason: internal error. Recompile libmoard in debug mode for more info \n");
	               break;
	           default:
                   fprintf(stderr, "\t MB_Clear returned error code: %d (see libmboard docs for details)\n", rc);
                   break;
	       }

	       
       	   exit(rc);
	    }
	    #endif
	
	    rc = MB_Clear(b_bank_identity);
	    #ifdef ERRCHECK
	    if (rc != MB_SUCCESS)
	    {
	       fprintf(stderr, "ERROR: Could not clear 'bank_identity' board\n");
	       switch(rc) {
	           case MB_ERR_INVALID:
	               fprintf(stderr, "\t reason: 'bank_identity' board is invalid\n");
	               break;
	           case MB_ERR_LOCKED:
	               fprintf(stderr, "\t reason: 'bank_identity' board is locked\n");
	               break;
	           case MB_ERR_INTERNAL:
	               fprintf(stderr, "\t reason: internal error. Recompile libmoard in debug mode for more info \n");
	               break;
	           default:
                   fprintf(stderr, "\t MB_Clear returned error code: %d (see libmboard docs for details)\n", rc);
                   break;
	       }

	       
       	   exit(rc);
	    }
	    #endif
	
	    rc = MB_Clear(b_loan_request);
	    #ifdef ERRCHECK
	    if (rc != MB_SUCCESS)
	    {
	       fprintf(stderr, "ERROR: Could not clear 'loan_request' board\n");
	       switch(rc) {
	           case MB_ERR_INVALID:
	               fprintf(stderr, "\t reason: 'loan_request' board is invalid\n");
	               break;
	           case MB_ERR_LOCKED:
	               fprintf(stderr, "\t reason: 'loan_request' board is locked\n");
	               break;
	           case MB_ERR_INTERNAL:
	               fprintf(stderr, "\t reason: internal error. Recompile libmoard in debug mode for more info \n");
	               break;
	           default:
                   fprintf(stderr, "\t MB_Clear returned error code: %d (see libmboard docs for details)\n", rc);
                   break;
	       }

	       
       	   exit(rc);
	    }
	    #endif
	
	    rc = MB_Clear(b_loan_request_ranked);
	    #ifdef ERRCHECK
	    if (rc != MB_SUCCESS)
	    {
	       fprintf(stderr, "ERROR: Could not clear 'loan_request_ranked' board\n");
	       switch(rc) {
	           case MB_ERR_INVALID:
	               fprintf(stderr, "\t reason: 'loan_request_ranked' board is invalid\n");
	               break;
	           case MB_ERR_LOCKED:
	               fprintf(stderr, "\t reason: 'loan_request_ranked' board is locked\n");
	               break;
	           case MB_ERR_INTERNAL:
	               fprintf(stderr, "\t reason: internal error. Recompile libmoard in debug mode for more info \n");
	               break;
	           default:
                   fprintf(stderr, "\t MB_Clear returned error code: %d (see libmboard docs for details)\n", rc);
                   break;
	       }

	       
       	   exit(rc);
	    }
	    #endif
	
	    rc = MB_Clear(b_loan_conditions);
	    #ifdef ERRCHECK
	    if (rc != MB_SUCCESS)
	    {
	       fprintf(stderr, "ERROR: Could not clear 'loan_conditions' board\n");
	       switch(rc) {
	           case MB_ERR_INVALID:
	               fprintf(stderr, "\t reason: 'loan_conditions' board is invalid\n");
	               break;
	           case MB_ERR_LOCKED:
	               fprintf(stderr, "\t reason: 'loan_conditions' board is locked\n");
	               break;
	           case MB_ERR_INTERNAL:
	               fprintf(stderr, "\t reason: internal error. Recompile libmoard in debug mode for more info \n");
	               break;
	           default:
                   fprintf(stderr, "\t MB_Clear returned error code: %d (see libmboard docs for details)\n", rc);
                   break;
	       }

	       
       	   exit(rc);
	    }
	    #endif
	
	    rc = MB_Clear(b_loan_acceptance);
	    #ifdef ERRCHECK
	    if (rc != MB_SUCCESS)
	    {
	       fprintf(stderr, "ERROR: Could not clear 'loan_acceptance' board\n");
	       switch(rc) {
	           case MB_ERR_INVALID:
	               fprintf(stderr, "\t reason: 'loan_acceptance' board is invalid\n");
	               break;
	           case MB_ERR_LOCKED:
	               fprintf(stderr, "\t reason: 'loan_acceptance' board is locked\n");
	               break;
	           case MB_ERR_INTERNAL:
	               fprintf(stderr, "\t reason: internal error. Recompile libmoard in debug mode for more info \n");
	               break;
	           default:
                   fprintf(stderr, "\t MB_Clear returned error code: %d (see libmboard docs for details)\n", rc);
                   break;
	       }

	       
       	   exit(rc);
	    }
	    #endif
	
	    rc = MB_Clear(b_installment);
	    #ifdef ERRCHECK
	    if (rc != MB_SUCCESS)
	    {
	       fprintf(stderr, "ERROR: Could not clear 'installment' board\n");
	       switch(rc) {
	           case MB_ERR_INVALID:
	               fprintf(stderr, "\t reason: 'installment' board is invalid\n");
	               break;
	           case MB_ERR_LOCKED:
	               fprintf(stderr, "\t reason: 'installment' board is locked\n");
	               break;
	           case MB_ERR_INTERNAL:
	               fprintf(stderr, "\t reason: internal error. Recompile libmoard in debug mode for more info \n");
	               break;
	           default:
                   fprintf(stderr, "\t MB_Clear returned error code: %d (see libmboard docs for details)\n", rc);
                   break;
	       }

	       
       	   exit(rc);
	    }
	    #endif
	
	    rc = MB_Clear(b_bankruptcy);
	    #ifdef ERRCHECK
	    if (rc != MB_SUCCESS)
	    {
	       fprintf(stderr, "ERROR: Could not clear 'bankruptcy' board\n");
	       switch(rc) {
	           case MB_ERR_INVALID:
	               fprintf(stderr, "\t reason: 'bankruptcy' board is invalid\n");
	               break;
	           case MB_ERR_LOCKED:
	               fprintf(stderr, "\t reason: 'bankruptcy' board is locked\n");
	               break;
	           case MB_ERR_INTERNAL:
	               fprintf(stderr, "\t reason: internal error. Recompile libmoard in debug mode for more info \n");
	               break;
	           default:
                   fprintf(stderr, "\t MB_Clear returned error code: %d (see libmboard docs for details)\n", rc);
                   break;
	       }

	       
       	   exit(rc);
	    }
	    #endif
	
	    rc = MB_Clear(b_bank_interest_payment);
	    #ifdef ERRCHECK
	    if (rc != MB_SUCCESS)
	    {
	       fprintf(stderr, "ERROR: Could not clear 'bank_interest_payment' board\n");
	       switch(rc) {
	           case MB_ERR_INVALID:
	               fprintf(stderr, "\t reason: 'bank_interest_payment' board is invalid\n");
	               break;
	           case MB_ERR_LOCKED:
	               fprintf(stderr, "\t reason: 'bank_interest_payment' board is locked\n");
	               break;
	           case MB_ERR_INTERNAL:
	               fprintf(stderr, "\t reason: internal error. Recompile libmoard in debug mode for more info \n");
	               break;
	           default:
                   fprintf(stderr, "\t MB_Clear returned error code: %d (see libmboard docs for details)\n", rc);
                   break;
	       }

	       
       	   exit(rc);
	    }
	    #endif
	
	    rc = MB_Clear(b_account_interest);
	    #ifdef ERRCHECK
	    if (rc != MB_SUCCESS)
	    {
	       fprintf(stderr, "ERROR: Could not clear 'account_interest' board\n");
	       switch(rc) {
	           case MB_ERR_INVALID:
	               fprintf(stderr, "\t reason: 'account_interest' board is invalid\n");
	               break;
	           case MB_ERR_LOCKED:
	               fprintf(stderr, "\t reason: 'account_interest' board is locked\n");
	               break;
	           case MB_ERR_INTERNAL:
	               fprintf(stderr, "\t reason: internal error. Recompile libmoard in debug mode for more info \n");
	               break;
	           default:
                   fprintf(stderr, "\t MB_Clear returned error code: %d (see libmboard docs for details)\n", rc);
                   break;
	       }

	       
       	   exit(rc);
	    }
	    #endif
	
	    rc = MB_Clear(b_ecb_dividend);
	    #ifdef ERRCHECK
	    if (rc != MB_SUCCESS)
	    {
	       fprintf(stderr, "ERROR: Could not clear 'ecb_dividend' board\n");
	       switch(rc) {
	           case MB_ERR_INVALID:
	               fprintf(stderr, "\t reason: 'ecb_dividend' board is invalid\n");
	               break;
	           case MB_ERR_LOCKED:
	               fprintf(stderr, "\t reason: 'ecb_dividend' board is locked\n");
	               break;
	           case MB_ERR_INTERNAL:
	               fprintf(stderr, "\t reason: internal error. Recompile libmoard in debug mode for more info \n");
	               break;
	           default:
                   fprintf(stderr, "\t MB_Clear returned error code: %d (see libmboard docs for details)\n", rc);
                   break;
	       }

	       
       	   exit(rc);
	    }
	    #endif
	
	    rc = MB_Clear(b_credit_var_update);
	    #ifdef ERRCHECK
	    if (rc != MB_SUCCESS)
	    {
	       fprintf(stderr, "ERROR: Could not clear 'credit_var_update' board\n");
	       switch(rc) {
	           case MB_ERR_INVALID:
	               fprintf(stderr, "\t reason: 'credit_var_update' board is invalid\n");
	               break;
	           case MB_ERR_LOCKED:
	               fprintf(stderr, "\t reason: 'credit_var_update' board is locked\n");
	               break;
	           case MB_ERR_INTERNAL:
	               fprintf(stderr, "\t reason: internal error. Recompile libmoard in debug mode for more info \n");
	               break;
	           default:
                   fprintf(stderr, "\t MB_Clear returned error code: %d (see libmboard docs for details)\n", rc);
                   break;
	       }

	       
       	   exit(rc);
	    }
	    #endif
	
	    rc = MB_Clear(b_bankruptcy_illiquidity);
	    #ifdef ERRCHECK
	    if (rc != MB_SUCCESS)
	    {
	       fprintf(stderr, "ERROR: Could not clear 'bankruptcy_illiquidity' board\n");
	       switch(rc) {
	           case MB_ERR_INVALID:
	               fprintf(stderr, "\t reason: 'bankruptcy_illiquidity' board is invalid\n");
	               break;
	           case MB_ERR_LOCKED:
	               fprintf(stderr, "\t reason: 'bankruptcy_illiquidity' board is locked\n");
	               break;
	           case MB_ERR_INTERNAL:
	               fprintf(stderr, "\t reason: internal error. Recompile libmoard in debug mode for more info \n");
	               break;
	           default:
                   fprintf(stderr, "\t MB_Clear returned error code: %d (see libmboard docs for details)\n", rc);
                   break;
	       }

	       
       	   exit(rc);
	    }
	    #endif
	
	    rc = MB_Clear(b_bankruptcy_insolvency);
	    #ifdef ERRCHECK
	    if (rc != MB_SUCCESS)
	    {
	       fprintf(stderr, "ERROR: Could not clear 'bankruptcy_insolvency' board\n");
	       switch(rc) {
	           case MB_ERR_INVALID:
	               fprintf(stderr, "\t reason: 'bankruptcy_insolvency' board is invalid\n");
	               break;
	           case MB_ERR_LOCKED:
	               fprintf(stderr, "\t reason: 'bankruptcy_insolvency' board is locked\n");
	               break;
	           case MB_ERR_INTERNAL:
	               fprintf(stderr, "\t reason: internal error. Recompile libmoard in debug mode for more info \n");
	               break;
	           default:
                   fprintf(stderr, "\t MB_Clear returned error code: %d (see libmboard docs for details)\n", rc);
                   break;
	       }

	       
       	   exit(rc);
	    }
	    #endif
	
	    rc = MB_Clear(b_index_info);
	    #ifdef ERRCHECK
	    if (rc != MB_SUCCESS)
	    {
	       fprintf(stderr, "ERROR: Could not clear 'index_info' board\n");
	       switch(rc) {
	           case MB_ERR_INVALID:
	               fprintf(stderr, "\t reason: 'index_info' board is invalid\n");
	               break;
	           case MB_ERR_LOCKED:
	               fprintf(stderr, "\t reason: 'index_info' board is locked\n");
	               break;
	           case MB_ERR_INTERNAL:
	               fprintf(stderr, "\t reason: internal error. Recompile libmoard in debug mode for more info \n");
	               break;
	           default:
                   fprintf(stderr, "\t MB_Clear returned error code: %d (see libmboard docs for details)\n", rc);
                   break;
	       }

	       
       	   exit(rc);
	    }
	    #endif
	
	    rc = MB_Clear(b_index_price);
	    #ifdef ERRCHECK
	    if (rc != MB_SUCCESS)
	    {
	       fprintf(stderr, "ERROR: Could not clear 'index_price' board\n");
	       switch(rc) {
	           case MB_ERR_INVALID:
	               fprintf(stderr, "\t reason: 'index_price' board is invalid\n");
	               break;
	           case MB_ERR_LOCKED:
	               fprintf(stderr, "\t reason: 'index_price' board is locked\n");
	               break;
	           case MB_ERR_INTERNAL:
	               fprintf(stderr, "\t reason: internal error. Recompile libmoard in debug mode for more info \n");
	               break;
	           default:
                   fprintf(stderr, "\t MB_Clear returned error code: %d (see libmboard docs for details)\n", rc);
                   break;
	       }

	       
       	   exit(rc);
	    }
	    #endif
	
	    rc = MB_Clear(b_order);
	    #ifdef ERRCHECK
	    if (rc != MB_SUCCESS)
	    {
	       fprintf(stderr, "ERROR: Could not clear 'order' board\n");
	       switch(rc) {
	           case MB_ERR_INVALID:
	               fprintf(stderr, "\t reason: 'order' board is invalid\n");
	               break;
	           case MB_ERR_LOCKED:
	               fprintf(stderr, "\t reason: 'order' board is locked\n");
	               break;
	           case MB_ERR_INTERNAL:
	               fprintf(stderr, "\t reason: internal error. Recompile libmoard in debug mode for more info \n");
	               break;
	           default:
                   fprintf(stderr, "\t MB_Clear returned error code: %d (see libmboard docs for details)\n", rc);
                   break;
	       }

	       
       	   exit(rc);
	    }
	    #endif
	
	    rc = MB_Clear(b_order_status);
	    #ifdef ERRCHECK
	    if (rc != MB_SUCCESS)
	    {
	       fprintf(stderr, "ERROR: Could not clear 'order_status' board\n");
	       switch(rc) {
	           case MB_ERR_INVALID:
	               fprintf(stderr, "\t reason: 'order_status' board is invalid\n");
	               break;
	           case MB_ERR_LOCKED:
	               fprintf(stderr, "\t reason: 'order_status' board is locked\n");
	               break;
	           case MB_ERR_INTERNAL:
	               fprintf(stderr, "\t reason: internal error. Recompile libmoard in debug mode for more info \n");
	               break;
	           default:
                   fprintf(stderr, "\t MB_Clear returned error code: %d (see libmboard docs for details)\n", rc);
                   break;
	       }

	       
       	   exit(rc);
	    }
	    #endif
	
	    rc = MB_Clear(b_dividend_info);
	    #ifdef ERRCHECK
	    if (rc != MB_SUCCESS)
	    {
	       fprintf(stderr, "ERROR: Could not clear 'dividend_info' board\n");
	       switch(rc) {
	           case MB_ERR_INVALID:
	               fprintf(stderr, "\t reason: 'dividend_info' board is invalid\n");
	               break;
	           case MB_ERR_LOCKED:
	               fprintf(stderr, "\t reason: 'dividend_info' board is locked\n");
	               break;
	           case MB_ERR_INTERNAL:
	               fprintf(stderr, "\t reason: internal error. Recompile libmoard in debug mode for more info \n");
	               break;
	           default:
                   fprintf(stderr, "\t MB_Clear returned error code: %d (see libmboard docs for details)\n", rc);
                   break;
	       }

	       
       	   exit(rc);
	    }
	    #endif
	
	    rc = MB_Clear(b_productivity);
	    #ifdef ERRCHECK
	    if (rc != MB_SUCCESS)
	    {
	       fprintf(stderr, "ERROR: Could not clear 'productivity' board\n");
	       switch(rc) {
	           case MB_ERR_INVALID:
	               fprintf(stderr, "\t reason: 'productivity' board is invalid\n");
	               break;
	           case MB_ERR_LOCKED:
	               fprintf(stderr, "\t reason: 'productivity' board is locked\n");
	               break;
	           case MB_ERR_INTERNAL:
	               fprintf(stderr, "\t reason: internal error. Recompile libmoard in debug mode for more info \n");
	               break;
	           default:
                   fprintf(stderr, "\t MB_Clear returned error code: %d (see libmboard docs for details)\n", rc);
                   break;
	       }

	       
       	   exit(rc);
	    }
	    #endif
	
	    rc = MB_Clear(b_capital_good_request);
	    #ifdef ERRCHECK
	    if (rc != MB_SUCCESS)
	    {
	       fprintf(stderr, "ERROR: Could not clear 'capital_good_request' board\n");
	       switch(rc) {
	           case MB_ERR_INVALID:
	               fprintf(stderr, "\t reason: 'capital_good_request' board is invalid\n");
	               break;
	           case MB_ERR_LOCKED:
	               fprintf(stderr, "\t reason: 'capital_good_request' board is locked\n");
	               break;
	           case MB_ERR_INTERNAL:
	               fprintf(stderr, "\t reason: internal error. Recompile libmoard in debug mode for more info \n");
	               break;
	           default:
                   fprintf(stderr, "\t MB_Clear returned error code: %d (see libmboard docs for details)\n", rc);
                   break;
	       }

	       
       	   exit(rc);
	    }
	    #endif
	
	    rc = MB_Clear(b_capital_good_delivery);
	    #ifdef ERRCHECK
	    if (rc != MB_SUCCESS)
	    {
	       fprintf(stderr, "ERROR: Could not clear 'capital_good_delivery' board\n");
	       switch(rc) {
	           case MB_ERR_INVALID:
	               fprintf(stderr, "\t reason: 'capital_good_delivery' board is invalid\n");
	               break;
	           case MB_ERR_LOCKED:
	               fprintf(stderr, "\t reason: 'capital_good_delivery' board is locked\n");
	               break;
	           case MB_ERR_INTERNAL:
	               fprintf(stderr, "\t reason: internal error. Recompile libmoard in debug mode for more info \n");
	               break;
	           default:
                   fprintf(stderr, "\t MB_Clear returned error code: %d (see libmboard docs for details)\n", rc);
                   break;
	       }

	       
       	   exit(rc);
	    }
	    #endif
	
	    rc = MB_Clear(b_pay_capital_goods);
	    #ifdef ERRCHECK
	    if (rc != MB_SUCCESS)
	    {
	       fprintf(stderr, "ERROR: Could not clear 'pay_capital_goods' board\n");
	       switch(rc) {
	           case MB_ERR_INVALID:
	               fprintf(stderr, "\t reason: 'pay_capital_goods' board is invalid\n");
	               break;
	           case MB_ERR_LOCKED:
	               fprintf(stderr, "\t reason: 'pay_capital_goods' board is locked\n");
	               break;
	           case MB_ERR_INTERNAL:
	               fprintf(stderr, "\t reason: internal error. Recompile libmoard in debug mode for more info \n");
	               break;
	           default:
                   fprintf(stderr, "\t MB_Clear returned error code: %d (see libmboard docs for details)\n", rc);
                   break;
	       }

	       
       	   exit(rc);
	    }
	    #endif
	
	    rc = MB_Clear(b_vacancies);
	    #ifdef ERRCHECK
	    if (rc != MB_SUCCESS)
	    {
	       fprintf(stderr, "ERROR: Could not clear 'vacancies' board\n");
	       switch(rc) {
	           case MB_ERR_INVALID:
	               fprintf(stderr, "\t reason: 'vacancies' board is invalid\n");
	               break;
	           case MB_ERR_LOCKED:
	               fprintf(stderr, "\t reason: 'vacancies' board is locked\n");
	               break;
	           case MB_ERR_INTERNAL:
	               fprintf(stderr, "\t reason: internal error. Recompile libmoard in debug mode for more info \n");
	               break;
	           default:
                   fprintf(stderr, "\t MB_Clear returned error code: %d (see libmboard docs for details)\n", rc);
                   break;
	       }

	       
       	   exit(rc);
	    }
	    #endif
	
	    rc = MB_Clear(b_vacancies2);
	    #ifdef ERRCHECK
	    if (rc != MB_SUCCESS)
	    {
	       fprintf(stderr, "ERROR: Could not clear 'vacancies2' board\n");
	       switch(rc) {
	           case MB_ERR_INVALID:
	               fprintf(stderr, "\t reason: 'vacancies2' board is invalid\n");
	               break;
	           case MB_ERR_LOCKED:
	               fprintf(stderr, "\t reason: 'vacancies2' board is locked\n");
	               break;
	           case MB_ERR_INTERNAL:
	               fprintf(stderr, "\t reason: internal error. Recompile libmoard in debug mode for more info \n");
	               break;
	           default:
                   fprintf(stderr, "\t MB_Clear returned error code: %d (see libmboard docs for details)\n", rc);
                   break;
	       }

	       
       	   exit(rc);
	    }
	    #endif
	
	    rc = MB_Clear(b_vacancies_r_and_d_employees);
	    #ifdef ERRCHECK
	    if (rc != MB_SUCCESS)
	    {
	       fprintf(stderr, "ERROR: Could not clear 'vacancies_r_and_d_employees' board\n");
	       switch(rc) {
	           case MB_ERR_INVALID:
	               fprintf(stderr, "\t reason: 'vacancies_r_and_d_employees' board is invalid\n");
	               break;
	           case MB_ERR_LOCKED:
	               fprintf(stderr, "\t reason: 'vacancies_r_and_d_employees' board is locked\n");
	               break;
	           case MB_ERR_INTERNAL:
	               fprintf(stderr, "\t reason: internal error. Recompile libmoard in debug mode for more info \n");
	               break;
	           default:
                   fprintf(stderr, "\t MB_Clear returned error code: %d (see libmboard docs for details)\n", rc);
                   break;
	       }

	       
       	   exit(rc);
	    }
	    #endif
	
	    rc = MB_Clear(b_vacancies_r_and_d_employees2);
	    #ifdef ERRCHECK
	    if (rc != MB_SUCCESS)
	    {
	       fprintf(stderr, "ERROR: Could not clear 'vacancies_r_and_d_employees2' board\n");
	       switch(rc) {
	           case MB_ERR_INVALID:
	               fprintf(stderr, "\t reason: 'vacancies_r_and_d_employees2' board is invalid\n");
	               break;
	           case MB_ERR_LOCKED:
	               fprintf(stderr, "\t reason: 'vacancies_r_and_d_employees2' board is locked\n");
	               break;
	           case MB_ERR_INTERNAL:
	               fprintf(stderr, "\t reason: internal error. Recompile libmoard in debug mode for more info \n");
	               break;
	           default:
                   fprintf(stderr, "\t MB_Clear returned error code: %d (see libmboard docs for details)\n", rc);
                   break;
	       }

	       
       	   exit(rc);
	    }
	    #endif
	
	    rc = MB_Clear(b_firing);
	    #ifdef ERRCHECK
	    if (rc != MB_SUCCESS)
	    {
	       fprintf(stderr, "ERROR: Could not clear 'firing' board\n");
	       switch(rc) {
	           case MB_ERR_INVALID:
	               fprintf(stderr, "\t reason: 'firing' board is invalid\n");
	               break;
	           case MB_ERR_LOCKED:
	               fprintf(stderr, "\t reason: 'firing' board is locked\n");
	               break;
	           case MB_ERR_INTERNAL:
	               fprintf(stderr, "\t reason: internal error. Recompile libmoard in debug mode for more info \n");
	               break;
	           default:
                   fprintf(stderr, "\t MB_Clear returned error code: %d (see libmboard docs for details)\n", rc);
                   break;
	       }

	       
       	   exit(rc);
	    }
	    #endif
	
	    rc = MB_Clear(b_job_application);
	    #ifdef ERRCHECK
	    if (rc != MB_SUCCESS)
	    {
	       fprintf(stderr, "ERROR: Could not clear 'job_application' board\n");
	       switch(rc) {
	           case MB_ERR_INVALID:
	               fprintf(stderr, "\t reason: 'job_application' board is invalid\n");
	               break;
	           case MB_ERR_LOCKED:
	               fprintf(stderr, "\t reason: 'job_application' board is locked\n");
	               break;
	           case MB_ERR_INTERNAL:
	               fprintf(stderr, "\t reason: internal error. Recompile libmoard in debug mode for more info \n");
	               break;
	           default:
                   fprintf(stderr, "\t MB_Clear returned error code: %d (see libmboard docs for details)\n", rc);
                   break;
	       }

	       
       	   exit(rc);
	    }
	    #endif
	
	    rc = MB_Clear(b_job_application2);
	    #ifdef ERRCHECK
	    if (rc != MB_SUCCESS)
	    {
	       fprintf(stderr, "ERROR: Could not clear 'job_application2' board\n");
	       switch(rc) {
	           case MB_ERR_INVALID:
	               fprintf(stderr, "\t reason: 'job_application2' board is invalid\n");
	               break;
	           case MB_ERR_LOCKED:
	               fprintf(stderr, "\t reason: 'job_application2' board is locked\n");
	               break;
	           case MB_ERR_INTERNAL:
	               fprintf(stderr, "\t reason: internal error. Recompile libmoard in debug mode for more info \n");
	               break;
	           default:
                   fprintf(stderr, "\t MB_Clear returned error code: %d (see libmboard docs for details)\n", rc);
                   break;
	       }

	       
       	   exit(rc);
	    }
	    #endif
	
	    rc = MB_Clear(b_job_offer);
	    #ifdef ERRCHECK
	    if (rc != MB_SUCCESS)
	    {
	       fprintf(stderr, "ERROR: Could not clear 'job_offer' board\n");
	       switch(rc) {
	           case MB_ERR_INVALID:
	               fprintf(stderr, "\t reason: 'job_offer' board is invalid\n");
	               break;
	           case MB_ERR_LOCKED:
	               fprintf(stderr, "\t reason: 'job_offer' board is locked\n");
	               break;
	           case MB_ERR_INTERNAL:
	               fprintf(stderr, "\t reason: internal error. Recompile libmoard in debug mode for more info \n");
	               break;
	           default:
                   fprintf(stderr, "\t MB_Clear returned error code: %d (see libmboard docs for details)\n", rc);
                   break;
	       }

	       
       	   exit(rc);
	    }
	    #endif
	
	    rc = MB_Clear(b_job_offer2);
	    #ifdef ERRCHECK
	    if (rc != MB_SUCCESS)
	    {
	       fprintf(stderr, "ERROR: Could not clear 'job_offer2' board\n");
	       switch(rc) {
	           case MB_ERR_INVALID:
	               fprintf(stderr, "\t reason: 'job_offer2' board is invalid\n");
	               break;
	           case MB_ERR_LOCKED:
	               fprintf(stderr, "\t reason: 'job_offer2' board is locked\n");
	               break;
	           case MB_ERR_INTERNAL:
	               fprintf(stderr, "\t reason: internal error. Recompile libmoard in debug mode for more info \n");
	               break;
	           default:
                   fprintf(stderr, "\t MB_Clear returned error code: %d (see libmboard docs for details)\n", rc);
                   break;
	       }

	       
       	   exit(rc);
	    }
	    #endif
	
	    rc = MB_Clear(b_job_acceptance);
	    #ifdef ERRCHECK
	    if (rc != MB_SUCCESS)
	    {
	       fprintf(stderr, "ERROR: Could not clear 'job_acceptance' board\n");
	       switch(rc) {
	           case MB_ERR_INVALID:
	               fprintf(stderr, "\t reason: 'job_acceptance' board is invalid\n");
	               break;
	           case MB_ERR_LOCKED:
	               fprintf(stderr, "\t reason: 'job_acceptance' board is locked\n");
	               break;
	           case MB_ERR_INTERNAL:
	               fprintf(stderr, "\t reason: internal error. Recompile libmoard in debug mode for more info \n");
	               break;
	           default:
                   fprintf(stderr, "\t MB_Clear returned error code: %d (see libmboard docs for details)\n", rc);
                   break;
	       }

	       
       	   exit(rc);
	    }
	    #endif
	
	    rc = MB_Clear(b_job_acceptance2);
	    #ifdef ERRCHECK
	    if (rc != MB_SUCCESS)
	    {
	       fprintf(stderr, "ERROR: Could not clear 'job_acceptance2' board\n");
	       switch(rc) {
	           case MB_ERR_INVALID:
	               fprintf(stderr, "\t reason: 'job_acceptance2' board is invalid\n");
	               break;
	           case MB_ERR_LOCKED:
	               fprintf(stderr, "\t reason: 'job_acceptance2' board is locked\n");
	               break;
	           case MB_ERR_INTERNAL:
	               fprintf(stderr, "\t reason: internal error. Recompile libmoard in debug mode for more info \n");
	               break;
	           default:
                   fprintf(stderr, "\t MB_Clear returned error code: %d (see libmboard docs for details)\n", rc);
                   break;
	       }

	       
       	   exit(rc);
	    }
	    #endif
	
	    rc = MB_Clear(b_quitting);
	    #ifdef ERRCHECK
	    if (rc != MB_SUCCESS)
	    {
	       fprintf(stderr, "ERROR: Could not clear 'quitting' board\n");
	       switch(rc) {
	           case MB_ERR_INVALID:
	               fprintf(stderr, "\t reason: 'quitting' board is invalid\n");
	               break;
	           case MB_ERR_LOCKED:
	               fprintf(stderr, "\t reason: 'quitting' board is locked\n");
	               break;
	           case MB_ERR_INTERNAL:
	               fprintf(stderr, "\t reason: internal error. Recompile libmoard in debug mode for more info \n");
	               break;
	           default:
                   fprintf(stderr, "\t MB_Clear returned error code: %d (see libmboard docs for details)\n", rc);
                   break;
	       }

	       
       	   exit(rc);
	    }
	    #endif
	
	    rc = MB_Clear(b_quitting2);
	    #ifdef ERRCHECK
	    if (rc != MB_SUCCESS)
	    {
	       fprintf(stderr, "ERROR: Could not clear 'quitting2' board\n");
	       switch(rc) {
	           case MB_ERR_INVALID:
	               fprintf(stderr, "\t reason: 'quitting2' board is invalid\n");
	               break;
	           case MB_ERR_LOCKED:
	               fprintf(stderr, "\t reason: 'quitting2' board is locked\n");
	               break;
	           case MB_ERR_INTERNAL:
	               fprintf(stderr, "\t reason: internal error. Recompile libmoard in debug mode for more info \n");
	               break;
	           default:
                   fprintf(stderr, "\t MB_Clear returned error code: %d (see libmboard docs for details)\n", rc);
                   break;
	       }

	       
       	   exit(rc);
	    }
	    #endif
	
	    rc = MB_Clear(b_unemployment_notification);
	    #ifdef ERRCHECK
	    if (rc != MB_SUCCESS)
	    {
	       fprintf(stderr, "ERROR: Could not clear 'unemployment_notification' board\n");
	       switch(rc) {
	           case MB_ERR_INVALID:
	               fprintf(stderr, "\t reason: 'unemployment_notification' board is invalid\n");
	               break;
	           case MB_ERR_LOCKED:
	               fprintf(stderr, "\t reason: 'unemployment_notification' board is locked\n");
	               break;
	           case MB_ERR_INTERNAL:
	               fprintf(stderr, "\t reason: internal error. Recompile libmoard in debug mode for more info \n");
	               break;
	           default:
                   fprintf(stderr, "\t MB_Clear returned error code: %d (see libmboard docs for details)\n", rc);
                   break;
	       }

	       
       	   exit(rc);
	    }
	    #endif
	
	    rc = MB_Clear(b_policy_announcement);
	    #ifdef ERRCHECK
	    if (rc != MB_SUCCESS)
	    {
	       fprintf(stderr, "ERROR: Could not clear 'policy_announcement' board\n");
	       switch(rc) {
	           case MB_ERR_INVALID:
	               fprintf(stderr, "\t reason: 'policy_announcement' board is invalid\n");
	               break;
	           case MB_ERR_LOCKED:
	               fprintf(stderr, "\t reason: 'policy_announcement' board is locked\n");
	               break;
	           case MB_ERR_INTERNAL:
	               fprintf(stderr, "\t reason: internal error. Recompile libmoard in debug mode for more info \n");
	               break;
	           default:
                   fprintf(stderr, "\t MB_Clear returned error code: %d (see libmboard docs for details)\n", rc);
                   break;
	       }

	       
       	   exit(rc);
	    }
	    #endif
	
	    rc = MB_Clear(b_tax_payment);
	    #ifdef ERRCHECK
	    if (rc != MB_SUCCESS)
	    {
	       fprintf(stderr, "ERROR: Could not clear 'tax_payment' board\n");
	       switch(rc) {
	           case MB_ERR_INVALID:
	               fprintf(stderr, "\t reason: 'tax_payment' board is invalid\n");
	               break;
	           case MB_ERR_LOCKED:
	               fprintf(stderr, "\t reason: 'tax_payment' board is locked\n");
	               break;
	           case MB_ERR_INTERNAL:
	               fprintf(stderr, "\t reason: internal error. Recompile libmoard in debug mode for more info \n");
	               break;
	           default:
                   fprintf(stderr, "\t MB_Clear returned error code: %d (see libmboard docs for details)\n", rc);
                   break;
	       }

	       
       	   exit(rc);
	    }
	    #endif
	
	    rc = MB_Clear(b_unemployment_benefit_restitution);
	    #ifdef ERRCHECK
	    if (rc != MB_SUCCESS)
	    {
	       fprintf(stderr, "ERROR: Could not clear 'unemployment_benefit_restitution' board\n");
	       switch(rc) {
	           case MB_ERR_INVALID:
	               fprintf(stderr, "\t reason: 'unemployment_benefit_restitution' board is invalid\n");
	               break;
	           case MB_ERR_LOCKED:
	               fprintf(stderr, "\t reason: 'unemployment_benefit_restitution' board is locked\n");
	               break;
	           case MB_ERR_INTERNAL:
	               fprintf(stderr, "\t reason: internal error. Recompile libmoard in debug mode for more info \n");
	               break;
	           default:
                   fprintf(stderr, "\t MB_Clear returned error code: %d (see libmboard docs for details)\n", rc);
                   break;
	       }

	       
       	   exit(rc);
	    }
	    #endif
	
	    rc = MB_Clear(b_hh_transfer_notification);
	    #ifdef ERRCHECK
	    if (rc != MB_SUCCESS)
	    {
	       fprintf(stderr, "ERROR: Could not clear 'hh_transfer_notification' board\n");
	       switch(rc) {
	           case MB_ERR_INVALID:
	               fprintf(stderr, "\t reason: 'hh_transfer_notification' board is invalid\n");
	               break;
	           case MB_ERR_LOCKED:
	               fprintf(stderr, "\t reason: 'hh_transfer_notification' board is locked\n");
	               break;
	           case MB_ERR_INTERNAL:
	               fprintf(stderr, "\t reason: internal error. Recompile libmoard in debug mode for more info \n");
	               break;
	           default:
                   fprintf(stderr, "\t MB_Clear returned error code: %d (see libmboard docs for details)\n", rc);
                   break;
	       }

	       
       	   exit(rc);
	    }
	    #endif
	
	    rc = MB_Clear(b_hh_subsidy_notification);
	    #ifdef ERRCHECK
	    if (rc != MB_SUCCESS)
	    {
	       fprintf(stderr, "ERROR: Could not clear 'hh_subsidy_notification' board\n");
	       switch(rc) {
	           case MB_ERR_INVALID:
	               fprintf(stderr, "\t reason: 'hh_subsidy_notification' board is invalid\n");
	               break;
	           case MB_ERR_LOCKED:
	               fprintf(stderr, "\t reason: 'hh_subsidy_notification' board is locked\n");
	               break;
	           case MB_ERR_INTERNAL:
	               fprintf(stderr, "\t reason: internal error. Recompile libmoard in debug mode for more info \n");
	               break;
	           default:
                   fprintf(stderr, "\t MB_Clear returned error code: %d (see libmboard docs for details)\n", rc);
                   break;
	       }

	       
       	   exit(rc);
	    }
	    #endif
	
	    rc = MB_Clear(b_human_capital_policy_announcement);
	    #ifdef ERRCHECK
	    if (rc != MB_SUCCESS)
	    {
	       fprintf(stderr, "ERROR: Could not clear 'human_capital_policy_announcement' board\n");
	       switch(rc) {
	           case MB_ERR_INVALID:
	               fprintf(stderr, "\t reason: 'human_capital_policy_announcement' board is invalid\n");
	               break;
	           case MB_ERR_LOCKED:
	               fprintf(stderr, "\t reason: 'human_capital_policy_announcement' board is locked\n");
	               break;
	           case MB_ERR_INTERNAL:
	               fprintf(stderr, "\t reason: internal error. Recompile libmoard in debug mode for more info \n");
	               break;
	           default:
                   fprintf(stderr, "\t MB_Clear returned error code: %d (see libmboard docs for details)\n", rc);
                   break;
	       }

	       
       	   exit(rc);
	    }
	    #endif
	
	    rc = MB_Clear(b_firm_transfer_notification);
	    #ifdef ERRCHECK
	    if (rc != MB_SUCCESS)
	    {
	       fprintf(stderr, "ERROR: Could not clear 'firm_transfer_notification' board\n");
	       switch(rc) {
	           case MB_ERR_INVALID:
	               fprintf(stderr, "\t reason: 'firm_transfer_notification' board is invalid\n");
	               break;
	           case MB_ERR_LOCKED:
	               fprintf(stderr, "\t reason: 'firm_transfer_notification' board is locked\n");
	               break;
	           case MB_ERR_INTERNAL:
	               fprintf(stderr, "\t reason: internal error. Recompile libmoard in debug mode for more info \n");
	               break;
	           default:
                   fprintf(stderr, "\t MB_Clear returned error code: %d (see libmboard docs for details)\n", rc);
                   break;
	       }

	       
       	   exit(rc);
	    }
	    #endif
	
	    rc = MB_Clear(b_firm_subsidy_notification);
	    #ifdef ERRCHECK
	    if (rc != MB_SUCCESS)
	    {
	       fprintf(stderr, "ERROR: Could not clear 'firm_subsidy_notification' board\n");
	       switch(rc) {
	           case MB_ERR_INVALID:
	               fprintf(stderr, "\t reason: 'firm_subsidy_notification' board is invalid\n");
	               break;
	           case MB_ERR_LOCKED:
	               fprintf(stderr, "\t reason: 'firm_subsidy_notification' board is locked\n");
	               break;
	           case MB_ERR_INTERNAL:
	               fprintf(stderr, "\t reason: internal error. Recompile libmoard in debug mode for more info \n");
	               break;
	           default:
                   fprintf(stderr, "\t MB_Clear returned error code: %d (see libmboard docs for details)\n", rc);
                   break;
	       }

	       
       	   exit(rc);
	    }
	    #endif
	
	    rc = MB_Clear(b_request_fiat_money);
	    #ifdef ERRCHECK
	    if (rc != MB_SUCCESS)
	    {
	       fprintf(stderr, "ERROR: Could not clear 'request_fiat_money' board\n");
	       switch(rc) {
	           case MB_ERR_INVALID:
	               fprintf(stderr, "\t reason: 'request_fiat_money' board is invalid\n");
	               break;
	           case MB_ERR_LOCKED:
	               fprintf(stderr, "\t reason: 'request_fiat_money' board is locked\n");
	               break;
	           case MB_ERR_INTERNAL:
	               fprintf(stderr, "\t reason: internal error. Recompile libmoard in debug mode for more info \n");
	               break;
	           default:
                   fprintf(stderr, "\t MB_Clear returned error code: %d (see libmboard docs for details)\n", rc);
                   break;
	       }

	       
       	   exit(rc);
	    }
	    #endif
	
	    rc = MB_Clear(b_human_capital_policy_general_skill_information);
	    #ifdef ERRCHECK
	    if (rc != MB_SUCCESS)
	    {
	       fprintf(stderr, "ERROR: Could not clear 'human_capital_policy_general_skill_information' board\n");
	       switch(rc) {
	           case MB_ERR_INVALID:
	               fprintf(stderr, "\t reason: 'human_capital_policy_general_skill_information' board is invalid\n");
	               break;
	           case MB_ERR_LOCKED:
	               fprintf(stderr, "\t reason: 'human_capital_policy_general_skill_information' board is locked\n");
	               break;
	           case MB_ERR_INTERNAL:
	               fprintf(stderr, "\t reason: internal error. Recompile libmoard in debug mode for more info \n");
	               break;
	           default:
                   fprintf(stderr, "\t MB_Clear returned error code: %d (see libmboard docs for details)\n", rc);
                   break;
	       }

	       
       	   exit(rc);
	    }
	    #endif
	
	    rc = MB_Clear(b_human_capital_policy_new_general_skill_notification);
	    #ifdef ERRCHECK
	    if (rc != MB_SUCCESS)
	    {
	       fprintf(stderr, "ERROR: Could not clear 'human_capital_policy_new_general_skill_notification' board\n");
	       switch(rc) {
	           case MB_ERR_INVALID:
	               fprintf(stderr, "\t reason: 'human_capital_policy_new_general_skill_notification' board is invalid\n");
	               break;
	           case MB_ERR_LOCKED:
	               fprintf(stderr, "\t reason: 'human_capital_policy_new_general_skill_notification' board is locked\n");
	               break;
	           case MB_ERR_INTERNAL:
	               fprintf(stderr, "\t reason: internal error. Recompile libmoard in debug mode for more info \n");
	               break;
	           default:
                   fprintf(stderr, "\t MB_Clear returned error code: %d (see libmboard docs for details)\n", rc);
                   break;
	       }

	       
       	   exit(rc);
	    }
	    #endif
	
	    rc = MB_Clear(b_firm_send_data);
	    #ifdef ERRCHECK
	    if (rc != MB_SUCCESS)
	    {
	       fprintf(stderr, "ERROR: Could not clear 'firm_send_data' board\n");
	       switch(rc) {
	           case MB_ERR_INVALID:
	               fprintf(stderr, "\t reason: 'firm_send_data' board is invalid\n");
	               break;
	           case MB_ERR_LOCKED:
	               fprintf(stderr, "\t reason: 'firm_send_data' board is locked\n");
	               break;
	           case MB_ERR_INTERNAL:
	               fprintf(stderr, "\t reason: internal error. Recompile libmoard in debug mode for more info \n");
	               break;
	           default:
                   fprintf(stderr, "\t MB_Clear returned error code: %d (see libmboard docs for details)\n", rc);
                   break;
	       }

	       
       	   exit(rc);
	    }
	    #endif
	
	    rc = MB_Clear(b_government_send_data);
	    #ifdef ERRCHECK
	    if (rc != MB_SUCCESS)
	    {
	       fprintf(stderr, "ERROR: Could not clear 'government_send_data' board\n");
	       switch(rc) {
	           case MB_ERR_INVALID:
	               fprintf(stderr, "\t reason: 'government_send_data' board is invalid\n");
	               break;
	           case MB_ERR_LOCKED:
	               fprintf(stderr, "\t reason: 'government_send_data' board is locked\n");
	               break;
	           case MB_ERR_INTERNAL:
	               fprintf(stderr, "\t reason: internal error. Recompile libmoard in debug mode for more info \n");
	               break;
	           default:
                   fprintf(stderr, "\t MB_Clear returned error code: %d (see libmboard docs for details)\n", rc);
                   break;
	       }

	       
       	   exit(rc);
	    }
	    #endif
	
	    rc = MB_Clear(b_household_send_data);
	    #ifdef ERRCHECK
	    if (rc != MB_SUCCESS)
	    {
	       fprintf(stderr, "ERROR: Could not clear 'household_send_data' board\n");
	       switch(rc) {
	           case MB_ERR_INVALID:
	               fprintf(stderr, "\t reason: 'household_send_data' board is invalid\n");
	               break;
	           case MB_ERR_LOCKED:
	               fprintf(stderr, "\t reason: 'household_send_data' board is locked\n");
	               break;
	           case MB_ERR_INTERNAL:
	               fprintf(stderr, "\t reason: internal error. Recompile libmoard in debug mode for more info \n");
	               break;
	           default:
                   fprintf(stderr, "\t MB_Clear returned error code: %d (see libmboard docs for details)\n", rc);
                   break;
	       }

	       
       	   exit(rc);
	    }
	    #endif
	
	    rc = MB_Clear(b_mall_data);
	    #ifdef ERRCHECK
	    if (rc != MB_SUCCESS)
	    {
	       fprintf(stderr, "ERROR: Could not clear 'mall_data' board\n");
	       switch(rc) {
	           case MB_ERR_INVALID:
	               fprintf(stderr, "\t reason: 'mall_data' board is invalid\n");
	               break;
	           case MB_ERR_LOCKED:
	               fprintf(stderr, "\t reason: 'mall_data' board is locked\n");
	               break;
	           case MB_ERR_INTERNAL:
	               fprintf(stderr, "\t reason: internal error. Recompile libmoard in debug mode for more info \n");
	               break;
	           default:
                   fprintf(stderr, "\t MB_Clear returned error code: %d (see libmboard docs for details)\n", rc);
                   break;
	       }

	       
       	   exit(rc);
	    }
	    #endif
	
	    rc = MB_Clear(b_eurostat_send_specific_skills);
	    #ifdef ERRCHECK
	    if (rc != MB_SUCCESS)
	    {
	       fprintf(stderr, "ERROR: Could not clear 'eurostat_send_specific_skills' board\n");
	       switch(rc) {
	           case MB_ERR_INVALID:
	               fprintf(stderr, "\t reason: 'eurostat_send_specific_skills' board is invalid\n");
	               break;
	           case MB_ERR_LOCKED:
	               fprintf(stderr, "\t reason: 'eurostat_send_specific_skills' board is locked\n");
	               break;
	           case MB_ERR_INTERNAL:
	               fprintf(stderr, "\t reason: internal error. Recompile libmoard in debug mode for more info \n");
	               break;
	           default:
                   fprintf(stderr, "\t MB_Clear returned error code: %d (see libmboard docs for details)\n", rc);
                   break;
	       }

	       
       	   exit(rc);
	    }
	    #endif
	
	    rc = MB_Clear(b_data_for_government);
	    #ifdef ERRCHECK
	    if (rc != MB_SUCCESS)
	    {
	       fprintf(stderr, "ERROR: Could not clear 'data_for_government' board\n");
	       switch(rc) {
	           case MB_ERR_INVALID:
	               fprintf(stderr, "\t reason: 'data_for_government' board is invalid\n");
	               break;
	           case MB_ERR_LOCKED:
	               fprintf(stderr, "\t reason: 'data_for_government' board is locked\n");
	               break;
	           case MB_ERR_INTERNAL:
	               fprintf(stderr, "\t reason: internal error. Recompile libmoard in debug mode for more info \n");
	               break;
	           default:
                   fprintf(stderr, "\t MB_Clear returned error code: %d (see libmboard docs for details)\n", rc);
                   break;
	       }

	       
       	   exit(rc);
	    }
	    #endif
	
	    rc = MB_Clear(b_eurostat_send_macrodata);
	    #ifdef ERRCHECK
	    if (rc != MB_SUCCESS)
	    {
	       fprintf(stderr, "ERROR: Could not clear 'eurostat_send_macrodata' board\n");
	       switch(rc) {
	           case MB_ERR_INVALID:
	               fprintf(stderr, "\t reason: 'eurostat_send_macrodata' board is invalid\n");
	               break;
	           case MB_ERR_LOCKED:
	               fprintf(stderr, "\t reason: 'eurostat_send_macrodata' board is locked\n");
	               break;
	           case MB_ERR_INTERNAL:
	               fprintf(stderr, "\t reason: internal error. Recompile libmoard in debug mode for more info \n");
	               break;
	           default:
                   fprintf(stderr, "\t MB_Clear returned error code: %d (see libmboard docs for details)\n", rc);
                   break;
	       }

	       
       	   exit(rc);
	    }
	    #endif
	
	    rc = MB_Clear(b_msg_firm_id_to_malls);
	    #ifdef ERRCHECK
	    if (rc != MB_SUCCESS)
	    {
	       fprintf(stderr, "ERROR: Could not clear 'msg_firm_id_to_malls' board\n");
	       switch(rc) {
	           case MB_ERR_INVALID:
	               fprintf(stderr, "\t reason: 'msg_firm_id_to_malls' board is invalid\n");
	               break;
	           case MB_ERR_LOCKED:
	               fprintf(stderr, "\t reason: 'msg_firm_id_to_malls' board is locked\n");
	               break;
	           case MB_ERR_INTERNAL:
	               fprintf(stderr, "\t reason: internal error. Recompile libmoard in debug mode for more info \n");
	               break;
	           default:
                   fprintf(stderr, "\t MB_Clear returned error code: %d (see libmboard docs for details)\n", rc);
                   break;
	       }

	       
       	   exit(rc);
	    }
	    #endif
	
	    rc = MB_Clear(b_msg_mall_id_to_firms);
	    #ifdef ERRCHECK
	    if (rc != MB_SUCCESS)
	    {
	       fprintf(stderr, "ERROR: Could not clear 'msg_mall_id_to_firms' board\n");
	       switch(rc) {
	           case MB_ERR_INVALID:
	               fprintf(stderr, "\t reason: 'msg_mall_id_to_firms' board is invalid\n");
	               break;
	           case MB_ERR_LOCKED:
	               fprintf(stderr, "\t reason: 'msg_mall_id_to_firms' board is locked\n");
	               break;
	           case MB_ERR_INTERNAL:
	               fprintf(stderr, "\t reason: internal error. Recompile libmoard in debug mode for more info \n");
	               break;
	           default:
                   fprintf(stderr, "\t MB_Clear returned error code: %d (see libmboard docs for details)\n", rc);
                   break;
	       }

	       
       	   exit(rc);
	    }
	    #endif
	
	    rc = MB_Clear(b_msg_skills_eurostat_to_igfirm);
	    #ifdef ERRCHECK
	    if (rc != MB_SUCCESS)
	    {
	       fprintf(stderr, "ERROR: Could not clear 'msg_skills_eurostat_to_igfirm' board\n");
	       switch(rc) {
	           case MB_ERR_INVALID:
	               fprintf(stderr, "\t reason: 'msg_skills_eurostat_to_igfirm' board is invalid\n");
	               break;
	           case MB_ERR_LOCKED:
	               fprintf(stderr, "\t reason: 'msg_skills_eurostat_to_igfirm' board is locked\n");
	               break;
	           case MB_ERR_INTERNAL:
	               fprintf(stderr, "\t reason: internal error. Recompile libmoard in debug mode for more info \n");
	               break;
	           default:
                   fprintf(stderr, "\t MB_Clear returned error code: %d (see libmboard docs for details)\n", rc);
                   break;
	       }

	       
       	   exit(rc);
	    }
	    #endif
	
	    rc = MB_Clear(b_msg_market_sizes);
	    #ifdef ERRCHECK
	    if (rc != MB_SUCCESS)
	    {
	       fprintf(stderr, "ERROR: Could not clear 'msg_market_sizes' board\n");
	       switch(rc) {
	           case MB_ERR_INVALID:
	               fprintf(stderr, "\t reason: 'msg_market_sizes' board is invalid\n");
	               break;
	           case MB_ERR_LOCKED:
	               fprintf(stderr, "\t reason: 'msg_market_sizes' board is locked\n");
	               break;
	           case MB_ERR_INTERNAL:
	               fprintf(stderr, "\t reason: internal error. Recompile libmoard in debug mode for more info \n");
	               break;
	           default:
                   fprintf(stderr, "\t MB_Clear returned error code: %d (see libmboard docs for details)\n", rc);
                   break;
	       }

	       
       	   exit(rc);
	    }
	    #endif
	
	    rc = MB_Clear(b_total_subsidies);
	    #ifdef ERRCHECK
	    if (rc != MB_SUCCESS)
	    {
	       fprintf(stderr, "ERROR: Could not clear 'total_subsidies' board\n");
	       switch(rc) {
	           case MB_ERR_INVALID:
	               fprintf(stderr, "\t reason: 'total_subsidies' board is invalid\n");
	               break;
	           case MB_ERR_LOCKED:
	               fprintf(stderr, "\t reason: 'total_subsidies' board is locked\n");
	               break;
	           case MB_ERR_INTERNAL:
	               fprintf(stderr, "\t reason: internal error. Recompile libmoard in debug mode for more info \n");
	               break;
	           default:
                   fprintf(stderr, "\t MB_Clear returned error code: %d (see libmboard docs for details)\n", rc);
                   break;
	       }

	       
       	   exit(rc);
	    }
	    #endif
	
	    rc = MB_Clear(b_redistributed_subsidies);
	    #ifdef ERRCHECK
	    if (rc != MB_SUCCESS)
	    {
	       fprintf(stderr, "ERROR: Could not clear 'redistributed_subsidies' board\n");
	       switch(rc) {
	           case MB_ERR_INVALID:
	               fprintf(stderr, "\t reason: 'redistributed_subsidies' board is invalid\n");
	               break;
	           case MB_ERR_LOCKED:
	               fprintf(stderr, "\t reason: 'redistributed_subsidies' board is locked\n");
	               break;
	           case MB_ERR_INTERNAL:
	               fprintf(stderr, "\t reason: internal error. Recompile libmoard in debug mode for more info \n");
	               break;
	           default:
                   fprintf(stderr, "\t MB_Clear returned error code: %d (see libmboard docs for details)\n", rc);
                   break;
	       }

	       
       	   exit(rc);
	    }
	    #endif
	
	    rc = MB_Clear(b_quality_price);
	    #ifdef ERRCHECK
	    if (rc != MB_SUCCESS)
	    {
	       fprintf(stderr, "ERROR: Could not clear 'quality_price' board\n");
	       switch(rc) {
	           case MB_ERR_INVALID:
	               fprintf(stderr, "\t reason: 'quality_price' board is invalid\n");
	               break;
	           case MB_ERR_LOCKED:
	               fprintf(stderr, "\t reason: 'quality_price' board is locked\n");
	               break;
	           case MB_ERR_INTERNAL:
	               fprintf(stderr, "\t reason: internal error. Recompile libmoard in debug mode for more info \n");
	               break;
	           default:
                   fprintf(stderr, "\t MB_Clear returned error code: %d (see libmboard docs for details)\n", rc);
                   break;
	       }

	       
       	   exit(rc);
	    }
	    #endif
	
	    rc = MB_Clear(b_interview_request);
	    #ifdef ERRCHECK
	    if (rc != MB_SUCCESS)
	    {
	       fprintf(stderr, "ERROR: Could not clear 'interview_request' board\n");
	       switch(rc) {
	           case MB_ERR_INVALID:
	               fprintf(stderr, "\t reason: 'interview_request' board is invalid\n");
	               break;
	           case MB_ERR_LOCKED:
	               fprintf(stderr, "\t reason: 'interview_request' board is locked\n");
	               break;
	           case MB_ERR_INTERNAL:
	               fprintf(stderr, "\t reason: internal error. Recompile libmoard in debug mode for more info \n");
	               break;
	           default:
                   fprintf(stderr, "\t MB_Clear returned error code: %d (see libmboard docs for details)\n", rc);
                   break;
	       }

	       
       	   exit(rc);
	    }
	    #endif
	
	    rc = MB_Clear(b_interview_positive_response);
	    #ifdef ERRCHECK
	    if (rc != MB_SUCCESS)
	    {
	       fprintf(stderr, "ERROR: Could not clear 'interview_positive_response' board\n");
	       switch(rc) {
	           case MB_ERR_INVALID:
	               fprintf(stderr, "\t reason: 'interview_positive_response' board is invalid\n");
	               break;
	           case MB_ERR_LOCKED:
	               fprintf(stderr, "\t reason: 'interview_positive_response' board is locked\n");
	               break;
	           case MB_ERR_INTERNAL:
	               fprintf(stderr, "\t reason: internal error. Recompile libmoard in debug mode for more info \n");
	               break;
	           default:
                   fprintf(stderr, "\t MB_Clear returned error code: %d (see libmboard docs for details)\n", rc);
                   break;
	       }

	       
       	   exit(rc);
	    }
	    #endif
	
	    rc = MB_Clear(b_questionnaire_innovation);
	    #ifdef ERRCHECK
	    if (rc != MB_SUCCESS)
	    {
	       fprintf(stderr, "ERROR: Could not clear 'questionnaire_innovation' board\n");
	       switch(rc) {
	           case MB_ERR_INVALID:
	               fprintf(stderr, "\t reason: 'questionnaire_innovation' board is invalid\n");
	               break;
	           case MB_ERR_LOCKED:
	               fprintf(stderr, "\t reason: 'questionnaire_innovation' board is locked\n");
	               break;
	           case MB_ERR_INTERNAL:
	               fprintf(stderr, "\t reason: internal error. Recompile libmoard in debug mode for more info \n");
	               break;
	           default:
                   fprintf(stderr, "\t MB_Clear returned error code: %d (see libmboard docs for details)\n", rc);
                   break;
	       }

	       
       	   exit(rc);
	    }
	    #endif
	
	    rc = MB_Clear(b_filled_out_questionnaire_product_innovation);
	    #ifdef ERRCHECK
	    if (rc != MB_SUCCESS)
	    {
	       fprintf(stderr, "ERROR: Could not clear 'filled_out_questionnaire_product_innovation' board\n");
	       switch(rc) {
	           case MB_ERR_INVALID:
	               fprintf(stderr, "\t reason: 'filled_out_questionnaire_product_innovation' board is invalid\n");
	               break;
	           case MB_ERR_LOCKED:
	               fprintf(stderr, "\t reason: 'filled_out_questionnaire_product_innovation' board is locked\n");
	               break;
	           case MB_ERR_INTERNAL:
	               fprintf(stderr, "\t reason: internal error. Recompile libmoard in debug mode for more info \n");
	               break;
	           default:
                   fprintf(stderr, "\t MB_Clear returned error code: %d (see libmboard docs for details)\n", rc);
                   break;
	       }

	       
       	   exit(rc);
	    }
	    #endif
	
}

/** \fn void initialise_pointers()
 * \brief Initialises pointers to xmachine, message, and node lists.
 */
void initialise_pointers()
{
int rc;

	/* Initialise message sync composite params as NULL */
	FLAME_m_bank_account_update_composite_params = NULL;

	    rc = MB_Create(&b_bank_account_update, sizeof(m_bank_account_update));
	    #ifdef ERRCHECK
	    if (rc != MB_SUCCESS)
	    {
	       fprintf(stderr, "ERROR: Could not create 'bank_account_update' board\n");
	       switch(rc) {
	           case MB_ERR_INVALID:
	               fprintf(stderr, "\t reason: Invalid message size\n");
	               break;
	           case MB_ERR_MEMALLOC:
	               fprintf(stderr, "\t reason: out of memory\n");
	               break;
	           case MB_ERR_INTERNAL:
	               fprintf(stderr, "\t reason: internal error. Recompile libmoard in debug mode for more info \n");
	               break;
	           default:
                   fprintf(stderr, "\t MB_Create returned error code: %d (see libmboard docs for details)\n", rc);
                   break;
	       }

	       
       	   exit(rc);
	    }
	    #endif
	
	/* Initialise message sync composite params as NULL */
	FLAME_m_bank_to_central_bank_account_update_composite_params = NULL;

	    rc = MB_Create(&b_bank_to_central_bank_account_update, sizeof(m_bank_to_central_bank_account_update));
	    #ifdef ERRCHECK
	    if (rc != MB_SUCCESS)
	    {
	       fprintf(stderr, "ERROR: Could not create 'bank_to_central_bank_account_update' board\n");
	       switch(rc) {
	           case MB_ERR_INVALID:
	               fprintf(stderr, "\t reason: Invalid message size\n");
	               break;
	           case MB_ERR_MEMALLOC:
	               fprintf(stderr, "\t reason: out of memory\n");
	               break;
	           case MB_ERR_INTERNAL:
	               fprintf(stderr, "\t reason: internal error. Recompile libmoard in debug mode for more info \n");
	               break;
	           default:
                   fprintf(stderr, "\t MB_Create returned error code: %d (see libmboard docs for details)\n", rc);
                   break;
	       }

	       
       	   exit(rc);
	    }
	    #endif
	
	/* Initialise message sync composite params as NULL */
	FLAME_m_gov_to_central_bank_account_update_composite_params = NULL;

	    rc = MB_Create(&b_gov_to_central_bank_account_update, sizeof(m_gov_to_central_bank_account_update));
	    #ifdef ERRCHECK
	    if (rc != MB_SUCCESS)
	    {
	       fprintf(stderr, "ERROR: Could not create 'gov_to_central_bank_account_update' board\n");
	       switch(rc) {
	           case MB_ERR_INVALID:
	               fprintf(stderr, "\t reason: Invalid message size\n");
	               break;
	           case MB_ERR_MEMALLOC:
	               fprintf(stderr, "\t reason: out of memory\n");
	               break;
	           case MB_ERR_INTERNAL:
	               fprintf(stderr, "\t reason: internal error. Recompile libmoard in debug mode for more info \n");
	               break;
	           default:
                   fprintf(stderr, "\t MB_Create returned error code: %d (see libmboard docs for details)\n", rc);
                   break;
	       }

	       
       	   exit(rc);
	    }
	    #endif
	
	/* Initialise message sync composite params as NULL */
	FLAME_m_wage_payment_composite_params = NULL;

	    rc = MB_Create(&b_wage_payment, sizeof(m_wage_payment));
	    #ifdef ERRCHECK
	    if (rc != MB_SUCCESS)
	    {
	       fprintf(stderr, "ERROR: Could not create 'wage_payment' board\n");
	       switch(rc) {
	           case MB_ERR_INVALID:
	               fprintf(stderr, "\t reason: Invalid message size\n");
	               break;
	           case MB_ERR_MEMALLOC:
	               fprintf(stderr, "\t reason: out of memory\n");
	               break;
	           case MB_ERR_INTERNAL:
	               fprintf(stderr, "\t reason: internal error. Recompile libmoard in debug mode for more info \n");
	               break;
	           default:
                   fprintf(stderr, "\t MB_Create returned error code: %d (see libmboard docs for details)\n", rc);
                   break;
	       }

	       
       	   exit(rc);
	    }
	    #endif
	
	/* Initialise message sync composite params as NULL */
	FLAME_m_quality_price_info_1_composite_params = NULL;

	    rc = MB_Create(&b_quality_price_info_1, sizeof(m_quality_price_info_1));
	    #ifdef ERRCHECK
	    if (rc != MB_SUCCESS)
	    {
	       fprintf(stderr, "ERROR: Could not create 'quality_price_info_1' board\n");
	       switch(rc) {
	           case MB_ERR_INVALID:
	               fprintf(stderr, "\t reason: Invalid message size\n");
	               break;
	           case MB_ERR_MEMALLOC:
	               fprintf(stderr, "\t reason: out of memory\n");
	               break;
	           case MB_ERR_INTERNAL:
	               fprintf(stderr, "\t reason: internal error. Recompile libmoard in debug mode for more info \n");
	               break;
	           default:
                   fprintf(stderr, "\t MB_Create returned error code: %d (see libmboard docs for details)\n", rc);
                   break;
	       }

	       
       	   exit(rc);
	    }
	    #endif
	
	/* Initialise message sync composite params as NULL */
	FLAME_m_quality_price_info_2_composite_params = NULL;

	    rc = MB_Create(&b_quality_price_info_2, sizeof(m_quality_price_info_2));
	    #ifdef ERRCHECK
	    if (rc != MB_SUCCESS)
	    {
	       fprintf(stderr, "ERROR: Could not create 'quality_price_info_2' board\n");
	       switch(rc) {
	           case MB_ERR_INVALID:
	               fprintf(stderr, "\t reason: Invalid message size\n");
	               break;
	           case MB_ERR_MEMALLOC:
	               fprintf(stderr, "\t reason: out of memory\n");
	               break;
	           case MB_ERR_INTERNAL:
	               fprintf(stderr, "\t reason: internal error. Recompile libmoard in debug mode for more info \n");
	               break;
	           default:
                   fprintf(stderr, "\t MB_Create returned error code: %d (see libmboard docs for details)\n", rc);
                   break;
	       }

	       
       	   exit(rc);
	    }
	    #endif
	
	/* Initialise message sync composite params as NULL */
	FLAME_m_update_mall_stock_composite_params = NULL;

	    rc = MB_Create(&b_update_mall_stock, sizeof(m_update_mall_stock));
	    #ifdef ERRCHECK
	    if (rc != MB_SUCCESS)
	    {
	       fprintf(stderr, "ERROR: Could not create 'update_mall_stock' board\n");
	       switch(rc) {
	           case MB_ERR_INVALID:
	               fprintf(stderr, "\t reason: Invalid message size\n");
	               break;
	           case MB_ERR_MEMALLOC:
	               fprintf(stderr, "\t reason: out of memory\n");
	               break;
	           case MB_ERR_INTERNAL:
	               fprintf(stderr, "\t reason: internal error. Recompile libmoard in debug mode for more info \n");
	               break;
	           default:
                   fprintf(stderr, "\t MB_Create returned error code: %d (see libmboard docs for details)\n", rc);
                   break;
	       }

	       
       	   exit(rc);
	    }
	    #endif
	
	/* Initialise message sync composite params as NULL */
	FLAME_m_consumption_request_1_composite_params = NULL;

	    rc = MB_Create(&b_consumption_request_1, sizeof(m_consumption_request_1));
	    #ifdef ERRCHECK
	    if (rc != MB_SUCCESS)
	    {
	       fprintf(stderr, "ERROR: Could not create 'consumption_request_1' board\n");
	       switch(rc) {
	           case MB_ERR_INVALID:
	               fprintf(stderr, "\t reason: Invalid message size\n");
	               break;
	           case MB_ERR_MEMALLOC:
	               fprintf(stderr, "\t reason: out of memory\n");
	               break;
	           case MB_ERR_INTERNAL:
	               fprintf(stderr, "\t reason: internal error. Recompile libmoard in debug mode for more info \n");
	               break;
	           default:
                   fprintf(stderr, "\t MB_Create returned error code: %d (see libmboard docs for details)\n", rc);
                   break;
	       }

	       
       	   exit(rc);
	    }
	    #endif
	
	/* Initialise message sync composite params as NULL */
	FLAME_m_consumption_request_2_composite_params = NULL;

	    rc = MB_Create(&b_consumption_request_2, sizeof(m_consumption_request_2));
	    #ifdef ERRCHECK
	    if (rc != MB_SUCCESS)
	    {
	       fprintf(stderr, "ERROR: Could not create 'consumption_request_2' board\n");
	       switch(rc) {
	           case MB_ERR_INVALID:
	               fprintf(stderr, "\t reason: Invalid message size\n");
	               break;
	           case MB_ERR_MEMALLOC:
	               fprintf(stderr, "\t reason: out of memory\n");
	               break;
	           case MB_ERR_INTERNAL:
	               fprintf(stderr, "\t reason: internal error. Recompile libmoard in debug mode for more info \n");
	               break;
	           default:
                   fprintf(stderr, "\t MB_Create returned error code: %d (see libmboard docs for details)\n", rc);
                   break;
	       }

	       
       	   exit(rc);
	    }
	    #endif
	
	/* Initialise message sync composite params as NULL */
	FLAME_m_accepted_consumption_1_composite_params = NULL;

	    rc = MB_Create(&b_accepted_consumption_1, sizeof(m_accepted_consumption_1));
	    #ifdef ERRCHECK
	    if (rc != MB_SUCCESS)
	    {
	       fprintf(stderr, "ERROR: Could not create 'accepted_consumption_1' board\n");
	       switch(rc) {
	           case MB_ERR_INVALID:
	               fprintf(stderr, "\t reason: Invalid message size\n");
	               break;
	           case MB_ERR_MEMALLOC:
	               fprintf(stderr, "\t reason: out of memory\n");
	               break;
	           case MB_ERR_INTERNAL:
	               fprintf(stderr, "\t reason: internal error. Recompile libmoard in debug mode for more info \n");
	               break;
	           default:
                   fprintf(stderr, "\t MB_Create returned error code: %d (see libmboard docs for details)\n", rc);
                   break;
	       }

	       
       	   exit(rc);
	    }
	    #endif
	
	/* Initialise message sync composite params as NULL */
	FLAME_m_accepted_consumption_2_composite_params = NULL;

	    rc = MB_Create(&b_accepted_consumption_2, sizeof(m_accepted_consumption_2));
	    #ifdef ERRCHECK
	    if (rc != MB_SUCCESS)
	    {
	       fprintf(stderr, "ERROR: Could not create 'accepted_consumption_2' board\n");
	       switch(rc) {
	           case MB_ERR_INVALID:
	               fprintf(stderr, "\t reason: Invalid message size\n");
	               break;
	           case MB_ERR_MEMALLOC:
	               fprintf(stderr, "\t reason: out of memory\n");
	               break;
	           case MB_ERR_INTERNAL:
	               fprintf(stderr, "\t reason: internal error. Recompile libmoard in debug mode for more info \n");
	               break;
	           default:
                   fprintf(stderr, "\t MB_Create returned error code: %d (see libmboard docs for details)\n", rc);
                   break;
	       }

	       
       	   exit(rc);
	    }
	    #endif
	
	/* Initialise message sync composite params as NULL */
	FLAME_m_sales_composite_params = NULL;

	    rc = MB_Create(&b_sales, sizeof(m_sales));
	    #ifdef ERRCHECK
	    if (rc != MB_SUCCESS)
	    {
	       fprintf(stderr, "ERROR: Could not create 'sales' board\n");
	       switch(rc) {
	           case MB_ERR_INVALID:
	               fprintf(stderr, "\t reason: Invalid message size\n");
	               break;
	           case MB_ERR_MEMALLOC:
	               fprintf(stderr, "\t reason: out of memory\n");
	               break;
	           case MB_ERR_INTERNAL:
	               fprintf(stderr, "\t reason: internal error. Recompile libmoard in debug mode for more info \n");
	               break;
	           default:
                   fprintf(stderr, "\t MB_Create returned error code: %d (see libmboard docs for details)\n", rc);
                   break;
	       }

	       
       	   exit(rc);
	    }
	    #endif
	
	/* Initialise message sync composite params as NULL */
	FLAME_m_specific_skill_update_composite_params = NULL;

	    rc = MB_Create(&b_specific_skill_update, sizeof(m_specific_skill_update));
	    #ifdef ERRCHECK
	    if (rc != MB_SUCCESS)
	    {
	       fprintf(stderr, "ERROR: Could not create 'specific_skill_update' board\n");
	       switch(rc) {
	           case MB_ERR_INVALID:
	               fprintf(stderr, "\t reason: Invalid message size\n");
	               break;
	           case MB_ERR_MEMALLOC:
	               fprintf(stderr, "\t reason: out of memory\n");
	               break;
	           case MB_ERR_INTERNAL:
	               fprintf(stderr, "\t reason: internal error. Recompile libmoard in debug mode for more info \n");
	               break;
	           default:
                   fprintf(stderr, "\t MB_Create returned error code: %d (see libmboard docs for details)\n", rc);
                   break;
	       }

	       
       	   exit(rc);
	    }
	    #endif
	
	/* Initialise message sync composite params as NULL */
	FLAME_m_policy_rate_composite_params = NULL;

	    rc = MB_Create(&b_policy_rate, sizeof(m_policy_rate));
	    #ifdef ERRCHECK
	    if (rc != MB_SUCCESS)
	    {
	       fprintf(stderr, "ERROR: Could not create 'policy_rate' board\n");
	       switch(rc) {
	           case MB_ERR_INVALID:
	               fprintf(stderr, "\t reason: Invalid message size\n");
	               break;
	           case MB_ERR_MEMALLOC:
	               fprintf(stderr, "\t reason: out of memory\n");
	               break;
	           case MB_ERR_INTERNAL:
	               fprintf(stderr, "\t reason: internal error. Recompile libmoard in debug mode for more info \n");
	               break;
	           default:
                   fprintf(stderr, "\t MB_Create returned error code: %d (see libmboard docs for details)\n", rc);
                   break;
	       }

	       
       	   exit(rc);
	    }
	    #endif
	
	/* Initialise message sync composite params as NULL */
	FLAME_m_bank_identity_composite_params = NULL;

	    rc = MB_Create(&b_bank_identity, sizeof(m_bank_identity));
	    #ifdef ERRCHECK
	    if (rc != MB_SUCCESS)
	    {
	       fprintf(stderr, "ERROR: Could not create 'bank_identity' board\n");
	       switch(rc) {
	           case MB_ERR_INVALID:
	               fprintf(stderr, "\t reason: Invalid message size\n");
	               break;
	           case MB_ERR_MEMALLOC:
	               fprintf(stderr, "\t reason: out of memory\n");
	               break;
	           case MB_ERR_INTERNAL:
	               fprintf(stderr, "\t reason: internal error. Recompile libmoard in debug mode for more info \n");
	               break;
	           default:
                   fprintf(stderr, "\t MB_Create returned error code: %d (see libmboard docs for details)\n", rc);
                   break;
	       }

	       
       	   exit(rc);
	    }
	    #endif
	
	/* Initialise message sync composite params as NULL */
	FLAME_m_loan_request_composite_params = NULL;

	    rc = MB_Create(&b_loan_request, sizeof(m_loan_request));
	    #ifdef ERRCHECK
	    if (rc != MB_SUCCESS)
	    {
	       fprintf(stderr, "ERROR: Could not create 'loan_request' board\n");
	       switch(rc) {
	           case MB_ERR_INVALID:
	               fprintf(stderr, "\t reason: Invalid message size\n");
	               break;
	           case MB_ERR_MEMALLOC:
	               fprintf(stderr, "\t reason: out of memory\n");
	               break;
	           case MB_ERR_INTERNAL:
	               fprintf(stderr, "\t reason: internal error. Recompile libmoard in debug mode for more info \n");
	               break;
	           default:
                   fprintf(stderr, "\t MB_Create returned error code: %d (see libmboard docs for details)\n", rc);
                   break;
	       }

	       
       	   exit(rc);
	    }
	    #endif
	
	/* Initialise message sync composite params as NULL */
	FLAME_m_loan_request_ranked_composite_params = NULL;

	    rc = MB_Create(&b_loan_request_ranked, sizeof(m_loan_request_ranked));
	    #ifdef ERRCHECK
	    if (rc != MB_SUCCESS)
	    {
	       fprintf(stderr, "ERROR: Could not create 'loan_request_ranked' board\n");
	       switch(rc) {
	           case MB_ERR_INVALID:
	               fprintf(stderr, "\t reason: Invalid message size\n");
	               break;
	           case MB_ERR_MEMALLOC:
	               fprintf(stderr, "\t reason: out of memory\n");
	               break;
	           case MB_ERR_INTERNAL:
	               fprintf(stderr, "\t reason: internal error. Recompile libmoard in debug mode for more info \n");
	               break;
	           default:
                   fprintf(stderr, "\t MB_Create returned error code: %d (see libmboard docs for details)\n", rc);
                   break;
	       }

	       
       	   exit(rc);
	    }
	    #endif
	
	/* Initialise message sync composite params as NULL */
	FLAME_m_loan_conditions_composite_params = NULL;

	    rc = MB_Create(&b_loan_conditions, sizeof(m_loan_conditions));
	    #ifdef ERRCHECK
	    if (rc != MB_SUCCESS)
	    {
	       fprintf(stderr, "ERROR: Could not create 'loan_conditions' board\n");
	       switch(rc) {
	           case MB_ERR_INVALID:
	               fprintf(stderr, "\t reason: Invalid message size\n");
	               break;
	           case MB_ERR_MEMALLOC:
	               fprintf(stderr, "\t reason: out of memory\n");
	               break;
	           case MB_ERR_INTERNAL:
	               fprintf(stderr, "\t reason: internal error. Recompile libmoard in debug mode for more info \n");
	               break;
	           default:
                   fprintf(stderr, "\t MB_Create returned error code: %d (see libmboard docs for details)\n", rc);
                   break;
	       }

	       
       	   exit(rc);
	    }
	    #endif
	
	/* Initialise message sync composite params as NULL */
	FLAME_m_loan_acceptance_composite_params = NULL;

	    rc = MB_Create(&b_loan_acceptance, sizeof(m_loan_acceptance));
	    #ifdef ERRCHECK
	    if (rc != MB_SUCCESS)
	    {
	       fprintf(stderr, "ERROR: Could not create 'loan_acceptance' board\n");
	       switch(rc) {
	           case MB_ERR_INVALID:
	               fprintf(stderr, "\t reason: Invalid message size\n");
	               break;
	           case MB_ERR_MEMALLOC:
	               fprintf(stderr, "\t reason: out of memory\n");
	               break;
	           case MB_ERR_INTERNAL:
	               fprintf(stderr, "\t reason: internal error. Recompile libmoard in debug mode for more info \n");
	               break;
	           default:
                   fprintf(stderr, "\t MB_Create returned error code: %d (see libmboard docs for details)\n", rc);
                   break;
	       }

	       
       	   exit(rc);
	    }
	    #endif
	
	/* Initialise message sync composite params as NULL */
	FLAME_m_installment_composite_params = NULL;

	    rc = MB_Create(&b_installment, sizeof(m_installment));
	    #ifdef ERRCHECK
	    if (rc != MB_SUCCESS)
	    {
	       fprintf(stderr, "ERROR: Could not create 'installment' board\n");
	       switch(rc) {
	           case MB_ERR_INVALID:
	               fprintf(stderr, "\t reason: Invalid message size\n");
	               break;
	           case MB_ERR_MEMALLOC:
	               fprintf(stderr, "\t reason: out of memory\n");
	               break;
	           case MB_ERR_INTERNAL:
	               fprintf(stderr, "\t reason: internal error. Recompile libmoard in debug mode for more info \n");
	               break;
	           default:
                   fprintf(stderr, "\t MB_Create returned error code: %d (see libmboard docs for details)\n", rc);
                   break;
	       }

	       
       	   exit(rc);
	    }
	    #endif
	
	/* Initialise message sync composite params as NULL */
	FLAME_m_bankruptcy_composite_params = NULL;

	    rc = MB_Create(&b_bankruptcy, sizeof(m_bankruptcy));
	    #ifdef ERRCHECK
	    if (rc != MB_SUCCESS)
	    {
	       fprintf(stderr, "ERROR: Could not create 'bankruptcy' board\n");
	       switch(rc) {
	           case MB_ERR_INVALID:
	               fprintf(stderr, "\t reason: Invalid message size\n");
	               break;
	           case MB_ERR_MEMALLOC:
	               fprintf(stderr, "\t reason: out of memory\n");
	               break;
	           case MB_ERR_INTERNAL:
	               fprintf(stderr, "\t reason: internal error. Recompile libmoard in debug mode for more info \n");
	               break;
	           default:
                   fprintf(stderr, "\t MB_Create returned error code: %d (see libmboard docs for details)\n", rc);
                   break;
	       }

	       
       	   exit(rc);
	    }
	    #endif
	
	/* Initialise message sync composite params as NULL */
	FLAME_m_bank_interest_payment_composite_params = NULL;

	    rc = MB_Create(&b_bank_interest_payment, sizeof(m_bank_interest_payment));
	    #ifdef ERRCHECK
	    if (rc != MB_SUCCESS)
	    {
	       fprintf(stderr, "ERROR: Could not create 'bank_interest_payment' board\n");
	       switch(rc) {
	           case MB_ERR_INVALID:
	               fprintf(stderr, "\t reason: Invalid message size\n");
	               break;
	           case MB_ERR_MEMALLOC:
	               fprintf(stderr, "\t reason: out of memory\n");
	               break;
	           case MB_ERR_INTERNAL:
	               fprintf(stderr, "\t reason: internal error. Recompile libmoard in debug mode for more info \n");
	               break;
	           default:
                   fprintf(stderr, "\t MB_Create returned error code: %d (see libmboard docs for details)\n", rc);
                   break;
	       }

	       
       	   exit(rc);
	    }
	    #endif
	
	/* Initialise message sync composite params as NULL */
	FLAME_m_account_interest_composite_params = NULL;

	    rc = MB_Create(&b_account_interest, sizeof(m_account_interest));
	    #ifdef ERRCHECK
	    if (rc != MB_SUCCESS)
	    {
	       fprintf(stderr, "ERROR: Could not create 'account_interest' board\n");
	       switch(rc) {
	           case MB_ERR_INVALID:
	               fprintf(stderr, "\t reason: Invalid message size\n");
	               break;
	           case MB_ERR_MEMALLOC:
	               fprintf(stderr, "\t reason: out of memory\n");
	               break;
	           case MB_ERR_INTERNAL:
	               fprintf(stderr, "\t reason: internal error. Recompile libmoard in debug mode for more info \n");
	               break;
	           default:
                   fprintf(stderr, "\t MB_Create returned error code: %d (see libmboard docs for details)\n", rc);
                   break;
	       }

	       
       	   exit(rc);
	    }
	    #endif
	
	/* Initialise message sync composite params as NULL */
	FLAME_m_ecb_dividend_composite_params = NULL;

	    rc = MB_Create(&b_ecb_dividend, sizeof(m_ecb_dividend));
	    #ifdef ERRCHECK
	    if (rc != MB_SUCCESS)
	    {
	       fprintf(stderr, "ERROR: Could not create 'ecb_dividend' board\n");
	       switch(rc) {
	           case MB_ERR_INVALID:
	               fprintf(stderr, "\t reason: Invalid message size\n");
	               break;
	           case MB_ERR_MEMALLOC:
	               fprintf(stderr, "\t reason: out of memory\n");
	               break;
	           case MB_ERR_INTERNAL:
	               fprintf(stderr, "\t reason: internal error. Recompile libmoard in debug mode for more info \n");
	               break;
	           default:
                   fprintf(stderr, "\t MB_Create returned error code: %d (see libmboard docs for details)\n", rc);
                   break;
	       }

	       
       	   exit(rc);
	    }
	    #endif
	
	/* Initialise message sync composite params as NULL */
	FLAME_m_credit_var_update_composite_params = NULL;

	    rc = MB_Create(&b_credit_var_update, sizeof(m_credit_var_update));
	    #ifdef ERRCHECK
	    if (rc != MB_SUCCESS)
	    {
	       fprintf(stderr, "ERROR: Could not create 'credit_var_update' board\n");
	       switch(rc) {
	           case MB_ERR_INVALID:
	               fprintf(stderr, "\t reason: Invalid message size\n");
	               break;
	           case MB_ERR_MEMALLOC:
	               fprintf(stderr, "\t reason: out of memory\n");
	               break;
	           case MB_ERR_INTERNAL:
	               fprintf(stderr, "\t reason: internal error. Recompile libmoard in debug mode for more info \n");
	               break;
	           default:
                   fprintf(stderr, "\t MB_Create returned error code: %d (see libmboard docs for details)\n", rc);
                   break;
	       }

	       
       	   exit(rc);
	    }
	    #endif
	
	/* Initialise message sync composite params as NULL */
	FLAME_m_bankruptcy_illiquidity_composite_params = NULL;

	    rc = MB_Create(&b_bankruptcy_illiquidity, sizeof(m_bankruptcy_illiquidity));
	    #ifdef ERRCHECK
	    if (rc != MB_SUCCESS)
	    {
	       fprintf(stderr, "ERROR: Could not create 'bankruptcy_illiquidity' board\n");
	       switch(rc) {
	           case MB_ERR_INVALID:
	               fprintf(stderr, "\t reason: Invalid message size\n");
	               break;
	           case MB_ERR_MEMALLOC:
	               fprintf(stderr, "\t reason: out of memory\n");
	               break;
	           case MB_ERR_INTERNAL:
	               fprintf(stderr, "\t reason: internal error. Recompile libmoard in debug mode for more info \n");
	               break;
	           default:
                   fprintf(stderr, "\t MB_Create returned error code: %d (see libmboard docs for details)\n", rc);
                   break;
	       }

	       
       	   exit(rc);
	    }
	    #endif
	
	/* Initialise message sync composite params as NULL */
	FLAME_m_bankruptcy_insolvency_composite_params = NULL;

	    rc = MB_Create(&b_bankruptcy_insolvency, sizeof(m_bankruptcy_insolvency));
	    #ifdef ERRCHECK
	    if (rc != MB_SUCCESS)
	    {
	       fprintf(stderr, "ERROR: Could not create 'bankruptcy_insolvency' board\n");
	       switch(rc) {
	           case MB_ERR_INVALID:
	               fprintf(stderr, "\t reason: Invalid message size\n");
	               break;
	           case MB_ERR_MEMALLOC:
	               fprintf(stderr, "\t reason: out of memory\n");
	               break;
	           case MB_ERR_INTERNAL:
	               fprintf(stderr, "\t reason: internal error. Recompile libmoard in debug mode for more info \n");
	               break;
	           default:
                   fprintf(stderr, "\t MB_Create returned error code: %d (see libmboard docs for details)\n", rc);
                   break;
	       }

	       
       	   exit(rc);
	    }
	    #endif
	
	/* Initialise message sync composite params as NULL */
	FLAME_m_index_info_composite_params = NULL;

	    rc = MB_Create(&b_index_info, sizeof(m_index_info));
	    #ifdef ERRCHECK
	    if (rc != MB_SUCCESS)
	    {
	       fprintf(stderr, "ERROR: Could not create 'index_info' board\n");
	       switch(rc) {
	           case MB_ERR_INVALID:
	               fprintf(stderr, "\t reason: Invalid message size\n");
	               break;
	           case MB_ERR_MEMALLOC:
	               fprintf(stderr, "\t reason: out of memory\n");
	               break;
	           case MB_ERR_INTERNAL:
	               fprintf(stderr, "\t reason: internal error. Recompile libmoard in debug mode for more info \n");
	               break;
	           default:
                   fprintf(stderr, "\t MB_Create returned error code: %d (see libmboard docs for details)\n", rc);
                   break;
	       }

	       
       	   exit(rc);
	    }
	    #endif
	
	/* Initialise message sync composite params as NULL */
	FLAME_m_index_price_composite_params = NULL;

	    rc = MB_Create(&b_index_price, sizeof(m_index_price));
	    #ifdef ERRCHECK
	    if (rc != MB_SUCCESS)
	    {
	       fprintf(stderr, "ERROR: Could not create 'index_price' board\n");
	       switch(rc) {
	           case MB_ERR_INVALID:
	               fprintf(stderr, "\t reason: Invalid message size\n");
	               break;
	           case MB_ERR_MEMALLOC:
	               fprintf(stderr, "\t reason: out of memory\n");
	               break;
	           case MB_ERR_INTERNAL:
	               fprintf(stderr, "\t reason: internal error. Recompile libmoard in debug mode for more info \n");
	               break;
	           default:
                   fprintf(stderr, "\t MB_Create returned error code: %d (see libmboard docs for details)\n", rc);
                   break;
	       }

	       
       	   exit(rc);
	    }
	    #endif
	
	/* Initialise message sync composite params as NULL */
	FLAME_m_order_composite_params = NULL;

	    rc = MB_Create(&b_order, sizeof(m_order));
	    #ifdef ERRCHECK
	    if (rc != MB_SUCCESS)
	    {
	       fprintf(stderr, "ERROR: Could not create 'order' board\n");
	       switch(rc) {
	           case MB_ERR_INVALID:
	               fprintf(stderr, "\t reason: Invalid message size\n");
	               break;
	           case MB_ERR_MEMALLOC:
	               fprintf(stderr, "\t reason: out of memory\n");
	               break;
	           case MB_ERR_INTERNAL:
	               fprintf(stderr, "\t reason: internal error. Recompile libmoard in debug mode for more info \n");
	               break;
	           default:
                   fprintf(stderr, "\t MB_Create returned error code: %d (see libmboard docs for details)\n", rc);
                   break;
	       }

	       
       	   exit(rc);
	    }
	    #endif
	
	/* Initialise message sync composite params as NULL */
	FLAME_m_order_status_composite_params = NULL;

	    rc = MB_Create(&b_order_status, sizeof(m_order_status));
	    #ifdef ERRCHECK
	    if (rc != MB_SUCCESS)
	    {
	       fprintf(stderr, "ERROR: Could not create 'order_status' board\n");
	       switch(rc) {
	           case MB_ERR_INVALID:
	               fprintf(stderr, "\t reason: Invalid message size\n");
	               break;
	           case MB_ERR_MEMALLOC:
	               fprintf(stderr, "\t reason: out of memory\n");
	               break;
	           case MB_ERR_INTERNAL:
	               fprintf(stderr, "\t reason: internal error. Recompile libmoard in debug mode for more info \n");
	               break;
	           default:
                   fprintf(stderr, "\t MB_Create returned error code: %d (see libmboard docs for details)\n", rc);
                   break;
	       }

	       
       	   exit(rc);
	    }
	    #endif
	
	/* Initialise message sync composite params as NULL */
	FLAME_m_dividend_info_composite_params = NULL;

	    rc = MB_Create(&b_dividend_info, sizeof(m_dividend_info));
	    #ifdef ERRCHECK
	    if (rc != MB_SUCCESS)
	    {
	       fprintf(stderr, "ERROR: Could not create 'dividend_info' board\n");
	       switch(rc) {
	           case MB_ERR_INVALID:
	               fprintf(stderr, "\t reason: Invalid message size\n");
	               break;
	           case MB_ERR_MEMALLOC:
	               fprintf(stderr, "\t reason: out of memory\n");
	               break;
	           case MB_ERR_INTERNAL:
	               fprintf(stderr, "\t reason: internal error. Recompile libmoard in debug mode for more info \n");
	               break;
	           default:
                   fprintf(stderr, "\t MB_Create returned error code: %d (see libmboard docs for details)\n", rc);
                   break;
	       }

	       
       	   exit(rc);
	    }
	    #endif
	
	/* Initialise message sync composite params as NULL */
	FLAME_m_productivity_composite_params = NULL;

	    rc = MB_Create(&b_productivity, sizeof(m_productivity));
	    #ifdef ERRCHECK
	    if (rc != MB_SUCCESS)
	    {
	       fprintf(stderr, "ERROR: Could not create 'productivity' board\n");
	       switch(rc) {
	           case MB_ERR_INVALID:
	               fprintf(stderr, "\t reason: Invalid message size\n");
	               break;
	           case MB_ERR_MEMALLOC:
	               fprintf(stderr, "\t reason: out of memory\n");
	               break;
	           case MB_ERR_INTERNAL:
	               fprintf(stderr, "\t reason: internal error. Recompile libmoard in debug mode for more info \n");
	               break;
	           default:
                   fprintf(stderr, "\t MB_Create returned error code: %d (see libmboard docs for details)\n", rc);
                   break;
	       }

	       
       	   exit(rc);
	    }
	    #endif
	
	/* Initialise message sync composite params as NULL */
	FLAME_m_capital_good_request_composite_params = NULL;

	    rc = MB_Create(&b_capital_good_request, sizeof(m_capital_good_request));
	    #ifdef ERRCHECK
	    if (rc != MB_SUCCESS)
	    {
	       fprintf(stderr, "ERROR: Could not create 'capital_good_request' board\n");
	       switch(rc) {
	           case MB_ERR_INVALID:
	               fprintf(stderr, "\t reason: Invalid message size\n");
	               break;
	           case MB_ERR_MEMALLOC:
	               fprintf(stderr, "\t reason: out of memory\n");
	               break;
	           case MB_ERR_INTERNAL:
	               fprintf(stderr, "\t reason: internal error. Recompile libmoard in debug mode for more info \n");
	               break;
	           default:
                   fprintf(stderr, "\t MB_Create returned error code: %d (see libmboard docs for details)\n", rc);
                   break;
	       }

	       
       	   exit(rc);
	    }
	    #endif
	
	/* Initialise message sync composite params as NULL */
	FLAME_m_capital_good_delivery_composite_params = NULL;

	    rc = MB_Create(&b_capital_good_delivery, sizeof(m_capital_good_delivery));
	    #ifdef ERRCHECK
	    if (rc != MB_SUCCESS)
	    {
	       fprintf(stderr, "ERROR: Could not create 'capital_good_delivery' board\n");
	       switch(rc) {
	           case MB_ERR_INVALID:
	               fprintf(stderr, "\t reason: Invalid message size\n");
	               break;
	           case MB_ERR_MEMALLOC:
	               fprintf(stderr, "\t reason: out of memory\n");
	               break;
	           case MB_ERR_INTERNAL:
	               fprintf(stderr, "\t reason: internal error. Recompile libmoard in debug mode for more info \n");
	               break;
	           default:
                   fprintf(stderr, "\t MB_Create returned error code: %d (see libmboard docs for details)\n", rc);
                   break;
	       }

	       
       	   exit(rc);
	    }
	    #endif
	
	/* Initialise message sync composite params as NULL */
	FLAME_m_pay_capital_goods_composite_params = NULL;

	    rc = MB_Create(&b_pay_capital_goods, sizeof(m_pay_capital_goods));
	    #ifdef ERRCHECK
	    if (rc != MB_SUCCESS)
	    {
	       fprintf(stderr, "ERROR: Could not create 'pay_capital_goods' board\n");
	       switch(rc) {
	           case MB_ERR_INVALID:
	               fprintf(stderr, "\t reason: Invalid message size\n");
	               break;
	           case MB_ERR_MEMALLOC:
	               fprintf(stderr, "\t reason: out of memory\n");
	               break;
	           case MB_ERR_INTERNAL:
	               fprintf(stderr, "\t reason: internal error. Recompile libmoard in debug mode for more info \n");
	               break;
	           default:
                   fprintf(stderr, "\t MB_Create returned error code: %d (see libmboard docs for details)\n", rc);
                   break;
	       }

	       
       	   exit(rc);
	    }
	    #endif
	
	/* Initialise message sync composite params as NULL */
	FLAME_m_vacancies_composite_params = NULL;

	    rc = MB_Create(&b_vacancies, sizeof(m_vacancies));
	    #ifdef ERRCHECK
	    if (rc != MB_SUCCESS)
	    {
	       fprintf(stderr, "ERROR: Could not create 'vacancies' board\n");
	       switch(rc) {
	           case MB_ERR_INVALID:
	               fprintf(stderr, "\t reason: Invalid message size\n");
	               break;
	           case MB_ERR_MEMALLOC:
	               fprintf(stderr, "\t reason: out of memory\n");
	               break;
	           case MB_ERR_INTERNAL:
	               fprintf(stderr, "\t reason: internal error. Recompile libmoard in debug mode for more info \n");
	               break;
	           default:
                   fprintf(stderr, "\t MB_Create returned error code: %d (see libmboard docs for details)\n", rc);
                   break;
	       }

	       
       	   exit(rc);
	    }
	    #endif
	
	/* Initialise message sync composite params as NULL */
	FLAME_m_vacancies2_composite_params = NULL;

	    rc = MB_Create(&b_vacancies2, sizeof(m_vacancies2));
	    #ifdef ERRCHECK
	    if (rc != MB_SUCCESS)
	    {
	       fprintf(stderr, "ERROR: Could not create 'vacancies2' board\n");
	       switch(rc) {
	           case MB_ERR_INVALID:
	               fprintf(stderr, "\t reason: Invalid message size\n");
	               break;
	           case MB_ERR_MEMALLOC:
	               fprintf(stderr, "\t reason: out of memory\n");
	               break;
	           case MB_ERR_INTERNAL:
	               fprintf(stderr, "\t reason: internal error. Recompile libmoard in debug mode for more info \n");
	               break;
	           default:
                   fprintf(stderr, "\t MB_Create returned error code: %d (see libmboard docs for details)\n", rc);
                   break;
	       }

	       
       	   exit(rc);
	    }
	    #endif
	
	/* Initialise message sync composite params as NULL */
	FLAME_m_vacancies_r_and_d_employees_composite_params = NULL;

	    rc = MB_Create(&b_vacancies_r_and_d_employees, sizeof(m_vacancies_r_and_d_employees));
	    #ifdef ERRCHECK
	    if (rc != MB_SUCCESS)
	    {
	       fprintf(stderr, "ERROR: Could not create 'vacancies_r_and_d_employees' board\n");
	       switch(rc) {
	           case MB_ERR_INVALID:
	               fprintf(stderr, "\t reason: Invalid message size\n");
	               break;
	           case MB_ERR_MEMALLOC:
	               fprintf(stderr, "\t reason: out of memory\n");
	               break;
	           case MB_ERR_INTERNAL:
	               fprintf(stderr, "\t reason: internal error. Recompile libmoard in debug mode for more info \n");
	               break;
	           default:
                   fprintf(stderr, "\t MB_Create returned error code: %d (see libmboard docs for details)\n", rc);
                   break;
	       }

	       
       	   exit(rc);
	    }
	    #endif
	
	/* Initialise message sync composite params as NULL */
	FLAME_m_vacancies_r_and_d_employees2_composite_params = NULL;

	    rc = MB_Create(&b_vacancies_r_and_d_employees2, sizeof(m_vacancies_r_and_d_employees2));
	    #ifdef ERRCHECK
	    if (rc != MB_SUCCESS)
	    {
	       fprintf(stderr, "ERROR: Could not create 'vacancies_r_and_d_employees2' board\n");
	       switch(rc) {
	           case MB_ERR_INVALID:
	               fprintf(stderr, "\t reason: Invalid message size\n");
	               break;
	           case MB_ERR_MEMALLOC:
	               fprintf(stderr, "\t reason: out of memory\n");
	               break;
	           case MB_ERR_INTERNAL:
	               fprintf(stderr, "\t reason: internal error. Recompile libmoard in debug mode for more info \n");
	               break;
	           default:
                   fprintf(stderr, "\t MB_Create returned error code: %d (see libmboard docs for details)\n", rc);
                   break;
	       }

	       
       	   exit(rc);
	    }
	    #endif
	
	/* Initialise message sync composite params as NULL */
	FLAME_m_firing_composite_params = NULL;

	    rc = MB_Create(&b_firing, sizeof(m_firing));
	    #ifdef ERRCHECK
	    if (rc != MB_SUCCESS)
	    {
	       fprintf(stderr, "ERROR: Could not create 'firing' board\n");
	       switch(rc) {
	           case MB_ERR_INVALID:
	               fprintf(stderr, "\t reason: Invalid message size\n");
	               break;
	           case MB_ERR_MEMALLOC:
	               fprintf(stderr, "\t reason: out of memory\n");
	               break;
	           case MB_ERR_INTERNAL:
	               fprintf(stderr, "\t reason: internal error. Recompile libmoard in debug mode for more info \n");
	               break;
	           default:
                   fprintf(stderr, "\t MB_Create returned error code: %d (see libmboard docs for details)\n", rc);
                   break;
	       }

	       
       	   exit(rc);
	    }
	    #endif
	
	/* Initialise message sync composite params as NULL */
	FLAME_m_job_application_composite_params = NULL;

	    rc = MB_Create(&b_job_application, sizeof(m_job_application));
	    #ifdef ERRCHECK
	    if (rc != MB_SUCCESS)
	    {
	       fprintf(stderr, "ERROR: Could not create 'job_application' board\n");
	       switch(rc) {
	           case MB_ERR_INVALID:
	               fprintf(stderr, "\t reason: Invalid message size\n");
	               break;
	           case MB_ERR_MEMALLOC:
	               fprintf(stderr, "\t reason: out of memory\n");
	               break;
	           case MB_ERR_INTERNAL:
	               fprintf(stderr, "\t reason: internal error. Recompile libmoard in debug mode for more info \n");
	               break;
	           default:
                   fprintf(stderr, "\t MB_Create returned error code: %d (see libmboard docs for details)\n", rc);
                   break;
	       }

	       
       	   exit(rc);
	    }
	    #endif
	
	/* Initialise message sync composite params as NULL */
	FLAME_m_job_application2_composite_params = NULL;

	    rc = MB_Create(&b_job_application2, sizeof(m_job_application2));
	    #ifdef ERRCHECK
	    if (rc != MB_SUCCESS)
	    {
	       fprintf(stderr, "ERROR: Could not create 'job_application2' board\n");
	       switch(rc) {
	           case MB_ERR_INVALID:
	               fprintf(stderr, "\t reason: Invalid message size\n");
	               break;
	           case MB_ERR_MEMALLOC:
	               fprintf(stderr, "\t reason: out of memory\n");
	               break;
	           case MB_ERR_INTERNAL:
	               fprintf(stderr, "\t reason: internal error. Recompile libmoard in debug mode for more info \n");
	               break;
	           default:
                   fprintf(stderr, "\t MB_Create returned error code: %d (see libmboard docs for details)\n", rc);
                   break;
	       }

	       
       	   exit(rc);
	    }
	    #endif
	
	/* Initialise message sync composite params as NULL */
	FLAME_m_job_offer_composite_params = NULL;

	    rc = MB_Create(&b_job_offer, sizeof(m_job_offer));
	    #ifdef ERRCHECK
	    if (rc != MB_SUCCESS)
	    {
	       fprintf(stderr, "ERROR: Could not create 'job_offer' board\n");
	       switch(rc) {
	           case MB_ERR_INVALID:
	               fprintf(stderr, "\t reason: Invalid message size\n");
	               break;
	           case MB_ERR_MEMALLOC:
	               fprintf(stderr, "\t reason: out of memory\n");
	               break;
	           case MB_ERR_INTERNAL:
	               fprintf(stderr, "\t reason: internal error. Recompile libmoard in debug mode for more info \n");
	               break;
	           default:
                   fprintf(stderr, "\t MB_Create returned error code: %d (see libmboard docs for details)\n", rc);
                   break;
	       }

	       
       	   exit(rc);
	    }
	    #endif
	
	/* Initialise message sync composite params as NULL */
	FLAME_m_job_offer2_composite_params = NULL;

	    rc = MB_Create(&b_job_offer2, sizeof(m_job_offer2));
	    #ifdef ERRCHECK
	    if (rc != MB_SUCCESS)
	    {
	       fprintf(stderr, "ERROR: Could not create 'job_offer2' board\n");
	       switch(rc) {
	           case MB_ERR_INVALID:
	               fprintf(stderr, "\t reason: Invalid message size\n");
	               break;
	           case MB_ERR_MEMALLOC:
	               fprintf(stderr, "\t reason: out of memory\n");
	               break;
	           case MB_ERR_INTERNAL:
	               fprintf(stderr, "\t reason: internal error. Recompile libmoard in debug mode for more info \n");
	               break;
	           default:
                   fprintf(stderr, "\t MB_Create returned error code: %d (see libmboard docs for details)\n", rc);
                   break;
	       }

	       
       	   exit(rc);
	    }
	    #endif
	
	/* Initialise message sync composite params as NULL */
	FLAME_m_job_acceptance_composite_params = NULL;

	    rc = MB_Create(&b_job_acceptance, sizeof(m_job_acceptance));
	    #ifdef ERRCHECK
	    if (rc != MB_SUCCESS)
	    {
	       fprintf(stderr, "ERROR: Could not create 'job_acceptance' board\n");
	       switch(rc) {
	           case MB_ERR_INVALID:
	               fprintf(stderr, "\t reason: Invalid message size\n");
	               break;
	           case MB_ERR_MEMALLOC:
	               fprintf(stderr, "\t reason: out of memory\n");
	               break;
	           case MB_ERR_INTERNAL:
	               fprintf(stderr, "\t reason: internal error. Recompile libmoard in debug mode for more info \n");
	               break;
	           default:
                   fprintf(stderr, "\t MB_Create returned error code: %d (see libmboard docs for details)\n", rc);
                   break;
	       }

	       
       	   exit(rc);
	    }
	    #endif
	
	/* Initialise message sync composite params as NULL */
	FLAME_m_job_acceptance2_composite_params = NULL;

	    rc = MB_Create(&b_job_acceptance2, sizeof(m_job_acceptance2));
	    #ifdef ERRCHECK
	    if (rc != MB_SUCCESS)
	    {
	       fprintf(stderr, "ERROR: Could not create 'job_acceptance2' board\n");
	       switch(rc) {
	           case MB_ERR_INVALID:
	               fprintf(stderr, "\t reason: Invalid message size\n");
	               break;
	           case MB_ERR_MEMALLOC:
	               fprintf(stderr, "\t reason: out of memory\n");
	               break;
	           case MB_ERR_INTERNAL:
	               fprintf(stderr, "\t reason: internal error. Recompile libmoard in debug mode for more info \n");
	               break;
	           default:
                   fprintf(stderr, "\t MB_Create returned error code: %d (see libmboard docs for details)\n", rc);
                   break;
	       }

	       
       	   exit(rc);
	    }
	    #endif
	
	/* Initialise message sync composite params as NULL */
	FLAME_m_quitting_composite_params = NULL;

	    rc = MB_Create(&b_quitting, sizeof(m_quitting));
	    #ifdef ERRCHECK
	    if (rc != MB_SUCCESS)
	    {
	       fprintf(stderr, "ERROR: Could not create 'quitting' board\n");
	       switch(rc) {
	           case MB_ERR_INVALID:
	               fprintf(stderr, "\t reason: Invalid message size\n");
	               break;
	           case MB_ERR_MEMALLOC:
	               fprintf(stderr, "\t reason: out of memory\n");
	               break;
	           case MB_ERR_INTERNAL:
	               fprintf(stderr, "\t reason: internal error. Recompile libmoard in debug mode for more info \n");
	               break;
	           default:
                   fprintf(stderr, "\t MB_Create returned error code: %d (see libmboard docs for details)\n", rc);
                   break;
	       }

	       
       	   exit(rc);
	    }
	    #endif
	
	/* Initialise message sync composite params as NULL */
	FLAME_m_quitting2_composite_params = NULL;

	    rc = MB_Create(&b_quitting2, sizeof(m_quitting2));
	    #ifdef ERRCHECK
	    if (rc != MB_SUCCESS)
	    {
	       fprintf(stderr, "ERROR: Could not create 'quitting2' board\n");
	       switch(rc) {
	           case MB_ERR_INVALID:
	               fprintf(stderr, "\t reason: Invalid message size\n");
	               break;
	           case MB_ERR_MEMALLOC:
	               fprintf(stderr, "\t reason: out of memory\n");
	               break;
	           case MB_ERR_INTERNAL:
	               fprintf(stderr, "\t reason: internal error. Recompile libmoard in debug mode for more info \n");
	               break;
	           default:
                   fprintf(stderr, "\t MB_Create returned error code: %d (see libmboard docs for details)\n", rc);
                   break;
	       }

	       
       	   exit(rc);
	    }
	    #endif
	
	/* Initialise message sync composite params as NULL */
	FLAME_m_unemployment_notification_composite_params = NULL;

	    rc = MB_Create(&b_unemployment_notification, sizeof(m_unemployment_notification));
	    #ifdef ERRCHECK
	    if (rc != MB_SUCCESS)
	    {
	       fprintf(stderr, "ERROR: Could not create 'unemployment_notification' board\n");
	       switch(rc) {
	           case MB_ERR_INVALID:
	               fprintf(stderr, "\t reason: Invalid message size\n");
	               break;
	           case MB_ERR_MEMALLOC:
	               fprintf(stderr, "\t reason: out of memory\n");
	               break;
	           case MB_ERR_INTERNAL:
	               fprintf(stderr, "\t reason: internal error. Recompile libmoard in debug mode for more info \n");
	               break;
	           default:
                   fprintf(stderr, "\t MB_Create returned error code: %d (see libmboard docs for details)\n", rc);
                   break;
	       }

	       
       	   exit(rc);
	    }
	    #endif
	
	/* Initialise message sync composite params as NULL */
	FLAME_m_policy_announcement_composite_params = NULL;

	    rc = MB_Create(&b_policy_announcement, sizeof(m_policy_announcement));
	    #ifdef ERRCHECK
	    if (rc != MB_SUCCESS)
	    {
	       fprintf(stderr, "ERROR: Could not create 'policy_announcement' board\n");
	       switch(rc) {
	           case MB_ERR_INVALID:
	               fprintf(stderr, "\t reason: Invalid message size\n");
	               break;
	           case MB_ERR_MEMALLOC:
	               fprintf(stderr, "\t reason: out of memory\n");
	               break;
	           case MB_ERR_INTERNAL:
	               fprintf(stderr, "\t reason: internal error. Recompile libmoard in debug mode for more info \n");
	               break;
	           default:
                   fprintf(stderr, "\t MB_Create returned error code: %d (see libmboard docs for details)\n", rc);
                   break;
	       }

	       
       	   exit(rc);
	    }
	    #endif
	
	/* Initialise message sync composite params as NULL */
	FLAME_m_tax_payment_composite_params = NULL;

	    rc = MB_Create(&b_tax_payment, sizeof(m_tax_payment));
	    #ifdef ERRCHECK
	    if (rc != MB_SUCCESS)
	    {
	       fprintf(stderr, "ERROR: Could not create 'tax_payment' board\n");
	       switch(rc) {
	           case MB_ERR_INVALID:
	               fprintf(stderr, "\t reason: Invalid message size\n");
	               break;
	           case MB_ERR_MEMALLOC:
	               fprintf(stderr, "\t reason: out of memory\n");
	               break;
	           case MB_ERR_INTERNAL:
	               fprintf(stderr, "\t reason: internal error. Recompile libmoard in debug mode for more info \n");
	               break;
	           default:
                   fprintf(stderr, "\t MB_Create returned error code: %d (see libmboard docs for details)\n", rc);
                   break;
	       }

	       
       	   exit(rc);
	    }
	    #endif
	
	/* Initialise message sync composite params as NULL */
	FLAME_m_unemployment_benefit_restitution_composite_params = NULL;

	    rc = MB_Create(&b_unemployment_benefit_restitution, sizeof(m_unemployment_benefit_restitution));
	    #ifdef ERRCHECK
	    if (rc != MB_SUCCESS)
	    {
	       fprintf(stderr, "ERROR: Could not create 'unemployment_benefit_restitution' board\n");
	       switch(rc) {
	           case MB_ERR_INVALID:
	               fprintf(stderr, "\t reason: Invalid message size\n");
	               break;
	           case MB_ERR_MEMALLOC:
	               fprintf(stderr, "\t reason: out of memory\n");
	               break;
	           case MB_ERR_INTERNAL:
	               fprintf(stderr, "\t reason: internal error. Recompile libmoard in debug mode for more info \n");
	               break;
	           default:
                   fprintf(stderr, "\t MB_Create returned error code: %d (see libmboard docs for details)\n", rc);
                   break;
	       }

	       
       	   exit(rc);
	    }
	    #endif
	
	/* Initialise message sync composite params as NULL */
	FLAME_m_hh_transfer_notification_composite_params = NULL;

	    rc = MB_Create(&b_hh_transfer_notification, sizeof(m_hh_transfer_notification));
	    #ifdef ERRCHECK
	    if (rc != MB_SUCCESS)
	    {
	       fprintf(stderr, "ERROR: Could not create 'hh_transfer_notification' board\n");
	       switch(rc) {
	           case MB_ERR_INVALID:
	               fprintf(stderr, "\t reason: Invalid message size\n");
	               break;
	           case MB_ERR_MEMALLOC:
	               fprintf(stderr, "\t reason: out of memory\n");
	               break;
	           case MB_ERR_INTERNAL:
	               fprintf(stderr, "\t reason: internal error. Recompile libmoard in debug mode for more info \n");
	               break;
	           default:
                   fprintf(stderr, "\t MB_Create returned error code: %d (see libmboard docs for details)\n", rc);
                   break;
	       }

	       
       	   exit(rc);
	    }
	    #endif
	
	/* Initialise message sync composite params as NULL */
	FLAME_m_hh_subsidy_notification_composite_params = NULL;

	    rc = MB_Create(&b_hh_subsidy_notification, sizeof(m_hh_subsidy_notification));
	    #ifdef ERRCHECK
	    if (rc != MB_SUCCESS)
	    {
	       fprintf(stderr, "ERROR: Could not create 'hh_subsidy_notification' board\n");
	       switch(rc) {
	           case MB_ERR_INVALID:
	               fprintf(stderr, "\t reason: Invalid message size\n");
	               break;
	           case MB_ERR_MEMALLOC:
	               fprintf(stderr, "\t reason: out of memory\n");
	               break;
	           case MB_ERR_INTERNAL:
	               fprintf(stderr, "\t reason: internal error. Recompile libmoard in debug mode for more info \n");
	               break;
	           default:
                   fprintf(stderr, "\t MB_Create returned error code: %d (see libmboard docs for details)\n", rc);
                   break;
	       }

	       
       	   exit(rc);
	    }
	    #endif
	
	/* Initialise message sync composite params as NULL */
	FLAME_m_human_capital_policy_announcement_composite_params = NULL;

	    rc = MB_Create(&b_human_capital_policy_announcement, sizeof(m_human_capital_policy_announcement));
	    #ifdef ERRCHECK
	    if (rc != MB_SUCCESS)
	    {
	       fprintf(stderr, "ERROR: Could not create 'human_capital_policy_announcement' board\n");
	       switch(rc) {
	           case MB_ERR_INVALID:
	               fprintf(stderr, "\t reason: Invalid message size\n");
	               break;
	           case MB_ERR_MEMALLOC:
	               fprintf(stderr, "\t reason: out of memory\n");
	               break;
	           case MB_ERR_INTERNAL:
	               fprintf(stderr, "\t reason: internal error. Recompile libmoard in debug mode for more info \n");
	               break;
	           default:
                   fprintf(stderr, "\t MB_Create returned error code: %d (see libmboard docs for details)\n", rc);
                   break;
	       }

	       
       	   exit(rc);
	    }
	    #endif
	
	/* Initialise message sync composite params as NULL */
	FLAME_m_firm_transfer_notification_composite_params = NULL;

	    rc = MB_Create(&b_firm_transfer_notification, sizeof(m_firm_transfer_notification));
	    #ifdef ERRCHECK
	    if (rc != MB_SUCCESS)
	    {
	       fprintf(stderr, "ERROR: Could not create 'firm_transfer_notification' board\n");
	       switch(rc) {
	           case MB_ERR_INVALID:
	               fprintf(stderr, "\t reason: Invalid message size\n");
	               break;
	           case MB_ERR_MEMALLOC:
	               fprintf(stderr, "\t reason: out of memory\n");
	               break;
	           case MB_ERR_INTERNAL:
	               fprintf(stderr, "\t reason: internal error. Recompile libmoard in debug mode for more info \n");
	               break;
	           default:
                   fprintf(stderr, "\t MB_Create returned error code: %d (see libmboard docs for details)\n", rc);
                   break;
	       }

	       
       	   exit(rc);
	    }
	    #endif
	
	/* Initialise message sync composite params as NULL */
	FLAME_m_firm_subsidy_notification_composite_params = NULL;

	    rc = MB_Create(&b_firm_subsidy_notification, sizeof(m_firm_subsidy_notification));
	    #ifdef ERRCHECK
	    if (rc != MB_SUCCESS)
	    {
	       fprintf(stderr, "ERROR: Could not create 'firm_subsidy_notification' board\n");
	       switch(rc) {
	           case MB_ERR_INVALID:
	               fprintf(stderr, "\t reason: Invalid message size\n");
	               break;
	           case MB_ERR_MEMALLOC:
	               fprintf(stderr, "\t reason: out of memory\n");
	               break;
	           case MB_ERR_INTERNAL:
	               fprintf(stderr, "\t reason: internal error. Recompile libmoard in debug mode for more info \n");
	               break;
	           default:
                   fprintf(stderr, "\t MB_Create returned error code: %d (see libmboard docs for details)\n", rc);
                   break;
	       }

	       
       	   exit(rc);
	    }
	    #endif
	
	/* Initialise message sync composite params as NULL */
	FLAME_m_request_fiat_money_composite_params = NULL;

	    rc = MB_Create(&b_request_fiat_money, sizeof(m_request_fiat_money));
	    #ifdef ERRCHECK
	    if (rc != MB_SUCCESS)
	    {
	       fprintf(stderr, "ERROR: Could not create 'request_fiat_money' board\n");
	       switch(rc) {
	           case MB_ERR_INVALID:
	               fprintf(stderr, "\t reason: Invalid message size\n");
	               break;
	           case MB_ERR_MEMALLOC:
	               fprintf(stderr, "\t reason: out of memory\n");
	               break;
	           case MB_ERR_INTERNAL:
	               fprintf(stderr, "\t reason: internal error. Recompile libmoard in debug mode for more info \n");
	               break;
	           default:
                   fprintf(stderr, "\t MB_Create returned error code: %d (see libmboard docs for details)\n", rc);
                   break;
	       }

	       
       	   exit(rc);
	    }
	    #endif
	
	/* Initialise message sync composite params as NULL */
	FLAME_m_human_capital_policy_general_skill_information_composite_params = NULL;

	    rc = MB_Create(&b_human_capital_policy_general_skill_information, sizeof(m_human_capital_policy_general_skill_information));
	    #ifdef ERRCHECK
	    if (rc != MB_SUCCESS)
	    {
	       fprintf(stderr, "ERROR: Could not create 'human_capital_policy_general_skill_information' board\n");
	       switch(rc) {
	           case MB_ERR_INVALID:
	               fprintf(stderr, "\t reason: Invalid message size\n");
	               break;
	           case MB_ERR_MEMALLOC:
	               fprintf(stderr, "\t reason: out of memory\n");
	               break;
	           case MB_ERR_INTERNAL:
	               fprintf(stderr, "\t reason: internal error. Recompile libmoard in debug mode for more info \n");
	               break;
	           default:
                   fprintf(stderr, "\t MB_Create returned error code: %d (see libmboard docs for details)\n", rc);
                   break;
	       }

	       
       	   exit(rc);
	    }
	    #endif
	
	/* Initialise message sync composite params as NULL */
	FLAME_m_human_capital_policy_new_general_skill_notification_composite_params = NULL;

	    rc = MB_Create(&b_human_capital_policy_new_general_skill_notification, sizeof(m_human_capital_policy_new_general_skill_notification));
	    #ifdef ERRCHECK
	    if (rc != MB_SUCCESS)
	    {
	       fprintf(stderr, "ERROR: Could not create 'human_capital_policy_new_general_skill_notification' board\n");
	       switch(rc) {
	           case MB_ERR_INVALID:
	               fprintf(stderr, "\t reason: Invalid message size\n");
	               break;
	           case MB_ERR_MEMALLOC:
	               fprintf(stderr, "\t reason: out of memory\n");
	               break;
	           case MB_ERR_INTERNAL:
	               fprintf(stderr, "\t reason: internal error. Recompile libmoard in debug mode for more info \n");
	               break;
	           default:
                   fprintf(stderr, "\t MB_Create returned error code: %d (see libmboard docs for details)\n", rc);
                   break;
	       }

	       
       	   exit(rc);
	    }
	    #endif
	
	/* Initialise message sync composite params as NULL */
	FLAME_m_firm_send_data_composite_params = NULL;

	    rc = MB_Create(&b_firm_send_data, sizeof(m_firm_send_data));
	    #ifdef ERRCHECK
	    if (rc != MB_SUCCESS)
	    {
	       fprintf(stderr, "ERROR: Could not create 'firm_send_data' board\n");
	       switch(rc) {
	           case MB_ERR_INVALID:
	               fprintf(stderr, "\t reason: Invalid message size\n");
	               break;
	           case MB_ERR_MEMALLOC:
	               fprintf(stderr, "\t reason: out of memory\n");
	               break;
	           case MB_ERR_INTERNAL:
	               fprintf(stderr, "\t reason: internal error. Recompile libmoard in debug mode for more info \n");
	               break;
	           default:
                   fprintf(stderr, "\t MB_Create returned error code: %d (see libmboard docs for details)\n", rc);
                   break;
	       }

	       
       	   exit(rc);
	    }
	    #endif
	
	/* Initialise message sync composite params as NULL */
	FLAME_m_government_send_data_composite_params = NULL;

	    rc = MB_Create(&b_government_send_data, sizeof(m_government_send_data));
	    #ifdef ERRCHECK
	    if (rc != MB_SUCCESS)
	    {
	       fprintf(stderr, "ERROR: Could not create 'government_send_data' board\n");
	       switch(rc) {
	           case MB_ERR_INVALID:
	               fprintf(stderr, "\t reason: Invalid message size\n");
	               break;
	           case MB_ERR_MEMALLOC:
	               fprintf(stderr, "\t reason: out of memory\n");
	               break;
	           case MB_ERR_INTERNAL:
	               fprintf(stderr, "\t reason: internal error. Recompile libmoard in debug mode for more info \n");
	               break;
	           default:
                   fprintf(stderr, "\t MB_Create returned error code: %d (see libmboard docs for details)\n", rc);
                   break;
	       }

	       
       	   exit(rc);
	    }
	    #endif
	
	/* Initialise message sync composite params as NULL */
	FLAME_m_household_send_data_composite_params = NULL;

	    rc = MB_Create(&b_household_send_data, sizeof(m_household_send_data));
	    #ifdef ERRCHECK
	    if (rc != MB_SUCCESS)
	    {
	       fprintf(stderr, "ERROR: Could not create 'household_send_data' board\n");
	       switch(rc) {
	           case MB_ERR_INVALID:
	               fprintf(stderr, "\t reason: Invalid message size\n");
	               break;
	           case MB_ERR_MEMALLOC:
	               fprintf(stderr, "\t reason: out of memory\n");
	               break;
	           case MB_ERR_INTERNAL:
	               fprintf(stderr, "\t reason: internal error. Recompile libmoard in debug mode for more info \n");
	               break;
	           default:
                   fprintf(stderr, "\t MB_Create returned error code: %d (see libmboard docs for details)\n", rc);
                   break;
	       }

	       
       	   exit(rc);
	    }
	    #endif
	
	/* Initialise message sync composite params as NULL */
	FLAME_m_mall_data_composite_params = NULL;

	    rc = MB_Create(&b_mall_data, sizeof(m_mall_data));
	    #ifdef ERRCHECK
	    if (rc != MB_SUCCESS)
	    {
	       fprintf(stderr, "ERROR: Could not create 'mall_data' board\n");
	       switch(rc) {
	           case MB_ERR_INVALID:
	               fprintf(stderr, "\t reason: Invalid message size\n");
	               break;
	           case MB_ERR_MEMALLOC:
	               fprintf(stderr, "\t reason: out of memory\n");
	               break;
	           case MB_ERR_INTERNAL:
	               fprintf(stderr, "\t reason: internal error. Recompile libmoard in debug mode for more info \n");
	               break;
	           default:
                   fprintf(stderr, "\t MB_Create returned error code: %d (see libmboard docs for details)\n", rc);
                   break;
	       }

	       
       	   exit(rc);
	    }
	    #endif
	
	/* Initialise message sync composite params as NULL */
	FLAME_m_eurostat_send_specific_skills_composite_params = NULL;

	    rc = MB_Create(&b_eurostat_send_specific_skills, sizeof(m_eurostat_send_specific_skills));
	    #ifdef ERRCHECK
	    if (rc != MB_SUCCESS)
	    {
	       fprintf(stderr, "ERROR: Could not create 'eurostat_send_specific_skills' board\n");
	       switch(rc) {
	           case MB_ERR_INVALID:
	               fprintf(stderr, "\t reason: Invalid message size\n");
	               break;
	           case MB_ERR_MEMALLOC:
	               fprintf(stderr, "\t reason: out of memory\n");
	               break;
	           case MB_ERR_INTERNAL:
	               fprintf(stderr, "\t reason: internal error. Recompile libmoard in debug mode for more info \n");
	               break;
	           default:
                   fprintf(stderr, "\t MB_Create returned error code: %d (see libmboard docs for details)\n", rc);
                   break;
	       }

	       
       	   exit(rc);
	    }
	    #endif
	
	/* Initialise message sync composite params as NULL */
	FLAME_m_data_for_government_composite_params = NULL;

	    rc = MB_Create(&b_data_for_government, sizeof(m_data_for_government));
	    #ifdef ERRCHECK
	    if (rc != MB_SUCCESS)
	    {
	       fprintf(stderr, "ERROR: Could not create 'data_for_government' board\n");
	       switch(rc) {
	           case MB_ERR_INVALID:
	               fprintf(stderr, "\t reason: Invalid message size\n");
	               break;
	           case MB_ERR_MEMALLOC:
	               fprintf(stderr, "\t reason: out of memory\n");
	               break;
	           case MB_ERR_INTERNAL:
	               fprintf(stderr, "\t reason: internal error. Recompile libmoard in debug mode for more info \n");
	               break;
	           default:
                   fprintf(stderr, "\t MB_Create returned error code: %d (see libmboard docs for details)\n", rc);
                   break;
	       }

	       
       	   exit(rc);
	    }
	    #endif
	
	/* Initialise message sync composite params as NULL */
	FLAME_m_eurostat_send_macrodata_composite_params = NULL;

	    rc = MB_Create(&b_eurostat_send_macrodata, sizeof(m_eurostat_send_macrodata));
	    #ifdef ERRCHECK
	    if (rc != MB_SUCCESS)
	    {
	       fprintf(stderr, "ERROR: Could not create 'eurostat_send_macrodata' board\n");
	       switch(rc) {
	           case MB_ERR_INVALID:
	               fprintf(stderr, "\t reason: Invalid message size\n");
	               break;
	           case MB_ERR_MEMALLOC:
	               fprintf(stderr, "\t reason: out of memory\n");
	               break;
	           case MB_ERR_INTERNAL:
	               fprintf(stderr, "\t reason: internal error. Recompile libmoard in debug mode for more info \n");
	               break;
	           default:
                   fprintf(stderr, "\t MB_Create returned error code: %d (see libmboard docs for details)\n", rc);
                   break;
	       }

	       
       	   exit(rc);
	    }
	    #endif
	
	/* Initialise message sync composite params as NULL */
	FLAME_m_msg_firm_id_to_malls_composite_params = NULL;

	    rc = MB_Create(&b_msg_firm_id_to_malls, sizeof(m_msg_firm_id_to_malls));
	    #ifdef ERRCHECK
	    if (rc != MB_SUCCESS)
	    {
	       fprintf(stderr, "ERROR: Could not create 'msg_firm_id_to_malls' board\n");
	       switch(rc) {
	           case MB_ERR_INVALID:
	               fprintf(stderr, "\t reason: Invalid message size\n");
	               break;
	           case MB_ERR_MEMALLOC:
	               fprintf(stderr, "\t reason: out of memory\n");
	               break;
	           case MB_ERR_INTERNAL:
	               fprintf(stderr, "\t reason: internal error. Recompile libmoard in debug mode for more info \n");
	               break;
	           default:
                   fprintf(stderr, "\t MB_Create returned error code: %d (see libmboard docs for details)\n", rc);
                   break;
	       }

	       
       	   exit(rc);
	    }
	    #endif
	
	/* Initialise message sync composite params as NULL */
	FLAME_m_msg_mall_id_to_firms_composite_params = NULL;

	    rc = MB_Create(&b_msg_mall_id_to_firms, sizeof(m_msg_mall_id_to_firms));
	    #ifdef ERRCHECK
	    if (rc != MB_SUCCESS)
	    {
	       fprintf(stderr, "ERROR: Could not create 'msg_mall_id_to_firms' board\n");
	       switch(rc) {
	           case MB_ERR_INVALID:
	               fprintf(stderr, "\t reason: Invalid message size\n");
	               break;
	           case MB_ERR_MEMALLOC:
	               fprintf(stderr, "\t reason: out of memory\n");
	               break;
	           case MB_ERR_INTERNAL:
	               fprintf(stderr, "\t reason: internal error. Recompile libmoard in debug mode for more info \n");
	               break;
	           default:
                   fprintf(stderr, "\t MB_Create returned error code: %d (see libmboard docs for details)\n", rc);
                   break;
	       }

	       
       	   exit(rc);
	    }
	    #endif
	
	/* Initialise message sync composite params as NULL */
	FLAME_m_msg_skills_eurostat_to_igfirm_composite_params = NULL;

	    rc = MB_Create(&b_msg_skills_eurostat_to_igfirm, sizeof(m_msg_skills_eurostat_to_igfirm));
	    #ifdef ERRCHECK
	    if (rc != MB_SUCCESS)
	    {
	       fprintf(stderr, "ERROR: Could not create 'msg_skills_eurostat_to_igfirm' board\n");
	       switch(rc) {
	           case MB_ERR_INVALID:
	               fprintf(stderr, "\t reason: Invalid message size\n");
	               break;
	           case MB_ERR_MEMALLOC:
	               fprintf(stderr, "\t reason: out of memory\n");
	               break;
	           case MB_ERR_INTERNAL:
	               fprintf(stderr, "\t reason: internal error. Recompile libmoard in debug mode for more info \n");
	               break;
	           default:
                   fprintf(stderr, "\t MB_Create returned error code: %d (see libmboard docs for details)\n", rc);
                   break;
	       }

	       
       	   exit(rc);
	    }
	    #endif
	
	/* Initialise message sync composite params as NULL */
	FLAME_m_msg_market_sizes_composite_params = NULL;

	    rc = MB_Create(&b_msg_market_sizes, sizeof(m_msg_market_sizes));
	    #ifdef ERRCHECK
	    if (rc != MB_SUCCESS)
	    {
	       fprintf(stderr, "ERROR: Could not create 'msg_market_sizes' board\n");
	       switch(rc) {
	           case MB_ERR_INVALID:
	               fprintf(stderr, "\t reason: Invalid message size\n");
	               break;
	           case MB_ERR_MEMALLOC:
	               fprintf(stderr, "\t reason: out of memory\n");
	               break;
	           case MB_ERR_INTERNAL:
	               fprintf(stderr, "\t reason: internal error. Recompile libmoard in debug mode for more info \n");
	               break;
	           default:
                   fprintf(stderr, "\t MB_Create returned error code: %d (see libmboard docs for details)\n", rc);
                   break;
	       }

	       
       	   exit(rc);
	    }
	    #endif
	
	/* Initialise message sync composite params as NULL */
	FLAME_m_total_subsidies_composite_params = NULL;

	    rc = MB_Create(&b_total_subsidies, sizeof(m_total_subsidies));
	    #ifdef ERRCHECK
	    if (rc != MB_SUCCESS)
	    {
	       fprintf(stderr, "ERROR: Could not create 'total_subsidies' board\n");
	       switch(rc) {
	           case MB_ERR_INVALID:
	               fprintf(stderr, "\t reason: Invalid message size\n");
	               break;
	           case MB_ERR_MEMALLOC:
	               fprintf(stderr, "\t reason: out of memory\n");
	               break;
	           case MB_ERR_INTERNAL:
	               fprintf(stderr, "\t reason: internal error. Recompile libmoard in debug mode for more info \n");
	               break;
	           default:
                   fprintf(stderr, "\t MB_Create returned error code: %d (see libmboard docs for details)\n", rc);
                   break;
	       }

	       
       	   exit(rc);
	    }
	    #endif
	
	/* Initialise message sync composite params as NULL */
	FLAME_m_redistributed_subsidies_composite_params = NULL;

	    rc = MB_Create(&b_redistributed_subsidies, sizeof(m_redistributed_subsidies));
	    #ifdef ERRCHECK
	    if (rc != MB_SUCCESS)
	    {
	       fprintf(stderr, "ERROR: Could not create 'redistributed_subsidies' board\n");
	       switch(rc) {
	           case MB_ERR_INVALID:
	               fprintf(stderr, "\t reason: Invalid message size\n");
	               break;
	           case MB_ERR_MEMALLOC:
	               fprintf(stderr, "\t reason: out of memory\n");
	               break;
	           case MB_ERR_INTERNAL:
	               fprintf(stderr, "\t reason: internal error. Recompile libmoard in debug mode for more info \n");
	               break;
	           default:
                   fprintf(stderr, "\t MB_Create returned error code: %d (see libmboard docs for details)\n", rc);
                   break;
	       }

	       
       	   exit(rc);
	    }
	    #endif
	
	/* Initialise message sync composite params as NULL */
	FLAME_m_quality_price_composite_params = NULL;

	    rc = MB_Create(&b_quality_price, sizeof(m_quality_price));
	    #ifdef ERRCHECK
	    if (rc != MB_SUCCESS)
	    {
	       fprintf(stderr, "ERROR: Could not create 'quality_price' board\n");
	       switch(rc) {
	           case MB_ERR_INVALID:
	               fprintf(stderr, "\t reason: Invalid message size\n");
	               break;
	           case MB_ERR_MEMALLOC:
	               fprintf(stderr, "\t reason: out of memory\n");
	               break;
	           case MB_ERR_INTERNAL:
	               fprintf(stderr, "\t reason: internal error. Recompile libmoard in debug mode for more info \n");
	               break;
	           default:
                   fprintf(stderr, "\t MB_Create returned error code: %d (see libmboard docs for details)\n", rc);
                   break;
	       }

	       
       	   exit(rc);
	    }
	    #endif
	
	/* Initialise message sync composite params as NULL */
	FLAME_m_interview_request_composite_params = NULL;

	    rc = MB_Create(&b_interview_request, sizeof(m_interview_request));
	    #ifdef ERRCHECK
	    if (rc != MB_SUCCESS)
	    {
	       fprintf(stderr, "ERROR: Could not create 'interview_request' board\n");
	       switch(rc) {
	           case MB_ERR_INVALID:
	               fprintf(stderr, "\t reason: Invalid message size\n");
	               break;
	           case MB_ERR_MEMALLOC:
	               fprintf(stderr, "\t reason: out of memory\n");
	               break;
	           case MB_ERR_INTERNAL:
	               fprintf(stderr, "\t reason: internal error. Recompile libmoard in debug mode for more info \n");
	               break;
	           default:
                   fprintf(stderr, "\t MB_Create returned error code: %d (see libmboard docs for details)\n", rc);
                   break;
	       }

	       
       	   exit(rc);
	    }
	    #endif
	
	/* Initialise message sync composite params as NULL */
	FLAME_m_interview_positive_response_composite_params = NULL;

	    rc = MB_Create(&b_interview_positive_response, sizeof(m_interview_positive_response));
	    #ifdef ERRCHECK
	    if (rc != MB_SUCCESS)
	    {
	       fprintf(stderr, "ERROR: Could not create 'interview_positive_response' board\n");
	       switch(rc) {
	           case MB_ERR_INVALID:
	               fprintf(stderr, "\t reason: Invalid message size\n");
	               break;
	           case MB_ERR_MEMALLOC:
	               fprintf(stderr, "\t reason: out of memory\n");
	               break;
	           case MB_ERR_INTERNAL:
	               fprintf(stderr, "\t reason: internal error. Recompile libmoard in debug mode for more info \n");
	               break;
	           default:
                   fprintf(stderr, "\t MB_Create returned error code: %d (see libmboard docs for details)\n", rc);
                   break;
	       }

	       
       	   exit(rc);
	    }
	    #endif
	
	/* Initialise message sync composite params as NULL */
	FLAME_m_questionnaire_innovation_composite_params = NULL;

	    rc = MB_Create(&b_questionnaire_innovation, sizeof(m_questionnaire_innovation));
	    #ifdef ERRCHECK
	    if (rc != MB_SUCCESS)
	    {
	       fprintf(stderr, "ERROR: Could not create 'questionnaire_innovation' board\n");
	       switch(rc) {
	           case MB_ERR_INVALID:
	               fprintf(stderr, "\t reason: Invalid message size\n");
	               break;
	           case MB_ERR_MEMALLOC:
	               fprintf(stderr, "\t reason: out of memory\n");
	               break;
	           case MB_ERR_INTERNAL:
	               fprintf(stderr, "\t reason: internal error. Recompile libmoard in debug mode for more info \n");
	               break;
	           default:
                   fprintf(stderr, "\t MB_Create returned error code: %d (see libmboard docs for details)\n", rc);
                   break;
	       }

	       
       	   exit(rc);
	    }
	    #endif
	
	/* Initialise message sync composite params as NULL */
	FLAME_m_filled_out_questionnaire_product_innovation_composite_params = NULL;

	    rc = MB_Create(&b_filled_out_questionnaire_product_innovation, sizeof(m_filled_out_questionnaire_product_innovation));
	    #ifdef ERRCHECK
	    if (rc != MB_SUCCESS)
	    {
	       fprintf(stderr, "ERROR: Could not create 'filled_out_questionnaire_product_innovation' board\n");
	       switch(rc) {
	           case MB_ERR_INVALID:
	               fprintf(stderr, "\t reason: Invalid message size\n");
	               break;
	           case MB_ERR_MEMALLOC:
	               fprintf(stderr, "\t reason: out of memory\n");
	               break;
	           case MB_ERR_INTERNAL:
	               fprintf(stderr, "\t reason: internal error. Recompile libmoard in debug mode for more info \n");
	               break;
	           default:
                   fprintf(stderr, "\t MB_Create returned error code: %d (see libmboard docs for details)\n", rc);
                   break;
	       }

	       
       	   exit(rc);
	    }
	    #endif
	
	Firm_MR_01_state = init_Firm_state();

	Firm_MR_03_state = init_Firm_state();

	Firm_MR_02_state = init_Firm_state();

	Firm_MR_6_state = init_Firm_state();

	Firm_MR_5_state = init_Firm_state();

	Firm_MR_4a_state = init_Firm_state();

	Firm_MR_4_state = init_Firm_state();

	Firm_MR_3_state = init_Firm_state();

	Firm_MR_2_state = init_Firm_state();

	Firm_MR_1_state = init_Firm_state();

	Firm_MR_0_state = init_Firm_state();

	Firm_end_Firm_state = init_Firm_state();

	Firm_Firm_Send_Data_state = init_Firm_state();

	Firm_Firm_Start_Market_Research_Role_state = init_Firm_state();

	Firm_Firm_init_01_state = init_Firm_state();

	Firm_Firm_reset_state = init_Firm_state();

	Firm_Firm_initialize_state = init_Firm_state();

	Firm_start_Firm_state = init_Firm_state();

	Firm_10_state = init_Firm_state();

	Firm_09b_state = init_Firm_state();

	Firm_08_state = init_Firm_state();

	Firm_07_state = init_Firm_state();

	Firm_09a_state = init_Firm_state();

	Firm_06_state = init_Firm_state();

	Firm_03d_state = init_Firm_state();

	Firm_03c_state = init_Firm_state();

	Firm_09c_state = init_Firm_state();

	Firm_05b_state = init_Firm_state();

	Firm_05a_state = init_Firm_state();

	Firm_04_state = init_Firm_state();

	Firm_03ccc_state = init_Firm_state();

	Firm_03_state = init_Firm_state();

	Firm_04ccc_state = init_Firm_state();

	Firm_011_state = init_Firm_state();

	Firm_011a_state = init_Firm_state();

	Firm_16_state = init_Firm_state();

	Firm_15_state = init_Firm_state();

	Firm_Firm_End_Branches_state = init_Firm_state();

	Firm_Firm_bankruptcy_state_4_state = init_Firm_state();

	Firm_Firm_is_active_state = init_Firm_state();

	Firm_Firm_bankruptcy_state_1_state = init_Firm_state();

	Firm_Firm_bankruptcy_state_01_state = init_Firm_state();

	Firm_Firm_bankruptcy_state_0_state = init_Firm_state();

	Firm_Firm_not_active_state = init_Firm_state();

	Firm_005_state = init_Firm_state();

	Firm_Firm_End_External_Financing_state = init_Firm_state();

	Firm_Firm_resolve_financial_crisis_state = init_Firm_state();

	Firm_Firm_checks_financial_crisis_state = init_Firm_state();

	Firm_Firm_variables_reset2_state = init_Firm_state();

	Firm_Firm_bankruptcy_checked_state = init_Firm_state();

	Firm_02b_state = init_Firm_state();

	Firm_Firm_variables_reset_state = init_Firm_state();

	Firm_Firm_Bankruptcy_check_state = init_Firm_state();

	Firm_004_state = init_Firm_state();

	Firm_003_state = init_Firm_state();

	Firm_002_state = init_Firm_state();

	Firm_001_state = init_Firm_state();

	Firm_Firm_End_Public_Sector_Role_state = init_Firm_state();

	Firm_Firm_End_Credit_Role_state = init_Firm_state();

	Firm_Firm_Credit_02_state = init_Firm_state();

	Firm_Firm_Start_Credit_Role_state = init_Firm_state();

	Firm_Firm_checks_if_active_state = init_Firm_state();

	Firm_Firm_interest_state = init_Firm_state();

	Firm_Firm_Start_Financial_Management_Role_state = init_Firm_state();

	Firm_Firm_End_Financial_Management_Role_state = init_Firm_state();

	Firm_14_state = init_Firm_state();

	Firm_Firm_End_Seller_Role_state = init_Firm_state();

	Firm_Firm_Start_Seller_Role_state = init_Firm_state();

	Firm_12_state = init_Firm_state();

	Firm_11_state = init_Firm_state();

	Firm_11b_state = init_Firm_state();

	Firm_11a_state = init_Firm_state();

	Firm_Firm_End_Labour_Role_state = init_Firm_state();

	Firm_Firm_Start_Labour_Role_state = init_Firm_state();

	Firm_Firm_End_Financial_Management_state = init_Firm_state();

	Firm_02_state = init_Firm_state();

	Firm_00b_state = init_Firm_state();

	Firm_01_state = init_Firm_state();

	Firm_Firm_Start_Producer_Role_state = init_Firm_state();

	Household_HH_MR_2_state = init_Household_state();

	Household_HH_MR_1_state = init_Household_state();

	Household_end_Household_state = init_Household_state();

	Household_17_state = init_Household_state();

	Household_Household_Start_Market_Research_Role_state = init_Household_state();

	Household_Household_Start_Policy_Data_state = init_Household_state();

	Household_Pol_01_state = init_Household_state();

	Household_Household_Start_Yearly_Loop_Top_state = init_Household_state();

	Household_Household_initialize_state = init_Household_state();

	Household_start_Household_state = init_Household_state();

	Household_08b_state = init_Household_state();

	Household_08_state = init_Household_state();

	Household_07_state = init_Household_state();

	Household_06e_state = init_Household_state();

	Household_06d_state = init_Household_state();

	Household_06c_state = init_Household_state();

	Household_06b_state = init_Household_state();

	Household_05_state = init_Household_state();

	Household_04_state = init_Household_state();

	Household_03_state = init_Household_state();

	Household_02_state = init_Household_state();

	Household_06_state = init_Household_state();

	Household_01_state = init_Household_state();

	Household_01a_state = init_Household_state();

	Household_01d_state = init_Household_state();

	Household_Household_Start_Labour_Role_state = init_Household_state();

	Household_AFM_002_state = init_Household_state();

	Household_AFM_001_state = init_Household_state();

	Household_AFM_000_state = init_Household_state();

	Household_Household_Start_Financial_Market_Role_state = init_Household_state();

	Household_16_state = init_Household_state();

	Household_12_state = init_Household_state();

	Household_14_state = init_Household_state();

	Household_11_state = init_Household_state();

	Household_10_state = init_Household_state();

	Household_15_state = init_Household_state();

	Household_09_state = init_Household_state();

	Mall_Mall_initialize_state = init_Mall_state();

	Mall_start_Mall_state = init_Mall_state();

	Mall_end_Mall_state = init_Mall_state();

	Mall_06_state = init_Mall_state();

	Mall_05a_state = init_Mall_state();

	Mall_05_state = init_Mall_state();

	Mall_04_state = init_Mall_state();

	Mall_03_state = init_Mall_state();

	Mall_02_state = init_Mall_state();

	Mall_01_state = init_Mall_state();

	Mall_001_state = init_Mall_state();

	IGFirm_end_IGFirm_state = init_IGFirm_state();

	IGFirm_IGFirm_Send_Data_state = init_IGFirm_state();

	IGFirm_IGFirm_End_Branches_state = init_IGFirm_state();

	IGFirm_IGFirm_init_01_state = init_IGFirm_state();

	IGFirm_IGFirm_start_state = init_IGFirm_state();

	IGFirm_03_state = init_IGFirm_state();

	IGFirm_02_state = init_IGFirm_state();

	IGFirm_01_state = init_IGFirm_state();

	IGFirm_01a_state = init_IGFirm_state();

	IGFirm_Start_IGFirm_Productivity_state = init_IGFirm_state();

	IGFirm_07_state = init_IGFirm_state();

	IGFirm_06_state = init_IGFirm_state();

	IGFirm_004_state = init_IGFirm_state();

	IGFirm_003_state = init_IGFirm_state();

	IGFirm_002_state = init_IGFirm_state();

	IGFirm_IGFirm_End_Public_Sector_Role_state = init_IGFirm_state();

	IGFirm_05_state = init_IGFirm_state();

	IGFirm_IGFirm_End_Financial_Management_Role_state = init_IGFirm_state();

	IGFirm_IGFirm_Start_Financial_Management_Role_state = init_IGFirm_state();

	IGFirm_IGFirm_End_Financial_Management_state = init_IGFirm_state();

	IGFirm_01kk_state = init_IGFirm_state();

	IGFirm_IGFirm_is_active_state = init_IGFirm_state();

	IGFirm_IGFirm_checks_if_active_state = init_IGFirm_state();

	IGFirm_IGFirm_interest_state = init_IGFirm_state();

	Eurostat_start_Eurostat_state = init_Eurostat_state();

	Eurostat_end_Eurostat_state = init_Eurostat_state();

	Eurostat_Eurostat_Start_EndOfYear_Loop_state = init_Eurostat_state();

	Eurostat_05_state = init_Eurostat_state();

	Eurostat_04_state = init_Eurostat_state();

	Eurostat_Eurostat_Start_Quarterly_Loop_state = init_Eurostat_state();

	Eurostat_02_state = init_Eurostat_state();

	Eurostat_Eurostat_Start_Monthly_Loop_state = init_Eurostat_state();

	Eurostat_01_state = init_Eurostat_state();

	Eurostat_00_state = init_Eurostat_state();

	Bank_Bank_reset_state = init_Bank_state();

	Bank_start_Bank_state = init_Bank_state();

	Bank_end_Bank_state = init_Bank_state();

	Bank_Bank_08_state = init_Bank_state();

	Bank_Bank_07_state = init_Bank_state();

	Bank_Bank_06_state = init_Bank_state();

	Bank_Bank_05_state = init_Bank_state();

	Bank_Bank_04_state = init_Bank_state();

	Bank_Bank_03_state = init_Bank_state();

	Bank_Bank_021_state = init_Bank_state();

	Bank_Bank_02_state = init_Bank_state();

	Bank_Bank_01b_state = init_Bank_state();

	Bank_Bank_01_state = init_Bank_state();

	Bank_Bank_start_credit_market_role_state = init_Bank_state();

	Bank_Bank_update_policy_rate_state = init_Bank_state();

	Government_end_Government_state = init_Government_state();

	Government_Gov_Start_Yearly_Loop_state = init_Government_state();

	Government_08_state = init_Government_state();

	Government_07_state = init_Government_state();

	Government_Gov_bonds_decision_state = init_Government_state();

	Government_05a_state = init_Government_state();

	Government_06_state = init_Government_state();

	Government_Gov_Start_Monthly_Loop_state = init_Government_state();

	Government_04_state = init_Government_state();

	Government_03_state = init_Government_state();

	Government_02_state = init_Government_state();

	Government_End_Gov_Consumer_Role_state = init_Government_state();

	Government_Gov_Cons_5_state = init_Government_state();

	Government_Gov_Cons_4_state = init_Government_state();

	Government_Gov_Cons_3_state = init_Government_state();

	Government_Gov_Cons_2_state = init_Government_state();

	Government_Gov_Cons_1_state = init_Government_state();

	Government_003b_state = init_Government_state();

	Government_003a_state = init_Government_state();

	Government_003_state = init_Government_state();

	Government_002_state = init_Government_state();

	Government_Government_Start_Yearly_Loop_Top_state = init_Government_state();

	Government_001_state = init_Government_state();

	Government_Government_Start_Monthly_Loop_Top_state = init_Government_state();

	Government_start_Government_state = init_Government_state();

	Government_Start_Gov_Consumer_Role_state = init_Government_state();

	Government_Gov_Start_Bond_Market_state = init_Government_state();

	CentralBank_CB_financial_operations_end_state = init_CentralBank_state();

	CentralBank_CB_market_operations_state = init_CentralBank_state();

	CentralBank_CB_reset_state = init_CentralBank_state();

	CentralBank_start_Central_Bank_state = init_CentralBank_state();

	CentralBank_end_Central_Bank_state = init_CentralBank_state();

	CentralBank_00_state = init_CentralBank_state();

	ClearingHouse_end_Clearinghouse_state = init_ClearingHouse_state();

	ClearingHouse_AFM_05_state = init_ClearingHouse_state();

	ClearingHouse_AFM_04_state = init_ClearingHouse_state();

	ClearingHouse_AFM_03_state = init_ClearingHouse_state();

	ClearingHouse_AFM_02_state = init_ClearingHouse_state();

	ClearingHouse_AFM_01_state = init_ClearingHouse_state();

	ClearingHouse_AFM_00_state = init_ClearingHouse_state();

	ClearingHouse_start_Clearinghouse_state = init_ClearingHouse_state();

	temp_node_info = NULL;
	p_node_info = &temp_node_info;
}

/** \fn void initialise_unit_testing()
 * \brief Initialises framework for unit testing.
 */
void initialise_unit_testing()
{
	int rc;

	rc = MB_Env_Init();
	#ifdef ERRCHECK
	if (rc != MB_SUCCESS)
	{
	   fprintf(stderr, "ERROR: Failed to initialise Message Board environment\n");
	   switch(rc) {
	       case MB_ERR_MPI:
	           fprintf(stderr, "\t reason: MPI library not initialised\n");
	           break;
	       case MB_ERR_MEMALLOC:
	           fprintf(stderr, "\t reason: out of memory\n");
	           break;
	       default:
               fprintf(stderr, "\t MB_Env_Init returned error code: %d (see libmboard docs for details)\n", rc);
               break;
	       }

	       
       	   exit(rc);

	}
	#endif

	initialise_pointers();
}

FLAME_output * add_FLAME_output(FLAME_output ** outputs)
{
	FLAME_output * current;

	current = (FLAME_output *)malloc(sizeof(FLAME_output));
	CHECK_POINTER(current);
	current->next = *outputs;
	*outputs = current;

	current->type = -1;
	current->format = -1;
	current->location = NULL;
	current->period = -1;
	current->phase = -1;
	current->flag = 0;

	return current;
}

void free_FLAME_outputs(FLAME_output ** outputs)
{
	FLAME_output * current, * next;

	current = *outputs;
	while(current)
	{
		next = current->next;
		free(current->location);
		free(current);
		current = next;
	}
	*outputs = NULL;
}

/* add_location */
/** \fn void add_location(double point, location ** p_location)
 * \brief Adds a location in order into the location list.
 * \param point Position of an agent.
 * \param p_location Pointer Pointer to the location list.
 */
void add_location(double point, location ** p_location)
{
	location * current = *p_location;
	location * tmp = NULL;
	location * newlocation = NULL;
	int found = 0;

	while(found == 0)
	{
		if(current == NULL) found = 1;
		else if(point > current->point) found = 1;
		else
		{
			tmp = current;
			current = current->next;
		}
	}

	newlocation = (location *)malloc(sizeof(location));
	CHECK_POINTER(newlocation);
	if(tmp)
	{
		tmp->next = newlocation;
	}
	else
	{
		*p_location = newlocation;
	}

	newlocation->next = current;
	newlocation->point = point;
}

/* freelocations */
/** \fn void freelocations(location ** p_location)
 * \brief Free locations from the location list.
 * \param p_location Pointer Pointer to the location list.
 */
void freelocations(location ** p_location)
{
	location * head = *p_location;
	location * tmp = NULL;

	while(head)
	{
		tmp = head->next;
		free(head);
		head = tmp;
	}

	*p_location = NULL;
}

void init_int_static_array(/*@out@*/ int * array, int size)
{
	int i;

	for(i = 0; i < size; i++) array[i] = 0;
}

void init_float_static_array(/*@out@*/ float * array, int size)
{
	int i;

	for(i = 0; i < size; i++) array[i] = 0.0;
}

void init_double_static_array(/*@out@*/ double* array, int size)
{
	int i;

	for(i = 0; i < size; i++) array[i] = 0.0;
}

void init_char_static_array(/*@out@*/ char * array, int size)
{
	int i;

	for(i = 0; i < size; i++) array[i] = '\0';
}



void init_consumption_goods_offer(/*@out@*/ consumption_goods_offer * temp)
{
	(*temp).id = 0;
	(*temp).quality = 0.0;
	(*temp).price = 0.0;

}

void init_consumption_goods_offer_static_array(/*@out@*/ consumption_goods_offer * array, int size)
{
	int i;

	for(i = 0; i < size; i++) init_consumption_goods_offer(&array[i]);
}

void free_consumption_goods_offer(consumption_goods_offer * temp)
{

}

void free_consumption_goods_offer_static_array(consumption_goods_offer * array, int size)
{
	int i;

	for(i = 0; i < size; i++) free_consumption_goods_offer(&array[i]);
}

void copy_consumption_goods_offer(consumption_goods_offer * from, consumption_goods_offer * to)
{
	(*to).id = (*from).id;
	(*to).quality = (*from).quality;
	(*to).price = (*from).price;
}

void copy_consumption_goods_offer_static_array(consumption_goods_offer * from, consumption_goods_offer * to, int size)
{
	int i;

	for(i = 0; i < size; i++)
	{
		copy_consumption_goods_offer(&from[i], &to[i]);
	}
}


void init_estimators_linear_regression(/*@out@*/ estimators_linear_regression * temp)
{
	(*temp).mall_id = 0;
	(*temp).region_id = 0;
	(*temp).intercept = 0.0;
	(*temp).regressor = 0.0;
	(*temp).variance = 0.0;

}

void init_estimators_linear_regression_static_array(/*@out@*/ estimators_linear_regression * array, int size)
{
	int i;

	for(i = 0; i < size; i++) init_estimators_linear_regression(&array[i]);
}

void free_estimators_linear_regression(estimators_linear_regression * temp)
{

}

void free_estimators_linear_regression_static_array(estimators_linear_regression * array, int size)
{
	int i;

	for(i = 0; i < size; i++) free_estimators_linear_regression(&array[i]);
}

void copy_estimators_linear_regression(estimators_linear_regression * from, estimators_linear_regression * to)
{
	(*to).mall_id = (*from).mall_id;
	(*to).region_id = (*from).region_id;
	(*to).intercept = (*from).intercept;
	(*to).regressor = (*from).regressor;
	(*to).variance = (*from).variance;
}

void copy_estimators_linear_regression_static_array(estimators_linear_regression * from, estimators_linear_regression * to, int size)
{
	int i;

	for(i = 0; i < size; i++)
	{
		copy_estimators_linear_regression(&from[i], &to[i]);
	}
}


void init_consumption_request(/*@out@*/ consumption_request * temp)
{
	(*temp).worker_id = 0;
	(*temp).consumer_region_id = 0;
	(*temp).firm_id = 0;
	(*temp).quantity = 0.0;

}

void init_consumption_request_static_array(/*@out@*/ consumption_request * array, int size)
{
	int i;

	for(i = 0; i < size; i++) init_consumption_request(&array[i]);
}

void free_consumption_request(consumption_request * temp)
{

}

void free_consumption_request_static_array(consumption_request * array, int size)
{
	int i;

	for(i = 0; i < size; i++) free_consumption_request(&array[i]);
}

void copy_consumption_request(consumption_request * from, consumption_request * to)
{
	(*to).worker_id = (*from).worker_id;
	(*to).consumer_region_id = (*from).consumer_region_id;
	(*to).firm_id = (*from).firm_id;
	(*to).quantity = (*from).quantity;
}

void copy_consumption_request_static_array(consumption_request * from, consumption_request * to, int size)
{
	int i;

	for(i = 0; i < size; i++)
	{
		copy_consumption_request(&from[i], &to[i]);
	}
}


void init_mall_info(/*@out@*/ mall_info * temp)
{
	(*temp).mall_id = 0;
	(*temp).critical_stock = 0.0;
	(*temp).current_stock = 0.0;

}

void init_mall_info_static_array(/*@out@*/ mall_info * array, int size)
{
	int i;

	for(i = 0; i < size; i++) init_mall_info(&array[i]);
}

void free_mall_info(mall_info * temp)
{

}

void free_mall_info_static_array(mall_info * array, int size)
{
	int i;

	for(i = 0; i < size; i++) free_mall_info(&array[i]);
}

void copy_mall_info(mall_info * from, mall_info * to)
{
	(*to).mall_id = (*from).mall_id;
	(*to).critical_stock = (*from).critical_stock;
	(*to).current_stock = (*from).current_stock;
}

void copy_mall_info_static_array(mall_info * from, mall_info * to, int size)
{
	int i;

	for(i = 0; i < size; i++)
	{
		copy_mall_info(&from[i], &to[i]);
	}
}


void init_mall_quality_price_info(/*@out@*/ mall_quality_price_info * temp)
{
	(*temp).mall_id = 0;
	(*temp).firm_id = 0;
	(*temp).mall_region_id = 0;
	(*temp).quality = 0.0;
	(*temp).price = 0.0;
	(*temp).available = 0;

}

void init_mall_quality_price_info_static_array(/*@out@*/ mall_quality_price_info * array, int size)
{
	int i;

	for(i = 0; i < size; i++) init_mall_quality_price_info(&array[i]);
}

void free_mall_quality_price_info(mall_quality_price_info * temp)
{

}

void free_mall_quality_price_info_static_array(mall_quality_price_info * array, int size)
{
	int i;

	for(i = 0; i < size; i++) free_mall_quality_price_info(&array[i]);
}

void copy_mall_quality_price_info(mall_quality_price_info * from, mall_quality_price_info * to)
{
	(*to).mall_id = (*from).mall_id;
	(*to).firm_id = (*from).firm_id;
	(*to).mall_region_id = (*from).mall_region_id;
	(*to).quality = (*from).quality;
	(*to).price = (*from).price;
	(*to).available = (*from).available;
}

void copy_mall_quality_price_info_static_array(mall_quality_price_info * from, mall_quality_price_info * to, int size)
{
	int i;

	for(i = 0; i < size; i++)
	{
		copy_mall_quality_price_info(&from[i], &to[i]);
	}
}


void init_mall_stock(/*@out@*/ mall_stock * temp)
{
	(*temp).firm_id = 0;
	(*temp).region_id = 0;
	(*temp).stock = 0.0;
	(*temp).price = 0.0;
	(*temp).quality = 0.0;
	(*temp).previous_price = 0.0;

}

void init_mall_stock_static_array(/*@out@*/ mall_stock * array, int size)
{
	int i;

	for(i = 0; i < size; i++) init_mall_stock(&array[i]);
}

void free_mall_stock(mall_stock * temp)
{

}

void free_mall_stock_static_array(mall_stock * array, int size)
{
	int i;

	for(i = 0; i < size; i++) free_mall_stock(&array[i]);
}

void copy_mall_stock(mall_stock * from, mall_stock * to)
{
	(*to).firm_id = (*from).firm_id;
	(*to).region_id = (*from).region_id;
	(*to).stock = (*from).stock;
	(*to).price = (*from).price;
	(*to).quality = (*from).quality;
	(*to).previous_price = (*from).previous_price;
}

void copy_mall_stock_static_array(mall_stock * from, mall_stock * to, int size)
{
	int i;

	for(i = 0; i < size; i++)
	{
		copy_mall_stock(&from[i], &to[i]);
	}
}


void init_delivery_volume_per_mall(/*@out@*/ delivery_volume_per_mall * temp)
{
	(*temp).mall_id = 0;
	(*temp).quantity = 0.0;
	(*temp).price = 0.0;
	(*temp).quality = 0.0;

}

void init_delivery_volume_per_mall_static_array(/*@out@*/ delivery_volume_per_mall * array, int size)
{
	int i;

	for(i = 0; i < size; i++) init_delivery_volume_per_mall(&array[i]);
}

void free_delivery_volume_per_mall(delivery_volume_per_mall * temp)
{

}

void free_delivery_volume_per_mall_static_array(delivery_volume_per_mall * array, int size)
{
	int i;

	for(i = 0; i < size; i++) free_delivery_volume_per_mall(&array[i]);
}

void copy_delivery_volume_per_mall(delivery_volume_per_mall * from, delivery_volume_per_mall * to)
{
	(*to).mall_id = (*from).mall_id;
	(*to).quantity = (*from).quantity;
	(*to).price = (*from).price;
	(*to).quality = (*from).quality;
}

void copy_delivery_volume_per_mall_static_array(delivery_volume_per_mall * from, delivery_volume_per_mall * to, int size)
{
	int i;

	for(i = 0; i < size; i++)
	{
		copy_delivery_volume_per_mall(&from[i], &to[i]);
	}
}


void init_logit_firm_id(/*@out@*/ logit_firm_id * temp)
{
	(*temp).logit = 0.0;
	(*temp).firm_id = 0;

}

void init_logit_firm_id_static_array(/*@out@*/ logit_firm_id * array, int size)
{
	int i;

	for(i = 0; i < size; i++) init_logit_firm_id(&array[i]);
}

void free_logit_firm_id(logit_firm_id * temp)
{

}

void free_logit_firm_id_static_array(logit_firm_id * array, int size)
{
	int i;

	for(i = 0; i < size; i++) free_logit_firm_id(&array[i]);
}

void copy_logit_firm_id(logit_firm_id * from, logit_firm_id * to)
{
	(*to).logit = (*from).logit;
	(*to).firm_id = (*from).firm_id;
}

void copy_logit_firm_id_static_array(logit_firm_id * from, logit_firm_id * to, int size)
{
	int i;

	for(i = 0; i < size; i++)
	{
		copy_logit_firm_id(&from[i], &to[i]);
	}
}


void init_sales_in_mall(/*@out@*/ sales_in_mall * temp)
{
	(*temp).firm_id = 0;
	(*temp).sales = 0.0;

}

void init_sales_in_mall_static_array(/*@out@*/ sales_in_mall * array, int size)
{
	int i;

	for(i = 0; i < size; i++) init_sales_in_mall(&array[i]);
}

void free_sales_in_mall(sales_in_mall * temp)
{

}

void free_sales_in_mall_static_array(sales_in_mall * array, int size)
{
	int i;

	for(i = 0; i < size; i++) free_sales_in_mall(&array[i]);
}

void copy_sales_in_mall(sales_in_mall * from, sales_in_mall * to)
{
	(*to).firm_id = (*from).firm_id;
	(*to).sales = (*from).sales;
}

void copy_sales_in_mall_static_array(sales_in_mall * from, sales_in_mall * to, int size)
{
	int i;

	for(i = 0; i < size; i++)
	{
		copy_sales_in_mall(&from[i], &to[i]);
	}
}


void init_ordered_quantity(/*@out@*/ ordered_quantity * temp)
{
	(*temp).firm_id = 0;
	(*temp).quantity = 0.0;
	(*temp).price = 0.0;
	(*temp).quality = 0.0;

}

void init_ordered_quantity_static_array(/*@out@*/ ordered_quantity * array, int size)
{
	int i;

	for(i = 0; i < size; i++) init_ordered_quantity(&array[i]);
}

void free_ordered_quantity(ordered_quantity * temp)
{

}

void free_ordered_quantity_static_array(ordered_quantity * array, int size)
{
	int i;

	for(i = 0; i < size; i++) free_ordered_quantity(&array[i]);
}

void copy_ordered_quantity(ordered_quantity * from, ordered_quantity * to)
{
	(*to).firm_id = (*from).firm_id;
	(*to).quantity = (*from).quantity;
	(*to).price = (*from).price;
	(*to).quality = (*from).quality;
}

void copy_ordered_quantity_static_array(ordered_quantity * from, ordered_quantity * to, int size)
{
	int i;

	for(i = 0; i < size; i++)
	{
		copy_ordered_quantity(&from[i], &to[i]);
	}
}


void init_received_quantities(/*@out@*/ received_quantities * temp)
{
	(*temp).firm_id = 0;
	(*temp).quantity = 0.0;

}

void init_received_quantities_static_array(/*@out@*/ received_quantities * array, int size)
{
	int i;

	for(i = 0; i < size; i++) init_received_quantities(&array[i]);
}

void free_received_quantities(received_quantities * temp)
{

}

void free_received_quantities_static_array(received_quantities * array, int size)
{
	int i;

	for(i = 0; i < size; i++) free_received_quantities(&array[i]);
}

void copy_received_quantities(received_quantities * from, received_quantities * to)
{
	(*to).firm_id = (*from).firm_id;
	(*to).quantity = (*from).quantity;
}

void copy_received_quantities_static_array(received_quantities * from, received_quantities * to, int size)
{
	int i;

	for(i = 0; i < size; i++)
	{
		copy_received_quantities(&from[i], &to[i]);
	}
}


void init_sold_quantities_per_mall(/*@out@*/ sold_quantities_per_mall * temp)
{
	(*temp).mall_id = 0;
	(*temp).sold_quantity = 0.0;
	(*temp).stock_empty = 0;
	(*temp).estimated_demand = 0.0;

}

void init_sold_quantities_per_mall_static_array(/*@out@*/ sold_quantities_per_mall * array, int size)
{
	int i;

	for(i = 0; i < size; i++) init_sold_quantities_per_mall(&array[i]);
}

void free_sold_quantities_per_mall(sold_quantities_per_mall * temp)
{

}

void free_sold_quantities_per_mall_static_array(sold_quantities_per_mall * array, int size)
{
	int i;

	for(i = 0; i < size; i++) free_sold_quantities_per_mall(&array[i]);
}

void copy_sold_quantities_per_mall(sold_quantities_per_mall * from, sold_quantities_per_mall * to)
{
	(*to).mall_id = (*from).mall_id;
	(*to).sold_quantity = (*from).sold_quantity;
	(*to).stock_empty = (*from).stock_empty;
	(*to).estimated_demand = (*from).estimated_demand;
}

void copy_sold_quantities_per_mall_static_array(sold_quantities_per_mall * from, sold_quantities_per_mall * to, int size)
{
	int i;

	for(i = 0; i < size; i++)
	{
		copy_sold_quantities_per_mall(&from[i], &to[i]);
	}
}


void init_data_type_sales(/*@out@*/ data_type_sales * temp)
{
	(*temp).period = 0;
	(*temp).sales = 0.0;

}

void init_data_type_sales_static_array(/*@out@*/ data_type_sales * array, int size)
{
	int i;

	for(i = 0; i < size; i++) init_data_type_sales(&array[i]);
}

void free_data_type_sales(data_type_sales * temp)
{

}

void free_data_type_sales_static_array(data_type_sales * array, int size)
{
	int i;

	for(i = 0; i < size; i++) free_data_type_sales(&array[i]);
}

void copy_data_type_sales(data_type_sales * from, data_type_sales * to)
{
	(*to).period = (*from).period;
	(*to).sales = (*from).sales;
}

void copy_data_type_sales_static_array(data_type_sales * from, data_type_sales * to, int size)
{
	int i;

	for(i = 0; i < size; i++)
	{
		copy_data_type_sales(&from[i], &to[i]);
	}
}


void init_sales_statistics(/*@out@*/ sales_statistics * temp)
{
	(*temp).mall_id = 0;
	(*temp).region_id = 0;
	init_data_type_sales_array(&(*temp).sales);

}

void init_sales_statistics_static_array(/*@out@*/ sales_statistics * array, int size)
{
	int i;

	for(i = 0; i < size; i++) init_sales_statistics(&array[i]);
}

void free_sales_statistics(sales_statistics * temp)
{
	free_data_type_sales_array(&(*temp).sales);

}

void free_sales_statistics_static_array(sales_statistics * array, int size)
{
	int i;

	for(i = 0; i < size; i++) free_sales_statistics(&array[i]);
}

void copy_sales_statistics(sales_statistics * from, sales_statistics * to)
{
	(*to).mall_id = (*from).mall_id;
	(*to).region_id = (*from).region_id;
	copy_data_type_sales_array(&(*from).sales, &(*to).sales);
}

void copy_sales_statistics_static_array(sales_statistics * from, sales_statistics * to, int size)
{
	int i;

	for(i = 0; i < size; i++)
	{
		copy_sales_statistics(&from[i], &to[i]);
	}
}


void init_adt_technology_vintages(/*@out@*/ adt_technology_vintages * temp)
{
	(*temp).productivity = 0.0;
	(*temp).price = 0.0;
	(*temp).sum_effective_productivities = 0.0;

}

void init_adt_technology_vintages_static_array(/*@out@*/ adt_technology_vintages * array, int size)
{
	int i;

	for(i = 0; i < size; i++) init_adt_technology_vintages(&array[i]);
}

void free_adt_technology_vintages(adt_technology_vintages * temp)
{

}

void free_adt_technology_vintages_static_array(adt_technology_vintages * array, int size)
{
	int i;

	for(i = 0; i < size; i++) free_adt_technology_vintages(&array[i]);
}

void copy_adt_technology_vintages(adt_technology_vintages * from, adt_technology_vintages * to)
{
	(*to).productivity = (*from).productivity;
	(*to).price = (*from).price;
	(*to).sum_effective_productivities = (*from).sum_effective_productivities;
}

void copy_adt_technology_vintages_static_array(adt_technology_vintages * from, adt_technology_vintages * to, int size)
{
	int i;

	for(i = 0; i < size; i++)
	{
		copy_adt_technology_vintages(&from[i], &to[i]);
	}
}


void init_adt_capital_stock_vintages(/*@out@*/ adt_capital_stock_vintages * temp)
{
	(*temp).amount = 0.0;
	(*temp).productivity = 0.0;

}

void init_adt_capital_stock_vintages_static_array(/*@out@*/ adt_capital_stock_vintages * array, int size)
{
	int i;

	for(i = 0; i < size; i++) init_adt_capital_stock_vintages(&array[i]);
}

void free_adt_capital_stock_vintages(adt_capital_stock_vintages * temp)
{

}

void free_adt_capital_stock_vintages_static_array(adt_capital_stock_vintages * array, int size)
{
	int i;

	for(i = 0; i < size; i++) free_adt_capital_stock_vintages(&array[i]);
}

void copy_adt_capital_stock_vintages(adt_capital_stock_vintages * from, adt_capital_stock_vintages * to)
{
	(*to).amount = (*from).amount;
	(*to).productivity = (*from).productivity;
}

void copy_adt_capital_stock_vintages_static_array(adt_capital_stock_vintages * from, adt_capital_stock_vintages * to, int size)
{
	int i;

	for(i = 0; i < size; i++)
	{
		copy_adt_capital_stock_vintages(&from[i], &to[i]);
	}
}


void init_financing_capital(/*@out@*/ financing_capital * temp)
{
	(*temp).financing_per_month = 0.0;
	(*temp).nr_periods_before_repayment = 0;

}

void init_financing_capital_static_array(/*@out@*/ financing_capital * array, int size)
{
	int i;

	for(i = 0; i < size; i++) init_financing_capital(&array[i]);
}

void free_financing_capital(financing_capital * temp)
{

}

void free_financing_capital_static_array(financing_capital * array, int size)
{
	int i;

	for(i = 0; i < size; i++) free_financing_capital(&array[i]);
}

void copy_financing_capital(financing_capital * from, financing_capital * to)
{
	(*to).financing_per_month = (*from).financing_per_month;
	(*to).nr_periods_before_repayment = (*from).nr_periods_before_repayment;
}

void copy_financing_capital_static_array(financing_capital * from, financing_capital * to, int size)
{
	int i;

	for(i = 0; i < size; i++)
	{
		copy_financing_capital(&from[i], &to[i]);
	}
}


void init_temporary_sales_statistics(/*@out@*/ temporary_sales_statistics * temp)
{
	(*temp).mall_id = 0;
	(*temp).period = 0;
	(*temp).sales = 0.0;

}

void init_temporary_sales_statistics_static_array(/*@out@*/ temporary_sales_statistics * array, int size)
{
	int i;

	for(i = 0; i < size; i++) init_temporary_sales_statistics(&array[i]);
}

void free_temporary_sales_statistics(temporary_sales_statistics * temp)
{

}

void free_temporary_sales_statistics_static_array(temporary_sales_statistics * array, int size)
{
	int i;

	for(i = 0; i < size; i++) free_temporary_sales_statistics(&array[i]);
}

void copy_temporary_sales_statistics(temporary_sales_statistics * from, temporary_sales_statistics * to)
{
	(*to).mall_id = (*from).mall_id;
	(*to).period = (*from).period;
	(*to).sales = (*from).sales;
}

void copy_temporary_sales_statistics_static_array(temporary_sales_statistics * from, temporary_sales_statistics * to, int size)
{
	int i;

	for(i = 0; i < size; i++)
	{
		copy_temporary_sales_statistics(&from[i], &to[i]);
	}
}


void init_account_item(/*@out@*/ account_item * temp)
{
	(*temp).id = 0;
	(*temp).payment_account = 0.0;

}

void init_account_item_static_array(/*@out@*/ account_item * array, int size)
{
	int i;

	for(i = 0; i < size; i++) init_account_item(&array[i]);
}

void free_account_item(account_item * temp)
{

}

void free_account_item_static_array(account_item * array, int size)
{
	int i;

	for(i = 0; i < size; i++) free_account_item(&array[i]);
}

void copy_account_item(account_item * from, account_item * to)
{
	(*to).id = (*from).id;
	(*to).payment_account = (*from).payment_account;
}

void copy_account_item_static_array(account_item * from, account_item * to, int size)
{
	int i;

	for(i = 0; i < size; i++)
	{
		copy_account_item(&from[i], &to[i]);
	}
}


void init_debt_item(/*@out@*/ debt_item * temp)
{
	(*temp).bank_id = 0;
	(*temp).loan_value = 0.0;
	(*temp).interest_rate = 0.0;
	(*temp).installment_amount = 0.0;
	(*temp).var_per_installment = 0.0;
	(*temp).residual_var = 0.0;
	(*temp).bad_debt = 0.0;
	(*temp).nr_periods_before_repayment = 0;

}

void init_debt_item_static_array(/*@out@*/ debt_item * array, int size)
{
	int i;

	for(i = 0; i < size; i++) init_debt_item(&array[i]);
}

void free_debt_item(debt_item * temp)
{

}

void free_debt_item_static_array(debt_item * array, int size)
{
	int i;

	for(i = 0; i < size; i++) free_debt_item(&array[i]);
}

void copy_debt_item(debt_item * from, debt_item * to)
{
	(*to).bank_id = (*from).bank_id;
	(*to).loan_value = (*from).loan_value;
	(*to).interest_rate = (*from).interest_rate;
	(*to).installment_amount = (*from).installment_amount;
	(*to).var_per_installment = (*from).var_per_installment;
	(*to).residual_var = (*from).residual_var;
	(*to).bad_debt = (*from).bad_debt;
	(*to).nr_periods_before_repayment = (*from).nr_periods_before_repayment;
}

void copy_debt_item_static_array(debt_item * from, debt_item * to, int size)
{
	int i;

	for(i = 0; i < size; i++)
	{
		copy_debt_item(&from[i], &to[i]);
	}
}


void init_order(/*@out@*/ order * temp)
{
	(*temp).trader_id = 0;
	(*temp).value = 0.0;
	(*temp).quantity = 0;

}

void init_order_static_array(/*@out@*/ order * array, int size)
{
	int i;

	for(i = 0; i < size; i++) init_order(&array[i]);
}

void free_order(order * temp)
{

}

void free_order_static_array(order * array, int size)
{
	int i;

	for(i = 0; i < size; i++) free_order(&array[i]);
}

void copy_order(order * from, order * to)
{
	(*to).trader_id = (*from).trader_id;
	(*to).value = (*from).value;
	(*to).quantity = (*from).quantity;
}

void copy_order_static_array(order * from, order * to, int size)
{
	int i;

	for(i = 0; i < size; i++)
	{
		copy_order(&from[i], &to[i]);
	}
}


void init_index_adt(/*@out@*/ index_adt * temp)
{
	(*temp).price = 0.0;
	(*temp).weight = 0.0;
	(*temp).total_dividend = 0.0;
	(*temp).dividend_per_share = 0.0;
	(*temp).nr_shares = 0;
	(*temp).moving_avg_price = 0.0;
	init_double_array(&(*temp).price_history);

}

void init_index_adt_static_array(/*@out@*/ index_adt * array, int size)
{
	int i;

	for(i = 0; i < size; i++) init_index_adt(&array[i]);
}

void free_index_adt(index_adt * temp)
{
	free_double_array(&(*temp).price_history);

}

void free_index_adt_static_array(index_adt * array, int size)
{
	int i;

	for(i = 0; i < size; i++) free_index_adt(&array[i]);
}

void copy_index_adt(index_adt * from, index_adt * to)
{
	(*to).price = (*from).price;
	(*to).weight = (*from).weight;
	(*to).total_dividend = (*from).total_dividend;
	(*to).dividend_per_share = (*from).dividend_per_share;
	(*to).nr_shares = (*from).nr_shares;
	(*to).moving_avg_price = (*from).moving_avg_price;
	copy_double_array(&(*from).price_history, &(*to).price_history);
}

void copy_index_adt_static_array(index_adt * from, index_adt * to, int size)
{
	int i;

	for(i = 0; i < size; i++)
	{
		copy_index_adt(&from[i], &to[i]);
	}
}


void init_index_portfolio(/*@out@*/ index_portfolio * temp)
{
	(*temp).lastprice = 0.0;
	(*temp).units = 0;
	(*temp).moving_avg_price = 0.0;

}

void init_index_portfolio_static_array(/*@out@*/ index_portfolio * array, int size)
{
	int i;

	for(i = 0; i < size; i++) init_index_portfolio(&array[i]);
}

void free_index_portfolio(index_portfolio * temp)
{

}

void free_index_portfolio_static_array(index_portfolio * array, int size)
{
	int i;

	for(i = 0; i < size; i++) free_index_portfolio(&array[i]);
}

void copy_index_portfolio(index_portfolio * from, index_portfolio * to)
{
	(*to).lastprice = (*from).lastprice;
	(*to).units = (*from).units;
	(*to).moving_avg_price = (*from).moving_avg_price;
}

void copy_index_portfolio_static_array(index_portfolio * from, index_portfolio * to, int size)
{
	int i;

	for(i = 0; i < size; i++)
	{
		copy_index_portfolio(&from[i], &to[i]);
	}
}


void init_Belief(/*@out@*/ Belief * temp)
{
	(*temp).expected_dividend = 0.0;
	(*temp).expected_price = 0.0;
	(*temp).expected_return = 0.0;
	(*temp).expected_volatility = 0.0;
	(*temp).last_price = 0.0;
	(*temp).fraction_to_invest = 0.0;

}

void init_Belief_static_array(/*@out@*/ Belief * array, int size)
{
	int i;

	for(i = 0; i < size; i++) init_Belief(&array[i]);
}

void free_Belief(Belief * temp)
{

}

void free_Belief_static_array(Belief * array, int size)
{
	int i;

	for(i = 0; i < size; i++) free_Belief(&array[i]);
}

void copy_Belief(Belief * from, Belief * to)
{
	(*to).expected_dividend = (*from).expected_dividend;
	(*to).expected_price = (*from).expected_price;
	(*to).expected_return = (*from).expected_return;
	(*to).expected_volatility = (*from).expected_volatility;
	(*to).last_price = (*from).last_price;
	(*to).fraction_to_invest = (*from).fraction_to_invest;
}

void copy_Belief_static_array(Belief * from, Belief * to, int size)
{
	int i;

	for(i = 0; i < size; i++)
	{
		copy_Belief(&from[i], &to[i]);
	}
}


void init_capital_good_request(/*@out@*/ capital_good_request * temp)
{
	(*temp).firm_id = 0;
	(*temp).capital_good_order = 0.0;
	(*temp).vintage = 0;

}

void init_capital_good_request_static_array(/*@out@*/ capital_good_request * array, int size)
{
	int i;

	for(i = 0; i < size; i++) init_capital_good_request(&array[i]);
}

void free_capital_good_request(capital_good_request * temp)
{

}

void free_capital_good_request_static_array(capital_good_request * array, int size)
{
	int i;

	for(i = 0; i < size; i++) free_capital_good_request(&array[i]);
}

void copy_capital_good_request(capital_good_request * from, capital_good_request * to)
{
	(*to).firm_id = (*from).firm_id;
	(*to).capital_good_order = (*from).capital_good_order;
	(*to).vintage = (*from).vintage;
}

void copy_capital_good_request_static_array(capital_good_request * from, capital_good_request * to, int size)
{
	int i;

	for(i = 0; i < size; i++)
	{
		copy_capital_good_request(&from[i], &to[i]);
	}
}


void init_vintage(/*@out@*/ vintage * temp)
{
	(*temp).productivity = 0.0;
	(*temp).price = 0.0;
	(*temp).discounted_productivity = 0.0;
	(*temp).sales = 0.0;

}

void init_vintage_static_array(/*@out@*/ vintage * array, int size)
{
	int i;

	for(i = 0; i < size; i++) init_vintage(&array[i]);
}

void free_vintage(vintage * temp)
{

}

void free_vintage_static_array(vintage * array, int size)
{
	int i;

	for(i = 0; i < size; i++) free_vintage(&array[i]);
}

void copy_vintage(vintage * from, vintage * to)
{
	(*to).productivity = (*from).productivity;
	(*to).price = (*from).price;
	(*to).discounted_productivity = (*from).discounted_productivity;
	(*to).sales = (*from).sales;
}

void copy_vintage_static_array(vintage * from, vintage * to, int size)
{
	int i;

	for(i = 0; i < size; i++)
	{
		copy_vintage(&from[i], &to[i]);
	}
}


void init_adt_sales_per_vintage(/*@out@*/ adt_sales_per_vintage * temp)
{
	(*temp).productivity_of_vintage = 0.0;
	(*temp).sales = 0.0;
	(*temp).revenue = 0.0;

}

void init_adt_sales_per_vintage_static_array(/*@out@*/ adt_sales_per_vintage * array, int size)
{
	int i;

	for(i = 0; i < size; i++) init_adt_sales_per_vintage(&array[i]);
}

void free_adt_sales_per_vintage(adt_sales_per_vintage * temp)
{

}

void free_adt_sales_per_vintage_static_array(adt_sales_per_vintage * array, int size)
{
	int i;

	for(i = 0; i < size; i++) free_adt_sales_per_vintage(&array[i]);
}

void copy_adt_sales_per_vintage(adt_sales_per_vintage * from, adt_sales_per_vintage * to)
{
	(*to).productivity_of_vintage = (*from).productivity_of_vintage;
	(*to).sales = (*from).sales;
	(*to).revenue = (*from).revenue;
}

void copy_adt_sales_per_vintage_static_array(adt_sales_per_vintage * from, adt_sales_per_vintage * to, int size)
{
	int i;

	for(i = 0; i < size; i++)
	{
		copy_adt_sales_per_vintage(&from[i], &to[i]);
	}
}


void init_adt_list_adaptation_speed(/*@out@*/ adt_list_adaptation_speed * temp)
{
	(*temp).general_skill_level = 0;
	(*temp).adaptation_speed = 0.0;

}

void init_adt_list_adaptation_speed_static_array(/*@out@*/ adt_list_adaptation_speed * array, int size)
{
	int i;

	for(i = 0; i < size; i++) init_adt_list_adaptation_speed(&array[i]);
}

void free_adt_list_adaptation_speed(adt_list_adaptation_speed * temp)
{

}

void free_adt_list_adaptation_speed_static_array(adt_list_adaptation_speed * array, int size)
{
	int i;

	for(i = 0; i < size; i++) free_adt_list_adaptation_speed(&array[i]);
}

void copy_adt_list_adaptation_speed(adt_list_adaptation_speed * from, adt_list_adaptation_speed * to)
{
	(*to).general_skill_level = (*from).general_skill_level;
	(*to).adaptation_speed = (*from).adaptation_speed;
}

void copy_adt_list_adaptation_speed_static_array(adt_list_adaptation_speed * from, adt_list_adaptation_speed * to, int size)
{
	int i;

	for(i = 0; i < size; i++)
	{
		copy_adt_list_adaptation_speed(&from[i], &to[i]);
	}
}


void init_employee(/*@out@*/ employee * temp)
{
	(*temp).id = 0;
	(*temp).region_id = 0;
	(*temp).wage = 0.0;
	(*temp).general_skill = 0;
	(*temp).specific_skill = 0.0;
	(*temp).subsidy_pct = 0.0;

}

void init_employee_static_array(/*@out@*/ employee * array, int size)
{
	int i;

	for(i = 0; i < size; i++) init_employee(&array[i]);
}

void free_employee(employee * temp)
{

}

void free_employee_static_array(employee * array, int size)
{
	int i;

	for(i = 0; i < size; i++) free_employee(&array[i]);
}

void copy_employee(employee * from, employee * to)
{
	(*to).id = (*from).id;
	(*to).region_id = (*from).region_id;
	(*to).wage = (*from).wage;
	(*to).general_skill = (*from).general_skill;
	(*to).specific_skill = (*from).specific_skill;
	(*to).subsidy_pct = (*from).subsidy_pct;
}

void copy_employee_static_array(employee * from, employee * to, int size)
{
	int i;

	for(i = 0; i < size; i++)
	{
		copy_employee(&from[i], &to[i]);
	}
}


void init_vacancy(/*@out@*/ vacancy * temp)
{
	(*temp).firm_id = 0;
	(*temp).region_id = 0;
	(*temp).wage_offer = 0.0;
	(*temp).job_type = 0;

}

void init_vacancy_static_array(/*@out@*/ vacancy * array, int size)
{
	int i;

	for(i = 0; i < size; i++) init_vacancy(&array[i]);
}

void free_vacancy(vacancy * temp)
{

}

void free_vacancy_static_array(vacancy * array, int size)
{
	int i;

	for(i = 0; i < size; i++) free_vacancy(&array[i]);
}

void copy_vacancy(vacancy * from, vacancy * to)
{
	(*to).firm_id = (*from).firm_id;
	(*to).region_id = (*from).region_id;
	(*to).wage_offer = (*from).wage_offer;
	(*to).job_type = (*from).job_type;
}

void copy_vacancy_static_array(vacancy * from, vacancy * to, int size)
{
	int i;

	for(i = 0; i < size; i++)
	{
		copy_vacancy(&from[i], &to[i]);
	}
}


void init_job_application(/*@out@*/ job_application * temp)
{
	(*temp).worker_id = 0;
	(*temp).region_id = 0;
	(*temp).general_skill = 0;
	(*temp).specific_skill = 0.0;
	(*temp).wage_offer = 0.0;
	(*temp).job_type = 0;

}

void init_job_application_static_array(/*@out@*/ job_application * array, int size)
{
	int i;

	for(i = 0; i < size; i++) init_job_application(&array[i]);
}

void free_job_application(job_application * temp)
{

}

void free_job_application_static_array(job_application * array, int size)
{
	int i;

	for(i = 0; i < size; i++) free_job_application(&array[i]);
}

void copy_job_application(job_application * from, job_application * to)
{
	(*to).worker_id = (*from).worker_id;
	(*to).region_id = (*from).region_id;
	(*to).general_skill = (*from).general_skill;
	(*to).specific_skill = (*from).specific_skill;
	(*to).wage_offer = (*from).wage_offer;
	(*to).job_type = (*from).job_type;
}

void copy_job_application_static_array(job_application * from, job_application * to, int size)
{
	int i;

	for(i = 0; i < size; i++)
	{
		copy_job_application(&from[i], &to[i]);
	}
}


void init_job_offer(/*@out@*/ job_offer * temp)
{
	(*temp).firm_id = 0;
	(*temp).region_id = 0;
	(*temp).wage_offer = 0.0;
	(*temp).job_type = 0;

}

void init_job_offer_static_array(/*@out@*/ job_offer * array, int size)
{
	int i;

	for(i = 0; i < size; i++) init_job_offer(&array[i]);
}

void free_job_offer(job_offer * temp)
{

}

void free_job_offer_static_array(job_offer * array, int size)
{
	int i;

	for(i = 0; i < size; i++) free_job_offer(&array[i]);
}

void copy_job_offer(job_offer * from, job_offer * to)
{
	(*to).firm_id = (*from).firm_id;
	(*to).region_id = (*from).region_id;
	(*to).wage_offer = (*from).wage_offer;
	(*to).job_type = (*from).job_type;
}

void copy_job_offer_static_array(job_offer * from, job_offer * to, int size)
{
	int i;

	for(i = 0; i < size; i++)
	{
		copy_job_offer(&from[i], &to[i]);
	}
}


void init_logit(/*@out@*/ logit * temp)
{
	(*temp).logit_value = 0.0;
	(*temp).worker_id = 0;
	(*temp).general_skill = 0;
	(*temp).wage_offer = 0.0;
	(*temp).job_type = 0;

}

void init_logit_static_array(/*@out@*/ logit * array, int size)
{
	int i;

	for(i = 0; i < size; i++) init_logit(&array[i]);
}

void free_logit(logit * temp)
{

}

void free_logit_static_array(logit * array, int size)
{
	int i;

	for(i = 0; i < size; i++) free_logit(&array[i]);
}

void copy_logit(logit * from, logit * to)
{
	(*to).logit_value = (*from).logit_value;
	(*to).worker_id = (*from).worker_id;
	(*to).general_skill = (*from).general_skill;
	(*to).wage_offer = (*from).wage_offer;
	(*to).job_type = (*from).job_type;
}

void copy_logit_static_array(logit * from, logit * to, int size)
{
	int i;

	for(i = 0; i < size; i++)
	{
		copy_logit(&from[i], &to[i]);
	}
}


void init_adt_skill_distribution(/*@out@*/ adt_skill_distribution * temp)
{
	(*temp).general_skill_group = 0;
	(*temp).percentage = 0.0;

}

void init_adt_skill_distribution_static_array(/*@out@*/ adt_skill_distribution * array, int size)
{
	int i;

	for(i = 0; i < size; i++) init_adt_skill_distribution(&array[i]);
}

void free_adt_skill_distribution(adt_skill_distribution * temp)
{

}

void free_adt_skill_distribution_static_array(adt_skill_distribution * array, int size)
{
	int i;

	for(i = 0; i < size; i++) free_adt_skill_distribution(&array[i]);
}

void copy_adt_skill_distribution(adt_skill_distribution * from, adt_skill_distribution * to)
{
	(*to).general_skill_group = (*from).general_skill_group;
	(*to).percentage = (*from).percentage;
}

void copy_adt_skill_distribution_static_array(adt_skill_distribution * from, adt_skill_distribution * to, int size)
{
	int i;

	for(i = 0; i < size; i++)
	{
		copy_adt_skill_distribution(&from[i], &to[i]);
	}
}


void init_adt_actual_skill_distribution_with_ids(/*@out@*/ adt_actual_skill_distribution_with_ids * temp)
{
	(*temp).general_skill_group = 0;
	init_int_array(&(*temp).id_list);

}

void init_adt_actual_skill_distribution_with_ids_static_array(/*@out@*/ adt_actual_skill_distribution_with_ids * array, int size)
{
	int i;

	for(i = 0; i < size; i++) init_adt_actual_skill_distribution_with_ids(&array[i]);
}

void free_adt_actual_skill_distribution_with_ids(adt_actual_skill_distribution_with_ids * temp)
{
	free_int_array(&(*temp).id_list);

}

void free_adt_actual_skill_distribution_with_ids_static_array(adt_actual_skill_distribution_with_ids * array, int size)
{
	int i;

	for(i = 0; i < size; i++) free_adt_actual_skill_distribution_with_ids(&array[i]);
}

void copy_adt_actual_skill_distribution_with_ids(adt_actual_skill_distribution_with_ids * from, adt_actual_skill_distribution_with_ids * to)
{
	(*to).general_skill_group = (*from).general_skill_group;
	copy_int_array(&(*from).id_list, &(*to).id_list);
}

void copy_adt_actual_skill_distribution_with_ids_static_array(adt_actual_skill_distribution_with_ids * from, adt_actual_skill_distribution_with_ids * to, int size)
{
	int i;

	for(i = 0; i < size; i++)
	{
		copy_adt_actual_skill_distribution_with_ids(&from[i], &to[i]);
	}
}


void init_adt_gov_inflows_outflows(/*@out@*/ adt_gov_inflows_outflows * temp)
{
	(*temp).inflows = 0.0;
	(*temp).outflows = 0.0;
	(*temp).tax_basis = 0.0;

}

void init_adt_gov_inflows_outflows_static_array(/*@out@*/ adt_gov_inflows_outflows * array, int size)
{
	int i;

	for(i = 0; i < size; i++) init_adt_gov_inflows_outflows(&array[i]);
}

void free_adt_gov_inflows_outflows(adt_gov_inflows_outflows * temp)
{

}

void free_adt_gov_inflows_outflows_static_array(adt_gov_inflows_outflows * array, int size)
{
	int i;

	for(i = 0; i < size; i++) free_adt_gov_inflows_outflows(&array[i]);
}

void copy_adt_gov_inflows_outflows(adt_gov_inflows_outflows * from, adt_gov_inflows_outflows * to)
{
	(*to).inflows = (*from).inflows;
	(*to).outflows = (*from).outflows;
	(*to).tax_basis = (*from).tax_basis;
}

void copy_adt_gov_inflows_outflows_static_array(adt_gov_inflows_outflows * from, adt_gov_inflows_outflows * to, int size)
{
	int i;

	for(i = 0; i < size; i++)
	{
		copy_adt_gov_inflows_outflows(&from[i], &to[i]);
	}
}


void init_household_data(/*@out@*/ household_data * temp)
{
	(*temp).region_id = 0;
	(*temp).no_households = 0;
	(*temp).no_households_skill_1 = 0;
	(*temp).no_households_skill_2 = 0;
	(*temp).no_households_skill_3 = 0;
	(*temp).no_households_skill_4 = 0;
	(*temp).no_households_skill_5 = 0;
	(*temp).employed = 0;
	(*temp).employed_skill_1 = 0;
	(*temp).employed_skill_2 = 0;
	(*temp).employed_skill_3 = 0;
	(*temp).employed_skill_4 = 0;
	(*temp).employed_skill_5 = 0;
	(*temp).unemployed = 0;
	(*temp).unemployment_rate = 0.0;
	(*temp).unemployment_rate_skill_1 = 0.0;
	(*temp).unemployment_rate_skill_2 = 0.0;
	(*temp).unemployment_rate_skill_3 = 0.0;
	(*temp).unemployment_rate_skill_4 = 0.0;
	(*temp).unemployment_rate_skill_5 = 0.0;
	(*temp).consumption_budget = 0.0;
	(*temp).average_wage = 0.0;
	(*temp).average_wage_skill_1 = 0.0;
	(*temp).average_wage_skill_2 = 0.0;
	(*temp).average_wage_skill_3 = 0.0;
	(*temp).average_wage_skill_4 = 0.0;
	(*temp).average_wage_skill_5 = 0.0;
	(*temp).average_s_skill = 0.0;
	(*temp).average_s_skill_1 = 0.0;
	(*temp).average_s_skill_2 = 0.0;
	(*temp).average_s_skill_3 = 0.0;
	(*temp).average_s_skill_4 = 0.0;
	(*temp).average_s_skill_5 = 0.0;

}

void init_household_data_static_array(/*@out@*/ household_data * array, int size)
{
	int i;

	for(i = 0; i < size; i++) init_household_data(&array[i]);
}

void free_household_data(household_data * temp)
{

}

void free_household_data_static_array(household_data * array, int size)
{
	int i;

	for(i = 0; i < size; i++) free_household_data(&array[i]);
}

void copy_household_data(household_data * from, household_data * to)
{
	(*to).region_id = (*from).region_id;
	(*to).no_households = (*from).no_households;
	(*to).no_households_skill_1 = (*from).no_households_skill_1;
	(*to).no_households_skill_2 = (*from).no_households_skill_2;
	(*to).no_households_skill_3 = (*from).no_households_skill_3;
	(*to).no_households_skill_4 = (*from).no_households_skill_4;
	(*to).no_households_skill_5 = (*from).no_households_skill_5;
	(*to).employed = (*from).employed;
	(*to).employed_skill_1 = (*from).employed_skill_1;
	(*to).employed_skill_2 = (*from).employed_skill_2;
	(*to).employed_skill_3 = (*from).employed_skill_3;
	(*to).employed_skill_4 = (*from).employed_skill_4;
	(*to).employed_skill_5 = (*from).employed_skill_5;
	(*to).unemployed = (*from).unemployed;
	(*to).unemployment_rate = (*from).unemployment_rate;
	(*to).unemployment_rate_skill_1 = (*from).unemployment_rate_skill_1;
	(*to).unemployment_rate_skill_2 = (*from).unemployment_rate_skill_2;
	(*to).unemployment_rate_skill_3 = (*from).unemployment_rate_skill_3;
	(*to).unemployment_rate_skill_4 = (*from).unemployment_rate_skill_4;
	(*to).unemployment_rate_skill_5 = (*from).unemployment_rate_skill_5;
	(*to).consumption_budget = (*from).consumption_budget;
	(*to).average_wage = (*from).average_wage;
	(*to).average_wage_skill_1 = (*from).average_wage_skill_1;
	(*to).average_wage_skill_2 = (*from).average_wage_skill_2;
	(*to).average_wage_skill_3 = (*from).average_wage_skill_3;
	(*to).average_wage_skill_4 = (*from).average_wage_skill_4;
	(*to).average_wage_skill_5 = (*from).average_wage_skill_5;
	(*to).average_s_skill = (*from).average_s_skill;
	(*to).average_s_skill_1 = (*from).average_s_skill_1;
	(*to).average_s_skill_2 = (*from).average_s_skill_2;
	(*to).average_s_skill_3 = (*from).average_s_skill_3;
	(*to).average_s_skill_4 = (*from).average_s_skill_4;
	(*to).average_s_skill_5 = (*from).average_s_skill_5;
}

void copy_household_data_static_array(household_data * from, household_data * to, int size)
{
	int i;

	for(i = 0; i < size; i++)
	{
		copy_household_data(&from[i], &to[i]);
	}
}


void init_price_quality_pair(/*@out@*/ price_quality_pair * temp)
{
	(*temp).region_id = 0;
	(*temp).price = 0.0;
	(*temp).quality = 0.0;

}

void init_price_quality_pair_static_array(/*@out@*/ price_quality_pair * array, int size)
{
	int i;

	for(i = 0; i < size; i++) init_price_quality_pair(&array[i]);
}

void free_price_quality_pair(price_quality_pair * temp)
{

}

void free_price_quality_pair_static_array(price_quality_pair * array, int size)
{
	int i;

	for(i = 0; i < size; i++) free_price_quality_pair(&array[i]);
}

void copy_price_quality_pair(price_quality_pair * from, price_quality_pair * to)
{
	(*to).region_id = (*from).region_id;
	(*to).price = (*from).price;
	(*to).quality = (*from).quality;
}

void copy_price_quality_pair_static_array(price_quality_pair * from, price_quality_pair * to, int size)
{
	int i;

	for(i = 0; i < size; i++)
	{
		copy_price_quality_pair(&from[i], &to[i]);
	}
}


void init_firm_data(/*@out@*/ firm_data * temp)
{
	(*temp).region_id = 0;
	(*temp).no_firms = 0;
	(*temp).no_active_firms = 0;
	(*temp).vacancies = 0;
	(*temp).posted_vacancies = 0;
	(*temp).employees = 0;
	(*temp).employees_skill_1 = 0;
	(*temp).employees_skill_2 = 0;
	(*temp).employees_skill_3 = 0;
	(*temp).employees_skill_4 = 0;
	(*temp).employees_skill_5 = 0;
	(*temp).average_wage = 0.0;
	(*temp).average_wage_skill_1 = 0.0;
	(*temp).average_wage_skill_2 = 0.0;
	(*temp).average_wage_skill_3 = 0.0;
	(*temp).average_wage_skill_4 = 0.0;
	(*temp).average_wage_skill_5 = 0.0;
	(*temp).average_s_skill = 0.0;
	(*temp).average_s_skill_1 = 0.0;
	(*temp).average_s_skill_2 = 0.0;
	(*temp).average_s_skill_3 = 0.0;
	(*temp).average_s_skill_4 = 0.0;
	(*temp).average_s_skill_5 = 0.0;
	(*temp).labour_productivity = 0.0;
	(*temp).total_earnings = 0.0;
	(*temp).total_debt = 0.0;
	(*temp).total_assets = 0.0;
	(*temp).total_equity = 0.0;
	(*temp).average_debt_earnings_ratio = 0.0;
	(*temp).average_debt_equity_ratio = 0.0;
	(*temp).labour_share_ratio = 0.0;
	(*temp).monthly_sold_quantity = 0.0;
	(*temp).monthly_output = 0.0;
	(*temp).monthly_revenue = 0.0;
	(*temp).monthly_planned_output = 0.0;
	(*temp).monthly_investment_value = 0.0;
	(*temp).investment_gdp_ratio = 0.0;
	(*temp).gdp = 0.0;
	(*temp).cpi = 0.0;
	(*temp).cpi_last_month = 0.0;
	(*temp).no_firm_births = 0;
	(*temp).no_firm_deaths = 0;
	(*temp).productivity_progress = 0.0;
	(*temp).productivity = 0.0;
	(*temp).wage_offer = 0.0;
	(*temp).technology = 0.0;

}

void init_firm_data_static_array(/*@out@*/ firm_data * array, int size)
{
	int i;

	for(i = 0; i < size; i++) init_firm_data(&array[i]);
}

void free_firm_data(firm_data * temp)
{

}

void free_firm_data_static_array(firm_data * array, int size)
{
	int i;

	for(i = 0; i < size; i++) free_firm_data(&array[i]);
}

void copy_firm_data(firm_data * from, firm_data * to)
{
	(*to).region_id = (*from).region_id;
	(*to).no_firms = (*from).no_firms;
	(*to).no_active_firms = (*from).no_active_firms;
	(*to).vacancies = (*from).vacancies;
	(*to).posted_vacancies = (*from).posted_vacancies;
	(*to).employees = (*from).employees;
	(*to).employees_skill_1 = (*from).employees_skill_1;
	(*to).employees_skill_2 = (*from).employees_skill_2;
	(*to).employees_skill_3 = (*from).employees_skill_3;
	(*to).employees_skill_4 = (*from).employees_skill_4;
	(*to).employees_skill_5 = (*from).employees_skill_5;
	(*to).average_wage = (*from).average_wage;
	(*to).average_wage_skill_1 = (*from).average_wage_skill_1;
	(*to).average_wage_skill_2 = (*from).average_wage_skill_2;
	(*to).average_wage_skill_3 = (*from).average_wage_skill_3;
	(*to).average_wage_skill_4 = (*from).average_wage_skill_4;
	(*to).average_wage_skill_5 = (*from).average_wage_skill_5;
	(*to).average_s_skill = (*from).average_s_skill;
	(*to).average_s_skill_1 = (*from).average_s_skill_1;
	(*to).average_s_skill_2 = (*from).average_s_skill_2;
	(*to).average_s_skill_3 = (*from).average_s_skill_3;
	(*to).average_s_skill_4 = (*from).average_s_skill_4;
	(*to).average_s_skill_5 = (*from).average_s_skill_5;
	(*to).labour_productivity = (*from).labour_productivity;
	(*to).total_earnings = (*from).total_earnings;
	(*to).total_debt = (*from).total_debt;
	(*to).total_assets = (*from).total_assets;
	(*to).total_equity = (*from).total_equity;
	(*to).average_debt_earnings_ratio = (*from).average_debt_earnings_ratio;
	(*to).average_debt_equity_ratio = (*from).average_debt_equity_ratio;
	(*to).labour_share_ratio = (*from).labour_share_ratio;
	(*to).monthly_sold_quantity = (*from).monthly_sold_quantity;
	(*to).monthly_output = (*from).monthly_output;
	(*to).monthly_revenue = (*from).monthly_revenue;
	(*to).monthly_planned_output = (*from).monthly_planned_output;
	(*to).monthly_investment_value = (*from).monthly_investment_value;
	(*to).investment_gdp_ratio = (*from).investment_gdp_ratio;
	(*to).gdp = (*from).gdp;
	(*to).cpi = (*from).cpi;
	(*to).cpi_last_month = (*from).cpi_last_month;
	(*to).no_firm_births = (*from).no_firm_births;
	(*to).no_firm_deaths = (*from).no_firm_deaths;
	(*to).productivity_progress = (*from).productivity_progress;
	(*to).productivity = (*from).productivity;
	(*to).wage_offer = (*from).wage_offer;
	(*to).technology = (*from).technology;
}

void copy_firm_data_static_array(firm_data * from, firm_data * to, int size)
{
	int i;

	for(i = 0; i < size; i++)
	{
		copy_firm_data(&from[i], &to[i]);
	}
}


void init_government_data(/*@out@*/ government_data * temp)
{
	(*temp).region_id = 0;
	(*temp).consumption_expenditures = 0.0;

}

void init_government_data_static_array(/*@out@*/ government_data * array, int size)
{
	int i;

	for(i = 0; i < size; i++) init_government_data(&array[i]);
}

void free_government_data(government_data * temp)
{

}

void free_government_data_static_array(government_data * array, int size)
{
	int i;

	for(i = 0; i < size; i++) free_government_data(&array[i]);
}

void copy_government_data(government_data * from, government_data * to)
{
	(*to).region_id = (*from).region_id;
	(*to).consumption_expenditures = (*from).consumption_expenditures;
}

void copy_government_data_static_array(government_data * from, government_data * to, int size)
{
	int i;

	for(i = 0; i < size; i++)
	{
		copy_government_data(&from[i], &to[i]);
	}
}


void init_region_data_item(/*@out@*/ region_data_item * temp)
{
	(*temp).cpi = 0.0;
	(*temp).cpi_last_month = 0.0;
	(*temp).gdp = 0.0;
	(*temp).output = 0.0;
	(*temp).employment = 0;
	(*temp).unemployment_rate = 0.0;
	(*temp).unemployment_rate_skill_1 = 0.0;
	(*temp).unemployment_rate_skill_2 = 0.0;
	(*temp).unemployment_rate_skill_3 = 0.0;
	(*temp).unemployment_rate_skill_4 = 0.0;
	(*temp).unemployment_rate_skill_5 = 0.0;
	(*temp).average_wage = 0.0;
	(*temp).no_firms = 0;
	(*temp).no_active_firms = 0;
	(*temp).no_firm_births = 0;
	(*temp).no_firm_deaths = 0;
	(*temp).investment_value = 0.0;

}

void init_region_data_item_static_array(/*@out@*/ region_data_item * array, int size)
{
	int i;

	for(i = 0; i < size; i++) init_region_data_item(&array[i]);
}

void free_region_data_item(region_data_item * temp)
{

}

void free_region_data_item_static_array(region_data_item * array, int size)
{
	int i;

	for(i = 0; i < size; i++) free_region_data_item(&array[i]);
}

void copy_region_data_item(region_data_item * from, region_data_item * to)
{
	(*to).cpi = (*from).cpi;
	(*to).cpi_last_month = (*from).cpi_last_month;
	(*to).gdp = (*from).gdp;
	(*to).output = (*from).output;
	(*to).employment = (*from).employment;
	(*to).unemployment_rate = (*from).unemployment_rate;
	(*to).unemployment_rate_skill_1 = (*from).unemployment_rate_skill_1;
	(*to).unemployment_rate_skill_2 = (*from).unemployment_rate_skill_2;
	(*to).unemployment_rate_skill_3 = (*from).unemployment_rate_skill_3;
	(*to).unemployment_rate_skill_4 = (*from).unemployment_rate_skill_4;
	(*to).unemployment_rate_skill_5 = (*from).unemployment_rate_skill_5;
	(*to).average_wage = (*from).average_wage;
	(*to).no_firms = (*from).no_firms;
	(*to).no_active_firms = (*from).no_active_firms;
	(*to).no_firm_births = (*from).no_firm_births;
	(*to).no_firm_deaths = (*from).no_firm_deaths;
	(*to).investment_value = (*from).investment_value;
}

void copy_region_data_item_static_array(region_data_item * from, region_data_item * to, int size)
{
	int i;

	for(i = 0; i < size; i++)
	{
		copy_region_data_item(&from[i], &to[i]);
	}
}


void init_history_item(/*@out@*/ history_item * temp)
{
	(*temp).cpi = 0.0;
	(*temp).gdp = 0.0;
	(*temp).output = 0.0;
	(*temp).employment = 0;
	(*temp).unemployment_rate = 0.0;
	(*temp).unemployment_rate_skill_1 = 0.0;
	(*temp).unemployment_rate_skill_2 = 0.0;
	(*temp).unemployment_rate_skill_3 = 0.0;
	(*temp).unemployment_rate_skill_4 = 0.0;
	(*temp).unemployment_rate_skill_5 = 0.0;
	(*temp).average_wage = 0.0;
	(*temp).no_firms = 0;
	(*temp).no_active_firms = 0;
	(*temp).no_firm_births = 0;
	(*temp).no_firm_deaths = 0;
	(*temp).investment_value = 0.0;
	init_region_data_item_array(&(*temp).region_data);

}

void init_history_item_static_array(/*@out@*/ history_item * array, int size)
{
	int i;

	for(i = 0; i < size; i++) init_history_item(&array[i]);
}

void free_history_item(history_item * temp)
{
	free_region_data_item_array(&(*temp).region_data);

}

void free_history_item_static_array(history_item * array, int size)
{
	int i;

	for(i = 0; i < size; i++) free_history_item(&array[i]);
}

void copy_history_item(history_item * from, history_item * to)
{
	(*to).cpi = (*from).cpi;
	(*to).gdp = (*from).gdp;
	(*to).output = (*from).output;
	(*to).employment = (*from).employment;
	(*to).unemployment_rate = (*from).unemployment_rate;
	(*to).unemployment_rate_skill_1 = (*from).unemployment_rate_skill_1;
	(*to).unemployment_rate_skill_2 = (*from).unemployment_rate_skill_2;
	(*to).unemployment_rate_skill_3 = (*from).unemployment_rate_skill_3;
	(*to).unemployment_rate_skill_4 = (*from).unemployment_rate_skill_4;
	(*to).unemployment_rate_skill_5 = (*from).unemployment_rate_skill_5;
	(*to).average_wage = (*from).average_wage;
	(*to).no_firms = (*from).no_firms;
	(*to).no_active_firms = (*from).no_active_firms;
	(*to).no_firm_births = (*from).no_firm_births;
	(*to).no_firm_deaths = (*from).no_firm_deaths;
	(*to).investment_value = (*from).investment_value;
	copy_region_data_item_array(&(*from).region_data, &(*to).region_data);
}

void copy_history_item_static_array(history_item * from, history_item * to, int size)
{
	int i;

	for(i = 0; i < size; i++)
	{
		copy_history_item(&from[i], &to[i]);
	}
}


void init_firm_stocks_adt(/*@out@*/ firm_stocks_adt * temp)
{
	(*temp).payment_account = 0.0;
	(*temp).total_value_local_inventory = 0.0;
	(*temp).total_value_capital_stock = 0.0;
	(*temp).total_assets = 0.0;
	(*temp).total_debt = 0.0;
	(*temp).equity = 0.0;
	(*temp).total_liabilities = 0.0;
	(*temp).current_shares_outstanding = 0;
	(*temp).payment_account_day_1 = 0.0;
	(*temp).payment_account_day_20 = 0.0;

}

void init_firm_stocks_adt_static_array(/*@out@*/ firm_stocks_adt * array, int size)
{
	int i;

	for(i = 0; i < size; i++) init_firm_stocks_adt(&array[i]);
}

void free_firm_stocks_adt(firm_stocks_adt * temp)
{

}

void free_firm_stocks_adt_static_array(firm_stocks_adt * array, int size)
{
	int i;

	for(i = 0; i < size; i++) free_firm_stocks_adt(&array[i]);
}

void copy_firm_stocks_adt(firm_stocks_adt * from, firm_stocks_adt * to)
{
	(*to).payment_account = (*from).payment_account;
	(*to).total_value_local_inventory = (*from).total_value_local_inventory;
	(*to).total_value_capital_stock = (*from).total_value_capital_stock;
	(*to).total_assets = (*from).total_assets;
	(*to).total_debt = (*from).total_debt;
	(*to).equity = (*from).equity;
	(*to).total_liabilities = (*from).total_liabilities;
	(*to).current_shares_outstanding = (*from).current_shares_outstanding;
	(*to).payment_account_day_1 = (*from).payment_account_day_1;
	(*to).payment_account_day_20 = (*from).payment_account_day_20;
}

void copy_firm_stocks_adt_static_array(firm_stocks_adt * from, firm_stocks_adt * to, int size)
{
	int i;

	for(i = 0; i < size; i++)
	{
		copy_firm_stocks_adt(&from[i], &to[i]);
	}
}


void init_firm_outflows_adt(/*@out@*/ firm_outflows_adt * temp)
{
	(*temp).labour_costs = 0.0;
	(*temp).capital_costs = 0.0;
	(*temp).energy_costs = 0.0;
	(*temp).tax_payment = 0.0;
	(*temp).total_debt_installment_payment = 0.0;
	(*temp).total_interest_payment = 0.0;
	(*temp).total_dividend_payment = 0.0;
	(*temp).value_of_repurchased_shares = 0.0;
	(*temp).total_expenses = 0.0;

}

void init_firm_outflows_adt_static_array(/*@out@*/ firm_outflows_adt * array, int size)
{
	int i;

	for(i = 0; i < size; i++) init_firm_outflows_adt(&array[i]);
}

void free_firm_outflows_adt(firm_outflows_adt * temp)
{

}

void free_firm_outflows_adt_static_array(firm_outflows_adt * array, int size)
{
	int i;

	for(i = 0; i < size; i++) free_firm_outflows_adt(&array[i]);
}

void copy_firm_outflows_adt(firm_outflows_adt * from, firm_outflows_adt * to)
{
	(*to).labour_costs = (*from).labour_costs;
	(*to).capital_costs = (*from).capital_costs;
	(*to).energy_costs = (*from).energy_costs;
	(*to).tax_payment = (*from).tax_payment;
	(*to).total_debt_installment_payment = (*from).total_debt_installment_payment;
	(*to).total_interest_payment = (*from).total_interest_payment;
	(*to).total_dividend_payment = (*from).total_dividend_payment;
	(*to).value_of_repurchased_shares = (*from).value_of_repurchased_shares;
	(*to).total_expenses = (*from).total_expenses;
}

void copy_firm_outflows_adt_static_array(firm_outflows_adt * from, firm_outflows_adt * to, int size)
{
	int i;

	for(i = 0; i < size; i++)
	{
		copy_firm_outflows_adt(&from[i], &to[i]);
	}
}


void init_firm_inflows_adt(/*@out@*/ firm_inflows_adt * temp)
{
	(*temp).cum_revenue = 0.0;
	(*temp).new_loans = 0.0;
	(*temp).value_of_issued_shares = 0.0;
	(*temp).subsidy = 0.0;
	(*temp).total_income = 0.0;
	(*temp).deposit_interest = 0.0;
	(*temp).net_inflow = 0.0;

}

void init_firm_inflows_adt_static_array(/*@out@*/ firm_inflows_adt * array, int size)
{
	int i;

	for(i = 0; i < size; i++) init_firm_inflows_adt(&array[i]);
}

void free_firm_inflows_adt(firm_inflows_adt * temp)
{

}

void free_firm_inflows_adt_static_array(firm_inflows_adt * array, int size)
{
	int i;

	for(i = 0; i < size; i++) free_firm_inflows_adt(&array[i]);
}

void copy_firm_inflows_adt(firm_inflows_adt * from, firm_inflows_adt * to)
{
	(*to).cum_revenue = (*from).cum_revenue;
	(*to).new_loans = (*from).new_loans;
	(*to).value_of_issued_shares = (*from).value_of_issued_shares;
	(*to).subsidy = (*from).subsidy;
	(*to).total_income = (*from).total_income;
	(*to).deposit_interest = (*from).deposit_interest;
	(*to).net_inflow = (*from).net_inflow;
}

void copy_firm_inflows_adt_static_array(firm_inflows_adt * from, firm_inflows_adt * to, int size)
{
	int i;

	for(i = 0; i < size; i++)
	{
		copy_firm_inflows_adt(&from[i], &to[i]);
	}
}


void init_household_stocks_adt(/*@out@*/ household_stocks_adt * temp)
{
	(*temp).payment_account = 0.0;
	(*temp).portfolio_value = 0.0;
	(*temp).total_assets = 0.0;
	(*temp).total_liabilities = 0.0;
	(*temp).nr_assets = 0;
	(*temp).payment_account_day_1 = 0.0;
	(*temp).payment_account_day_20 = 0.0;

}

void init_household_stocks_adt_static_array(/*@out@*/ household_stocks_adt * array, int size)
{
	int i;

	for(i = 0; i < size; i++) init_household_stocks_adt(&array[i]);
}

void free_household_stocks_adt(household_stocks_adt * temp)
{

}

void free_household_stocks_adt_static_array(household_stocks_adt * array, int size)
{
	int i;

	for(i = 0; i < size; i++) free_household_stocks_adt(&array[i]);
}

void copy_household_stocks_adt(household_stocks_adt * from, household_stocks_adt * to)
{
	(*to).payment_account = (*from).payment_account;
	(*to).portfolio_value = (*from).portfolio_value;
	(*to).total_assets = (*from).total_assets;
	(*to).total_liabilities = (*from).total_liabilities;
	(*to).nr_assets = (*from).nr_assets;
	(*to).payment_account_day_1 = (*from).payment_account_day_1;
	(*to).payment_account_day_20 = (*from).payment_account_day_20;
}

void copy_household_stocks_adt_static_array(household_stocks_adt * from, household_stocks_adt * to, int size)
{
	int i;

	for(i = 0; i < size; i++)
	{
		copy_household_stocks_adt(&from[i], &to[i]);
	}
}


void init_household_outflows_adt(/*@out@*/ household_outflows_adt * temp)
{
	(*temp).consumption_expenditure = 0.0;
	(*temp).tax_payment = 0.0;
	(*temp).restitution_payment = 0.0;
	(*temp).asset_purchases = 0.0;
	(*temp).total_expenses = 0.0;

}

void init_household_outflows_adt_static_array(/*@out@*/ household_outflows_adt * array, int size)
{
	int i;

	for(i = 0; i < size; i++) init_household_outflows_adt(&array[i]);
}

void free_household_outflows_adt(household_outflows_adt * temp)
{

}

void free_household_outflows_adt_static_array(household_outflows_adt * array, int size)
{
	int i;

	for(i = 0; i < size; i++) free_household_outflows_adt(&array[i]);
}

void copy_household_outflows_adt(household_outflows_adt * from, household_outflows_adt * to)
{
	(*to).consumption_expenditure = (*from).consumption_expenditure;
	(*to).tax_payment = (*from).tax_payment;
	(*to).restitution_payment = (*from).restitution_payment;
	(*to).asset_purchases = (*from).asset_purchases;
	(*to).total_expenses = (*from).total_expenses;
}

void copy_household_outflows_adt_static_array(household_outflows_adt * from, household_outflows_adt * to, int size)
{
	int i;

	for(i = 0; i < size; i++)
	{
		copy_household_outflows_adt(&from[i], &to[i]);
	}
}


void init_household_inflows_adt(/*@out@*/ household_inflows_adt * temp)
{
	(*temp).wage = 0.0;
	(*temp).unemployment_benefit = 0.0;
	(*temp).subsidies = 0.0;
	(*temp).transfer = 0.0;
	(*temp).gov_interest = 0.0;
	(*temp).asset_sales = 0.0;
	(*temp).total_dividends = 0.0;
	(*temp).deposit_interest = 0.0;
	(*temp).total_income = 0.0;
	(*temp).net_inflow = 0.0;

}

void init_household_inflows_adt_static_array(/*@out@*/ household_inflows_adt * array, int size)
{
	int i;

	for(i = 0; i < size; i++) init_household_inflows_adt(&array[i]);
}

void free_household_inflows_adt(household_inflows_adt * temp)
{

}

void free_household_inflows_adt_static_array(household_inflows_adt * array, int size)
{
	int i;

	for(i = 0; i < size; i++) free_household_inflows_adt(&array[i]);
}

void copy_household_inflows_adt(household_inflows_adt * from, household_inflows_adt * to)
{
	(*to).wage = (*from).wage;
	(*to).unemployment_benefit = (*from).unemployment_benefit;
	(*to).subsidies = (*from).subsidies;
	(*to).transfer = (*from).transfer;
	(*to).gov_interest = (*from).gov_interest;
	(*to).asset_sales = (*from).asset_sales;
	(*to).total_dividends = (*from).total_dividends;
	(*to).deposit_interest = (*from).deposit_interest;
	(*to).total_income = (*from).total_income;
	(*to).net_inflow = (*from).net_inflow;
}

void copy_household_inflows_adt_static_array(household_inflows_adt * from, household_inflows_adt * to, int size)
{
	int i;

	for(i = 0; i < size; i++)
	{
		copy_household_inflows_adt(&from[i], &to[i]);
	}
}


void init_igfirm_stocks_adt(/*@out@*/ igfirm_stocks_adt * temp)
{
	(*temp).payment_account = 0.0;
	(*temp).total_value_local_inventory = 0.0;
	(*temp).total_value_capital_stock = 0.0;
	(*temp).total_assets = 0.0;
	(*temp).total_debt = 0.0;
	(*temp).equity = 0.0;
	(*temp).total_liabilities = 0.0;
	(*temp).current_shares_outstanding = 0;
	(*temp).payment_account_day_1 = 0.0;
	(*temp).payment_account_day_20 = 0.0;

}

void init_igfirm_stocks_adt_static_array(/*@out@*/ igfirm_stocks_adt * array, int size)
{
	int i;

	for(i = 0; i < size; i++) init_igfirm_stocks_adt(&array[i]);
}

void free_igfirm_stocks_adt(igfirm_stocks_adt * temp)
{

}

void free_igfirm_stocks_adt_static_array(igfirm_stocks_adt * array, int size)
{
	int i;

	for(i = 0; i < size; i++) free_igfirm_stocks_adt(&array[i]);
}

void copy_igfirm_stocks_adt(igfirm_stocks_adt * from, igfirm_stocks_adt * to)
{
	(*to).payment_account = (*from).payment_account;
	(*to).total_value_local_inventory = (*from).total_value_local_inventory;
	(*to).total_value_capital_stock = (*from).total_value_capital_stock;
	(*to).total_assets = (*from).total_assets;
	(*to).total_debt = (*from).total_debt;
	(*to).equity = (*from).equity;
	(*to).total_liabilities = (*from).total_liabilities;
	(*to).current_shares_outstanding = (*from).current_shares_outstanding;
	(*to).payment_account_day_1 = (*from).payment_account_day_1;
	(*to).payment_account_day_20 = (*from).payment_account_day_20;
}

void copy_igfirm_stocks_adt_static_array(igfirm_stocks_adt * from, igfirm_stocks_adt * to, int size)
{
	int i;

	for(i = 0; i < size; i++)
	{
		copy_igfirm_stocks_adt(&from[i], &to[i]);
	}
}


void init_igfirm_outflows_adt(/*@out@*/ igfirm_outflows_adt * temp)
{
	(*temp).labour_costs = 0.0;
	(*temp).capital_costs = 0.0;
	(*temp).energy_costs = 0.0;
	(*temp).tax_payment = 0.0;
	(*temp).total_debt_installment_payment = 0.0;
	(*temp).total_interest_payment = 0.0;
	(*temp).total_dividend_payment = 0.0;
	(*temp).value_of_repurchased_shares = 0.0;
	(*temp).total_expenses = 0.0;

}

void init_igfirm_outflows_adt_static_array(/*@out@*/ igfirm_outflows_adt * array, int size)
{
	int i;

	for(i = 0; i < size; i++) init_igfirm_outflows_adt(&array[i]);
}

void free_igfirm_outflows_adt(igfirm_outflows_adt * temp)
{

}

void free_igfirm_outflows_adt_static_array(igfirm_outflows_adt * array, int size)
{
	int i;

	for(i = 0; i < size; i++) free_igfirm_outflows_adt(&array[i]);
}

void copy_igfirm_outflows_adt(igfirm_outflows_adt * from, igfirm_outflows_adt * to)
{
	(*to).labour_costs = (*from).labour_costs;
	(*to).capital_costs = (*from).capital_costs;
	(*to).energy_costs = (*from).energy_costs;
	(*to).tax_payment = (*from).tax_payment;
	(*to).total_debt_installment_payment = (*from).total_debt_installment_payment;
	(*to).total_interest_payment = (*from).total_interest_payment;
	(*to).total_dividend_payment = (*from).total_dividend_payment;
	(*to).value_of_repurchased_shares = (*from).value_of_repurchased_shares;
	(*to).total_expenses = (*from).total_expenses;
}

void copy_igfirm_outflows_adt_static_array(igfirm_outflows_adt * from, igfirm_outflows_adt * to, int size)
{
	int i;

	for(i = 0; i < size; i++)
	{
		copy_igfirm_outflows_adt(&from[i], &to[i]);
	}
}


void init_igfirm_inflows_adt(/*@out@*/ igfirm_inflows_adt * temp)
{
	(*temp).cum_revenue = 0.0;
	(*temp).new_loans = 0.0;
	(*temp).value_of_issued_shares = 0.0;
	(*temp).subsidy = 0.0;
	(*temp).total_income = 0.0;
	(*temp).deposit_interest = 0.0;
	(*temp).net_inflow = 0.0;

}

void init_igfirm_inflows_adt_static_array(/*@out@*/ igfirm_inflows_adt * array, int size)
{
	int i;

	for(i = 0; i < size; i++) init_igfirm_inflows_adt(&array[i]);
}

void free_igfirm_inflows_adt(igfirm_inflows_adt * temp)
{

}

void free_igfirm_inflows_adt_static_array(igfirm_inflows_adt * array, int size)
{
	int i;

	for(i = 0; i < size; i++) free_igfirm_inflows_adt(&array[i]);
}

void copy_igfirm_inflows_adt(igfirm_inflows_adt * from, igfirm_inflows_adt * to)
{
	(*to).cum_revenue = (*from).cum_revenue;
	(*to).new_loans = (*from).new_loans;
	(*to).value_of_issued_shares = (*from).value_of_issued_shares;
	(*to).subsidy = (*from).subsidy;
	(*to).total_income = (*from).total_income;
	(*to).deposit_interest = (*from).deposit_interest;
	(*to).net_inflow = (*from).net_inflow;
}

void copy_igfirm_inflows_adt_static_array(igfirm_inflows_adt * from, igfirm_inflows_adt * to, int size)
{
	int i;

	for(i = 0; i < size; i++)
	{
		copy_igfirm_inflows_adt(&from[i], &to[i]);
	}
}


void init_bank_stocks_adt(/*@out@*/ bank_stocks_adt * temp)
{
	(*temp).cash = 0.0;
	(*temp).total_credit = 0.0;
	(*temp).total_assets = 0.0;
	(*temp).deposits = 0.0;
	(*temp).ecb_debt = 0.0;
	(*temp).equity = 0.0;
	(*temp).total_liabilities = 0.0;
	(*temp).current_shares_outstanding = 0;
	(*temp).cash_day_1 = 0.0;
	(*temp).cash_day_20 = 0.0;

}

void init_bank_stocks_adt_static_array(/*@out@*/ bank_stocks_adt * array, int size)
{
	int i;

	for(i = 0; i < size; i++) init_bank_stocks_adt(&array[i]);
}

void free_bank_stocks_adt(bank_stocks_adt * temp)
{

}

void free_bank_stocks_adt_static_array(bank_stocks_adt * array, int size)
{
	int i;

	for(i = 0; i < size; i++) free_bank_stocks_adt(&array[i]);
}

void copy_bank_stocks_adt(bank_stocks_adt * from, bank_stocks_adt * to)
{
	(*to).cash = (*from).cash;
	(*to).total_credit = (*from).total_credit;
	(*to).total_assets = (*from).total_assets;
	(*to).deposits = (*from).deposits;
	(*to).ecb_debt = (*from).ecb_debt;
	(*to).equity = (*from).equity;
	(*to).total_liabilities = (*from).total_liabilities;
	(*to).current_shares_outstanding = (*from).current_shares_outstanding;
	(*to).cash_day_1 = (*from).cash_day_1;
	(*to).cash_day_20 = (*from).cash_day_20;
}

void copy_bank_stocks_adt_static_array(bank_stocks_adt * from, bank_stocks_adt * to, int size)
{
	int i;

	for(i = 0; i < size; i++)
	{
		copy_bank_stocks_adt(&from[i], &to[i]);
	}
}


void init_bank_outflows_adt(/*@out@*/ bank_outflows_adt * temp)
{
	(*temp).firm_loan_issues = 0.0;
	(*temp).debt_installment_to_ecb = 0.0;
	(*temp).ecb_interest_payment = 0.0;
	(*temp).deposit_interest_payment = 0.0;
	(*temp).dividend_payment = 0.0;
	(*temp).tax_payment = 0.0;
	(*temp).deposit_outflow = 0.0;
	(*temp).total_expenses = 0.0;

}

void init_bank_outflows_adt_static_array(/*@out@*/ bank_outflows_adt * array, int size)
{
	int i;

	for(i = 0; i < size; i++) init_bank_outflows_adt(&array[i]);
}

void free_bank_outflows_adt(bank_outflows_adt * temp)
{

}

void free_bank_outflows_adt_static_array(bank_outflows_adt * array, int size)
{
	int i;

	for(i = 0; i < size; i++) free_bank_outflows_adt(&array[i]);
}

void copy_bank_outflows_adt(bank_outflows_adt * from, bank_outflows_adt * to)
{
	(*to).firm_loan_issues = (*from).firm_loan_issues;
	(*to).debt_installment_to_ecb = (*from).debt_installment_to_ecb;
	(*to).ecb_interest_payment = (*from).ecb_interest_payment;
	(*to).deposit_interest_payment = (*from).deposit_interest_payment;
	(*to).dividend_payment = (*from).dividend_payment;
	(*to).tax_payment = (*from).tax_payment;
	(*to).deposit_outflow = (*from).deposit_outflow;
	(*to).total_expenses = (*from).total_expenses;
}

void copy_bank_outflows_adt_static_array(bank_outflows_adt * from, bank_outflows_adt * to, int size)
{
	int i;

	for(i = 0; i < size; i++)
	{
		copy_bank_outflows_adt(&from[i], &to[i]);
	}
}


void init_bank_inflows_adt(/*@out@*/ bank_inflows_adt * temp)
{
	(*temp).firm_loan_installments = 0.0;
	(*temp).firm_interest_payments = 0.0;
	(*temp).new_ecb_debt = 0.0;
	(*temp).deposit_inflow = 0.0;
	(*temp).total_income = 0.0;
	(*temp).net_inflow = 0.0;
	(*temp).net_deposit_inflow = 0.0;

}

void init_bank_inflows_adt_static_array(/*@out@*/ bank_inflows_adt * array, int size)
{
	int i;

	for(i = 0; i < size; i++) init_bank_inflows_adt(&array[i]);
}

void free_bank_inflows_adt(bank_inflows_adt * temp)
{

}

void free_bank_inflows_adt_static_array(bank_inflows_adt * array, int size)
{
	int i;

	for(i = 0; i < size; i++) free_bank_inflows_adt(&array[i]);
}

void copy_bank_inflows_adt(bank_inflows_adt * from, bank_inflows_adt * to)
{
	(*to).firm_loan_installments = (*from).firm_loan_installments;
	(*to).firm_interest_payments = (*from).firm_interest_payments;
	(*to).new_ecb_debt = (*from).new_ecb_debt;
	(*to).deposit_inflow = (*from).deposit_inflow;
	(*to).total_income = (*from).total_income;
	(*to).net_inflow = (*from).net_inflow;
	(*to).net_deposit_inflow = (*from).net_deposit_inflow;
}

void copy_bank_inflows_adt_static_array(bank_inflows_adt * from, bank_inflows_adt * to, int size)
{
	int i;

	for(i = 0; i < size; i++)
	{
		copy_bank_inflows_adt(&from[i], &to[i]);
	}
}


void init_gov_stocks_adt(/*@out@*/ gov_stocks_adt * temp)
{
	(*temp).payment_account = 0.0;
	(*temp).total_assets = 0.0;
	(*temp).value_bonds_outstanding = 0.0;
	(*temp).ecb_money = 0.0;
	(*temp).equity = 0.0;
	(*temp).total_liabilities = 0.0;
	(*temp).nr_bonds_outstanding = 0;
	(*temp).payment_account_day_1 = 0.0;
	(*temp).payment_account_day_20 = 0.0;

}

void init_gov_stocks_adt_static_array(/*@out@*/ gov_stocks_adt * array, int size)
{
	int i;

	for(i = 0; i < size; i++) init_gov_stocks_adt(&array[i]);
}

void free_gov_stocks_adt(gov_stocks_adt * temp)
{

}

void free_gov_stocks_adt_static_array(gov_stocks_adt * array, int size)
{
	int i;

	for(i = 0; i < size; i++) free_gov_stocks_adt(&array[i]);
}

void copy_gov_stocks_adt(gov_stocks_adt * from, gov_stocks_adt * to)
{
	(*to).payment_account = (*from).payment_account;
	(*to).total_assets = (*from).total_assets;
	(*to).value_bonds_outstanding = (*from).value_bonds_outstanding;
	(*to).ecb_money = (*from).ecb_money;
	(*to).equity = (*from).equity;
	(*to).total_liabilities = (*from).total_liabilities;
	(*to).nr_bonds_outstanding = (*from).nr_bonds_outstanding;
	(*to).payment_account_day_1 = (*from).payment_account_day_1;
	(*to).payment_account_day_20 = (*from).payment_account_day_20;
}

void copy_gov_stocks_adt_static_array(gov_stocks_adt * from, gov_stocks_adt * to, int size)
{
	int i;

	for(i = 0; i < size; i++)
	{
		copy_gov_stocks_adt(&from[i], &to[i]);
	}
}


void init_gov_outflows_adt(/*@out@*/ gov_outflows_adt * temp)
{
	(*temp).investment_expenditure = 0.0;
	(*temp).consumption_expenditure = 0.0;
	(*temp).benefit_payment = 0.0;
	(*temp).subsidy_payment_household = 0.0;
	(*temp).subsidy_payment_firm = 0.0;
	(*temp).transfer_payment_household = 0.0;
	(*temp).transfer_payment_firm = 0.0;
	(*temp).bond_interest_payment = 0.0;
	(*temp).debt_installment = 0.0;
	(*temp).total_bond_repurchase = 0.0;
	(*temp).total_expenses = 0.0;

}

void init_gov_outflows_adt_static_array(/*@out@*/ gov_outflows_adt * array, int size)
{
	int i;

	for(i = 0; i < size; i++) init_gov_outflows_adt(&array[i]);
}

void free_gov_outflows_adt(gov_outflows_adt * temp)
{

}

void free_gov_outflows_adt_static_array(gov_outflows_adt * array, int size)
{
	int i;

	for(i = 0; i < size; i++) free_gov_outflows_adt(&array[i]);
}

void copy_gov_outflows_adt(gov_outflows_adt * from, gov_outflows_adt * to)
{
	(*to).investment_expenditure = (*from).investment_expenditure;
	(*to).consumption_expenditure = (*from).consumption_expenditure;
	(*to).benefit_payment = (*from).benefit_payment;
	(*to).subsidy_payment_household = (*from).subsidy_payment_household;
	(*to).subsidy_payment_firm = (*from).subsidy_payment_firm;
	(*to).transfer_payment_household = (*from).transfer_payment_household;
	(*to).transfer_payment_firm = (*from).transfer_payment_firm;
	(*to).bond_interest_payment = (*from).bond_interest_payment;
	(*to).debt_installment = (*from).debt_installment;
	(*to).total_bond_repurchase = (*from).total_bond_repurchase;
	(*to).total_expenses = (*from).total_expenses;
}

void copy_gov_outflows_adt_static_array(gov_outflows_adt * from, gov_outflows_adt * to, int size)
{
	int i;

	for(i = 0; i < size; i++)
	{
		copy_gov_outflows_adt(&from[i], &to[i]);
	}
}


void init_gov_inflows_adt(/*@out@*/ gov_inflows_adt * temp)
{
	(*temp).tax_revenues = 0.0;
	(*temp).restitution_payment = 0.0;
	(*temp).total_bond_financing = 0.0;
	(*temp).total_money_financing = 0.0;
	(*temp).ecb_dividend = 0.0;
	(*temp).total_income = 0.0;
	(*temp).net_inflow = 0.0;

}

void init_gov_inflows_adt_static_array(/*@out@*/ gov_inflows_adt * array, int size)
{
	int i;

	for(i = 0; i < size; i++) init_gov_inflows_adt(&array[i]);
}

void free_gov_inflows_adt(gov_inflows_adt * temp)
{

}

void free_gov_inflows_adt_static_array(gov_inflows_adt * array, int size)
{
	int i;

	for(i = 0; i < size; i++) free_gov_inflows_adt(&array[i]);
}

void copy_gov_inflows_adt(gov_inflows_adt * from, gov_inflows_adt * to)
{
	(*to).tax_revenues = (*from).tax_revenues;
	(*to).restitution_payment = (*from).restitution_payment;
	(*to).total_bond_financing = (*from).total_bond_financing;
	(*to).total_money_financing = (*from).total_money_financing;
	(*to).ecb_dividend = (*from).ecb_dividend;
	(*to).total_income = (*from).total_income;
	(*to).net_inflow = (*from).net_inflow;
}

void copy_gov_inflows_adt_static_array(gov_inflows_adt * from, gov_inflows_adt * to, int size)
{
	int i;

	for(i = 0; i < size; i++)
	{
		copy_gov_inflows_adt(&from[i], &to[i]);
	}
}


void init_ecb_stocks_adt(/*@out@*/ ecb_stocks_adt * temp)
{
	(*temp).cash = 0.0;
	(*temp).gov_bond_holdings = 0.0;
	(*temp).fiat_money_banks = 0.0;
	(*temp).fiat_money_govs = 0.0;
	(*temp).total_assets = 0.0;
	(*temp).payment_account_banks = 0.0;
	(*temp).payment_account_govs = 0.0;
	(*temp).fiat_money = 0.0;
	(*temp).equity = 0.0;
	(*temp).total_liabilities = 0.0;
	(*temp).nr_gov_bonds = 0;
	(*temp).equity_day_1 = 0.0;
	(*temp).fiat_money_govs_bond = 0.0;

}

void init_ecb_stocks_adt_static_array(/*@out@*/ ecb_stocks_adt * array, int size)
{
	int i;

	for(i = 0; i < size; i++) init_ecb_stocks_adt(&array[i]);
}

void free_ecb_stocks_adt(ecb_stocks_adt * temp)
{

}

void free_ecb_stocks_adt_static_array(ecb_stocks_adt * array, int size)
{
	int i;

	for(i = 0; i < size; i++) free_ecb_stocks_adt(&array[i]);
}

void copy_ecb_stocks_adt(ecb_stocks_adt * from, ecb_stocks_adt * to)
{
	(*to).cash = (*from).cash;
	(*to).gov_bond_holdings = (*from).gov_bond_holdings;
	(*to).fiat_money_banks = (*from).fiat_money_banks;
	(*to).fiat_money_govs = (*from).fiat_money_govs;
	(*to).total_assets = (*from).total_assets;
	(*to).payment_account_banks = (*from).payment_account_banks;
	(*to).payment_account_govs = (*from).payment_account_govs;
	(*to).fiat_money = (*from).fiat_money;
	(*to).equity = (*from).equity;
	(*to).total_liabilities = (*from).total_liabilities;
	(*to).nr_gov_bonds = (*from).nr_gov_bonds;
	(*to).equity_day_1 = (*from).equity_day_1;
	(*to).fiat_money_govs_bond = (*from).fiat_money_govs_bond;
}

void copy_ecb_stocks_adt_static_array(ecb_stocks_adt * from, ecb_stocks_adt * to, int size)
{
	int i;

	for(i = 0; i < size; i++)
	{
		copy_ecb_stocks_adt(&from[i], &to[i]);
	}
}


void init_ecb_outflows_adt(/*@out@*/ ecb_outflows_adt * temp)
{
	(*temp).gov_bond_purchase = 0.0;
	(*temp).bank_fiat_money = 0.0;
	(*temp).bank_deposits = 0.0;
	(*temp).gov_deposits = 0.0;
	(*temp).dividend_payment = 0.0;
	(*temp).total_expenses = 0.0;

}

void init_ecb_outflows_adt_static_array(/*@out@*/ ecb_outflows_adt * array, int size)
{
	int i;

	for(i = 0; i < size; i++) init_ecb_outflows_adt(&array[i]);
}

void free_ecb_outflows_adt(ecb_outflows_adt * temp)
{

}

void free_ecb_outflows_adt_static_array(ecb_outflows_adt * array, int size)
{
	int i;

	for(i = 0; i < size; i++) free_ecb_outflows_adt(&array[i]);
}

void copy_ecb_outflows_adt(ecb_outflows_adt * from, ecb_outflows_adt * to)
{
	(*to).gov_bond_purchase = (*from).gov_bond_purchase;
	(*to).bank_fiat_money = (*from).bank_fiat_money;
	(*to).bank_deposits = (*from).bank_deposits;
	(*to).gov_deposits = (*from).gov_deposits;
	(*to).dividend_payment = (*from).dividend_payment;
	(*to).total_expenses = (*from).total_expenses;
}

void copy_ecb_outflows_adt_static_array(ecb_outflows_adt * from, ecb_outflows_adt * to, int size)
{
	int i;

	for(i = 0; i < size; i++)
	{
		copy_ecb_outflows_adt(&from[i], &to[i]);
	}
}


void init_ecb_inflows_adt(/*@out@*/ ecb_inflows_adt * temp)
{
	(*temp).bank_interest = 0.0;
	(*temp).bank_debt_installment = 0.0;
	(*temp).gov_interest = 0.0;
	(*temp).bank_deposits = 0.0;
	(*temp).gov_deposits = 0.0;
	(*temp).total_income = 0.0;
	(*temp).net_inflow = 0.0;

}

void init_ecb_inflows_adt_static_array(/*@out@*/ ecb_inflows_adt * array, int size)
{
	int i;

	for(i = 0; i < size; i++) init_ecb_inflows_adt(&array[i]);
}

void free_ecb_inflows_adt(ecb_inflows_adt * temp)
{

}

void free_ecb_inflows_adt_static_array(ecb_inflows_adt * array, int size)
{
	int i;

	for(i = 0; i < size; i++) free_ecb_inflows_adt(&array[i]);
}

void copy_ecb_inflows_adt(ecb_inflows_adt * from, ecb_inflows_adt * to)
{
	(*to).bank_interest = (*from).bank_interest;
	(*to).bank_debt_installment = (*from).bank_debt_installment;
	(*to).gov_interest = (*from).gov_interest;
	(*to).bank_deposits = (*from).bank_deposits;
	(*to).gov_deposits = (*from).gov_deposits;
	(*to).total_income = (*from).total_income;
	(*to).net_inflow = (*from).net_inflow;
}

void copy_ecb_inflows_adt_static_array(ecb_inflows_adt * from, ecb_inflows_adt * to, int size)
{
	int i;

	for(i = 0; i < size; i++)
	{
		copy_ecb_inflows_adt(&from[i], &to[i]);
	}
}


void init_firm_balance_sheet_adt(/*@out@*/ firm_balance_sheet_adt * temp)
{
	init_firm_stocks_adt(&(*temp).stocks);
	init_firm_outflows_adt(&(*temp).outflows);
	init_firm_inflows_adt(&(*temp).inflows);

}

void init_firm_balance_sheet_adt_static_array(/*@out@*/ firm_balance_sheet_adt * array, int size)
{
	int i;

	for(i = 0; i < size; i++) init_firm_balance_sheet_adt(&array[i]);
}

void free_firm_balance_sheet_adt(firm_balance_sheet_adt * temp)
{
	free_firm_stocks_adt(&(*temp).stocks);
	free_firm_outflows_adt(&(*temp).outflows);
	free_firm_inflows_adt(&(*temp).inflows);

}

void free_firm_balance_sheet_adt_static_array(firm_balance_sheet_adt * array, int size)
{
	int i;

	for(i = 0; i < size; i++) free_firm_balance_sheet_adt(&array[i]);
}

void copy_firm_balance_sheet_adt(firm_balance_sheet_adt * from, firm_balance_sheet_adt * to)
{
	copy_firm_stocks_adt(&(*from).stocks, &(*to).stocks);
	copy_firm_outflows_adt(&(*from).outflows, &(*to).outflows);
	copy_firm_inflows_adt(&(*from).inflows, &(*to).inflows);
}

void copy_firm_balance_sheet_adt_static_array(firm_balance_sheet_adt * from, firm_balance_sheet_adt * to, int size)
{
	int i;

	for(i = 0; i < size; i++)
	{
		copy_firm_balance_sheet_adt(&from[i], &to[i]);
	}
}


void init_household_balance_sheet_adt(/*@out@*/ household_balance_sheet_adt * temp)
{
	init_household_stocks_adt(&(*temp).stocks);
	init_household_outflows_adt(&(*temp).outflows);
	init_household_inflows_adt(&(*temp).inflows);

}

void init_household_balance_sheet_adt_static_array(/*@out@*/ household_balance_sheet_adt * array, int size)
{
	int i;

	for(i = 0; i < size; i++) init_household_balance_sheet_adt(&array[i]);
}

void free_household_balance_sheet_adt(household_balance_sheet_adt * temp)
{
	free_household_stocks_adt(&(*temp).stocks);
	free_household_outflows_adt(&(*temp).outflows);
	free_household_inflows_adt(&(*temp).inflows);

}

void free_household_balance_sheet_adt_static_array(household_balance_sheet_adt * array, int size)
{
	int i;

	for(i = 0; i < size; i++) free_household_balance_sheet_adt(&array[i]);
}

void copy_household_balance_sheet_adt(household_balance_sheet_adt * from, household_balance_sheet_adt * to)
{
	copy_household_stocks_adt(&(*from).stocks, &(*to).stocks);
	copy_household_outflows_adt(&(*from).outflows, &(*to).outflows);
	copy_household_inflows_adt(&(*from).inflows, &(*to).inflows);
}

void copy_household_balance_sheet_adt_static_array(household_balance_sheet_adt * from, household_balance_sheet_adt * to, int size)
{
	int i;

	for(i = 0; i < size; i++)
	{
		copy_household_balance_sheet_adt(&from[i], &to[i]);
	}
}


void init_igfirm_balance_sheet_adt(/*@out@*/ igfirm_balance_sheet_adt * temp)
{
	init_igfirm_stocks_adt(&(*temp).stocks);
	init_igfirm_outflows_adt(&(*temp).outflows);
	init_igfirm_inflows_adt(&(*temp).inflows);

}

void init_igfirm_balance_sheet_adt_static_array(/*@out@*/ igfirm_balance_sheet_adt * array, int size)
{
	int i;

	for(i = 0; i < size; i++) init_igfirm_balance_sheet_adt(&array[i]);
}

void free_igfirm_balance_sheet_adt(igfirm_balance_sheet_adt * temp)
{
	free_igfirm_stocks_adt(&(*temp).stocks);
	free_igfirm_outflows_adt(&(*temp).outflows);
	free_igfirm_inflows_adt(&(*temp).inflows);

}

void free_igfirm_balance_sheet_adt_static_array(igfirm_balance_sheet_adt * array, int size)
{
	int i;

	for(i = 0; i < size; i++) free_igfirm_balance_sheet_adt(&array[i]);
}

void copy_igfirm_balance_sheet_adt(igfirm_balance_sheet_adt * from, igfirm_balance_sheet_adt * to)
{
	copy_igfirm_stocks_adt(&(*from).stocks, &(*to).stocks);
	copy_igfirm_outflows_adt(&(*from).outflows, &(*to).outflows);
	copy_igfirm_inflows_adt(&(*from).inflows, &(*to).inflows);
}

void copy_igfirm_balance_sheet_adt_static_array(igfirm_balance_sheet_adt * from, igfirm_balance_sheet_adt * to, int size)
{
	int i;

	for(i = 0; i < size; i++)
	{
		copy_igfirm_balance_sheet_adt(&from[i], &to[i]);
	}
}


void init_bank_balance_sheet_adt(/*@out@*/ bank_balance_sheet_adt * temp)
{
	init_bank_stocks_adt(&(*temp).stocks);
	init_bank_outflows_adt(&(*temp).outflows);
	init_bank_inflows_adt(&(*temp).inflows);

}

void init_bank_balance_sheet_adt_static_array(/*@out@*/ bank_balance_sheet_adt * array, int size)
{
	int i;

	for(i = 0; i < size; i++) init_bank_balance_sheet_adt(&array[i]);
}

void free_bank_balance_sheet_adt(bank_balance_sheet_adt * temp)
{
	free_bank_stocks_adt(&(*temp).stocks);
	free_bank_outflows_adt(&(*temp).outflows);
	free_bank_inflows_adt(&(*temp).inflows);

}

void free_bank_balance_sheet_adt_static_array(bank_balance_sheet_adt * array, int size)
{
	int i;

	for(i = 0; i < size; i++) free_bank_balance_sheet_adt(&array[i]);
}

void copy_bank_balance_sheet_adt(bank_balance_sheet_adt * from, bank_balance_sheet_adt * to)
{
	copy_bank_stocks_adt(&(*from).stocks, &(*to).stocks);
	copy_bank_outflows_adt(&(*from).outflows, &(*to).outflows);
	copy_bank_inflows_adt(&(*from).inflows, &(*to).inflows);
}

void copy_bank_balance_sheet_adt_static_array(bank_balance_sheet_adt * from, bank_balance_sheet_adt * to, int size)
{
	int i;

	for(i = 0; i < size; i++)
	{
		copy_bank_balance_sheet_adt(&from[i], &to[i]);
	}
}


void init_gov_balance_sheet_adt(/*@out@*/ gov_balance_sheet_adt * temp)
{
	init_gov_stocks_adt(&(*temp).stocks);
	init_gov_outflows_adt(&(*temp).outflows);
	init_gov_inflows_adt(&(*temp).inflows);

}

void init_gov_balance_sheet_adt_static_array(/*@out@*/ gov_balance_sheet_adt * array, int size)
{
	int i;

	for(i = 0; i < size; i++) init_gov_balance_sheet_adt(&array[i]);
}

void free_gov_balance_sheet_adt(gov_balance_sheet_adt * temp)
{
	free_gov_stocks_adt(&(*temp).stocks);
	free_gov_outflows_adt(&(*temp).outflows);
	free_gov_inflows_adt(&(*temp).inflows);

}

void free_gov_balance_sheet_adt_static_array(gov_balance_sheet_adt * array, int size)
{
	int i;

	for(i = 0; i < size; i++) free_gov_balance_sheet_adt(&array[i]);
}

void copy_gov_balance_sheet_adt(gov_balance_sheet_adt * from, gov_balance_sheet_adt * to)
{
	copy_gov_stocks_adt(&(*from).stocks, &(*to).stocks);
	copy_gov_outflows_adt(&(*from).outflows, &(*to).outflows);
	copy_gov_inflows_adt(&(*from).inflows, &(*to).inflows);
}

void copy_gov_balance_sheet_adt_static_array(gov_balance_sheet_adt * from, gov_balance_sheet_adt * to, int size)
{
	int i;

	for(i = 0; i < size; i++)
	{
		copy_gov_balance_sheet_adt(&from[i], &to[i]);
	}
}


void init_ecb_balance_sheet_adt(/*@out@*/ ecb_balance_sheet_adt * temp)
{
	init_ecb_stocks_adt(&(*temp).stocks);
	init_ecb_outflows_adt(&(*temp).outflows);
	init_ecb_inflows_adt(&(*temp).inflows);

}

void init_ecb_balance_sheet_adt_static_array(/*@out@*/ ecb_balance_sheet_adt * array, int size)
{
	int i;

	for(i = 0; i < size; i++) init_ecb_balance_sheet_adt(&array[i]);
}

void free_ecb_balance_sheet_adt(ecb_balance_sheet_adt * temp)
{
	free_ecb_stocks_adt(&(*temp).stocks);
	free_ecb_outflows_adt(&(*temp).outflows);
	free_ecb_inflows_adt(&(*temp).inflows);

}

void free_ecb_balance_sheet_adt_static_array(ecb_balance_sheet_adt * array, int size)
{
	int i;

	for(i = 0; i < size; i++) free_ecb_balance_sheet_adt(&array[i]);
}

void copy_ecb_balance_sheet_adt(ecb_balance_sheet_adt * from, ecb_balance_sheet_adt * to)
{
	copy_ecb_stocks_adt(&(*from).stocks, &(*to).stocks);
	copy_ecb_outflows_adt(&(*from).outflows, &(*to).outflows);
	copy_ecb_inflows_adt(&(*from).inflows, &(*to).inflows);
}

void copy_ecb_balance_sheet_adt_static_array(ecb_balance_sheet_adt * from, ecb_balance_sheet_adt * to, int size)
{
	int i;

	for(i = 0; i < size; i++)
	{
		copy_ecb_balance_sheet_adt(&from[i], &to[i]);
	}
}


void init_adt_subsidies_per_government(/*@out@*/ adt_subsidies_per_government * temp)
{
	(*temp).gov_id = 0;
	(*temp).region_id = 0;
	(*temp).amount = 0.0;

}

void init_adt_subsidies_per_government_static_array(/*@out@*/ adt_subsidies_per_government * array, int size)
{
	int i;

	for(i = 0; i < size; i++) init_adt_subsidies_per_government(&array[i]);
}

void free_adt_subsidies_per_government(adt_subsidies_per_government * temp)
{

}

void free_adt_subsidies_per_government_static_array(adt_subsidies_per_government * array, int size)
{
	int i;

	for(i = 0; i < size; i++) free_adt_subsidies_per_government(&array[i]);
}

void copy_adt_subsidies_per_government(adt_subsidies_per_government * from, adt_subsidies_per_government * to)
{
	(*to).gov_id = (*from).gov_id;
	(*to).region_id = (*from).region_id;
	(*to).amount = (*from).amount;
}

void copy_adt_subsidies_per_government_static_array(adt_subsidies_per_government * from, adt_subsidies_per_government * to, int size)
{
	int i;

	for(i = 0; i < size; i++)
	{
		copy_adt_subsidies_per_government(&from[i], &to[i]);
	}
}


void init_estimated_values_adt(/*@out@*/ estimated_values_adt * temp)
{
	(*temp).no_positive_response = 0;
	(*temp).probability = 0.0;
	(*temp).estimated_fix_costs = 0.0;
	(*temp).estimated_variable_costs = 0.0;
	(*temp).estimated_earnings = 0.0;
	(*temp).additional_capital_Investments_depreciated = 0.0;
	(*temp).mean_specific_skills = 0.0;
	(*temp).mean_wage = 0.0;
	(*temp).no_employees = 0;

}

void init_estimated_values_adt_static_array(/*@out@*/ estimated_values_adt * array, int size)
{
	int i;

	for(i = 0; i < size; i++) init_estimated_values_adt(&array[i]);
}

void free_estimated_values_adt(estimated_values_adt * temp)
{

}

void free_estimated_values_adt_static_array(estimated_values_adt * array, int size)
{
	int i;

	for(i = 0; i < size; i++) free_estimated_values_adt(&array[i]);
}

void copy_estimated_values_adt(estimated_values_adt * from, estimated_values_adt * to)
{
	(*to).no_positive_response = (*from).no_positive_response;
	(*to).probability = (*from).probability;
	(*to).estimated_fix_costs = (*from).estimated_fix_costs;
	(*to).estimated_variable_costs = (*from).estimated_variable_costs;
	(*to).estimated_earnings = (*from).estimated_earnings;
	(*to).additional_capital_Investments_depreciated = (*from).additional_capital_Investments_depreciated;
	(*to).mean_specific_skills = (*from).mean_specific_skills;
	(*to).mean_wage = (*from).mean_wage;
	(*to).no_employees = (*from).no_employees;
}

void copy_estimated_values_adt_static_array(estimated_values_adt * from, estimated_values_adt * to, int size)
{
	int i;

	for(i = 0; i < size; i++)
	{
		copy_estimated_values_adt(&from[i], &to[i]);
	}
}


void init_dt_market_research_price(/*@out@*/ dt_market_research_price * temp)
{
	(*temp).price_change = 0.0;
	(*temp).price = 0.0;
	init_estimated_values_adt_array(&(*temp).estimated_values);

}

void init_dt_market_research_price_static_array(/*@out@*/ dt_market_research_price * array, int size)
{
	int i;

	for(i = 0; i < size; i++) init_dt_market_research_price(&array[i]);
}

void free_dt_market_research_price(dt_market_research_price * temp)
{
	free_estimated_values_adt_array(&(*temp).estimated_values);

}

void free_dt_market_research_price_static_array(dt_market_research_price * array, int size)
{
	int i;

	for(i = 0; i < size; i++) free_dt_market_research_price(&array[i]);
}

void copy_dt_market_research_price(dt_market_research_price * from, dt_market_research_price * to)
{
	(*to).price_change = (*from).price_change;
	(*to).price = (*from).price;
	copy_estimated_values_adt_array(&(*from).estimated_values, &(*to).estimated_values);
}

void copy_dt_market_research_price_static_array(dt_market_research_price * from, dt_market_research_price * to, int size)
{
	int i;

	for(i = 0; i < size; i++)
	{
		copy_dt_market_research_price(&from[i], &to[i]);
	}
}


void init_dt_market_research_qualities(/*@out@*/ dt_market_research_qualities * temp)
{
	(*temp).quality = 0.0;
	init_dt_market_research_price_array(&(*temp).market_research_price);

}

void init_dt_market_research_qualities_static_array(/*@out@*/ dt_market_research_qualities * array, int size)
{
	int i;

	for(i = 0; i < size; i++) init_dt_market_research_qualities(&array[i]);
}

void free_dt_market_research_qualities(dt_market_research_qualities * temp)
{
	free_dt_market_research_price_array(&(*temp).market_research_price);

}

void free_dt_market_research_qualities_static_array(dt_market_research_qualities * array, int size)
{
	int i;

	for(i = 0; i < size; i++) free_dt_market_research_qualities(&array[i]);
}

void copy_dt_market_research_qualities(dt_market_research_qualities * from, dt_market_research_qualities * to)
{
	(*to).quality = (*from).quality;
	copy_dt_market_research_price_array(&(*from).market_research_price, &(*to).market_research_price);
}

void copy_dt_market_research_qualities_static_array(dt_market_research_qualities * from, dt_market_research_qualities * to, int size)
{
	int i;

	for(i = 0; i < size; i++)
	{
		copy_dt_market_research_qualities(&from[i], &to[i]);
	}
}


void init_dt_best_price_strategies(/*@out@*/ dt_best_price_strategies * temp)
{
	(*temp).quality = 0.0;
	(*temp).price = 0.0;
	(*temp).expected_earnings = 0.0;
	(*temp).sum_earnings = 0.0;
	(*temp).sum_expected_earnings_discounted = 0.0;

}

void init_dt_best_price_strategies_static_array(/*@out@*/ dt_best_price_strategies * array, int size)
{
	int i;

	for(i = 0; i < size; i++) init_dt_best_price_strategies(&array[i]);
}

void free_dt_best_price_strategies(dt_best_price_strategies * temp)
{

}

void free_dt_best_price_strategies_static_array(dt_best_price_strategies * array, int size)
{
	int i;

	for(i = 0; i < size; i++) free_dt_best_price_strategies(&array[i]);
}

void copy_dt_best_price_strategies(dt_best_price_strategies * from, dt_best_price_strategies * to)
{
	(*to).quality = (*from).quality;
	(*to).price = (*from).price;
	(*to).expected_earnings = (*from).expected_earnings;
	(*to).sum_earnings = (*from).sum_earnings;
	(*to).sum_expected_earnings_discounted = (*from).sum_expected_earnings_discounted;
}

void copy_dt_best_price_strategies_static_array(dt_best_price_strategies * from, dt_best_price_strategies * to, int size)
{
	int i;

	for(i = 0; i < size; i++)
	{
		copy_dt_best_price_strategies(&from[i], &to[i]);
	}
}


void init_dt_price_range(/*@out@*/ dt_price_range * temp)
{
	(*temp).start_price = 0.0;
	(*temp).end_price = 0.0;
	(*temp).increment = 0.0;

}

void init_dt_price_range_static_array(/*@out@*/ dt_price_range * array, int size)
{
	int i;

	for(i = 0; i < size; i++) init_dt_price_range(&array[i]);
}

void free_dt_price_range(dt_price_range * temp)
{

}

void free_dt_price_range_static_array(dt_price_range * array, int size)
{
	int i;

	for(i = 0; i < size; i++) free_dt_price_range(&array[i]);
}

void copy_dt_price_range(dt_price_range * from, dt_price_range * to)
{
	(*to).start_price = (*from).start_price;
	(*to).end_price = (*from).end_price;
	(*to).increment = (*from).increment;
}

void copy_dt_price_range_static_array(dt_price_range * from, dt_price_range * to, int size)
{
	int i;

	for(i = 0; i < size; i++)
	{
		copy_dt_price_range(&from[i], &to[i]);
	}
}


void init_dt_prospective_variables(/*@out@*/ dt_prospective_variables * temp)
{
	(*temp).mean_specific_skills = 0.0;
	(*temp).estimated_mean_wage = 0.0;
	(*temp).no_employees = 0.0;
	(*temp).earnings = 0.0;
	(*temp).payment_account = 0.0;
	(*temp).buffer = 0.0;
	init_adt_capital_stock_vintages_array(&(*temp).capital_stock_vintages);
	init_financing_capital_array(&(*temp).capital_financing);
	init_debt_item_array(&(*temp).loans);

}

void init_dt_prospective_variables_static_array(/*@out@*/ dt_prospective_variables * array, int size)
{
	int i;

	for(i = 0; i < size; i++) init_dt_prospective_variables(&array[i]);
}

void free_dt_prospective_variables(dt_prospective_variables * temp)
{
	free_adt_capital_stock_vintages_array(&(*temp).capital_stock_vintages);
	free_financing_capital_array(&(*temp).capital_financing);
	free_debt_item_array(&(*temp).loans);

}

void free_dt_prospective_variables_static_array(dt_prospective_variables * array, int size)
{
	int i;

	for(i = 0; i < size; i++) free_dt_prospective_variables(&array[i]);
}

void copy_dt_prospective_variables(dt_prospective_variables * from, dt_prospective_variables * to)
{
	(*to).mean_specific_skills = (*from).mean_specific_skills;
	(*to).estimated_mean_wage = (*from).estimated_mean_wage;
	(*to).no_employees = (*from).no_employees;
	(*to).earnings = (*from).earnings;
	(*to).payment_account = (*from).payment_account;
	(*to).buffer = (*from).buffer;
	copy_adt_capital_stock_vintages_array(&(*from).capital_stock_vintages, &(*to).capital_stock_vintages);
	copy_financing_capital_array(&(*from).capital_financing, &(*to).capital_financing);
	copy_debt_item_array(&(*from).loans, &(*to).loans);
}

void copy_dt_prospective_variables_static_array(dt_prospective_variables * from, dt_prospective_variables * to, int size)
{
	int i;

	for(i = 0; i < size; i++)
	{
		copy_dt_prospective_variables(&from[i], &to[i]);
	}
}


void init_dt_variables_changed(/*@out@*/ dt_variables_changed * temp)
{
	(*temp).price_index = 0.0;
	(*temp).quality_index = 0.0;
	(*temp).productivity_progress = 0.0;

}

void init_dt_variables_changed_static_array(/*@out@*/ dt_variables_changed * array, int size)
{
	int i;

	for(i = 0; i < size; i++) init_dt_variables_changed(&array[i]);
}

void free_dt_variables_changed(dt_variables_changed * temp)
{

}

void free_dt_variables_changed_static_array(dt_variables_changed * array, int size)
{
	int i;

	for(i = 0; i < size; i++) free_dt_variables_changed(&array[i]);
}

void copy_dt_variables_changed(dt_variables_changed * from, dt_variables_changed * to)
{
	(*to).price_index = (*from).price_index;
	(*to).quality_index = (*from).quality_index;
	(*to).productivity_progress = (*from).productivity_progress;
}

void copy_dt_variables_changed_static_array(dt_variables_changed * from, dt_variables_changed * to, int size)
{
	int i;

	for(i = 0; i < size; i++)
	{
		copy_dt_variables_changed(&from[i], &to[i]);
	}
}


void init_dt_innovation_choice(/*@out@*/ dt_innovation_choice * temp)
{
	(*temp).development_period = 0;
	(*temp).employees_needed = 0;
	(*temp).quality = 0.0;
	(*temp).expected_discounted_earnings = 0.0;

}

void init_dt_innovation_choice_static_array(/*@out@*/ dt_innovation_choice * array, int size)
{
	int i;

	for(i = 0; i < size; i++) init_dt_innovation_choice(&array[i]);
}

void free_dt_innovation_choice(dt_innovation_choice * temp)
{

}

void free_dt_innovation_choice_static_array(dt_innovation_choice * array, int size)
{
	int i;

	for(i = 0; i < size; i++) free_dt_innovation_choice(&array[i]);
}

void copy_dt_innovation_choice(dt_innovation_choice * from, dt_innovation_choice * to)
{
	(*to).development_period = (*from).development_period;
	(*to).employees_needed = (*from).employees_needed;
	(*to).quality = (*from).quality;
	(*to).expected_discounted_earnings = (*from).expected_discounted_earnings;
}

void copy_dt_innovation_choice_static_array(dt_innovation_choice * from, dt_innovation_choice * to, int size)
{
	int i;

	for(i = 0; i < size; i++)
	{
		copy_dt_innovation_choice(&from[i], &to[i]);
	}
}


void init_dt_demand_function(/*@out@*/ dt_demand_function * temp)
{
	(*temp).quality = 0.0;
	(*temp).year = 0;
	(*temp).factor = 0.0;
	(*temp).exponent = 0.0;
	(*temp).variance = 0.0;

}

void init_dt_demand_function_static_array(/*@out@*/ dt_demand_function * array, int size)
{
	int i;

	for(i = 0; i < size; i++) init_dt_demand_function(&array[i]);
}

void free_dt_demand_function(dt_demand_function * temp)
{

}

void free_dt_demand_function_static_array(dt_demand_function * array, int size)
{
	int i;

	for(i = 0; i < size; i++) free_dt_demand_function(&array[i]);
}

void copy_dt_demand_function(dt_demand_function * from, dt_demand_function * to)
{
	(*to).quality = (*from).quality;
	(*to).year = (*from).year;
	(*to).factor = (*from).factor;
	(*to).exponent = (*from).exponent;
	(*to).variance = (*from).variance;
}

void copy_dt_demand_function_static_array(dt_demand_function * from, dt_demand_function * to, int size)
{
	int i;

	for(i = 0; i < size; i++)
	{
		copy_dt_demand_function(&from[i], &to[i]);
	}
}


void init_dt_price_quantity_touple(/*@out@*/ dt_price_quantity_touple * temp)
{
	(*temp).price = 0.0;
	(*temp).quantity = 0.0;

}

void init_dt_price_quantity_touple_static_array(/*@out@*/ dt_price_quantity_touple * array, int size)
{
	int i;

	for(i = 0; i < size; i++) init_dt_price_quantity_touple(&array[i]);
}

void free_dt_price_quantity_touple(dt_price_quantity_touple * temp)
{

}

void free_dt_price_quantity_touple_static_array(dt_price_quantity_touple * array, int size)
{
	int i;

	for(i = 0; i < size; i++) free_dt_price_quantity_touple(&array[i]);
}

void copy_dt_price_quantity_touple(dt_price_quantity_touple * from, dt_price_quantity_touple * to)
{
	(*to).price = (*from).price;
	(*to).quantity = (*from).quantity;
}

void copy_dt_price_quantity_touple_static_array(dt_price_quantity_touple * from, dt_price_quantity_touple * to, int size)
{
	int i;

	for(i = 0; i < size; i++)
	{
		copy_dt_price_quantity_touple(&from[i], &to[i]);
	}
}


void init_dt_market_size(/*@out@*/ dt_market_size * temp)
{
	(*temp).period = 0;
	(*temp).market_size = 0.0;

}

void init_dt_market_size_static_array(/*@out@*/ dt_market_size * array, int size)
{
	int i;

	for(i = 0; i < size; i++) init_dt_market_size(&array[i]);
}

void free_dt_market_size(dt_market_size * temp)
{

}

void free_dt_market_size_static_array(dt_market_size * array, int size)
{
	int i;

	for(i = 0; i < size; i++) free_dt_market_size(&array[i]);
}

void copy_dt_market_size(dt_market_size * from, dt_market_size * to)
{
	(*to).period = (*from).period;
	(*to).market_size = (*from).market_size;
}

void copy_dt_market_size_static_array(dt_market_size * from, dt_market_size * to, int size)
{
	int i;

	for(i = 0; i < size; i++)
	{
		copy_dt_market_size(&from[i], &to[i]);
	}
}


void init_dt_total_and_regional_market_size(/*@out@*/ dt_total_and_regional_market_size * temp)
{
	(*temp).region_id = 0;
	(*temp).mall_id = 0;
	init_dt_market_size_array(&(*temp).market_sizes);

}

void init_dt_total_and_regional_market_size_static_array(/*@out@*/ dt_total_and_regional_market_size * array, int size)
{
	int i;

	for(i = 0; i < size; i++) init_dt_total_and_regional_market_size(&array[i]);
}

void free_dt_total_and_regional_market_size(dt_total_and_regional_market_size * temp)
{
	free_dt_market_size_array(&(*temp).market_sizes);

}

void free_dt_total_and_regional_market_size_static_array(dt_total_and_regional_market_size * array, int size)
{
	int i;

	for(i = 0; i < size; i++) free_dt_total_and_regional_market_size(&array[i]);
}

void copy_dt_total_and_regional_market_size(dt_total_and_regional_market_size * from, dt_total_and_regional_market_size * to)
{
	(*to).region_id = (*from).region_id;
	(*to).mall_id = (*from).mall_id;
	copy_dt_market_size_array(&(*from).market_sizes, &(*to).market_sizes);
}

void copy_dt_total_and_regional_market_size_static_array(dt_total_and_regional_market_size * from, dt_total_and_regional_market_size * to, int size)
{
	int i;

	for(i = 0; i < size; i++)
	{
		copy_dt_total_and_regional_market_size(&from[i], &to[i]);
	}
}


void init_dt_value_lattice(/*@out@*/ dt_value_lattice * temp)
{
	(*temp).intermediate_quality = 0.0;
	(*temp).value = 0.0;
	(*temp).strategy = 0;

}

void init_dt_value_lattice_static_array(/*@out@*/ dt_value_lattice * array, int size)
{
	int i;

	for(i = 0; i < size; i++) init_dt_value_lattice(&array[i]);
}

void free_dt_value_lattice(dt_value_lattice * temp)
{

}

void free_dt_value_lattice_static_array(dt_value_lattice * array, int size)
{
	int i;

	for(i = 0; i < size; i++) free_dt_value_lattice(&array[i]);
}

void copy_dt_value_lattice(dt_value_lattice * from, dt_value_lattice * to)
{
	(*to).intermediate_quality = (*from).intermediate_quality;
	(*to).value = (*from).value;
	(*to).strategy = (*from).strategy;
}

void copy_dt_value_lattice_static_array(dt_value_lattice * from, dt_value_lattice * to, int size)
{
	int i;

	for(i = 0; i < size; i++)
	{
		copy_dt_value_lattice(&from[i], &to[i]);
	}
}


void init_dt_value_lattice_years(/*@out@*/ dt_value_lattice_years * temp)
{
	(*temp).year = 0;
	init_dt_value_lattice_array(&(*temp).values);

}

void init_dt_value_lattice_years_static_array(/*@out@*/ dt_value_lattice_years * array, int size)
{
	int i;

	for(i = 0; i < size; i++) init_dt_value_lattice_years(&array[i]);
}

void free_dt_value_lattice_years(dt_value_lattice_years * temp)
{
	free_dt_value_lattice_array(&(*temp).values);

}

void free_dt_value_lattice_years_static_array(dt_value_lattice_years * array, int size)
{
	int i;

	for(i = 0; i < size; i++) free_dt_value_lattice_years(&array[i]);
}

void copy_dt_value_lattice_years(dt_value_lattice_years * from, dt_value_lattice_years * to)
{
	(*to).year = (*from).year;
	copy_dt_value_lattice_array(&(*from).values, &(*to).values);
}

void copy_dt_value_lattice_years_static_array(dt_value_lattice_years * from, dt_value_lattice_years * to, int size)
{
	int i;

	for(i = 0; i < size; i++)
	{
		copy_dt_value_lattice_years(&from[i], &to[i]);
	}
}


void init_dt_monthly_estimations(/*@out@*/ dt_monthly_estimations * temp)
{
	(*temp).output = 0.0;
	(*temp).earnings = 0.0;
	(*temp).sold_quantity = 0.0;
	(*temp).labor_costs = 0.0;
	(*temp).capital_costs = 0.0;
	(*temp).interest_payments = 0.0;
	(*temp).wage = 0.0;
	(*temp).mean_specific_skills = 0.0;
	(*temp).average_productivity = 0.0;
	(*temp).investment_nominal = 0.0;

}

void init_dt_monthly_estimations_static_array(/*@out@*/ dt_monthly_estimations * array, int size)
{
	int i;

	for(i = 0; i < size; i++) init_dt_monthly_estimations(&array[i]);
}

void free_dt_monthly_estimations(dt_monthly_estimations * temp)
{

}

void free_dt_monthly_estimations_static_array(dt_monthly_estimations * array, int size)
{
	int i;

	for(i = 0; i < size; i++) free_dt_monthly_estimations(&array[i]);
}

void copy_dt_monthly_estimations(dt_monthly_estimations * from, dt_monthly_estimations * to)
{
	(*to).output = (*from).output;
	(*to).earnings = (*from).earnings;
	(*to).sold_quantity = (*from).sold_quantity;
	(*to).labor_costs = (*from).labor_costs;
	(*to).capital_costs = (*from).capital_costs;
	(*to).interest_payments = (*from).interest_payments;
	(*to).wage = (*from).wage;
	(*to).mean_specific_skills = (*from).mean_specific_skills;
	(*to).average_productivity = (*from).average_productivity;
	(*to).investment_nominal = (*from).investment_nominal;
}

void copy_dt_monthly_estimations_static_array(dt_monthly_estimations * from, dt_monthly_estimations * to, int size)
{
	int i;

	for(i = 0; i < size; i++)
	{
		copy_dt_monthly_estimations(&from[i], &to[i]);
	}
}



xmachine_memory_Firm_state * init_Firm_state()
{
	xmachine_memory_Firm_state * current = (xmachine_memory_Firm_state *)malloc(sizeof(xmachine_memory_Firm_state));
	CHECK_POINTER(current);

	current->agents = NULL;
	current->count = 0;

	return current;
}

xmachine_memory_Firm * init_Firm_agent()
{
	xmachine_memory_Firm * current = (xmachine_memory_Firm *)malloc(sizeof(xmachine_memory_Firm));
	CHECK_POINTER(current);

	current->id = 0;
	current->region_id = 0;
	current->gov_id = 0;
	current->day_of_month_to_act = 0;
	current->last_day_of_month_to_act = 0;
	current->payment_account = 0.0;
	current->payment_account_balance_sheet = 0.0;
	current->bank_id = 0;
	current->partition_id = 0;
	current->cpi = 0.0;
	current->mean_wage = 0.0;
	current->total_mean_wage = 0.0;
	current->mean_wage_r_and_d = 0.0;
	current->needed_capital_stock = 0.0;
	current->stock = 0.0;
	current->critical_stock = 0.0;
	current->actual_cap_price = 0.0;
	current->mean_specific_skills = 0.0;
	current->planned_production_quantity = 0.0;
	current->production_quantity = 0.0;
	current->planned_output = 0.0;
	current->output = 0.0;
	current->unit_costs = 0.0;
	current->total_supply = 0.0;
	current->production_costs = 0.0;
	current->total_buffer = 0.0;
	current->revenue_per_day = 0.0;
	init_estimators_linear_regression_array(&current->linear_regression_estimators);
	current->technological_frontier = 0.0;
	init_adt_technology_vintages_array(&current->technology_vintages);
	current->vintage_selected = 0;
	current->investment_subsidy_type = 0;
	current->initial_market_size = 0.0;
	current->initial_technology = 0.0;
	current->utilization_capacity = 0.0;
	current->used_capital_units = 0.0;
	current->cum_revenue = 0.0;
	init_sales_statistics_array(&current->malls_sales_statistics);
	current->quality = 0.0;
	current->price = 0.0;
	current->price_last_month = 0.0;
	current->actual_mark_up = 0.0;
	current->demand_capital_stock = 0.0;
	current->effective_investments = 0.0;
	current->effective_capital_stock = 0.0;
	current->planned_production_costs = 0.0;
	current->labour_costs_production = 0.0;
	current->labour_costs_innovation = 0.0;
	current->intermediate_quality_level_developing = 0.0;
	current->adaption_production_volume_due_to_insufficient_finances = 0.0;
	init_sold_quantities_per_mall_array(&current->sold_quantities);
	current->total_sold_quantity = 0.0;
	current->cum_total_sold_quantity = 0.0;
	current->sold_quantity_in_calendar_month = 0.0;
	init_delivery_volume_per_mall_array(&current->delivery_volume);
	init_delivery_volume_per_mall_array(&current->planned_delivery_volume);
	init_mall_info_array(&current->current_mall_stocks);
	init_double_array(&current->last_planned_production_quantities);
	current->total_external_financing_obtained = 0.0;
	current->capital_costs = 0.0;
	current->employees_needed_production = 0;
	current->no_employees_production = 0;
	current->planned_innovation_expenditures = 0.0;
	current->planned_expenditures_production_innovation = 0.0;
	current->labour_costs = 0.0;
	current->labour_costs_per_unit = 0.0;
	init_adt_capital_stock_vintages_array(&current->capital_stock_vintages);
	current->vintage_choice_taken = 0;
	init_financing_capital_array(&current->capital_financing);
	current->financial_resources_for_production = 0.0;
	current->total_units_local_inventory = 0.0;
	current->calc_capital_costs = 0.0;
	current->calc_production_costs = 0.0;
	current->firm_productivity = 0.0;
	current->total_productivity_capital_stock = 0.0;
	current->firm_productivity_last_year = 0.0;
	current->firm_productivity_progress = 0.0;
	current->sold_quantity_in_last_calendar_month = 0.0;
	init_double_array(&current->last_sold_quantities);
	init_double_array(&current->last_revenues);
	init_int_array(&current->set_of_lenders);
	init_int_array(&current->potential_lenders);
	current->number_of_banks_asked = 0;
	current->received_interest_daily = 0.0;
	current->received_interest_in_calendar_month = 0.0;
	current->flag_illiquidity_correction = 0;
	current->ebit = 0.0;
	current->earnings = 0.0;
	current->tax_rate_corporate = 0.0;
	current->tax_rate_vat = 0.0;
	current->tax_payment = 0.0;
	current->tax_payment_in_calendar_month = 0.0;
	current->net_earnings = 0.0;
	init_double_array(&current->earnings_history);
	current->previous_net_earnings = 0.0;
	current->total_interest_payment = 0.0;
	current->total_interest_payment_in_calendar_month = 0.0;
	current->total_debt_installment_payment = 0.0;
	current->total_debt_installment_payment_in_calendar_month = 0.0;
	current->total_dividend_payment = 0.0;
	current->total_dividend_payment_in_calendar_month = 0.0;
	current->flag_full_dividend = 0;
	current->current_share_price = 0.0;
	current->previous_dividend_per_share = 0.0;
	current->current_dividend_per_share = 0.0;
	current->previous_earnings_per_share = 0.0;
	current->current_earnings_per_share = 0.0;
	current->previous_dividend_per_earnings = 0.0;
	current->current_dividend_per_earnings = 0.0;
	current->debt_earnings_ratio = 0.0;
	current->debt_equity_ratio = 0.0;
	current->price_earnings_ratio = 0.0;
	current->retained_earnings_ratio = 0.0;
	current->earnings_per_share_ratio_growth = 0.0;
	current->critical_price_earnings_ratio = 0.0;
	current->critical_earnings_per_share_ratio = 0.0;
	init_debt_item_array(&current->loans);
	current->total_debt = 0.0;
	current->target_debt = 0.0;
	current->total_debt_balance_sheet = 0.0;
	current->total_value_local_inventory = 0.0;
	current->total_value_local_inventory_balance_sheet = 0.0;
	current->total_units_capital_stock = 0.0;
	current->total_value_capital_stock = 0.0;
	current->total_value_capital_stock_balance_sheet = 0.0;
	current->total_capital_depreciation_value = 0.0;
	current->total_capital_depreciation_units = 0.0;
	current->total_assets = 0.0;
	current->equity = 0.0;
	current->equity_balance_sheet = 0.0;
	current->production_liquidity_needs = 0.0;
	current->financial_liquidity_needs = 0.0;
	current->total_financial_needs = 0.0;
	current->external_financial_needs = 0.0;
	current->earnings_per_share = 0.0;
	current->retained_earnings = 0.0;
	current->total_payments = 0.0;
	current->previous_shares_outstanding = 0;
	current->minsky_state = 0;
	current->minsky_state_1 = 0;
	current->minsky_state_2 = 0;
	current->minsky_state_3 = 0;
	current->minsky_state_4 = 0;
	current->minsky_state_5 = 0;
	current->minsky_state_20 = 0;
	current->minsky_state_21 = 0;
	current->minsky_state_22 = 0;
	current->minsky_state_23 = 0;
	current->minsky_state_30 = 0;
	current->minsky_state_31 = 0;
	current->minsky_state_32 = 0;
	current->minsky_state_33 = 0;
	current->minsky_state_40 = 0;
	current->minsky_state_41 = 0;
	current->minsky_state_42 = 0;
	current->minsky_state_43 = 0;
	current->age_at_bankruptcy = 0;
	current->debt_at_bankruptcy = 0.0;
	current->equity_at_bankruptcy = 0.0;
	current->no_employees_at_bankruptcy = 0;
	current->equity_asset_ratio = 0.0;
	current->profit_asset_ratio = 0.0;
	current->sales_asset_ratio = 0.0;
	current->investment_asset_ratio = 0.0;
	current->total_income = 0.0;
	current->total_liabilities = 0.0;
	current->total_expenses = 0.0;
	current->current_shares_outstanding = 0;
	init_employee_array(&current->employees);
	init_employee_array(&current->r_and_d_employees);
	current->wage_offer = 0.0;
	current->technology = 0.0;
	current->no_employees = 0;
	current->no_employees_skill_1 = 0;
	current->no_employees_skill_2 = 0;
	current->no_employees_skill_3 = 0;
	current->no_employees_skill_4 = 0;
	current->no_employees_skill_5 = 0;
	current->no_employees_subsidized = 0;
	current->fraction_employees_subsidized = 0.0;
	current->vacancies = 0;
	current->no_redundancies = 0;
	current->no_applications_round_1 = 0;
	current->no_applications_round_2 = 0;
	current->no_redundancies_r_and_d_employees = 0;
	current->vacancies_r_and_d_employees = 0;
	current->posted_vacancies = 0;
	current->posted_vacancies_r_and_d_employees = 0;
	current->average_g_skill = 0.0;
	current->average_adaptation_speed_specific_skills = 0.0;
	init_adt_list_adaptation_speed_array(&current->list_adaptation_speed_per_skill_group);
	current->average_s_skill_of_1 = 0.0;
	current->average_s_skill_of_2 = 0.0;
	current->average_s_skill_of_3 = 0.0;
	current->average_s_skill_of_4 = 0.0;
	current->average_s_skill_of_5 = 0.0;
	current->wage_offer_for_skill_1 = 0.0;
	current->wage_offer_for_skill_2 = 0.0;
	current->wage_offer_for_skill_3 = 0.0;
	current->wage_offer_for_skill_4 = 0.0;
	current->wage_offer_for_skill_5 = 0.0;
	current->wage_offer_for_r_and_d_employees = 0.0;
	current->base_wage_offer_r_and_d = 0.0;
	current->employees_needed = 0;
	init_firm_balance_sheet_adt(&current->firm_balance_sheet_calendar);
	init_firm_stocks_adt(&current->firm_stocks_calendar);
	init_firm_outflows_adt(&current->firm_outflows_calendar);
	init_firm_inflows_adt(&current->firm_inflows_calendar);
	current->age = 0;
	current->transfer_payment = 0.0;
	current->subsidy_pct = 0.0;
	current->active = 0;
	current->inactive = 0;
	current->zero_output = 0;
	current->bankruptcy_idle_counter = 0;
	current->bankruptcy_state = 0;
	current->bankruptcy_insolvency_state = 0;
	current->bankruptcy_illiquidity_state = 0;
	current->financial_crisis_state = 0;
	current->vacancy_filling_rate = 0.0;
	current->average_s_skill_from_eurostat = 0.0;
	current->average_technology_from_eurostat = 0.0;
	current->average_wage_offer_from_eurostat = 0.0;
	current->average_output_from_eurostat = 0.0;
	init_price_quality_pair_array(&current->quality_price_competitors);
	current->subsidy_payment = 0.0;
	current->current_price_index = 0.0;
	current->current_quality_index = 0.0;
	current->minimum_wage = 0.0;
	current->no_competitors = 0;
	current->indicator_earnings = 0;
	current->indicator_capital_costs = 0;
	current->agg_vacancy_filling_rate = 0.0;
	current->market_research_sample_size = 0;
	current->product_innovation = 0;
	current->regional_analysis = 0;
	current->day_of_year_market_research = 0;
	current->day_of_month_price_was_set = 0;
	current->actual_sample_size = 0;
	init_dt_total_and_regional_market_size_array(&current->last_market_sizes);
	init_dt_price_range(&current->price_range_pricing);
	current->estimated_variance_market_share = 0.0;
	init_price_quality_pair(&current->estimated_coefficients);
	init_dt_price_range(&current->price_range_innovation);
	init_int_static_array(current->price_quality_counts, 12);
	init_price_quality_pair_static_array(current->price_quality_inno, 12);
	current->new_product_released = 0;
	init_dt_prospective_variables_array(&current->prospective_variables);
	current->price_at_questionnaire = 0.0;
	current->price_index_at_questionnaire = 0.0;
	init_dt_best_price_strategies_array(&current->best_pricing_strategies);
	current->intermediate_quality = 0.0;
	current->no_employees_product_innovation_fundable = 0;
	current->r_and_d_probability_for_incremental_success = 0.0;
	current->day_of_year_price_setting = 0;
	current->market_research_active = 0;
	current->innovation_successful = 0;
	current->actual_market_share = 0.0;
	current->market_size = 0.0;
	current->market_size_reg1 = 0.0;
	current->market_size_reg2 = 0.0;
	current->estimated_market_size = 0.0;
	init_estimators_linear_regression_array(&current->linear_regression_market_size);
	current->counter_month_since_last_price_setting = 0;
	init_dt_demand_function(&current->demand_function_pricing);
	init_dt_demand_function_array(&current->demand_functions_product_innovation);
	current->market_research_delayed = 0;
	init_dt_market_research_price_array(&current->market_research_data_pricing);
	init_dt_market_research_qualities_array(&current->market_research_data_product_innovation);
	current->expected_earnings_per_month = 0.0;
	init_double_array(&current->expected_price_choices);
	current->no_considered_qualities = 0.0;
	current->last_interest_rate_for_loans = 0.0;
	current->cum_earnings_last_r_d_project = 0.0;
	current->cum_r_d_investments = 0.0;
	current->r_d_investments_last_project = 0.0;
	current->total_person_months = 0;
	current->cum_person_months = 0;
	current->actual_r_and_d_success_probability = 0.0;
	current->last_quality = 0.0;
	current->quality_change = 0.0;
	current->expected_sold_quantity_per_month = 0.0;
	current->estimated_market_share = 0.0;
	current->estimated_yearly_earnings = 0.0;
	init_dt_monthly_estimations_static_array(current->expected_earnings_and_costs_over_year, 12);
	current->expected_output_in_current_month = 0.0;
	current->expected_profit_in_current_month = 0.0;
	current->expected_labor_costs_in_current_month = 0.0;
	current->expected_capital_costs_in_current_month = 0.0;
	current->expected_interests_in_current_month = 0.0;
	current->expected_output_in_previous_month = 0.0;
	current->expected_actual_sold_quantity_in_previous_month = 0.0;
	current->expected_actual_sold_quantity_in_current_month = 0.0;
	current->expected_labor_costs_in_previous_month = 0.0;
	current->expected_capital_costs_in_previous_month = 0.0;
	current->expected_interests_in_previous_month = 0.0;
	current->expected_profit_in_previous_month = 0.0;
	current->expected_wage_in_current_month = 0.0;
	current->expected_wage_in_previous_month = 0.0;
	current->expected_mean_specific_skills_in_current_month = 0.0;
	current->expected_mean_specific_skills_in_previous_month = 0.0;
	current->expected_average_productivity_in_current_month = 0.0;
	current->expected_investment_nominal_in_current_month = 0.0;
	current->expected_investment_nominal_in_previous_month = 0.0;
	current->expected_average_productivity_in_previous_month = 0.0;
	current->earnings_while_last_pricing_period = 0.0;
	current->sum_earnings_since_price_change = 0.0;
	init_dt_variables_changed_array(&current->variables_last_year);
	current->innovation_month_counter = 0;
	current->periods_output_zero_counter = 0;
	init_dt_variables_changed(&current->variables_change);
	current->r_and_d_investments_per_month = 0.0;
	current->innovation_flag = 0;
	current->innovation_employees_needed = 0;
	current->no_employees_innovation = 0;
	current->employees_needed_innovation = 0;
	current->optimal_employees_needed_innovation = 0;
	current->total_no_periods_for_product_development = 0;
	current->ratio_project_value_established_product = 0.0;
	current->vintage_choice_already_taken = 0;
	current->change_due_to_last_innovation = 0.0;
	current->remaining_periods_to_complete_product_development = 0;
	current->planned_quality = 0.0;
	current->product_development_completed = 0.0;
	current->price_just_set_flag = 0.0;
	init_dt_value_lattice_years_array(&current->value_lattice);
	current->combined_variance_demand_function = 0.0;

	return current;
}

void free_Firm_agent(xmachine_memory_Firm_holder * tmp, xmachine_memory_Firm_state * state)
{
	if(tmp->prev == NULL) state->agents = tmp->next;
	else tmp->prev->next = tmp->next;
	if(tmp->next != NULL) tmp->next->prev = tmp->prev;

	free_estimators_linear_regression_array(&tmp->agent->linear_regression_estimators);
	free_adt_technology_vintages_array(&tmp->agent->technology_vintages);
	free_sales_statistics_array(&tmp->agent->malls_sales_statistics);
	free_sold_quantities_per_mall_array(&tmp->agent->sold_quantities);
	free_delivery_volume_per_mall_array(&tmp->agent->delivery_volume);
	free_delivery_volume_per_mall_array(&tmp->agent->planned_delivery_volume);
	free_mall_info_array(&tmp->agent->current_mall_stocks);
	free_double_array(&tmp->agent->last_planned_production_quantities);
	free_adt_capital_stock_vintages_array(&tmp->agent->capital_stock_vintages);
	free_financing_capital_array(&tmp->agent->capital_financing);
	free_double_array(&tmp->agent->last_sold_quantities);
	free_double_array(&tmp->agent->last_revenues);
	free_int_array(&tmp->agent->set_of_lenders);
	free_int_array(&tmp->agent->potential_lenders);
	free_double_array(&tmp->agent->earnings_history);
	free_debt_item_array(&tmp->agent->loans);
	free_employee_array(&tmp->agent->employees);
	free_employee_array(&tmp->agent->r_and_d_employees);
	free_adt_list_adaptation_speed_array(&tmp->agent->list_adaptation_speed_per_skill_group);
	free_firm_balance_sheet_adt(&tmp->agent->firm_balance_sheet_calendar);
	free_firm_stocks_adt(&tmp->agent->firm_stocks_calendar);
	free_firm_outflows_adt(&tmp->agent->firm_outflows_calendar);
	free_firm_inflows_adt(&tmp->agent->firm_inflows_calendar);
	free_price_quality_pair_array(&tmp->agent->quality_price_competitors);
	free_dt_total_and_regional_market_size_array(&tmp->agent->last_market_sizes);
	free_dt_price_range(&tmp->agent->price_range_pricing);
	free_price_quality_pair(&tmp->agent->estimated_coefficients);
	free_dt_price_range(&tmp->agent->price_range_innovation);
	free_price_quality_pair_static_array(tmp->agent->price_quality_inno, 12);
	free_dt_prospective_variables_array(&tmp->agent->prospective_variables);
	free_dt_best_price_strategies_array(&tmp->agent->best_pricing_strategies);
	free_estimators_linear_regression_array(&tmp->agent->linear_regression_market_size);
	free_dt_demand_function(&tmp->agent->demand_function_pricing);
	free_dt_demand_function_array(&tmp->agent->demand_functions_product_innovation);
	free_dt_market_research_price_array(&tmp->agent->market_research_data_pricing);
	free_dt_market_research_qualities_array(&tmp->agent->market_research_data_product_innovation);
	free_double_array(&tmp->agent->expected_price_choices);
	free_dt_monthly_estimations_static_array(tmp->agent->expected_earnings_and_costs_over_year, 12);
	free_dt_variables_changed_array(&tmp->agent->variables_last_year);
	free_dt_variables_changed(&tmp->agent->variables_change);
	free_dt_value_lattice_years_array(&tmp->agent->value_lattice);
	

	free(tmp->agent);
	free(tmp);
}

void unittest_init_Firm_agent()
{
	current_xmachine_Firm = (xmachine_memory_Firm *)malloc(sizeof(xmachine_memory_Firm));
	CHECK_POINTER(current);

		current_xmachine_Firm->id = 0;
		current_xmachine_Firm->region_id = 0;
		current_xmachine_Firm->gov_id = 0;
		current_xmachine_Firm->day_of_month_to_act = 0;
		current_xmachine_Firm->last_day_of_month_to_act = 0;
		current_xmachine_Firm->payment_account = 0.0;
		current_xmachine_Firm->payment_account_balance_sheet = 0.0;
		current_xmachine_Firm->bank_id = 0;
		current_xmachine_Firm->partition_id = 0;
		current_xmachine_Firm->cpi = 0.0;
		current_xmachine_Firm->mean_wage = 0.0;
		current_xmachine_Firm->total_mean_wage = 0.0;
		current_xmachine_Firm->mean_wage_r_and_d = 0.0;
		current_xmachine_Firm->needed_capital_stock = 0.0;
		current_xmachine_Firm->stock = 0.0;
		current_xmachine_Firm->critical_stock = 0.0;
		current_xmachine_Firm->actual_cap_price = 0.0;
		current_xmachine_Firm->mean_specific_skills = 0.0;
		current_xmachine_Firm->planned_production_quantity = 0.0;
		current_xmachine_Firm->production_quantity = 0.0;
		current_xmachine_Firm->planned_output = 0.0;
		current_xmachine_Firm->output = 0.0;
		current_xmachine_Firm->unit_costs = 0.0;
		current_xmachine_Firm->total_supply = 0.0;
		current_xmachine_Firm->production_costs = 0.0;
		current_xmachine_Firm->total_buffer = 0.0;
		current_xmachine_Firm->revenue_per_day = 0.0;
		init_estimators_linear_regression_array(&current_xmachine_Firm->linear_regression_estimators);
		current_xmachine_Firm->technological_frontier = 0.0;
		init_adt_technology_vintages_array(&current_xmachine_Firm->technology_vintages);
		current_xmachine_Firm->vintage_selected = 0;
		current_xmachine_Firm->investment_subsidy_type = 0;
		current_xmachine_Firm->initial_market_size = 0.0;
		current_xmachine_Firm->initial_technology = 0.0;
		current_xmachine_Firm->utilization_capacity = 0.0;
		current_xmachine_Firm->used_capital_units = 0.0;
		current_xmachine_Firm->cum_revenue = 0.0;
		init_sales_statistics_array(&current_xmachine_Firm->malls_sales_statistics);
		current_xmachine_Firm->quality = 0.0;
		current_xmachine_Firm->price = 0.0;
		current_xmachine_Firm->price_last_month = 0.0;
		current_xmachine_Firm->actual_mark_up = 0.0;
		current_xmachine_Firm->demand_capital_stock = 0.0;
		current_xmachine_Firm->effective_investments = 0.0;
		current_xmachine_Firm->effective_capital_stock = 0.0;
		current_xmachine_Firm->planned_production_costs = 0.0;
		current_xmachine_Firm->labour_costs_production = 0.0;
		current_xmachine_Firm->labour_costs_innovation = 0.0;
		current_xmachine_Firm->intermediate_quality_level_developing = 0.0;
		current_xmachine_Firm->adaption_production_volume_due_to_insufficient_finances = 0.0;
		init_sold_quantities_per_mall_array(&current_xmachine_Firm->sold_quantities);
		current_xmachine_Firm->total_sold_quantity = 0.0;
		current_xmachine_Firm->cum_total_sold_quantity = 0.0;
		current_xmachine_Firm->sold_quantity_in_calendar_month = 0.0;
		init_delivery_volume_per_mall_array(&current_xmachine_Firm->delivery_volume);
		init_delivery_volume_per_mall_array(&current_xmachine_Firm->planned_delivery_volume);
		init_mall_info_array(&current_xmachine_Firm->current_mall_stocks);
		init_double_array(&current_xmachine_Firm->last_planned_production_quantities);
		current_xmachine_Firm->total_external_financing_obtained = 0.0;
		current_xmachine_Firm->capital_costs = 0.0;
		current_xmachine_Firm->employees_needed_production = 0;
		current_xmachine_Firm->no_employees_production = 0;
		current_xmachine_Firm->planned_innovation_expenditures = 0.0;
		current_xmachine_Firm->planned_expenditures_production_innovation = 0.0;
		current_xmachine_Firm->labour_costs = 0.0;
		current_xmachine_Firm->labour_costs_per_unit = 0.0;
		init_adt_capital_stock_vintages_array(&current_xmachine_Firm->capital_stock_vintages);
		current_xmachine_Firm->vintage_choice_taken = 0;
		init_financing_capital_array(&current_xmachine_Firm->capital_financing);
		current_xmachine_Firm->financial_resources_for_production = 0.0;
		current_xmachine_Firm->total_units_local_inventory = 0.0;
		current_xmachine_Firm->calc_capital_costs = 0.0;
		current_xmachine_Firm->calc_production_costs = 0.0;
		current_xmachine_Firm->firm_productivity = 0.0;
		current_xmachine_Firm->total_productivity_capital_stock = 0.0;
		current_xmachine_Firm->firm_productivity_last_year = 0.0;
		current_xmachine_Firm->firm_productivity_progress = 0.0;
		current_xmachine_Firm->sold_quantity_in_last_calendar_month = 0.0;
		init_double_array(&current_xmachine_Firm->last_sold_quantities);
		init_double_array(&current_xmachine_Firm->last_revenues);
		init_int_array(&current_xmachine_Firm->set_of_lenders);
		init_int_array(&current_xmachine_Firm->potential_lenders);
		current_xmachine_Firm->number_of_banks_asked = 0;
		current_xmachine_Firm->received_interest_daily = 0.0;
		current_xmachine_Firm->received_interest_in_calendar_month = 0.0;
		current_xmachine_Firm->flag_illiquidity_correction = 0;
		current_xmachine_Firm->ebit = 0.0;
		current_xmachine_Firm->earnings = 0.0;
		current_xmachine_Firm->tax_rate_corporate = 0.0;
		current_xmachine_Firm->tax_rate_vat = 0.0;
		current_xmachine_Firm->tax_payment = 0.0;
		current_xmachine_Firm->tax_payment_in_calendar_month = 0.0;
		current_xmachine_Firm->net_earnings = 0.0;
		init_double_array(&current_xmachine_Firm->earnings_history);
		current_xmachine_Firm->previous_net_earnings = 0.0;
		current_xmachine_Firm->total_interest_payment = 0.0;
		current_xmachine_Firm->total_interest_payment_in_calendar_month = 0.0;
		current_xmachine_Firm->total_debt_installment_payment = 0.0;
		current_xmachine_Firm->total_debt_installment_payment_in_calendar_month = 0.0;
		current_xmachine_Firm->total_dividend_payment = 0.0;
		current_xmachine_Firm->total_dividend_payment_in_calendar_month = 0.0;
		current_xmachine_Firm->flag_full_dividend = 0;
		current_xmachine_Firm->current_share_price = 0.0;
		current_xmachine_Firm->previous_dividend_per_share = 0.0;
		current_xmachine_Firm->current_dividend_per_share = 0.0;
		current_xmachine_Firm->previous_earnings_per_share = 0.0;
		current_xmachine_Firm->current_earnings_per_share = 0.0;
		current_xmachine_Firm->previous_dividend_per_earnings = 0.0;
		current_xmachine_Firm->current_dividend_per_earnings = 0.0;
		current_xmachine_Firm->debt_earnings_ratio = 0.0;
		current_xmachine_Firm->debt_equity_ratio = 0.0;
		current_xmachine_Firm->price_earnings_ratio = 0.0;
		current_xmachine_Firm->retained_earnings_ratio = 0.0;
		current_xmachine_Firm->earnings_per_share_ratio_growth = 0.0;
		current_xmachine_Firm->critical_price_earnings_ratio = 0.0;
		current_xmachine_Firm->critical_earnings_per_share_ratio = 0.0;
		init_debt_item_array(&current_xmachine_Firm->loans);
		current_xmachine_Firm->total_debt = 0.0;
		current_xmachine_Firm->target_debt = 0.0;
		current_xmachine_Firm->total_debt_balance_sheet = 0.0;
		current_xmachine_Firm->total_value_local_inventory = 0.0;
		current_xmachine_Firm->total_value_local_inventory_balance_sheet = 0.0;
		current_xmachine_Firm->total_units_capital_stock = 0.0;
		current_xmachine_Firm->total_value_capital_stock = 0.0;
		current_xmachine_Firm->total_value_capital_stock_balance_sheet = 0.0;
		current_xmachine_Firm->total_capital_depreciation_value = 0.0;
		current_xmachine_Firm->total_capital_depreciation_units = 0.0;
		current_xmachine_Firm->total_assets = 0.0;
		current_xmachine_Firm->equity = 0.0;
		current_xmachine_Firm->equity_balance_sheet = 0.0;
		current_xmachine_Firm->production_liquidity_needs = 0.0;
		current_xmachine_Firm->financial_liquidity_needs = 0.0;
		current_xmachine_Firm->total_financial_needs = 0.0;
		current_xmachine_Firm->external_financial_needs = 0.0;
		current_xmachine_Firm->earnings_per_share = 0.0;
		current_xmachine_Firm->retained_earnings = 0.0;
		current_xmachine_Firm->total_payments = 0.0;
		current_xmachine_Firm->previous_shares_outstanding = 0;
		current_xmachine_Firm->minsky_state = 0;
		current_xmachine_Firm->minsky_state_1 = 0;
		current_xmachine_Firm->minsky_state_2 = 0;
		current_xmachine_Firm->minsky_state_3 = 0;
		current_xmachine_Firm->minsky_state_4 = 0;
		current_xmachine_Firm->minsky_state_5 = 0;
		current_xmachine_Firm->minsky_state_20 = 0;
		current_xmachine_Firm->minsky_state_21 = 0;
		current_xmachine_Firm->minsky_state_22 = 0;
		current_xmachine_Firm->minsky_state_23 = 0;
		current_xmachine_Firm->minsky_state_30 = 0;
		current_xmachine_Firm->minsky_state_31 = 0;
		current_xmachine_Firm->minsky_state_32 = 0;
		current_xmachine_Firm->minsky_state_33 = 0;
		current_xmachine_Firm->minsky_state_40 = 0;
		current_xmachine_Firm->minsky_state_41 = 0;
		current_xmachine_Firm->minsky_state_42 = 0;
		current_xmachine_Firm->minsky_state_43 = 0;
		current_xmachine_Firm->age_at_bankruptcy = 0;
		current_xmachine_Firm->debt_at_bankruptcy = 0.0;
		current_xmachine_Firm->equity_at_bankruptcy = 0.0;
		current_xmachine_Firm->no_employees_at_bankruptcy = 0;
		current_xmachine_Firm->equity_asset_ratio = 0.0;
		current_xmachine_Firm->profit_asset_ratio = 0.0;
		current_xmachine_Firm->sales_asset_ratio = 0.0;
		current_xmachine_Firm->investment_asset_ratio = 0.0;
		current_xmachine_Firm->total_income = 0.0;
		current_xmachine_Firm->total_liabilities = 0.0;
		current_xmachine_Firm->total_expenses = 0.0;
		current_xmachine_Firm->current_shares_outstanding = 0;
		init_employee_array(&current_xmachine_Firm->employees);
		init_employee_array(&current_xmachine_Firm->r_and_d_employees);
		current_xmachine_Firm->wage_offer = 0.0;
		current_xmachine_Firm->technology = 0.0;
		current_xmachine_Firm->no_employees = 0;
		current_xmachine_Firm->no_employees_skill_1 = 0;
		current_xmachine_Firm->no_employees_skill_2 = 0;
		current_xmachine_Firm->no_employees_skill_3 = 0;
		current_xmachine_Firm->no_employees_skill_4 = 0;
		current_xmachine_Firm->no_employees_skill_5 = 0;
		current_xmachine_Firm->no_employees_subsidized = 0;
		current_xmachine_Firm->fraction_employees_subsidized = 0.0;
		current_xmachine_Firm->vacancies = 0;
		current_xmachine_Firm->no_redundancies = 0;
		current_xmachine_Firm->no_applications_round_1 = 0;
		current_xmachine_Firm->no_applications_round_2 = 0;
		current_xmachine_Firm->no_redundancies_r_and_d_employees = 0;
		current_xmachine_Firm->vacancies_r_and_d_employees = 0;
		current_xmachine_Firm->posted_vacancies = 0;
		current_xmachine_Firm->posted_vacancies_r_and_d_employees = 0;
		current_xmachine_Firm->average_g_skill = 0.0;
		current_xmachine_Firm->average_adaptation_speed_specific_skills = 0.0;
		init_adt_list_adaptation_speed_array(&current_xmachine_Firm->list_adaptation_speed_per_skill_group);
		current_xmachine_Firm->average_s_skill_of_1 = 0.0;
		current_xmachine_Firm->average_s_skill_of_2 = 0.0;
		current_xmachine_Firm->average_s_skill_of_3 = 0.0;
		current_xmachine_Firm->average_s_skill_of_4 = 0.0;
		current_xmachine_Firm->average_s_skill_of_5 = 0.0;
		current_xmachine_Firm->wage_offer_for_skill_1 = 0.0;
		current_xmachine_Firm->wage_offer_for_skill_2 = 0.0;
		current_xmachine_Firm->wage_offer_for_skill_3 = 0.0;
		current_xmachine_Firm->wage_offer_for_skill_4 = 0.0;
		current_xmachine_Firm->wage_offer_for_skill_5 = 0.0;
		current_xmachine_Firm->wage_offer_for_r_and_d_employees = 0.0;
		current_xmachine_Firm->base_wage_offer_r_and_d = 0.0;
		current_xmachine_Firm->employees_needed = 0;
		init_firm_balance_sheet_adt(&current_xmachine_Firm->firm_balance_sheet_calendar);
		init_firm_stocks_adt(&current_xmachine_Firm->firm_stocks_calendar);
		init_firm_outflows_adt(&current_xmachine_Firm->firm_outflows_calendar);
		init_firm_inflows_adt(&current_xmachine_Firm->firm_inflows_calendar);
		current_xmachine_Firm->age = 0;
		current_xmachine_Firm->transfer_payment = 0.0;
		current_xmachine_Firm->subsidy_pct = 0.0;
		current_xmachine_Firm->active = 0;
		current_xmachine_Firm->inactive = 0;
		current_xmachine_Firm->zero_output = 0;
		current_xmachine_Firm->bankruptcy_idle_counter = 0;
		current_xmachine_Firm->bankruptcy_state = 0;
		current_xmachine_Firm->bankruptcy_insolvency_state = 0;
		current_xmachine_Firm->bankruptcy_illiquidity_state = 0;
		current_xmachine_Firm->financial_crisis_state = 0;
		current_xmachine_Firm->vacancy_filling_rate = 0.0;
		current_xmachine_Firm->average_s_skill_from_eurostat = 0.0;
		current_xmachine_Firm->average_technology_from_eurostat = 0.0;
		current_xmachine_Firm->average_wage_offer_from_eurostat = 0.0;
		current_xmachine_Firm->average_output_from_eurostat = 0.0;
		init_price_quality_pair_array(&current_xmachine_Firm->quality_price_competitors);
		current_xmachine_Firm->subsidy_payment = 0.0;
		current_xmachine_Firm->current_price_index = 0.0;
		current_xmachine_Firm->current_quality_index = 0.0;
		current_xmachine_Firm->minimum_wage = 0.0;
		current_xmachine_Firm->no_competitors = 0;
		current_xmachine_Firm->indicator_earnings = 0;
		current_xmachine_Firm->indicator_capital_costs = 0;
		current_xmachine_Firm->agg_vacancy_filling_rate = 0.0;
		current_xmachine_Firm->market_research_sample_size = 0;
		current_xmachine_Firm->product_innovation = 0;
		current_xmachine_Firm->regional_analysis = 0;
		current_xmachine_Firm->day_of_year_market_research = 0;
		current_xmachine_Firm->day_of_month_price_was_set = 0;
		current_xmachine_Firm->actual_sample_size = 0;
		init_dt_total_and_regional_market_size_array(&current_xmachine_Firm->last_market_sizes);
		init_dt_price_range(&current_xmachine_Firm->price_range_pricing);
		current_xmachine_Firm->estimated_variance_market_share = 0.0;
		init_price_quality_pair(&current_xmachine_Firm->estimated_coefficients);
		init_dt_price_range(&current_xmachine_Firm->price_range_innovation);
		init_int_static_array(current_xmachine_Firm->price_quality_counts, 12);
		init_price_quality_pair_static_array(current_xmachine_Firm->price_quality_inno, 12);
		current_xmachine_Firm->new_product_released = 0;
		init_dt_prospective_variables_array(&current_xmachine_Firm->prospective_variables);
		current_xmachine_Firm->price_at_questionnaire = 0.0;
		current_xmachine_Firm->price_index_at_questionnaire = 0.0;
		init_dt_best_price_strategies_array(&current_xmachine_Firm->best_pricing_strategies);
		current_xmachine_Firm->intermediate_quality = 0.0;
		current_xmachine_Firm->no_employees_product_innovation_fundable = 0;
		current_xmachine_Firm->r_and_d_probability_for_incremental_success = 0.0;
		current_xmachine_Firm->day_of_year_price_setting = 0;
		current_xmachine_Firm->market_research_active = 0;
		current_xmachine_Firm->innovation_successful = 0;
		current_xmachine_Firm->actual_market_share = 0.0;
		current_xmachine_Firm->market_size = 0.0;
		current_xmachine_Firm->market_size_reg1 = 0.0;
		current_xmachine_Firm->market_size_reg2 = 0.0;
		current_xmachine_Firm->estimated_market_size = 0.0;
		init_estimators_linear_regression_array(&current_xmachine_Firm->linear_regression_market_size);
		current_xmachine_Firm->counter_month_since_last_price_setting = 0;
		init_dt_demand_function(&current_xmachine_Firm->demand_function_pricing);
		init_dt_demand_function_array(&current_xmachine_Firm->demand_functions_product_innovation);
		current_xmachine_Firm->market_research_delayed = 0;
		init_dt_market_research_price_array(&current_xmachine_Firm->market_research_data_pricing);
		init_dt_market_research_qualities_array(&current_xmachine_Firm->market_research_data_product_innovation);
		current_xmachine_Firm->expected_earnings_per_month = 0.0;
		init_double_array(&current_xmachine_Firm->expected_price_choices);
		current_xmachine_Firm->no_considered_qualities = 0.0;
		current_xmachine_Firm->last_interest_rate_for_loans = 0.0;
		current_xmachine_Firm->cum_earnings_last_r_d_project = 0.0;
		current_xmachine_Firm->cum_r_d_investments = 0.0;
		current_xmachine_Firm->r_d_investments_last_project = 0.0;
		current_xmachine_Firm->total_person_months = 0;
		current_xmachine_Firm->cum_person_months = 0;
		current_xmachine_Firm->actual_r_and_d_success_probability = 0.0;
		current_xmachine_Firm->last_quality = 0.0;
		current_xmachine_Firm->quality_change = 0.0;
		current_xmachine_Firm->expected_sold_quantity_per_month = 0.0;
		current_xmachine_Firm->estimated_market_share = 0.0;
		current_xmachine_Firm->estimated_yearly_earnings = 0.0;
		init_dt_monthly_estimations_static_array(current_xmachine_Firm->expected_earnings_and_costs_over_year, 12);
		current_xmachine_Firm->expected_output_in_current_month = 0.0;
		current_xmachine_Firm->expected_profit_in_current_month = 0.0;
		current_xmachine_Firm->expected_labor_costs_in_current_month = 0.0;
		current_xmachine_Firm->expected_capital_costs_in_current_month = 0.0;
		current_xmachine_Firm->expected_interests_in_current_month = 0.0;
		current_xmachine_Firm->expected_output_in_previous_month = 0.0;
		current_xmachine_Firm->expected_actual_sold_quantity_in_previous_month = 0.0;
		current_xmachine_Firm->expected_actual_sold_quantity_in_current_month = 0.0;
		current_xmachine_Firm->expected_labor_costs_in_previous_month = 0.0;
		current_xmachine_Firm->expected_capital_costs_in_previous_month = 0.0;
		current_xmachine_Firm->expected_interests_in_previous_month = 0.0;
		current_xmachine_Firm->expected_profit_in_previous_month = 0.0;
		current_xmachine_Firm->expected_wage_in_current_month = 0.0;
		current_xmachine_Firm->expected_wage_in_previous_month = 0.0;
		current_xmachine_Firm->expected_mean_specific_skills_in_current_month = 0.0;
		current_xmachine_Firm->expected_mean_specific_skills_in_previous_month = 0.0;
		current_xmachine_Firm->expected_average_productivity_in_current_month = 0.0;
		current_xmachine_Firm->expected_investment_nominal_in_current_month = 0.0;
		current_xmachine_Firm->expected_investment_nominal_in_previous_month = 0.0;
		current_xmachine_Firm->expected_average_productivity_in_previous_month = 0.0;
		current_xmachine_Firm->earnings_while_last_pricing_period = 0.0;
		current_xmachine_Firm->sum_earnings_since_price_change = 0.0;
		init_dt_variables_changed_array(&current_xmachine_Firm->variables_last_year);
		current_xmachine_Firm->innovation_month_counter = 0;
		current_xmachine_Firm->periods_output_zero_counter = 0;
		init_dt_variables_changed(&current_xmachine_Firm->variables_change);
		current_xmachine_Firm->r_and_d_investments_per_month = 0.0;
		current_xmachine_Firm->innovation_flag = 0;
		current_xmachine_Firm->innovation_employees_needed = 0;
		current_xmachine_Firm->no_employees_innovation = 0;
		current_xmachine_Firm->employees_needed_innovation = 0;
		current_xmachine_Firm->optimal_employees_needed_innovation = 0;
		current_xmachine_Firm->total_no_periods_for_product_development = 0;
		current_xmachine_Firm->ratio_project_value_established_product = 0.0;
		current_xmachine_Firm->vintage_choice_already_taken = 0;
		current_xmachine_Firm->change_due_to_last_innovation = 0.0;
		current_xmachine_Firm->remaining_periods_to_complete_product_development = 0;
		current_xmachine_Firm->planned_quality = 0.0;
		current_xmachine_Firm->product_development_completed = 0.0;
		current_xmachine_Firm->price_just_set_flag = 0.0;
		init_dt_value_lattice_years_array(&current_xmachine_Firm->value_lattice);
		current_xmachine_Firm->combined_variance_demand_function = 0.0;
	
}

void unittest_free_Firm_agent()
{
	free_estimators_linear_regression_array(&current_xmachine_Firm->linear_regression_estimators);
	free_adt_technology_vintages_array(&current_xmachine_Firm->technology_vintages);
	free_sales_statistics_array(&current_xmachine_Firm->malls_sales_statistics);
	free_sold_quantities_per_mall_array(&current_xmachine_Firm->sold_quantities);
	free_delivery_volume_per_mall_array(&current_xmachine_Firm->delivery_volume);
	free_delivery_volume_per_mall_array(&current_xmachine_Firm->planned_delivery_volume);
	free_mall_info_array(&current_xmachine_Firm->current_mall_stocks);
	free_double_array(&current_xmachine_Firm->last_planned_production_quantities);
	free_adt_capital_stock_vintages_array(&current_xmachine_Firm->capital_stock_vintages);
	free_financing_capital_array(&current_xmachine_Firm->capital_financing);
	free_double_array(&current_xmachine_Firm->last_sold_quantities);
	free_double_array(&current_xmachine_Firm->last_revenues);
	free_int_array(&current_xmachine_Firm->set_of_lenders);
	free_int_array(&current_xmachine_Firm->potential_lenders);
	free_double_array(&current_xmachine_Firm->earnings_history);
	free_debt_item_array(&current_xmachine_Firm->loans);
	free_employee_array(&current_xmachine_Firm->employees);
	free_employee_array(&current_xmachine_Firm->r_and_d_employees);
	free_adt_list_adaptation_speed_array(&current_xmachine_Firm->list_adaptation_speed_per_skill_group);
	free_firm_balance_sheet_adt(&current_xmachine_Firm->firm_balance_sheet_calendar);
	free_firm_stocks_adt(&current_xmachine_Firm->firm_stocks_calendar);
	free_firm_outflows_adt(&current_xmachine_Firm->firm_outflows_calendar);
	free_firm_inflows_adt(&current_xmachine_Firm->firm_inflows_calendar);
	free_price_quality_pair_array(&current_xmachine_Firm->quality_price_competitors);
	free_dt_total_and_regional_market_size_array(&current_xmachine_Firm->last_market_sizes);
	free_dt_price_range(&current_xmachine_Firm->price_range_pricing);
	free_price_quality_pair(&current_xmachine_Firm->estimated_coefficients);
	free_dt_price_range(&current_xmachine_Firm->price_range_innovation);
	free_price_quality_pair_static_array(current_xmachine_Firm->price_quality_inno, 12);
	free_dt_prospective_variables_array(&current_xmachine_Firm->prospective_variables);
	free_dt_best_price_strategies_array(&current_xmachine_Firm->best_pricing_strategies);
	free_estimators_linear_regression_array(&current_xmachine_Firm->linear_regression_market_size);
	free_dt_demand_function(&current_xmachine_Firm->demand_function_pricing);
	free_dt_demand_function_array(&current_xmachine_Firm->demand_functions_product_innovation);
	free_dt_market_research_price_array(&current_xmachine_Firm->market_research_data_pricing);
	free_dt_market_research_qualities_array(&current_xmachine_Firm->market_research_data_product_innovation);
	free_double_array(&current_xmachine_Firm->expected_price_choices);
	free_dt_monthly_estimations_static_array(current_xmachine_Firm->expected_earnings_and_costs_over_year, 12);
	free_dt_variables_changed_array(&current_xmachine_Firm->variables_last_year);
	free_dt_variables_changed(&current_xmachine_Firm->variables_change);
	free_dt_value_lattice_years_array(&current_xmachine_Firm->value_lattice);
	
	free(current_xmachine_Firm);
}

void free_Firm_agents()
{
	current_xmachine_Firm_holder = Firm_MR_01_state->agents;
	while(current_xmachine_Firm_holder)
	{
		temp_xmachine_Firm_holder = current_xmachine_Firm_holder->next;
		free_Firm_agent(current_xmachine_Firm_holder, Firm_MR_01_state);
		current_xmachine_Firm_holder = temp_xmachine_Firm_holder;
	}
	Firm_MR_01_state->count = 0;
	current_xmachine_Firm_holder = Firm_MR_03_state->agents;
	while(current_xmachine_Firm_holder)
	{
		temp_xmachine_Firm_holder = current_xmachine_Firm_holder->next;
		free_Firm_agent(current_xmachine_Firm_holder, Firm_MR_03_state);
		current_xmachine_Firm_holder = temp_xmachine_Firm_holder;
	}
	Firm_MR_03_state->count = 0;
	current_xmachine_Firm_holder = Firm_MR_02_state->agents;
	while(current_xmachine_Firm_holder)
	{
		temp_xmachine_Firm_holder = current_xmachine_Firm_holder->next;
		free_Firm_agent(current_xmachine_Firm_holder, Firm_MR_02_state);
		current_xmachine_Firm_holder = temp_xmachine_Firm_holder;
	}
	Firm_MR_02_state->count = 0;
	current_xmachine_Firm_holder = Firm_MR_6_state->agents;
	while(current_xmachine_Firm_holder)
	{
		temp_xmachine_Firm_holder = current_xmachine_Firm_holder->next;
		free_Firm_agent(current_xmachine_Firm_holder, Firm_MR_6_state);
		current_xmachine_Firm_holder = temp_xmachine_Firm_holder;
	}
	Firm_MR_6_state->count = 0;
	current_xmachine_Firm_holder = Firm_MR_5_state->agents;
	while(current_xmachine_Firm_holder)
	{
		temp_xmachine_Firm_holder = current_xmachine_Firm_holder->next;
		free_Firm_agent(current_xmachine_Firm_holder, Firm_MR_5_state);
		current_xmachine_Firm_holder = temp_xmachine_Firm_holder;
	}
	Firm_MR_5_state->count = 0;
	current_xmachine_Firm_holder = Firm_MR_4a_state->agents;
	while(current_xmachine_Firm_holder)
	{
		temp_xmachine_Firm_holder = current_xmachine_Firm_holder->next;
		free_Firm_agent(current_xmachine_Firm_holder, Firm_MR_4a_state);
		current_xmachine_Firm_holder = temp_xmachine_Firm_holder;
	}
	Firm_MR_4a_state->count = 0;
	current_xmachine_Firm_holder = Firm_MR_4_state->agents;
	while(current_xmachine_Firm_holder)
	{
		temp_xmachine_Firm_holder = current_xmachine_Firm_holder->next;
		free_Firm_agent(current_xmachine_Firm_holder, Firm_MR_4_state);
		current_xmachine_Firm_holder = temp_xmachine_Firm_holder;
	}
	Firm_MR_4_state->count = 0;
	current_xmachine_Firm_holder = Firm_MR_3_state->agents;
	while(current_xmachine_Firm_holder)
	{
		temp_xmachine_Firm_holder = current_xmachine_Firm_holder->next;
		free_Firm_agent(current_xmachine_Firm_holder, Firm_MR_3_state);
		current_xmachine_Firm_holder = temp_xmachine_Firm_holder;
	}
	Firm_MR_3_state->count = 0;
	current_xmachine_Firm_holder = Firm_MR_2_state->agents;
	while(current_xmachine_Firm_holder)
	{
		temp_xmachine_Firm_holder = current_xmachine_Firm_holder->next;
		free_Firm_agent(current_xmachine_Firm_holder, Firm_MR_2_state);
		current_xmachine_Firm_holder = temp_xmachine_Firm_holder;
	}
	Firm_MR_2_state->count = 0;
	current_xmachine_Firm_holder = Firm_MR_1_state->agents;
	while(current_xmachine_Firm_holder)
	{
		temp_xmachine_Firm_holder = current_xmachine_Firm_holder->next;
		free_Firm_agent(current_xmachine_Firm_holder, Firm_MR_1_state);
		current_xmachine_Firm_holder = temp_xmachine_Firm_holder;
	}
	Firm_MR_1_state->count = 0;
	current_xmachine_Firm_holder = Firm_MR_0_state->agents;
	while(current_xmachine_Firm_holder)
	{
		temp_xmachine_Firm_holder = current_xmachine_Firm_holder->next;
		free_Firm_agent(current_xmachine_Firm_holder, Firm_MR_0_state);
		current_xmachine_Firm_holder = temp_xmachine_Firm_holder;
	}
	Firm_MR_0_state->count = 0;
	current_xmachine_Firm_holder = Firm_end_Firm_state->agents;
	while(current_xmachine_Firm_holder)
	{
		temp_xmachine_Firm_holder = current_xmachine_Firm_holder->next;
		free_Firm_agent(current_xmachine_Firm_holder, Firm_end_Firm_state);
		current_xmachine_Firm_holder = temp_xmachine_Firm_holder;
	}
	Firm_end_Firm_state->count = 0;
	current_xmachine_Firm_holder = Firm_Firm_Send_Data_state->agents;
	while(current_xmachine_Firm_holder)
	{
		temp_xmachine_Firm_holder = current_xmachine_Firm_holder->next;
		free_Firm_agent(current_xmachine_Firm_holder, Firm_Firm_Send_Data_state);
		current_xmachine_Firm_holder = temp_xmachine_Firm_holder;
	}
	Firm_Firm_Send_Data_state->count = 0;
	current_xmachine_Firm_holder = Firm_Firm_Start_Market_Research_Role_state->agents;
	while(current_xmachine_Firm_holder)
	{
		temp_xmachine_Firm_holder = current_xmachine_Firm_holder->next;
		free_Firm_agent(current_xmachine_Firm_holder, Firm_Firm_Start_Market_Research_Role_state);
		current_xmachine_Firm_holder = temp_xmachine_Firm_holder;
	}
	Firm_Firm_Start_Market_Research_Role_state->count = 0;
	current_xmachine_Firm_holder = Firm_Firm_init_01_state->agents;
	while(current_xmachine_Firm_holder)
	{
		temp_xmachine_Firm_holder = current_xmachine_Firm_holder->next;
		free_Firm_agent(current_xmachine_Firm_holder, Firm_Firm_init_01_state);
		current_xmachine_Firm_holder = temp_xmachine_Firm_holder;
	}
	Firm_Firm_init_01_state->count = 0;
	current_xmachine_Firm_holder = Firm_Firm_reset_state->agents;
	while(current_xmachine_Firm_holder)
	{
		temp_xmachine_Firm_holder = current_xmachine_Firm_holder->next;
		free_Firm_agent(current_xmachine_Firm_holder, Firm_Firm_reset_state);
		current_xmachine_Firm_holder = temp_xmachine_Firm_holder;
	}
	Firm_Firm_reset_state->count = 0;
	current_xmachine_Firm_holder = Firm_Firm_initialize_state->agents;
	while(current_xmachine_Firm_holder)
	{
		temp_xmachine_Firm_holder = current_xmachine_Firm_holder->next;
		free_Firm_agent(current_xmachine_Firm_holder, Firm_Firm_initialize_state);
		current_xmachine_Firm_holder = temp_xmachine_Firm_holder;
	}
	Firm_Firm_initialize_state->count = 0;
	current_xmachine_Firm_holder = Firm_start_Firm_state->agents;
	while(current_xmachine_Firm_holder)
	{
		temp_xmachine_Firm_holder = current_xmachine_Firm_holder->next;
		free_Firm_agent(current_xmachine_Firm_holder, Firm_start_Firm_state);
		current_xmachine_Firm_holder = temp_xmachine_Firm_holder;
	}
	Firm_start_Firm_state->count = 0;
	current_xmachine_Firm_holder = Firm_10_state->agents;
	while(current_xmachine_Firm_holder)
	{
		temp_xmachine_Firm_holder = current_xmachine_Firm_holder->next;
		free_Firm_agent(current_xmachine_Firm_holder, Firm_10_state);
		current_xmachine_Firm_holder = temp_xmachine_Firm_holder;
	}
	Firm_10_state->count = 0;
	current_xmachine_Firm_holder = Firm_09b_state->agents;
	while(current_xmachine_Firm_holder)
	{
		temp_xmachine_Firm_holder = current_xmachine_Firm_holder->next;
		free_Firm_agent(current_xmachine_Firm_holder, Firm_09b_state);
		current_xmachine_Firm_holder = temp_xmachine_Firm_holder;
	}
	Firm_09b_state->count = 0;
	current_xmachine_Firm_holder = Firm_08_state->agents;
	while(current_xmachine_Firm_holder)
	{
		temp_xmachine_Firm_holder = current_xmachine_Firm_holder->next;
		free_Firm_agent(current_xmachine_Firm_holder, Firm_08_state);
		current_xmachine_Firm_holder = temp_xmachine_Firm_holder;
	}
	Firm_08_state->count = 0;
	current_xmachine_Firm_holder = Firm_07_state->agents;
	while(current_xmachine_Firm_holder)
	{
		temp_xmachine_Firm_holder = current_xmachine_Firm_holder->next;
		free_Firm_agent(current_xmachine_Firm_holder, Firm_07_state);
		current_xmachine_Firm_holder = temp_xmachine_Firm_holder;
	}
	Firm_07_state->count = 0;
	current_xmachine_Firm_holder = Firm_09a_state->agents;
	while(current_xmachine_Firm_holder)
	{
		temp_xmachine_Firm_holder = current_xmachine_Firm_holder->next;
		free_Firm_agent(current_xmachine_Firm_holder, Firm_09a_state);
		current_xmachine_Firm_holder = temp_xmachine_Firm_holder;
	}
	Firm_09a_state->count = 0;
	current_xmachine_Firm_holder = Firm_06_state->agents;
	while(current_xmachine_Firm_holder)
	{
		temp_xmachine_Firm_holder = current_xmachine_Firm_holder->next;
		free_Firm_agent(current_xmachine_Firm_holder, Firm_06_state);
		current_xmachine_Firm_holder = temp_xmachine_Firm_holder;
	}
	Firm_06_state->count = 0;
	current_xmachine_Firm_holder = Firm_03d_state->agents;
	while(current_xmachine_Firm_holder)
	{
		temp_xmachine_Firm_holder = current_xmachine_Firm_holder->next;
		free_Firm_agent(current_xmachine_Firm_holder, Firm_03d_state);
		current_xmachine_Firm_holder = temp_xmachine_Firm_holder;
	}
	Firm_03d_state->count = 0;
	current_xmachine_Firm_holder = Firm_03c_state->agents;
	while(current_xmachine_Firm_holder)
	{
		temp_xmachine_Firm_holder = current_xmachine_Firm_holder->next;
		free_Firm_agent(current_xmachine_Firm_holder, Firm_03c_state);
		current_xmachine_Firm_holder = temp_xmachine_Firm_holder;
	}
	Firm_03c_state->count = 0;
	current_xmachine_Firm_holder = Firm_09c_state->agents;
	while(current_xmachine_Firm_holder)
	{
		temp_xmachine_Firm_holder = current_xmachine_Firm_holder->next;
		free_Firm_agent(current_xmachine_Firm_holder, Firm_09c_state);
		current_xmachine_Firm_holder = temp_xmachine_Firm_holder;
	}
	Firm_09c_state->count = 0;
	current_xmachine_Firm_holder = Firm_05b_state->agents;
	while(current_xmachine_Firm_holder)
	{
		temp_xmachine_Firm_holder = current_xmachine_Firm_holder->next;
		free_Firm_agent(current_xmachine_Firm_holder, Firm_05b_state);
		current_xmachine_Firm_holder = temp_xmachine_Firm_holder;
	}
	Firm_05b_state->count = 0;
	current_xmachine_Firm_holder = Firm_05a_state->agents;
	while(current_xmachine_Firm_holder)
	{
		temp_xmachine_Firm_holder = current_xmachine_Firm_holder->next;
		free_Firm_agent(current_xmachine_Firm_holder, Firm_05a_state);
		current_xmachine_Firm_holder = temp_xmachine_Firm_holder;
	}
	Firm_05a_state->count = 0;
	current_xmachine_Firm_holder = Firm_04_state->agents;
	while(current_xmachine_Firm_holder)
	{
		temp_xmachine_Firm_holder = current_xmachine_Firm_holder->next;
		free_Firm_agent(current_xmachine_Firm_holder, Firm_04_state);
		current_xmachine_Firm_holder = temp_xmachine_Firm_holder;
	}
	Firm_04_state->count = 0;
	current_xmachine_Firm_holder = Firm_03ccc_state->agents;
	while(current_xmachine_Firm_holder)
	{
		temp_xmachine_Firm_holder = current_xmachine_Firm_holder->next;
		free_Firm_agent(current_xmachine_Firm_holder, Firm_03ccc_state);
		current_xmachine_Firm_holder = temp_xmachine_Firm_holder;
	}
	Firm_03ccc_state->count = 0;
	current_xmachine_Firm_holder = Firm_03_state->agents;
	while(current_xmachine_Firm_holder)
	{
		temp_xmachine_Firm_holder = current_xmachine_Firm_holder->next;
		free_Firm_agent(current_xmachine_Firm_holder, Firm_03_state);
		current_xmachine_Firm_holder = temp_xmachine_Firm_holder;
	}
	Firm_03_state->count = 0;
	current_xmachine_Firm_holder = Firm_04ccc_state->agents;
	while(current_xmachine_Firm_holder)
	{
		temp_xmachine_Firm_holder = current_xmachine_Firm_holder->next;
		free_Firm_agent(current_xmachine_Firm_holder, Firm_04ccc_state);
		current_xmachine_Firm_holder = temp_xmachine_Firm_holder;
	}
	Firm_04ccc_state->count = 0;
	current_xmachine_Firm_holder = Firm_011_state->agents;
	while(current_xmachine_Firm_holder)
	{
		temp_xmachine_Firm_holder = current_xmachine_Firm_holder->next;
		free_Firm_agent(current_xmachine_Firm_holder, Firm_011_state);
		current_xmachine_Firm_holder = temp_xmachine_Firm_holder;
	}
	Firm_011_state->count = 0;
	current_xmachine_Firm_holder = Firm_011a_state->agents;
	while(current_xmachine_Firm_holder)
	{
		temp_xmachine_Firm_holder = current_xmachine_Firm_holder->next;
		free_Firm_agent(current_xmachine_Firm_holder, Firm_011a_state);
		current_xmachine_Firm_holder = temp_xmachine_Firm_holder;
	}
	Firm_011a_state->count = 0;
	current_xmachine_Firm_holder = Firm_16_state->agents;
	while(current_xmachine_Firm_holder)
	{
		temp_xmachine_Firm_holder = current_xmachine_Firm_holder->next;
		free_Firm_agent(current_xmachine_Firm_holder, Firm_16_state);
		current_xmachine_Firm_holder = temp_xmachine_Firm_holder;
	}
	Firm_16_state->count = 0;
	current_xmachine_Firm_holder = Firm_15_state->agents;
	while(current_xmachine_Firm_holder)
	{
		temp_xmachine_Firm_holder = current_xmachine_Firm_holder->next;
		free_Firm_agent(current_xmachine_Firm_holder, Firm_15_state);
		current_xmachine_Firm_holder = temp_xmachine_Firm_holder;
	}
	Firm_15_state->count = 0;
	current_xmachine_Firm_holder = Firm_Firm_End_Branches_state->agents;
	while(current_xmachine_Firm_holder)
	{
		temp_xmachine_Firm_holder = current_xmachine_Firm_holder->next;
		free_Firm_agent(current_xmachine_Firm_holder, Firm_Firm_End_Branches_state);
		current_xmachine_Firm_holder = temp_xmachine_Firm_holder;
	}
	Firm_Firm_End_Branches_state->count = 0;
	current_xmachine_Firm_holder = Firm_Firm_bankruptcy_state_4_state->agents;
	while(current_xmachine_Firm_holder)
	{
		temp_xmachine_Firm_holder = current_xmachine_Firm_holder->next;
		free_Firm_agent(current_xmachine_Firm_holder, Firm_Firm_bankruptcy_state_4_state);
		current_xmachine_Firm_holder = temp_xmachine_Firm_holder;
	}
	Firm_Firm_bankruptcy_state_4_state->count = 0;
	current_xmachine_Firm_holder = Firm_Firm_is_active_state->agents;
	while(current_xmachine_Firm_holder)
	{
		temp_xmachine_Firm_holder = current_xmachine_Firm_holder->next;
		free_Firm_agent(current_xmachine_Firm_holder, Firm_Firm_is_active_state);
		current_xmachine_Firm_holder = temp_xmachine_Firm_holder;
	}
	Firm_Firm_is_active_state->count = 0;
	current_xmachine_Firm_holder = Firm_Firm_bankruptcy_state_1_state->agents;
	while(current_xmachine_Firm_holder)
	{
		temp_xmachine_Firm_holder = current_xmachine_Firm_holder->next;
		free_Firm_agent(current_xmachine_Firm_holder, Firm_Firm_bankruptcy_state_1_state);
		current_xmachine_Firm_holder = temp_xmachine_Firm_holder;
	}
	Firm_Firm_bankruptcy_state_1_state->count = 0;
	current_xmachine_Firm_holder = Firm_Firm_bankruptcy_state_01_state->agents;
	while(current_xmachine_Firm_holder)
	{
		temp_xmachine_Firm_holder = current_xmachine_Firm_holder->next;
		free_Firm_agent(current_xmachine_Firm_holder, Firm_Firm_bankruptcy_state_01_state);
		current_xmachine_Firm_holder = temp_xmachine_Firm_holder;
	}
	Firm_Firm_bankruptcy_state_01_state->count = 0;
	current_xmachine_Firm_holder = Firm_Firm_bankruptcy_state_0_state->agents;
	while(current_xmachine_Firm_holder)
	{
		temp_xmachine_Firm_holder = current_xmachine_Firm_holder->next;
		free_Firm_agent(current_xmachine_Firm_holder, Firm_Firm_bankruptcy_state_0_state);
		current_xmachine_Firm_holder = temp_xmachine_Firm_holder;
	}
	Firm_Firm_bankruptcy_state_0_state->count = 0;
	current_xmachine_Firm_holder = Firm_Firm_not_active_state->agents;
	while(current_xmachine_Firm_holder)
	{
		temp_xmachine_Firm_holder = current_xmachine_Firm_holder->next;
		free_Firm_agent(current_xmachine_Firm_holder, Firm_Firm_not_active_state);
		current_xmachine_Firm_holder = temp_xmachine_Firm_holder;
	}
	Firm_Firm_not_active_state->count = 0;
	current_xmachine_Firm_holder = Firm_005_state->agents;
	while(current_xmachine_Firm_holder)
	{
		temp_xmachine_Firm_holder = current_xmachine_Firm_holder->next;
		free_Firm_agent(current_xmachine_Firm_holder, Firm_005_state);
		current_xmachine_Firm_holder = temp_xmachine_Firm_holder;
	}
	Firm_005_state->count = 0;
	current_xmachine_Firm_holder = Firm_Firm_End_External_Financing_state->agents;
	while(current_xmachine_Firm_holder)
	{
		temp_xmachine_Firm_holder = current_xmachine_Firm_holder->next;
		free_Firm_agent(current_xmachine_Firm_holder, Firm_Firm_End_External_Financing_state);
		current_xmachine_Firm_holder = temp_xmachine_Firm_holder;
	}
	Firm_Firm_End_External_Financing_state->count = 0;
	current_xmachine_Firm_holder = Firm_Firm_resolve_financial_crisis_state->agents;
	while(current_xmachine_Firm_holder)
	{
		temp_xmachine_Firm_holder = current_xmachine_Firm_holder->next;
		free_Firm_agent(current_xmachine_Firm_holder, Firm_Firm_resolve_financial_crisis_state);
		current_xmachine_Firm_holder = temp_xmachine_Firm_holder;
	}
	Firm_Firm_resolve_financial_crisis_state->count = 0;
	current_xmachine_Firm_holder = Firm_Firm_checks_financial_crisis_state->agents;
	while(current_xmachine_Firm_holder)
	{
		temp_xmachine_Firm_holder = current_xmachine_Firm_holder->next;
		free_Firm_agent(current_xmachine_Firm_holder, Firm_Firm_checks_financial_crisis_state);
		current_xmachine_Firm_holder = temp_xmachine_Firm_holder;
	}
	Firm_Firm_checks_financial_crisis_state->count = 0;
	current_xmachine_Firm_holder = Firm_Firm_variables_reset2_state->agents;
	while(current_xmachine_Firm_holder)
	{
		temp_xmachine_Firm_holder = current_xmachine_Firm_holder->next;
		free_Firm_agent(current_xmachine_Firm_holder, Firm_Firm_variables_reset2_state);
		current_xmachine_Firm_holder = temp_xmachine_Firm_holder;
	}
	Firm_Firm_variables_reset2_state->count = 0;
	current_xmachine_Firm_holder = Firm_Firm_bankruptcy_checked_state->agents;
	while(current_xmachine_Firm_holder)
	{
		temp_xmachine_Firm_holder = current_xmachine_Firm_holder->next;
		free_Firm_agent(current_xmachine_Firm_holder, Firm_Firm_bankruptcy_checked_state);
		current_xmachine_Firm_holder = temp_xmachine_Firm_holder;
	}
	Firm_Firm_bankruptcy_checked_state->count = 0;
	current_xmachine_Firm_holder = Firm_02b_state->agents;
	while(current_xmachine_Firm_holder)
	{
		temp_xmachine_Firm_holder = current_xmachine_Firm_holder->next;
		free_Firm_agent(current_xmachine_Firm_holder, Firm_02b_state);
		current_xmachine_Firm_holder = temp_xmachine_Firm_holder;
	}
	Firm_02b_state->count = 0;
	current_xmachine_Firm_holder = Firm_Firm_variables_reset_state->agents;
	while(current_xmachine_Firm_holder)
	{
		temp_xmachine_Firm_holder = current_xmachine_Firm_holder->next;
		free_Firm_agent(current_xmachine_Firm_holder, Firm_Firm_variables_reset_state);
		current_xmachine_Firm_holder = temp_xmachine_Firm_holder;
	}
	Firm_Firm_variables_reset_state->count = 0;
	current_xmachine_Firm_holder = Firm_Firm_Bankruptcy_check_state->agents;
	while(current_xmachine_Firm_holder)
	{
		temp_xmachine_Firm_holder = current_xmachine_Firm_holder->next;
		free_Firm_agent(current_xmachine_Firm_holder, Firm_Firm_Bankruptcy_check_state);
		current_xmachine_Firm_holder = temp_xmachine_Firm_holder;
	}
	Firm_Firm_Bankruptcy_check_state->count = 0;
	current_xmachine_Firm_holder = Firm_004_state->agents;
	while(current_xmachine_Firm_holder)
	{
		temp_xmachine_Firm_holder = current_xmachine_Firm_holder->next;
		free_Firm_agent(current_xmachine_Firm_holder, Firm_004_state);
		current_xmachine_Firm_holder = temp_xmachine_Firm_holder;
	}
	Firm_004_state->count = 0;
	current_xmachine_Firm_holder = Firm_003_state->agents;
	while(current_xmachine_Firm_holder)
	{
		temp_xmachine_Firm_holder = current_xmachine_Firm_holder->next;
		free_Firm_agent(current_xmachine_Firm_holder, Firm_003_state);
		current_xmachine_Firm_holder = temp_xmachine_Firm_holder;
	}
	Firm_003_state->count = 0;
	current_xmachine_Firm_holder = Firm_002_state->agents;
	while(current_xmachine_Firm_holder)
	{
		temp_xmachine_Firm_holder = current_xmachine_Firm_holder->next;
		free_Firm_agent(current_xmachine_Firm_holder, Firm_002_state);
		current_xmachine_Firm_holder = temp_xmachine_Firm_holder;
	}
	Firm_002_state->count = 0;
	current_xmachine_Firm_holder = Firm_001_state->agents;
	while(current_xmachine_Firm_holder)
	{
		temp_xmachine_Firm_holder = current_xmachine_Firm_holder->next;
		free_Firm_agent(current_xmachine_Firm_holder, Firm_001_state);
		current_xmachine_Firm_holder = temp_xmachine_Firm_holder;
	}
	Firm_001_state->count = 0;
	current_xmachine_Firm_holder = Firm_Firm_End_Public_Sector_Role_state->agents;
	while(current_xmachine_Firm_holder)
	{
		temp_xmachine_Firm_holder = current_xmachine_Firm_holder->next;
		free_Firm_agent(current_xmachine_Firm_holder, Firm_Firm_End_Public_Sector_Role_state);
		current_xmachine_Firm_holder = temp_xmachine_Firm_holder;
	}
	Firm_Firm_End_Public_Sector_Role_state->count = 0;
	current_xmachine_Firm_holder = Firm_Firm_End_Credit_Role_state->agents;
	while(current_xmachine_Firm_holder)
	{
		temp_xmachine_Firm_holder = current_xmachine_Firm_holder->next;
		free_Firm_agent(current_xmachine_Firm_holder, Firm_Firm_End_Credit_Role_state);
		current_xmachine_Firm_holder = temp_xmachine_Firm_holder;
	}
	Firm_Firm_End_Credit_Role_state->count = 0;
	current_xmachine_Firm_holder = Firm_Firm_Credit_02_state->agents;
	while(current_xmachine_Firm_holder)
	{
		temp_xmachine_Firm_holder = current_xmachine_Firm_holder->next;
		free_Firm_agent(current_xmachine_Firm_holder, Firm_Firm_Credit_02_state);
		current_xmachine_Firm_holder = temp_xmachine_Firm_holder;
	}
	Firm_Firm_Credit_02_state->count = 0;
	current_xmachine_Firm_holder = Firm_Firm_Start_Credit_Role_state->agents;
	while(current_xmachine_Firm_holder)
	{
		temp_xmachine_Firm_holder = current_xmachine_Firm_holder->next;
		free_Firm_agent(current_xmachine_Firm_holder, Firm_Firm_Start_Credit_Role_state);
		current_xmachine_Firm_holder = temp_xmachine_Firm_holder;
	}
	Firm_Firm_Start_Credit_Role_state->count = 0;
	current_xmachine_Firm_holder = Firm_Firm_checks_if_active_state->agents;
	while(current_xmachine_Firm_holder)
	{
		temp_xmachine_Firm_holder = current_xmachine_Firm_holder->next;
		free_Firm_agent(current_xmachine_Firm_holder, Firm_Firm_checks_if_active_state);
		current_xmachine_Firm_holder = temp_xmachine_Firm_holder;
	}
	Firm_Firm_checks_if_active_state->count = 0;
	current_xmachine_Firm_holder = Firm_Firm_interest_state->agents;
	while(current_xmachine_Firm_holder)
	{
		temp_xmachine_Firm_holder = current_xmachine_Firm_holder->next;
		free_Firm_agent(current_xmachine_Firm_holder, Firm_Firm_interest_state);
		current_xmachine_Firm_holder = temp_xmachine_Firm_holder;
	}
	Firm_Firm_interest_state->count = 0;
	current_xmachine_Firm_holder = Firm_Firm_Start_Financial_Management_Role_state->agents;
	while(current_xmachine_Firm_holder)
	{
		temp_xmachine_Firm_holder = current_xmachine_Firm_holder->next;
		free_Firm_agent(current_xmachine_Firm_holder, Firm_Firm_Start_Financial_Management_Role_state);
		current_xmachine_Firm_holder = temp_xmachine_Firm_holder;
	}
	Firm_Firm_Start_Financial_Management_Role_state->count = 0;
	current_xmachine_Firm_holder = Firm_Firm_End_Financial_Management_Role_state->agents;
	while(current_xmachine_Firm_holder)
	{
		temp_xmachine_Firm_holder = current_xmachine_Firm_holder->next;
		free_Firm_agent(current_xmachine_Firm_holder, Firm_Firm_End_Financial_Management_Role_state);
		current_xmachine_Firm_holder = temp_xmachine_Firm_holder;
	}
	Firm_Firm_End_Financial_Management_Role_state->count = 0;
	current_xmachine_Firm_holder = Firm_14_state->agents;
	while(current_xmachine_Firm_holder)
	{
		temp_xmachine_Firm_holder = current_xmachine_Firm_holder->next;
		free_Firm_agent(current_xmachine_Firm_holder, Firm_14_state);
		current_xmachine_Firm_holder = temp_xmachine_Firm_holder;
	}
	Firm_14_state->count = 0;
	current_xmachine_Firm_holder = Firm_Firm_End_Seller_Role_state->agents;
	while(current_xmachine_Firm_holder)
	{
		temp_xmachine_Firm_holder = current_xmachine_Firm_holder->next;
		free_Firm_agent(current_xmachine_Firm_holder, Firm_Firm_End_Seller_Role_state);
		current_xmachine_Firm_holder = temp_xmachine_Firm_holder;
	}
	Firm_Firm_End_Seller_Role_state->count = 0;
	current_xmachine_Firm_holder = Firm_Firm_Start_Seller_Role_state->agents;
	while(current_xmachine_Firm_holder)
	{
		temp_xmachine_Firm_holder = current_xmachine_Firm_holder->next;
		free_Firm_agent(current_xmachine_Firm_holder, Firm_Firm_Start_Seller_Role_state);
		current_xmachine_Firm_holder = temp_xmachine_Firm_holder;
	}
	Firm_Firm_Start_Seller_Role_state->count = 0;
	current_xmachine_Firm_holder = Firm_12_state->agents;
	while(current_xmachine_Firm_holder)
	{
		temp_xmachine_Firm_holder = current_xmachine_Firm_holder->next;
		free_Firm_agent(current_xmachine_Firm_holder, Firm_12_state);
		current_xmachine_Firm_holder = temp_xmachine_Firm_holder;
	}
	Firm_12_state->count = 0;
	current_xmachine_Firm_holder = Firm_11_state->agents;
	while(current_xmachine_Firm_holder)
	{
		temp_xmachine_Firm_holder = current_xmachine_Firm_holder->next;
		free_Firm_agent(current_xmachine_Firm_holder, Firm_11_state);
		current_xmachine_Firm_holder = temp_xmachine_Firm_holder;
	}
	Firm_11_state->count = 0;
	current_xmachine_Firm_holder = Firm_11b_state->agents;
	while(current_xmachine_Firm_holder)
	{
		temp_xmachine_Firm_holder = current_xmachine_Firm_holder->next;
		free_Firm_agent(current_xmachine_Firm_holder, Firm_11b_state);
		current_xmachine_Firm_holder = temp_xmachine_Firm_holder;
	}
	Firm_11b_state->count = 0;
	current_xmachine_Firm_holder = Firm_11a_state->agents;
	while(current_xmachine_Firm_holder)
	{
		temp_xmachine_Firm_holder = current_xmachine_Firm_holder->next;
		free_Firm_agent(current_xmachine_Firm_holder, Firm_11a_state);
		current_xmachine_Firm_holder = temp_xmachine_Firm_holder;
	}
	Firm_11a_state->count = 0;
	current_xmachine_Firm_holder = Firm_Firm_End_Labour_Role_state->agents;
	while(current_xmachine_Firm_holder)
	{
		temp_xmachine_Firm_holder = current_xmachine_Firm_holder->next;
		free_Firm_agent(current_xmachine_Firm_holder, Firm_Firm_End_Labour_Role_state);
		current_xmachine_Firm_holder = temp_xmachine_Firm_holder;
	}
	Firm_Firm_End_Labour_Role_state->count = 0;
	current_xmachine_Firm_holder = Firm_Firm_Start_Labour_Role_state->agents;
	while(current_xmachine_Firm_holder)
	{
		temp_xmachine_Firm_holder = current_xmachine_Firm_holder->next;
		free_Firm_agent(current_xmachine_Firm_holder, Firm_Firm_Start_Labour_Role_state);
		current_xmachine_Firm_holder = temp_xmachine_Firm_holder;
	}
	Firm_Firm_Start_Labour_Role_state->count = 0;
	current_xmachine_Firm_holder = Firm_Firm_End_Financial_Management_state->agents;
	while(current_xmachine_Firm_holder)
	{
		temp_xmachine_Firm_holder = current_xmachine_Firm_holder->next;
		free_Firm_agent(current_xmachine_Firm_holder, Firm_Firm_End_Financial_Management_state);
		current_xmachine_Firm_holder = temp_xmachine_Firm_holder;
	}
	Firm_Firm_End_Financial_Management_state->count = 0;
	current_xmachine_Firm_holder = Firm_02_state->agents;
	while(current_xmachine_Firm_holder)
	{
		temp_xmachine_Firm_holder = current_xmachine_Firm_holder->next;
		free_Firm_agent(current_xmachine_Firm_holder, Firm_02_state);
		current_xmachine_Firm_holder = temp_xmachine_Firm_holder;
	}
	Firm_02_state->count = 0;
	current_xmachine_Firm_holder = Firm_00b_state->agents;
	while(current_xmachine_Firm_holder)
	{
		temp_xmachine_Firm_holder = current_xmachine_Firm_holder->next;
		free_Firm_agent(current_xmachine_Firm_holder, Firm_00b_state);
		current_xmachine_Firm_holder = temp_xmachine_Firm_holder;
	}
	Firm_00b_state->count = 0;
	current_xmachine_Firm_holder = Firm_01_state->agents;
	while(current_xmachine_Firm_holder)
	{
		temp_xmachine_Firm_holder = current_xmachine_Firm_holder->next;
		free_Firm_agent(current_xmachine_Firm_holder, Firm_01_state);
		current_xmachine_Firm_holder = temp_xmachine_Firm_holder;
	}
	Firm_01_state->count = 0;
	current_xmachine_Firm_holder = Firm_Firm_Start_Producer_Role_state->agents;
	while(current_xmachine_Firm_holder)
	{
		temp_xmachine_Firm_holder = current_xmachine_Firm_holder->next;
		free_Firm_agent(current_xmachine_Firm_holder, Firm_Firm_Start_Producer_Role_state);
		current_xmachine_Firm_holder = temp_xmachine_Firm_holder;
	}
	Firm_Firm_Start_Producer_Role_state->count = 0;
}

void free_Firm_states()
{
	free(Firm_MR_01_state);
	free(Firm_MR_03_state);
	free(Firm_MR_02_state);
	free(Firm_MR_6_state);
	free(Firm_MR_5_state);
	free(Firm_MR_4a_state);
	free(Firm_MR_4_state);
	free(Firm_MR_3_state);
	free(Firm_MR_2_state);
	free(Firm_MR_1_state);
	free(Firm_MR_0_state);
	free(Firm_end_Firm_state);
	free(Firm_Firm_Send_Data_state);
	free(Firm_Firm_Start_Market_Research_Role_state);
	free(Firm_Firm_init_01_state);
	free(Firm_Firm_reset_state);
	free(Firm_Firm_initialize_state);
	free(Firm_start_Firm_state);
	free(Firm_10_state);
	free(Firm_09b_state);
	free(Firm_08_state);
	free(Firm_07_state);
	free(Firm_09a_state);
	free(Firm_06_state);
	free(Firm_03d_state);
	free(Firm_03c_state);
	free(Firm_09c_state);
	free(Firm_05b_state);
	free(Firm_05a_state);
	free(Firm_04_state);
	free(Firm_03ccc_state);
	free(Firm_03_state);
	free(Firm_04ccc_state);
	free(Firm_011_state);
	free(Firm_011a_state);
	free(Firm_16_state);
	free(Firm_15_state);
	free(Firm_Firm_End_Branches_state);
	free(Firm_Firm_bankruptcy_state_4_state);
	free(Firm_Firm_is_active_state);
	free(Firm_Firm_bankruptcy_state_1_state);
	free(Firm_Firm_bankruptcy_state_01_state);
	free(Firm_Firm_bankruptcy_state_0_state);
	free(Firm_Firm_not_active_state);
	free(Firm_005_state);
	free(Firm_Firm_End_External_Financing_state);
	free(Firm_Firm_resolve_financial_crisis_state);
	free(Firm_Firm_checks_financial_crisis_state);
	free(Firm_Firm_variables_reset2_state);
	free(Firm_Firm_bankruptcy_checked_state);
	free(Firm_02b_state);
	free(Firm_Firm_variables_reset_state);
	free(Firm_Firm_Bankruptcy_check_state);
	free(Firm_004_state);
	free(Firm_003_state);
	free(Firm_002_state);
	free(Firm_001_state);
	free(Firm_Firm_End_Public_Sector_Role_state);
	free(Firm_Firm_End_Credit_Role_state);
	free(Firm_Firm_Credit_02_state);
	free(Firm_Firm_Start_Credit_Role_state);
	free(Firm_Firm_checks_if_active_state);
	free(Firm_Firm_interest_state);
	free(Firm_Firm_Start_Financial_Management_Role_state);
	free(Firm_Firm_End_Financial_Management_Role_state);
	free(Firm_14_state);
	free(Firm_Firm_End_Seller_Role_state);
	free(Firm_Firm_Start_Seller_Role_state);
	free(Firm_12_state);
	free(Firm_11_state);
	free(Firm_11b_state);
	free(Firm_11a_state);
	free(Firm_Firm_End_Labour_Role_state);
	free(Firm_Firm_Start_Labour_Role_state);
	free(Firm_Firm_End_Financial_Management_state);
	free(Firm_02_state);
	free(Firm_00b_state);
	free(Firm_01_state);
	free(Firm_Firm_Start_Producer_Role_state);
}

void transition_Firm_agent(xmachine_memory_Firm_holder * tmp, xmachine_memory_Firm_state * from_state, xmachine_memory_Firm_state * to_state)
{
	if(tmp->prev == NULL) from_state->agents = tmp->next;
	else tmp->prev->next = tmp->next;
	if(tmp->next != NULL) tmp->next->prev = tmp->prev;

	add_Firm_agent_internal(tmp->agent, to_state);
	free(tmp);
}

void add_Firm_agent_internal(xmachine_memory_Firm * agent, xmachine_memory_Firm_state * state)
{
	xmachine_memory_Firm_holder * current = (xmachine_memory_Firm_holder *)malloc(sizeof(xmachine_memory_Firm_holder));
	CHECK_POINTER(current);

	current->next = state->agents;
	current->prev = NULL;
	state->agents = current;
	if(current->next != NULL) current->next->prev = current;
	current->agent = agent;

	state->count++;

}

/** \fn void add_Firm_agent(int id, int region_id, int gov_id, int day_of_month_to_act, int last_day_of_month_to_act, double payment_account, double payment_account_balance_sheet, int bank_id, int partition_id, double cpi, double mean_wage, double total_mean_wage, double mean_wage_r_and_d, double needed_capital_stock, double stock, double critical_stock, double actual_cap_price, double mean_specific_skills, double planned_production_quantity, double production_quantity, double planned_output, double output, double unit_costs, double total_supply, double production_costs, double total_buffer, double revenue_per_day, estimators_linear_regression_array * linear_regression_estimators, double technological_frontier, adt_technology_vintages_array * technology_vintages, int vintage_selected, int investment_subsidy_type, double initial_market_size, double initial_technology, double utilization_capacity, double used_capital_units, double cum_revenue, sales_statistics_array * malls_sales_statistics, double quality, double price, double price_last_month, double actual_mark_up, double demand_capital_stock, double effective_investments, double effective_capital_stock, double planned_production_costs, double labour_costs_production, double labour_costs_innovation, double intermediate_quality_level_developing, double adaption_production_volume_due_to_insufficient_finances, sold_quantities_per_mall_array * sold_quantities, double total_sold_quantity, double cum_total_sold_quantity, double sold_quantity_in_calendar_month, delivery_volume_per_mall_array * delivery_volume, delivery_volume_per_mall_array * planned_delivery_volume, mall_info_array * current_mall_stocks, double_array * last_planned_production_quantities, double total_external_financing_obtained, double capital_costs, int employees_needed_production, int no_employees_production, double planned_innovation_expenditures, double planned_expenditures_production_innovation, double labour_costs, double labour_costs_per_unit, adt_capital_stock_vintages_array * capital_stock_vintages, int vintage_choice_taken, financing_capital_array * capital_financing, double financial_resources_for_production, double total_units_local_inventory, double calc_capital_costs, double calc_production_costs, double firm_productivity, double total_productivity_capital_stock, double firm_productivity_last_year, double firm_productivity_progress, double sold_quantity_in_last_calendar_month, double_array * last_sold_quantities, double_array * last_revenues, int_array * set_of_lenders, int_array * potential_lenders, int number_of_banks_asked, double received_interest_daily, double received_interest_in_calendar_month, int flag_illiquidity_correction, double ebit, double earnings, double tax_rate_corporate, double tax_rate_vat, double tax_payment, double tax_payment_in_calendar_month, double net_earnings, double_array * earnings_history, double previous_net_earnings, double total_interest_payment, double total_interest_payment_in_calendar_month, double total_debt_installment_payment, double total_debt_installment_payment_in_calendar_month, double total_dividend_payment, double total_dividend_payment_in_calendar_month, int flag_full_dividend, double current_share_price, double previous_dividend_per_share, double current_dividend_per_share, double previous_earnings_per_share, double current_earnings_per_share, double previous_dividend_per_earnings, double current_dividend_per_earnings, double debt_earnings_ratio, double debt_equity_ratio, double price_earnings_ratio, double retained_earnings_ratio, double earnings_per_share_ratio_growth, double critical_price_earnings_ratio, double critical_earnings_per_share_ratio, debt_item_array * loans, double total_debt, double target_debt, double total_debt_balance_sheet, double total_value_local_inventory, double total_value_local_inventory_balance_sheet, double total_units_capital_stock, double total_value_capital_stock, double total_value_capital_stock_balance_sheet, double total_capital_depreciation_value, double total_capital_depreciation_units, double total_assets, double equity, double equity_balance_sheet, double production_liquidity_needs, double financial_liquidity_needs, double total_financial_needs, double external_financial_needs, double earnings_per_share, double retained_earnings, double total_payments, int previous_shares_outstanding, int minsky_state, int minsky_state_1, int minsky_state_2, int minsky_state_3, int minsky_state_4, int minsky_state_5, int minsky_state_20, int minsky_state_21, int minsky_state_22, int minsky_state_23, int minsky_state_30, int minsky_state_31, int minsky_state_32, int minsky_state_33, int minsky_state_40, int minsky_state_41, int minsky_state_42, int minsky_state_43, int age_at_bankruptcy, double debt_at_bankruptcy, double equity_at_bankruptcy, int no_employees_at_bankruptcy, double equity_asset_ratio, double profit_asset_ratio, double sales_asset_ratio, double investment_asset_ratio, double total_income, double total_liabilities, double total_expenses, int current_shares_outstanding, employee_array * employees, employee_array * r_and_d_employees, double wage_offer, double technology, int no_employees, int no_employees_skill_1, int no_employees_skill_2, int no_employees_skill_3, int no_employees_skill_4, int no_employees_skill_5, int no_employees_subsidized, double fraction_employees_subsidized, int vacancies, int no_redundancies, int no_applications_round_1, int no_applications_round_2, int no_redundancies_r_and_d_employees, int vacancies_r_and_d_employees, int posted_vacancies, int posted_vacancies_r_and_d_employees, double average_g_skill, double average_adaptation_speed_specific_skills, adt_list_adaptation_speed_array * list_adaptation_speed_per_skill_group, double average_s_skill_of_1, double average_s_skill_of_2, double average_s_skill_of_3, double average_s_skill_of_4, double average_s_skill_of_5, double wage_offer_for_skill_1, double wage_offer_for_skill_2, double wage_offer_for_skill_3, double wage_offer_for_skill_4, double wage_offer_for_skill_5, double wage_offer_for_r_and_d_employees, double base_wage_offer_r_and_d, int employees_needed, firm_balance_sheet_adt * firm_balance_sheet_calendar, firm_stocks_adt * firm_stocks_calendar, firm_outflows_adt * firm_outflows_calendar, firm_inflows_adt * firm_inflows_calendar, int age, double transfer_payment, double subsidy_pct, int active, int inactive, int zero_output, int bankruptcy_idle_counter, int bankruptcy_state, int bankruptcy_insolvency_state, int bankruptcy_illiquidity_state, int financial_crisis_state, double vacancy_filling_rate, double average_s_skill_from_eurostat, double average_technology_from_eurostat, double average_wage_offer_from_eurostat, double average_output_from_eurostat, price_quality_pair_array * quality_price_competitors, double subsidy_payment, double current_price_index, double current_quality_index, double minimum_wage, int no_competitors, int indicator_earnings, int indicator_capital_costs, double agg_vacancy_filling_rate, int market_research_sample_size, int product_innovation, int regional_analysis, int day_of_year_market_research, int day_of_month_price_was_set, int actual_sample_size, dt_total_and_regional_market_size_array * last_market_sizes, dt_price_range * price_range_pricing, double estimated_variance_market_share, price_quality_pair * estimated_coefficients, dt_price_range * price_range_innovation, int price_quality_counts[], price_quality_pair ** price_quality_inno, int new_product_released, dt_prospective_variables_array * prospective_variables, double price_at_questionnaire, double price_index_at_questionnaire, dt_best_price_strategies_array * best_pricing_strategies, double intermediate_quality, int no_employees_product_innovation_fundable, double r_and_d_probability_for_incremental_success, int day_of_year_price_setting, int market_research_active, int innovation_successful, double actual_market_share, double market_size, double market_size_reg1, double market_size_reg2, double estimated_market_size, estimators_linear_regression_array * linear_regression_market_size, int counter_month_since_last_price_setting, dt_demand_function * demand_function_pricing, dt_demand_function_array * demand_functions_product_innovation, int market_research_delayed, dt_market_research_price_array * market_research_data_pricing, dt_market_research_qualities_array * market_research_data_product_innovation, double expected_earnings_per_month, double_array * expected_price_choices, double no_considered_qualities, double last_interest_rate_for_loans, double cum_earnings_last_r_d_project, double cum_r_d_investments, double r_d_investments_last_project, int total_person_months, int cum_person_months, double actual_r_and_d_success_probability, double last_quality, double quality_change, double expected_sold_quantity_per_month, double estimated_market_share, double estimated_yearly_earnings, dt_monthly_estimations ** expected_earnings_and_costs_over_year, double expected_output_in_current_month, double expected_profit_in_current_month, double expected_labor_costs_in_current_month, double expected_capital_costs_in_current_month, double expected_interests_in_current_month, double expected_output_in_previous_month, double expected_actual_sold_quantity_in_previous_month, double expected_actual_sold_quantity_in_current_month, double expected_labor_costs_in_previous_month, double expected_capital_costs_in_previous_month, double expected_interests_in_previous_month, double expected_profit_in_previous_month, double expected_wage_in_current_month, double expected_wage_in_previous_month, double expected_mean_specific_skills_in_current_month, double expected_mean_specific_skills_in_previous_month, double expected_average_productivity_in_current_month, double expected_investment_nominal_in_current_month, double expected_investment_nominal_in_previous_month, double expected_average_productivity_in_previous_month, double earnings_while_last_pricing_period, double sum_earnings_since_price_change, dt_variables_changed_array * variables_last_year, int innovation_month_counter, int periods_output_zero_counter, dt_variables_changed * variables_change, double r_and_d_investments_per_month, int innovation_flag, int innovation_employees_needed, int no_employees_innovation, int employees_needed_innovation, int optimal_employees_needed_innovation, int total_no_periods_for_product_development, double ratio_project_value_established_product, int vintage_choice_already_taken, double change_due_to_last_innovation, int remaining_periods_to_complete_product_development, double planned_quality, double product_development_completed, double price_just_set_flag, dt_value_lattice_years_array * value_lattice, double combined_variance_demand_function)
 * \brief Add Firm X-machine to the current being used X-machine list.
 * \param id Variable for the X-machine memory.
 * \param region_id Variable for the X-machine memory.
 * \param gov_id Variable for the X-machine memory.
 * \param day_of_month_to_act Variable for the X-machine memory.
 * \param last_day_of_month_to_act Variable for the X-machine memory.
 * \param payment_account Variable for the X-machine memory.
 * \param payment_account_balance_sheet Variable for the X-machine memory.
 * \param bank_id Variable for the X-machine memory.
 * \param partition_id Variable for the X-machine memory.
 * \param cpi Variable for the X-machine memory.
 * \param mean_wage Variable for the X-machine memory.
 * \param total_mean_wage Variable for the X-machine memory.
 * \param mean_wage_r_and_d Variable for the X-machine memory.
 * \param needed_capital_stock Variable for the X-machine memory.
 * \param stock Variable for the X-machine memory.
 * \param critical_stock Variable for the X-machine memory.
 * \param actual_cap_price Variable for the X-machine memory.
 * \param mean_specific_skills Variable for the X-machine memory.
 * \param planned_production_quantity Variable for the X-machine memory.
 * \param production_quantity Variable for the X-machine memory.
 * \param planned_output Variable for the X-machine memory.
 * \param output Variable for the X-machine memory.
 * \param unit_costs Variable for the X-machine memory.
 * \param total_supply Variable for the X-machine memory.
 * \param production_costs Variable for the X-machine memory.
 * \param total_buffer Variable for the X-machine memory.
 * \param revenue_per_day Variable for the X-machine memory.
 * \param linear_regression_estimators Variable for the X-machine memory.
 * \param technological_frontier Variable for the X-machine memory.
 * \param technology_vintages Variable for the X-machine memory.
 * \param vintage_selected Variable for the X-machine memory.
 * \param investment_subsidy_type Variable for the X-machine memory.
 * \param initial_market_size Variable for the X-machine memory.
 * \param initial_technology Variable for the X-machine memory.
 * \param utilization_capacity Variable for the X-machine memory.
 * \param used_capital_units Variable for the X-machine memory.
 * \param cum_revenue Variable for the X-machine memory.
 * \param malls_sales_statistics Variable for the X-machine memory.
 * \param quality Variable for the X-machine memory.
 * \param price Variable for the X-machine memory.
 * \param price_last_month Variable for the X-machine memory.
 * \param actual_mark_up Variable for the X-machine memory.
 * \param demand_capital_stock Variable for the X-machine memory.
 * \param effective_investments Variable for the X-machine memory.
 * \param effective_capital_stock Variable for the X-machine memory.
 * \param planned_production_costs Variable for the X-machine memory.
 * \param labour_costs_production Variable for the X-machine memory.
 * \param labour_costs_innovation Variable for the X-machine memory.
 * \param intermediate_quality_level_developing Variable for the X-machine memory.
 * \param adaption_production_volume_due_to_insufficient_finances Variable for the X-machine memory.
 * \param sold_quantities Variable for the X-machine memory.
 * \param total_sold_quantity Variable for the X-machine memory.
 * \param cum_total_sold_quantity Variable for the X-machine memory.
 * \param sold_quantity_in_calendar_month Variable for the X-machine memory.
 * \param delivery_volume Variable for the X-machine memory.
 * \param planned_delivery_volume Variable for the X-machine memory.
 * \param current_mall_stocks Variable for the X-machine memory.
 * \param last_planned_production_quantities Variable for the X-machine memory.
 * \param total_external_financing_obtained Variable for the X-machine memory.
 * \param capital_costs Variable for the X-machine memory.
 * \param employees_needed_production Variable for the X-machine memory.
 * \param no_employees_production Variable for the X-machine memory.
 * \param planned_innovation_expenditures Variable for the X-machine memory.
 * \param planned_expenditures_production_innovation Variable for the X-machine memory.
 * \param labour_costs Variable for the X-machine memory.
 * \param labour_costs_per_unit Variable for the X-machine memory.
 * \param capital_stock_vintages Variable for the X-machine memory.
 * \param vintage_choice_taken Variable for the X-machine memory.
 * \param capital_financing Variable for the X-machine memory.
 * \param financial_resources_for_production Variable for the X-machine memory.
 * \param total_units_local_inventory Variable for the X-machine memory.
 * \param calc_capital_costs Variable for the X-machine memory.
 * \param calc_production_costs Variable for the X-machine memory.
 * \param firm_productivity Variable for the X-machine memory.
 * \param total_productivity_capital_stock Variable for the X-machine memory.
 * \param firm_productivity_last_year Variable for the X-machine memory.
 * \param firm_productivity_progress Variable for the X-machine memory.
 * \param sold_quantity_in_last_calendar_month Variable for the X-machine memory.
 * \param last_sold_quantities Variable for the X-machine memory.
 * \param last_revenues Variable for the X-machine memory.
 * \param set_of_lenders Variable for the X-machine memory.
 * \param potential_lenders Variable for the X-machine memory.
 * \param number_of_banks_asked Variable for the X-machine memory.
 * \param received_interest_daily Variable for the X-machine memory.
 * \param received_interest_in_calendar_month Variable for the X-machine memory.
 * \param flag_illiquidity_correction Variable for the X-machine memory.
 * \param ebit Variable for the X-machine memory.
 * \param earnings Variable for the X-machine memory.
 * \param tax_rate_corporate Variable for the X-machine memory.
 * \param tax_rate_vat Variable for the X-machine memory.
 * \param tax_payment Variable for the X-machine memory.
 * \param tax_payment_in_calendar_month Variable for the X-machine memory.
 * \param net_earnings Variable for the X-machine memory.
 * \param earnings_history Variable for the X-machine memory.
 * \param previous_net_earnings Variable for the X-machine memory.
 * \param total_interest_payment Variable for the X-machine memory.
 * \param total_interest_payment_in_calendar_month Variable for the X-machine memory.
 * \param total_debt_installment_payment Variable for the X-machine memory.
 * \param total_debt_installment_payment_in_calendar_month Variable for the X-machine memory.
 * \param total_dividend_payment Variable for the X-machine memory.
 * \param total_dividend_payment_in_calendar_month Variable for the X-machine memory.
 * \param flag_full_dividend Variable for the X-machine memory.
 * \param current_share_price Variable for the X-machine memory.
 * \param previous_dividend_per_share Variable for the X-machine memory.
 * \param current_dividend_per_share Variable for the X-machine memory.
 * \param previous_earnings_per_share Variable for the X-machine memory.
 * \param current_earnings_per_share Variable for the X-machine memory.
 * \param previous_dividend_per_earnings Variable for the X-machine memory.
 * \param current_dividend_per_earnings Variable for the X-machine memory.
 * \param debt_earnings_ratio Variable for the X-machine memory.
 * \param debt_equity_ratio Variable for the X-machine memory.
 * \param price_earnings_ratio Variable for the X-machine memory.
 * \param retained_earnings_ratio Variable for the X-machine memory.
 * \param earnings_per_share_ratio_growth Variable for the X-machine memory.
 * \param critical_price_earnings_ratio Variable for the X-machine memory.
 * \param critical_earnings_per_share_ratio Variable for the X-machine memory.
 * \param loans Variable for the X-machine memory.
 * \param total_debt Variable for the X-machine memory.
 * \param target_debt Variable for the X-machine memory.
 * \param total_debt_balance_sheet Variable for the X-machine memory.
 * \param total_value_local_inventory Variable for the X-machine memory.
 * \param total_value_local_inventory_balance_sheet Variable for the X-machine memory.
 * \param total_units_capital_stock Variable for the X-machine memory.
 * \param total_value_capital_stock Variable for the X-machine memory.
 * \param total_value_capital_stock_balance_sheet Variable for the X-machine memory.
 * \param total_capital_depreciation_value Variable for the X-machine memory.
 * \param total_capital_depreciation_units Variable for the X-machine memory.
 * \param total_assets Variable for the X-machine memory.
 * \param equity Variable for the X-machine memory.
 * \param equity_balance_sheet Variable for the X-machine memory.
 * \param production_liquidity_needs Variable for the X-machine memory.
 * \param financial_liquidity_needs Variable for the X-machine memory.
 * \param total_financial_needs Variable for the X-machine memory.
 * \param external_financial_needs Variable for the X-machine memory.
 * \param earnings_per_share Variable for the X-machine memory.
 * \param retained_earnings Variable for the X-machine memory.
 * \param total_payments Variable for the X-machine memory.
 * \param previous_shares_outstanding Variable for the X-machine memory.
 * \param minsky_state Variable for the X-machine memory.
 * \param minsky_state_1 Variable for the X-machine memory.
 * \param minsky_state_2 Variable for the X-machine memory.
 * \param minsky_state_3 Variable for the X-machine memory.
 * \param minsky_state_4 Variable for the X-machine memory.
 * \param minsky_state_5 Variable for the X-machine memory.
 * \param minsky_state_20 Variable for the X-machine memory.
 * \param minsky_state_21 Variable for the X-machine memory.
 * \param minsky_state_22 Variable for the X-machine memory.
 * \param minsky_state_23 Variable for the X-machine memory.
 * \param minsky_state_30 Variable for the X-machine memory.
 * \param minsky_state_31 Variable for the X-machine memory.
 * \param minsky_state_32 Variable for the X-machine memory.
 * \param minsky_state_33 Variable for the X-machine memory.
 * \param minsky_state_40 Variable for the X-machine memory.
 * \param minsky_state_41 Variable for the X-machine memory.
 * \param minsky_state_42 Variable for the X-machine memory.
 * \param minsky_state_43 Variable for the X-machine memory.
 * \param age_at_bankruptcy Variable for the X-machine memory.
 * \param debt_at_bankruptcy Variable for the X-machine memory.
 * \param equity_at_bankruptcy Variable for the X-machine memory.
 * \param no_employees_at_bankruptcy Variable for the X-machine memory.
 * \param equity_asset_ratio Variable for the X-machine memory.
 * \param profit_asset_ratio Variable for the X-machine memory.
 * \param sales_asset_ratio Variable for the X-machine memory.
 * \param investment_asset_ratio Variable for the X-machine memory.
 * \param total_income Variable for the X-machine memory.
 * \param total_liabilities Variable for the X-machine memory.
 * \param total_expenses Variable for the X-machine memory.
 * \param current_shares_outstanding Variable for the X-machine memory.
 * \param employees Variable for the X-machine memory.
 * \param r_and_d_employees Variable for the X-machine memory.
 * \param wage_offer Variable for the X-machine memory.
 * \param technology Variable for the X-machine memory.
 * \param no_employees Variable for the X-machine memory.
 * \param no_employees_skill_1 Variable for the X-machine memory.
 * \param no_employees_skill_2 Variable for the X-machine memory.
 * \param no_employees_skill_3 Variable for the X-machine memory.
 * \param no_employees_skill_4 Variable for the X-machine memory.
 * \param no_employees_skill_5 Variable for the X-machine memory.
 * \param no_employees_subsidized Variable for the X-machine memory.
 * \param fraction_employees_subsidized Variable for the X-machine memory.
 * \param vacancies Variable for the X-machine memory.
 * \param no_redundancies Variable for the X-machine memory.
 * \param no_applications_round_1 Variable for the X-machine memory.
 * \param no_applications_round_2 Variable for the X-machine memory.
 * \param no_redundancies_r_and_d_employees Variable for the X-machine memory.
 * \param vacancies_r_and_d_employees Variable for the X-machine memory.
 * \param posted_vacancies Variable for the X-machine memory.
 * \param posted_vacancies_r_and_d_employees Variable for the X-machine memory.
 * \param average_g_skill Variable for the X-machine memory.
 * \param average_adaptation_speed_specific_skills Variable for the X-machine memory.
 * \param list_adaptation_speed_per_skill_group Variable for the X-machine memory.
 * \param average_s_skill_of_1 Variable for the X-machine memory.
 * \param average_s_skill_of_2 Variable for the X-machine memory.
 * \param average_s_skill_of_3 Variable for the X-machine memory.
 * \param average_s_skill_of_4 Variable for the X-machine memory.
 * \param average_s_skill_of_5 Variable for the X-machine memory.
 * \param wage_offer_for_skill_1 Variable for the X-machine memory.
 * \param wage_offer_for_skill_2 Variable for the X-machine memory.
 * \param wage_offer_for_skill_3 Variable for the X-machine memory.
 * \param wage_offer_for_skill_4 Variable for the X-machine memory.
 * \param wage_offer_for_skill_5 Variable for the X-machine memory.
 * \param wage_offer_for_r_and_d_employees Variable for the X-machine memory.
 * \param base_wage_offer_r_and_d Variable for the X-machine memory.
 * \param employees_needed Variable for the X-machine memory.
 * \param firm_balance_sheet_calendar Variable for the X-machine memory.
 * \param firm_stocks_calendar Variable for the X-machine memory.
 * \param firm_outflows_calendar Variable for the X-machine memory.
 * \param firm_inflows_calendar Variable for the X-machine memory.
 * \param age Variable for the X-machine memory.
 * \param transfer_payment Variable for the X-machine memory.
 * \param subsidy_pct Variable for the X-machine memory.
 * \param active Variable for the X-machine memory.
 * \param inactive Variable for the X-machine memory.
 * \param zero_output Variable for the X-machine memory.
 * \param bankruptcy_idle_counter Variable for the X-machine memory.
 * \param bankruptcy_state Variable for the X-machine memory.
 * \param bankruptcy_insolvency_state Variable for the X-machine memory.
 * \param bankruptcy_illiquidity_state Variable for the X-machine memory.
 * \param financial_crisis_state Variable for the X-machine memory.
 * \param vacancy_filling_rate Variable for the X-machine memory.
 * \param average_s_skill_from_eurostat Variable for the X-machine memory.
 * \param average_technology_from_eurostat Variable for the X-machine memory.
 * \param average_wage_offer_from_eurostat Variable for the X-machine memory.
 * \param average_output_from_eurostat Variable for the X-machine memory.
 * \param quality_price_competitors Variable for the X-machine memory.
 * \param subsidy_payment Variable for the X-machine memory.
 * \param current_price_index Variable for the X-machine memory.
 * \param current_quality_index Variable for the X-machine memory.
 * \param minimum_wage Variable for the X-machine memory.
 * \param no_competitors Variable for the X-machine memory.
 * \param indicator_earnings Variable for the X-machine memory.
 * \param indicator_capital_costs Variable for the X-machine memory.
 * \param agg_vacancy_filling_rate Variable for the X-machine memory.
 * \param market_research_sample_size Variable for the X-machine memory.
 * \param product_innovation Variable for the X-machine memory.
 * \param regional_analysis Variable for the X-machine memory.
 * \param day_of_year_market_research Variable for the X-machine memory.
 * \param day_of_month_price_was_set Variable for the X-machine memory.
 * \param actual_sample_size Variable for the X-machine memory.
 * \param last_market_sizes Variable for the X-machine memory.
 * \param price_range_pricing Variable for the X-machine memory.
 * \param estimated_variance_market_share Variable for the X-machine memory.
 * \param estimated_coefficients Variable for the X-machine memory.
 * \param price_range_innovation Variable for the X-machine memory.
 * \param price_quality_counts Variable for the X-machine memory.
 * \param price_quality_inno Variable for the X-machine memory.
 * \param new_product_released Variable for the X-machine memory.
 * \param prospective_variables Variable for the X-machine memory.
 * \param price_at_questionnaire Variable for the X-machine memory.
 * \param price_index_at_questionnaire Variable for the X-machine memory.
 * \param best_pricing_strategies Variable for the X-machine memory.
 * \param intermediate_quality Variable for the X-machine memory.
 * \param no_employees_product_innovation_fundable Variable for the X-machine memory.
 * \param r_and_d_probability_for_incremental_success Variable for the X-machine memory.
 * \param day_of_year_price_setting Variable for the X-machine memory.
 * \param market_research_active Variable for the X-machine memory.
 * \param innovation_successful Variable for the X-machine memory.
 * \param actual_market_share Variable for the X-machine memory.
 * \param market_size Variable for the X-machine memory.
 * \param market_size_reg1 Variable for the X-machine memory.
 * \param market_size_reg2 Variable for the X-machine memory.
 * \param estimated_market_size Variable for the X-machine memory.
 * \param linear_regression_market_size Variable for the X-machine memory.
 * \param counter_month_since_last_price_setting Variable for the X-machine memory.
 * \param demand_function_pricing Variable for the X-machine memory.
 * \param demand_functions_product_innovation Variable for the X-machine memory.
 * \param market_research_delayed Variable for the X-machine memory.
 * \param market_research_data_pricing Variable for the X-machine memory.
 * \param market_research_data_product_innovation Variable for the X-machine memory.
 * \param expected_earnings_per_month Variable for the X-machine memory.
 * \param expected_price_choices Variable for the X-machine memory.
 * \param no_considered_qualities Variable for the X-machine memory.
 * \param last_interest_rate_for_loans Variable for the X-machine memory.
 * \param cum_earnings_last_r_d_project Variable for the X-machine memory.
 * \param cum_r_d_investments Variable for the X-machine memory.
 * \param r_d_investments_last_project Variable for the X-machine memory.
 * \param total_person_months Variable for the X-machine memory.
 * \param cum_person_months Variable for the X-machine memory.
 * \param actual_r_and_d_success_probability Variable for the X-machine memory.
 * \param last_quality Variable for the X-machine memory.
 * \param quality_change Variable for the X-machine memory.
 * \param expected_sold_quantity_per_month Variable for the X-machine memory.
 * \param estimated_market_share Variable for the X-machine memory.
 * \param estimated_yearly_earnings Variable for the X-machine memory.
 * \param expected_earnings_and_costs_over_year Variable for the X-machine memory.
 * \param expected_output_in_current_month Variable for the X-machine memory.
 * \param expected_profit_in_current_month Variable for the X-machine memory.
 * \param expected_labor_costs_in_current_month Variable for the X-machine memory.
 * \param expected_capital_costs_in_current_month Variable for the X-machine memory.
 * \param expected_interests_in_current_month Variable for the X-machine memory.
 * \param expected_output_in_previous_month Variable for the X-machine memory.
 * \param expected_actual_sold_quantity_in_previous_month Variable for the X-machine memory.
 * \param expected_actual_sold_quantity_in_current_month Variable for the X-machine memory.
 * \param expected_labor_costs_in_previous_month Variable for the X-machine memory.
 * \param expected_capital_costs_in_previous_month Variable for the X-machine memory.
 * \param expected_interests_in_previous_month Variable for the X-machine memory.
 * \param expected_profit_in_previous_month Variable for the X-machine memory.
 * \param expected_wage_in_current_month Variable for the X-machine memory.
 * \param expected_wage_in_previous_month Variable for the X-machine memory.
 * \param expected_mean_specific_skills_in_current_month Variable for the X-machine memory.
 * \param expected_mean_specific_skills_in_previous_month Variable for the X-machine memory.
 * \param expected_average_productivity_in_current_month Variable for the X-machine memory.
 * \param expected_investment_nominal_in_current_month Variable for the X-machine memory.
 * \param expected_investment_nominal_in_previous_month Variable for the X-machine memory.
 * \param expected_average_productivity_in_previous_month Variable for the X-machine memory.
 * \param earnings_while_last_pricing_period Variable for the X-machine memory.
 * \param sum_earnings_since_price_change Variable for the X-machine memory.
 * \param variables_last_year Variable for the X-machine memory.
 * \param innovation_month_counter Variable for the X-machine memory.
 * \param periods_output_zero_counter Variable for the X-machine memory.
 * \param variables_change Variable for the X-machine memory.
 * \param r_and_d_investments_per_month Variable for the X-machine memory.
 * \param innovation_flag Variable for the X-machine memory.
 * \param innovation_employees_needed Variable for the X-machine memory.
 * \param no_employees_innovation Variable for the X-machine memory.
 * \param employees_needed_innovation Variable for the X-machine memory.
 * \param optimal_employees_needed_innovation Variable for the X-machine memory.
 * \param total_no_periods_for_product_development Variable for the X-machine memory.
 * \param ratio_project_value_established_product Variable for the X-machine memory.
 * \param vintage_choice_already_taken Variable for the X-machine memory.
 * \param change_due_to_last_innovation Variable for the X-machine memory.
 * \param remaining_periods_to_complete_product_development Variable for the X-machine memory.
 * \param planned_quality Variable for the X-machine memory.
 * \param product_development_completed Variable for the X-machine memory.
 * \param price_just_set_flag Variable for the X-machine memory.
 * \param value_lattice Variable for the X-machine memory.
 * \param combined_variance_demand_function Variable for the X-machine memory.
 */
void add_Firm_agent(int id, int region_id, int gov_id, int day_of_month_to_act, int last_day_of_month_to_act, double payment_account, double payment_account_balance_sheet, int bank_id, int partition_id, double cpi, double mean_wage, double total_mean_wage, double mean_wage_r_and_d, double needed_capital_stock, double stock, double critical_stock, double actual_cap_price, double mean_specific_skills, double planned_production_quantity, double production_quantity, double planned_output, double output, double unit_costs, double total_supply, double production_costs, double total_buffer, double revenue_per_day, estimators_linear_regression_array * linear_regression_estimators, double technological_frontier, adt_technology_vintages_array * technology_vintages, int vintage_selected, int investment_subsidy_type, double initial_market_size, double initial_technology, double utilization_capacity, double used_capital_units, double cum_revenue, sales_statistics_array * malls_sales_statistics, double quality, double price, double price_last_month, double actual_mark_up, double demand_capital_stock, double effective_investments, double effective_capital_stock, double planned_production_costs, double labour_costs_production, double labour_costs_innovation, double intermediate_quality_level_developing, double adaption_production_volume_due_to_insufficient_finances, sold_quantities_per_mall_array * sold_quantities, double total_sold_quantity, double cum_total_sold_quantity, double sold_quantity_in_calendar_month, delivery_volume_per_mall_array * delivery_volume, delivery_volume_per_mall_array * planned_delivery_volume, mall_info_array * current_mall_stocks, double_array * last_planned_production_quantities, double total_external_financing_obtained, double capital_costs, int employees_needed_production, int no_employees_production, double planned_innovation_expenditures, double planned_expenditures_production_innovation, double labour_costs, double labour_costs_per_unit, adt_capital_stock_vintages_array * capital_stock_vintages, int vintage_choice_taken, financing_capital_array * capital_financing, double financial_resources_for_production, double total_units_local_inventory, double calc_capital_costs, double calc_production_costs, double firm_productivity, double total_productivity_capital_stock, double firm_productivity_last_year, double firm_productivity_progress, double sold_quantity_in_last_calendar_month, double_array * last_sold_quantities, double_array * last_revenues, int_array * set_of_lenders, int_array * potential_lenders, int number_of_banks_asked, double received_interest_daily, double received_interest_in_calendar_month, int flag_illiquidity_correction, double ebit, double earnings, double tax_rate_corporate, double tax_rate_vat, double tax_payment, double tax_payment_in_calendar_month, double net_earnings, double_array * earnings_history, double previous_net_earnings, double total_interest_payment, double total_interest_payment_in_calendar_month, double total_debt_installment_payment, double total_debt_installment_payment_in_calendar_month, double total_dividend_payment, double total_dividend_payment_in_calendar_month, int flag_full_dividend, double current_share_price, double previous_dividend_per_share, double current_dividend_per_share, double previous_earnings_per_share, double current_earnings_per_share, double previous_dividend_per_earnings, double current_dividend_per_earnings, double debt_earnings_ratio, double debt_equity_ratio, double price_earnings_ratio, double retained_earnings_ratio, double earnings_per_share_ratio_growth, double critical_price_earnings_ratio, double critical_earnings_per_share_ratio, debt_item_array * loans, double total_debt, double target_debt, double total_debt_balance_sheet, double total_value_local_inventory, double total_value_local_inventory_balance_sheet, double total_units_capital_stock, double total_value_capital_stock, double total_value_capital_stock_balance_sheet, double total_capital_depreciation_value, double total_capital_depreciation_units, double total_assets, double equity, double equity_balance_sheet, double production_liquidity_needs, double financial_liquidity_needs, double total_financial_needs, double external_financial_needs, double earnings_per_share, double retained_earnings, double total_payments, int previous_shares_outstanding, int minsky_state, int minsky_state_1, int minsky_state_2, int minsky_state_3, int minsky_state_4, int minsky_state_5, int minsky_state_20, int minsky_state_21, int minsky_state_22, int minsky_state_23, int minsky_state_30, int minsky_state_31, int minsky_state_32, int minsky_state_33, int minsky_state_40, int minsky_state_41, int minsky_state_42, int minsky_state_43, int age_at_bankruptcy, double debt_at_bankruptcy, double equity_at_bankruptcy, int no_employees_at_bankruptcy, double equity_asset_ratio, double profit_asset_ratio, double sales_asset_ratio, double investment_asset_ratio, double total_income, double total_liabilities, double total_expenses, int current_shares_outstanding, employee_array * employees, employee_array * r_and_d_employees, double wage_offer, double technology, int no_employees, int no_employees_skill_1, int no_employees_skill_2, int no_employees_skill_3, int no_employees_skill_4, int no_employees_skill_5, int no_employees_subsidized, double fraction_employees_subsidized, int vacancies, int no_redundancies, int no_applications_round_1, int no_applications_round_2, int no_redundancies_r_and_d_employees, int vacancies_r_and_d_employees, int posted_vacancies, int posted_vacancies_r_and_d_employees, double average_g_skill, double average_adaptation_speed_specific_skills, adt_list_adaptation_speed_array * list_adaptation_speed_per_skill_group, double average_s_skill_of_1, double average_s_skill_of_2, double average_s_skill_of_3, double average_s_skill_of_4, double average_s_skill_of_5, double wage_offer_for_skill_1, double wage_offer_for_skill_2, double wage_offer_for_skill_3, double wage_offer_for_skill_4, double wage_offer_for_skill_5, double wage_offer_for_r_and_d_employees, double base_wage_offer_r_and_d, int employees_needed, firm_balance_sheet_adt firm_balance_sheet_calendar, firm_stocks_adt firm_stocks_calendar, firm_outflows_adt firm_outflows_calendar, firm_inflows_adt firm_inflows_calendar, int age, double transfer_payment, double subsidy_pct, int active, int inactive, int zero_output, int bankruptcy_idle_counter, int bankruptcy_state, int bankruptcy_insolvency_state, int bankruptcy_illiquidity_state, int financial_crisis_state, double vacancy_filling_rate, double average_s_skill_from_eurostat, double average_technology_from_eurostat, double average_wage_offer_from_eurostat, double average_output_from_eurostat, price_quality_pair_array * quality_price_competitors, double subsidy_payment, double current_price_index, double current_quality_index, double minimum_wage, int no_competitors, int indicator_earnings, int indicator_capital_costs, double agg_vacancy_filling_rate, int market_research_sample_size, int product_innovation, int regional_analysis, int day_of_year_market_research, int day_of_month_price_was_set, int actual_sample_size, dt_total_and_regional_market_size_array * last_market_sizes, dt_price_range price_range_pricing, double estimated_variance_market_share, price_quality_pair estimated_coefficients, dt_price_range price_range_innovation, int price_quality_counts[], price_quality_pair price_quality_inno[], int new_product_released, dt_prospective_variables_array * prospective_variables, double price_at_questionnaire, double price_index_at_questionnaire, dt_best_price_strategies_array * best_pricing_strategies, double intermediate_quality, int no_employees_product_innovation_fundable, double r_and_d_probability_for_incremental_success, int day_of_year_price_setting, int market_research_active, int innovation_successful, double actual_market_share, double market_size, double market_size_reg1, double market_size_reg2, double estimated_market_size, estimators_linear_regression_array * linear_regression_market_size, int counter_month_since_last_price_setting, dt_demand_function demand_function_pricing, dt_demand_function_array * demand_functions_product_innovation, int market_research_delayed, dt_market_research_price_array * market_research_data_pricing, dt_market_research_qualities_array * market_research_data_product_innovation, double expected_earnings_per_month, double_array * expected_price_choices, double no_considered_qualities, double last_interest_rate_for_loans, double cum_earnings_last_r_d_project, double cum_r_d_investments, double r_d_investments_last_project, int total_person_months, int cum_person_months, double actual_r_and_d_success_probability, double last_quality, double quality_change, double expected_sold_quantity_per_month, double estimated_market_share, double estimated_yearly_earnings, dt_monthly_estimations expected_earnings_and_costs_over_year[], double expected_output_in_current_month, double expected_profit_in_current_month, double expected_labor_costs_in_current_month, double expected_capital_costs_in_current_month, double expected_interests_in_current_month, double expected_output_in_previous_month, double expected_actual_sold_quantity_in_previous_month, double expected_actual_sold_quantity_in_current_month, double expected_labor_costs_in_previous_month, double expected_capital_costs_in_previous_month, double expected_interests_in_previous_month, double expected_profit_in_previous_month, double expected_wage_in_current_month, double expected_wage_in_previous_month, double expected_mean_specific_skills_in_current_month, double expected_mean_specific_skills_in_previous_month, double expected_average_productivity_in_current_month, double expected_investment_nominal_in_current_month, double expected_investment_nominal_in_previous_month, double expected_average_productivity_in_previous_month, double earnings_while_last_pricing_period, double sum_earnings_since_price_change, dt_variables_changed_array * variables_last_year, int innovation_month_counter, int periods_output_zero_counter, dt_variables_changed variables_change, double r_and_d_investments_per_month, int innovation_flag, int innovation_employees_needed, int no_employees_innovation, int employees_needed_innovation, int optimal_employees_needed_innovation, int total_no_periods_for_product_development, double ratio_project_value_established_product, int vintage_choice_already_taken, double change_due_to_last_innovation, int remaining_periods_to_complete_product_development, double planned_quality, double product_development_completed, double price_just_set_flag, dt_value_lattice_years_array * value_lattice, double combined_variance_demand_function)
{
	xmachine_memory_Firm * current;

	current = init_Firm_agent();
	/* new line added to handle dynamic agent creation*/
	current_xmachine_Firm_next_state = Firm_start_Firm_state;
	add_Firm_agent_internal(current, current_xmachine_Firm_next_state);

	current->id = id;
	current->region_id = region_id;
	current->gov_id = gov_id;
	current->day_of_month_to_act = day_of_month_to_act;
	current->last_day_of_month_to_act = last_day_of_month_to_act;
	current->payment_account = payment_account;
	current->payment_account_balance_sheet = payment_account_balance_sheet;
	current->bank_id = bank_id;
	current->partition_id = partition_id;
	current->cpi = cpi;
	current->mean_wage = mean_wage;
	current->total_mean_wage = total_mean_wage;
	current->mean_wage_r_and_d = mean_wage_r_and_d;
	current->needed_capital_stock = needed_capital_stock;
	current->stock = stock;
	current->critical_stock = critical_stock;
	current->actual_cap_price = actual_cap_price;
	current->mean_specific_skills = mean_specific_skills;
	current->planned_production_quantity = planned_production_quantity;
	current->production_quantity = production_quantity;
	current->planned_output = planned_output;
	current->output = output;
	current->unit_costs = unit_costs;
	current->total_supply = total_supply;
	current->production_costs = production_costs;
	current->total_buffer = total_buffer;
	current->revenue_per_day = revenue_per_day;
	copy_estimators_linear_regression_array(linear_regression_estimators, &current->linear_regression_estimators);
	current->technological_frontier = technological_frontier;
	copy_adt_technology_vintages_array(technology_vintages, &current->technology_vintages);
	current->vintage_selected = vintage_selected;
	current->investment_subsidy_type = investment_subsidy_type;
	current->initial_market_size = initial_market_size;
	current->initial_technology = initial_technology;
	current->utilization_capacity = utilization_capacity;
	current->used_capital_units = used_capital_units;
	current->cum_revenue = cum_revenue;
	copy_sales_statistics_array(malls_sales_statistics, &current->malls_sales_statistics);
	current->quality = quality;
	current->price = price;
	current->price_last_month = price_last_month;
	current->actual_mark_up = actual_mark_up;
	current->demand_capital_stock = demand_capital_stock;
	current->effective_investments = effective_investments;
	current->effective_capital_stock = effective_capital_stock;
	current->planned_production_costs = planned_production_costs;
	current->labour_costs_production = labour_costs_production;
	current->labour_costs_innovation = labour_costs_innovation;
	current->intermediate_quality_level_developing = intermediate_quality_level_developing;
	current->adaption_production_volume_due_to_insufficient_finances = adaption_production_volume_due_to_insufficient_finances;
	copy_sold_quantities_per_mall_array(sold_quantities, &current->sold_quantities);
	current->total_sold_quantity = total_sold_quantity;
	current->cum_total_sold_quantity = cum_total_sold_quantity;
	current->sold_quantity_in_calendar_month = sold_quantity_in_calendar_month;
	copy_delivery_volume_per_mall_array(delivery_volume, &current->delivery_volume);
	copy_delivery_volume_per_mall_array(planned_delivery_volume, &current->planned_delivery_volume);
	copy_mall_info_array(current_mall_stocks, &current->current_mall_stocks);
	copy_double_array(last_planned_production_quantities, &current->last_planned_production_quantities);
	current->total_external_financing_obtained = total_external_financing_obtained;
	current->capital_costs = capital_costs;
	current->employees_needed_production = employees_needed_production;
	current->no_employees_production = no_employees_production;
	current->planned_innovation_expenditures = planned_innovation_expenditures;
	current->planned_expenditures_production_innovation = planned_expenditures_production_innovation;
	current->labour_costs = labour_costs;
	current->labour_costs_per_unit = labour_costs_per_unit;
	copy_adt_capital_stock_vintages_array(capital_stock_vintages, &current->capital_stock_vintages);
	current->vintage_choice_taken = vintage_choice_taken;
	copy_financing_capital_array(capital_financing, &current->capital_financing);
	current->financial_resources_for_production = financial_resources_for_production;
	current->total_units_local_inventory = total_units_local_inventory;
	current->calc_capital_costs = calc_capital_costs;
	current->calc_production_costs = calc_production_costs;
	current->firm_productivity = firm_productivity;
	current->total_productivity_capital_stock = total_productivity_capital_stock;
	current->firm_productivity_last_year = firm_productivity_last_year;
	current->firm_productivity_progress = firm_productivity_progress;
	current->sold_quantity_in_last_calendar_month = sold_quantity_in_last_calendar_month;
	copy_double_array(last_sold_quantities, &current->last_sold_quantities);
	copy_double_array(last_revenues, &current->last_revenues);
	copy_int_array(set_of_lenders, &current->set_of_lenders);
	copy_int_array(potential_lenders, &current->potential_lenders);
	current->number_of_banks_asked = number_of_banks_asked;
	current->received_interest_daily = received_interest_daily;
	current->received_interest_in_calendar_month = received_interest_in_calendar_month;
	current->flag_illiquidity_correction = flag_illiquidity_correction;
	current->ebit = ebit;
	current->earnings = earnings;
	current->tax_rate_corporate = tax_rate_corporate;
	current->tax_rate_vat = tax_rate_vat;
	current->tax_payment = tax_payment;
	current->tax_payment_in_calendar_month = tax_payment_in_calendar_month;
	current->net_earnings = net_earnings;
	copy_double_array(earnings_history, &current->earnings_history);
	current->previous_net_earnings = previous_net_earnings;
	current->total_interest_payment = total_interest_payment;
	current->total_interest_payment_in_calendar_month = total_interest_payment_in_calendar_month;
	current->total_debt_installment_payment = total_debt_installment_payment;
	current->total_debt_installment_payment_in_calendar_month = total_debt_installment_payment_in_calendar_month;
	current->total_dividend_payment = total_dividend_payment;
	current->total_dividend_payment_in_calendar_month = total_dividend_payment_in_calendar_month;
	current->flag_full_dividend = flag_full_dividend;
	current->current_share_price = current_share_price;
	current->previous_dividend_per_share = previous_dividend_per_share;
	current->current_dividend_per_share = current_dividend_per_share;
	current->previous_earnings_per_share = previous_earnings_per_share;
	current->current_earnings_per_share = current_earnings_per_share;
	current->previous_dividend_per_earnings = previous_dividend_per_earnings;
	current->current_dividend_per_earnings = current_dividend_per_earnings;
	current->debt_earnings_ratio = debt_earnings_ratio;
	current->debt_equity_ratio = debt_equity_ratio;
	current->price_earnings_ratio = price_earnings_ratio;
	current->retained_earnings_ratio = retained_earnings_ratio;
	current->earnings_per_share_ratio_growth = earnings_per_share_ratio_growth;
	current->critical_price_earnings_ratio = critical_price_earnings_ratio;
	current->critical_earnings_per_share_ratio = critical_earnings_per_share_ratio;
	copy_debt_item_array(loans, &current->loans);
	current->total_debt = total_debt;
	current->target_debt = target_debt;
	current->total_debt_balance_sheet = total_debt_balance_sheet;
	current->total_value_local_inventory = total_value_local_inventory;
	current->total_value_local_inventory_balance_sheet = total_value_local_inventory_balance_sheet;
	current->total_units_capital_stock = total_units_capital_stock;
	current->total_value_capital_stock = total_value_capital_stock;
	current->total_value_capital_stock_balance_sheet = total_value_capital_stock_balance_sheet;
	current->total_capital_depreciation_value = total_capital_depreciation_value;
	current->total_capital_depreciation_units = total_capital_depreciation_units;
	current->total_assets = total_assets;
	current->equity = equity;
	current->equity_balance_sheet = equity_balance_sheet;
	current->production_liquidity_needs = production_liquidity_needs;
	current->financial_liquidity_needs = financial_liquidity_needs;
	current->total_financial_needs = total_financial_needs;
	current->external_financial_needs = external_financial_needs;
	current->earnings_per_share = earnings_per_share;
	current->retained_earnings = retained_earnings;
	current->total_payments = total_payments;
	current->previous_shares_outstanding = previous_shares_outstanding;
	current->minsky_state = minsky_state;
	current->minsky_state_1 = minsky_state_1;
	current->minsky_state_2 = minsky_state_2;
	current->minsky_state_3 = minsky_state_3;
	current->minsky_state_4 = minsky_state_4;
	current->minsky_state_5 = minsky_state_5;
	current->minsky_state_20 = minsky_state_20;
	current->minsky_state_21 = minsky_state_21;
	current->minsky_state_22 = minsky_state_22;
	current->minsky_state_23 = minsky_state_23;
	current->minsky_state_30 = minsky_state_30;
	current->minsky_state_31 = minsky_state_31;
	current->minsky_state_32 = minsky_state_32;
	current->minsky_state_33 = minsky_state_33;
	current->minsky_state_40 = minsky_state_40;
	current->minsky_state_41 = minsky_state_41;
	current->minsky_state_42 = minsky_state_42;
	current->minsky_state_43 = minsky_state_43;
	current->age_at_bankruptcy = age_at_bankruptcy;
	current->debt_at_bankruptcy = debt_at_bankruptcy;
	current->equity_at_bankruptcy = equity_at_bankruptcy;
	current->no_employees_at_bankruptcy = no_employees_at_bankruptcy;
	current->equity_asset_ratio = equity_asset_ratio;
	current->profit_asset_ratio = profit_asset_ratio;
	current->sales_asset_ratio = sales_asset_ratio;
	current->investment_asset_ratio = investment_asset_ratio;
	current->total_income = total_income;
	current->total_liabilities = total_liabilities;
	current->total_expenses = total_expenses;
	current->current_shares_outstanding = current_shares_outstanding;
	copy_employee_array(employees, &current->employees);
	copy_employee_array(r_and_d_employees, &current->r_and_d_employees);
	current->wage_offer = wage_offer;
	current->technology = technology;
	current->no_employees = no_employees;
	current->no_employees_skill_1 = no_employees_skill_1;
	current->no_employees_skill_2 = no_employees_skill_2;
	current->no_employees_skill_3 = no_employees_skill_3;
	current->no_employees_skill_4 = no_employees_skill_4;
	current->no_employees_skill_5 = no_employees_skill_5;
	current->no_employees_subsidized = no_employees_subsidized;
	current->fraction_employees_subsidized = fraction_employees_subsidized;
	current->vacancies = vacancies;
	current->no_redundancies = no_redundancies;
	current->no_applications_round_1 = no_applications_round_1;
	current->no_applications_round_2 = no_applications_round_2;
	current->no_redundancies_r_and_d_employees = no_redundancies_r_and_d_employees;
	current->vacancies_r_and_d_employees = vacancies_r_and_d_employees;
	current->posted_vacancies = posted_vacancies;
	current->posted_vacancies_r_and_d_employees = posted_vacancies_r_and_d_employees;
	current->average_g_skill = average_g_skill;
	current->average_adaptation_speed_specific_skills = average_adaptation_speed_specific_skills;
	copy_adt_list_adaptation_speed_array(list_adaptation_speed_per_skill_group, &current->list_adaptation_speed_per_skill_group);
	current->average_s_skill_of_1 = average_s_skill_of_1;
	current->average_s_skill_of_2 = average_s_skill_of_2;
	current->average_s_skill_of_3 = average_s_skill_of_3;
	current->average_s_skill_of_4 = average_s_skill_of_4;
	current->average_s_skill_of_5 = average_s_skill_of_5;
	current->wage_offer_for_skill_1 = wage_offer_for_skill_1;
	current->wage_offer_for_skill_2 = wage_offer_for_skill_2;
	current->wage_offer_for_skill_3 = wage_offer_for_skill_3;
	current->wage_offer_for_skill_4 = wage_offer_for_skill_4;
	current->wage_offer_for_skill_5 = wage_offer_for_skill_5;
	current->wage_offer_for_r_and_d_employees = wage_offer_for_r_and_d_employees;
	current->base_wage_offer_r_and_d = base_wage_offer_r_and_d;
	current->employees_needed = employees_needed;
	copy_firm_balance_sheet_adt(&firm_balance_sheet_calendar, &current->firm_balance_sheet_calendar);
	copy_firm_stocks_adt(&firm_stocks_calendar, &current->firm_stocks_calendar);
	copy_firm_outflows_adt(&firm_outflows_calendar, &current->firm_outflows_calendar);
	copy_firm_inflows_adt(&firm_inflows_calendar, &current->firm_inflows_calendar);
	current->age = age;
	current->transfer_payment = transfer_payment;
	current->subsidy_pct = subsidy_pct;
	current->active = active;
	current->inactive = inactive;
	current->zero_output = zero_output;
	current->bankruptcy_idle_counter = bankruptcy_idle_counter;
	current->bankruptcy_state = bankruptcy_state;
	current->bankruptcy_insolvency_state = bankruptcy_insolvency_state;
	current->bankruptcy_illiquidity_state = bankruptcy_illiquidity_state;
	current->financial_crisis_state = financial_crisis_state;
	current->vacancy_filling_rate = vacancy_filling_rate;
	current->average_s_skill_from_eurostat = average_s_skill_from_eurostat;
	current->average_technology_from_eurostat = average_technology_from_eurostat;
	current->average_wage_offer_from_eurostat = average_wage_offer_from_eurostat;
	current->average_output_from_eurostat = average_output_from_eurostat;
	copy_price_quality_pair_array(quality_price_competitors, &current->quality_price_competitors);
	current->subsidy_payment = subsidy_payment;
	current->current_price_index = current_price_index;
	current->current_quality_index = current_quality_index;
	current->minimum_wage = minimum_wage;
	current->no_competitors = no_competitors;
	current->indicator_earnings = indicator_earnings;
	current->indicator_capital_costs = indicator_capital_costs;
	current->agg_vacancy_filling_rate = agg_vacancy_filling_rate;
	current->market_research_sample_size = market_research_sample_size;
	current->product_innovation = product_innovation;
	current->regional_analysis = regional_analysis;
	current->day_of_year_market_research = day_of_year_market_research;
	current->day_of_month_price_was_set = day_of_month_price_was_set;
	current->actual_sample_size = actual_sample_size;
	copy_dt_total_and_regional_market_size_array(last_market_sizes, &current->last_market_sizes);
	copy_dt_price_range(&price_range_pricing, &current->price_range_pricing);
	current->estimated_variance_market_share = estimated_variance_market_share;
	copy_price_quality_pair(&estimated_coefficients, &current->estimated_coefficients);
	copy_dt_price_range(&price_range_innovation, &current->price_range_innovation);
	memcpy(current->price_quality_counts, price_quality_counts, 12*sizeof(int));
	copy_price_quality_pair_static_array(price_quality_inno, current->price_quality_inno, 12);
	current->new_product_released = new_product_released;
	copy_dt_prospective_variables_array(prospective_variables, &current->prospective_variables);
	current->price_at_questionnaire = price_at_questionnaire;
	current->price_index_at_questionnaire = price_index_at_questionnaire;
	copy_dt_best_price_strategies_array(best_pricing_strategies, &current->best_pricing_strategies);
	current->intermediate_quality = intermediate_quality;
	current->no_employees_product_innovation_fundable = no_employees_product_innovation_fundable;
	current->r_and_d_probability_for_incremental_success = r_and_d_probability_for_incremental_success;
	current->day_of_year_price_setting = day_of_year_price_setting;
	current->market_research_active = market_research_active;
	current->innovation_successful = innovation_successful;
	current->actual_market_share = actual_market_share;
	current->market_size = market_size;
	current->market_size_reg1 = market_size_reg1;
	current->market_size_reg2 = market_size_reg2;
	current->estimated_market_size = estimated_market_size;
	copy_estimators_linear_regression_array(linear_regression_market_size, &current->linear_regression_market_size);
	current->counter_month_since_last_price_setting = counter_month_since_last_price_setting;
	copy_dt_demand_function(&demand_function_pricing, &current->demand_function_pricing);
	copy_dt_demand_function_array(demand_functions_product_innovation, &current->demand_functions_product_innovation);
	current->market_research_delayed = market_research_delayed;
	copy_dt_market_research_price_array(market_research_data_pricing, &current->market_research_data_pricing);
	copy_dt_market_research_qualities_array(market_research_data_product_innovation, &current->market_research_data_product_innovation);
	current->expected_earnings_per_month = expected_earnings_per_month;
	copy_double_array(expected_price_choices, &current->expected_price_choices);
	current->no_considered_qualities = no_considered_qualities;
	current->last_interest_rate_for_loans = last_interest_rate_for_loans;
	current->cum_earnings_last_r_d_project = cum_earnings_last_r_d_project;
	current->cum_r_d_investments = cum_r_d_investments;
	current->r_d_investments_last_project = r_d_investments_last_project;
	current->total_person_months = total_person_months;
	current->cum_person_months = cum_person_months;
	current->actual_r_and_d_success_probability = actual_r_and_d_success_probability;
	current->last_quality = last_quality;
	current->quality_change = quality_change;
	current->expected_sold_quantity_per_month = expected_sold_quantity_per_month;
	current->estimated_market_share = estimated_market_share;
	current->estimated_yearly_earnings = estimated_yearly_earnings;
	copy_dt_monthly_estimations_static_array(expected_earnings_and_costs_over_year, current->expected_earnings_and_costs_over_year, 12);
	current->expected_output_in_current_month = expected_output_in_current_month;
	current->expected_profit_in_current_month = expected_profit_in_current_month;
	current->expected_labor_costs_in_current_month = expected_labor_costs_in_current_month;
	current->expected_capital_costs_in_current_month = expected_capital_costs_in_current_month;
	current->expected_interests_in_current_month = expected_interests_in_current_month;
	current->expected_output_in_previous_month = expected_output_in_previous_month;
	current->expected_actual_sold_quantity_in_previous_month = expected_actual_sold_quantity_in_previous_month;
	current->expected_actual_sold_quantity_in_current_month = expected_actual_sold_quantity_in_current_month;
	current->expected_labor_costs_in_previous_month = expected_labor_costs_in_previous_month;
	current->expected_capital_costs_in_previous_month = expected_capital_costs_in_previous_month;
	current->expected_interests_in_previous_month = expected_interests_in_previous_month;
	current->expected_profit_in_previous_month = expected_profit_in_previous_month;
	current->expected_wage_in_current_month = expected_wage_in_current_month;
	current->expected_wage_in_previous_month = expected_wage_in_previous_month;
	current->expected_mean_specific_skills_in_current_month = expected_mean_specific_skills_in_current_month;
	current->expected_mean_specific_skills_in_previous_month = expected_mean_specific_skills_in_previous_month;
	current->expected_average_productivity_in_current_month = expected_average_productivity_in_current_month;
	current->expected_investment_nominal_in_current_month = expected_investment_nominal_in_current_month;
	current->expected_investment_nominal_in_previous_month = expected_investment_nominal_in_previous_month;
	current->expected_average_productivity_in_previous_month = expected_average_productivity_in_previous_month;
	current->earnings_while_last_pricing_period = earnings_while_last_pricing_period;
	current->sum_earnings_since_price_change = sum_earnings_since_price_change;
	copy_dt_variables_changed_array(variables_last_year, &current->variables_last_year);
	current->innovation_month_counter = innovation_month_counter;
	current->periods_output_zero_counter = periods_output_zero_counter;
	copy_dt_variables_changed(&variables_change, &current->variables_change);
	current->r_and_d_investments_per_month = r_and_d_investments_per_month;
	current->innovation_flag = innovation_flag;
	current->innovation_employees_needed = innovation_employees_needed;
	current->no_employees_innovation = no_employees_innovation;
	current->employees_needed_innovation = employees_needed_innovation;
	current->optimal_employees_needed_innovation = optimal_employees_needed_innovation;
	current->total_no_periods_for_product_development = total_no_periods_for_product_development;
	current->ratio_project_value_established_product = ratio_project_value_established_product;
	current->vintage_choice_already_taken = vintage_choice_already_taken;
	current->change_due_to_last_innovation = change_due_to_last_innovation;
	current->remaining_periods_to_complete_product_development = remaining_periods_to_complete_product_development;
	current->planned_quality = planned_quality;
	current->product_development_completed = product_development_completed;
	current->price_just_set_flag = price_just_set_flag;
	copy_dt_value_lattice_years_array(value_lattice, &current->value_lattice);
	current->combined_variance_demand_function = combined_variance_demand_function;
}

xmachine_memory_Household_state * init_Household_state()
{
	xmachine_memory_Household_state * current = (xmachine_memory_Household_state *)malloc(sizeof(xmachine_memory_Household_state));
	CHECK_POINTER(current);

	current->agents = NULL;
	current->count = 0;

	return current;
}

xmachine_memory_Household * init_Household_agent()
{
	xmachine_memory_Household * current = (xmachine_memory_Household *)malloc(sizeof(xmachine_memory_Household));
	CHECK_POINTER(current);

	current->id = 0;
	current->region_id = 0;
	init_int_array(&current->neighboring_region_ids);
	current->gov_id = 0;
	current->day_of_month_to_act = 0;
	current->payment_account = 0.0;
	current->bank_id = 0;
	current->partition_id = 0;
	current->new_agent = 0;
	current->migration_status = 0;
	current->consumption_budget = 0.0;
	current->consumption_budget_in_month = 0.0;
	current->week_of_month = 0;
	current->weekly_budget = 0.0;
	current->rationed = 0;
	current->mall_completely_sold_out = 0;
	init_ordered_quantity_static_array(current->order_quantity, 2);
	init_received_quantities_static_array(current->received_quantity, 2);
	current->day_of_week_to_act = 0;
	current->day_of_month_receive_income = 0;
	current->current_productivity_employer = 0.0;
	current->current_mean_specific_skills_employer = 0.0;
	current->tax_payment = 0.0;
	current->cum_total_dividends = 0.0;
	current->tax_rate_hh_capital = 0.0;
	current->tax_rate_hh_labour = 0.0;
	current->price_index = 0.0;
	current->price_index_base_period = 0.0;
	current->commuting_costs_price_level_weight = 0.0;
	current->expenditures = 0.0;
	current->received_dividend = 0.0;
	current->received_dividend_in_calendar_month = 0.0;
	current->received_interest_daily = 0.0;
	current->received_interest_in_calendar_month = 0.0;
	current->flag_consumption_shifting = 0;
	current->excess_weekly_budget = 0.0;
	current->wealth_income_ratio_actual = 0.0;
	current->wealth_income_ratio_target = 0.0;
	current->last_weekly_budget = 0.0;
	current->risk_free_rate = 0.0;
	current->wealth = 0.0;
	init_Belief(&current->beliefs);
	init_index_portfolio(&current->assetsowned);
	current->logit_beta = 0.0;
	current->wage = 0.0;
	current->wage_reservation = 0.0;
	current->general_skill = 0;
	init_adt_list_adaptation_speed_array(&current->list_adaptation_speed_per_general_skill_group);
	current->on_the_job_search = 0;
	current->search_today = 0;
	current->last_labour_income = 0.0;
	current->specific_skill = 0.0;
	current->employee_firm_id = 0;
	current->hh_applications_per_day = 0;
	current->just_employed = 0;
	current->just_unemployed = 0;
	current->start_unemployed = 0;
	current->start_employed = 0;
	current->unemployed_duration = 0;
	current->enter_matching = 0;
	current->employer_region_id = 0;
	current->employer_igfirm = 0;
	current->day_of_month_receive_benefit = 0;
	current->unemployment_payment = 0.0;
	current->region_wide_mean_wage = 0.0;
	current->basic_security_benefits = 0.0;
	init_double_array(&current->last_net_income);
	current->mean_net_income = 0.0;
	init_household_balance_sheet_adt(&current->household_balance_sheet_calendar);
	init_household_stocks_adt(&current->household_stocks_calendar);
	init_household_outflows_adt(&current->household_outflows_calendar);
	init_household_inflows_adt(&current->household_inflows_calendar);
	current->unemployment_benefit_pct = 0.0;
	current->minimum_wage = 0.0;
	current->transfer_payment = 0.0;
	current->subsidy_pct = 0.0;
	current->monthly_interest_income = 0.0;
	current->total_income = 0.0;
	current->total_expenses = 0.0;
	current->total_assets = 0.0;
	current->total_liabilities = 0.0;
	current->monthly_consumption_expenditure = 0.0;
	current->monthly_bond_interest_income = 0.0;
	current->subsidy_payment = 0.0;
	current->region_mean_wage = 0.0;
	current->human_capital_policy_flag = 0;
	current->questionnaire_attending_propability = 0.0;
	current->willingness_to_attend = 0;
	current->interviewer_id = 0;
	current->random_no_test = 0;
	init_int_static_array(current->questionnaire, 40);
	init_consumption_goods_offer_array(&current->current_price_quality_list);

	return current;
}

void free_Household_agent(xmachine_memory_Household_holder * tmp, xmachine_memory_Household_state * state)
{
	if(tmp->prev == NULL) state->agents = tmp->next;
	else tmp->prev->next = tmp->next;
	if(tmp->next != NULL) tmp->next->prev = tmp->prev;

	free_int_array(&tmp->agent->neighboring_region_ids);
	free_ordered_quantity_static_array(tmp->agent->order_quantity, 2);
	free_received_quantities_static_array(tmp->agent->received_quantity, 2);
	free_Belief(&tmp->agent->beliefs);
	free_index_portfolio(&tmp->agent->assetsowned);
	free_adt_list_adaptation_speed_array(&tmp->agent->list_adaptation_speed_per_general_skill_group);
	free_double_array(&tmp->agent->last_net_income);
	free_household_balance_sheet_adt(&tmp->agent->household_balance_sheet_calendar);
	free_household_stocks_adt(&tmp->agent->household_stocks_calendar);
	free_household_outflows_adt(&tmp->agent->household_outflows_calendar);
	free_household_inflows_adt(&tmp->agent->household_inflows_calendar);
	free_consumption_goods_offer_array(&tmp->agent->current_price_quality_list);
	

	free(tmp->agent);
	free(tmp);
}

void unittest_init_Household_agent()
{
	current_xmachine_Household = (xmachine_memory_Household *)malloc(sizeof(xmachine_memory_Household));
	CHECK_POINTER(current);

		current_xmachine_Household->id = 0;
		current_xmachine_Household->region_id = 0;
		init_int_array(&current_xmachine_Household->neighboring_region_ids);
		current_xmachine_Household->gov_id = 0;
		current_xmachine_Household->day_of_month_to_act = 0;
		current_xmachine_Household->payment_account = 0.0;
		current_xmachine_Household->bank_id = 0;
		current_xmachine_Household->partition_id = 0;
		current_xmachine_Household->new_agent = 0;
		current_xmachine_Household->migration_status = 0;
		current_xmachine_Household->consumption_budget = 0.0;
		current_xmachine_Household->consumption_budget_in_month = 0.0;
		current_xmachine_Household->week_of_month = 0;
		current_xmachine_Household->weekly_budget = 0.0;
		current_xmachine_Household->rationed = 0;
		current_xmachine_Household->mall_completely_sold_out = 0;
		init_ordered_quantity_static_array(current_xmachine_Household->order_quantity, 2);
		init_received_quantities_static_array(current_xmachine_Household->received_quantity, 2);
		current_xmachine_Household->day_of_week_to_act = 0;
		current_xmachine_Household->day_of_month_receive_income = 0;
		current_xmachine_Household->current_productivity_employer = 0.0;
		current_xmachine_Household->current_mean_specific_skills_employer = 0.0;
		current_xmachine_Household->tax_payment = 0.0;
		current_xmachine_Household->cum_total_dividends = 0.0;
		current_xmachine_Household->tax_rate_hh_capital = 0.0;
		current_xmachine_Household->tax_rate_hh_labour = 0.0;
		current_xmachine_Household->price_index = 0.0;
		current_xmachine_Household->price_index_base_period = 0.0;
		current_xmachine_Household->commuting_costs_price_level_weight = 0.0;
		current_xmachine_Household->expenditures = 0.0;
		current_xmachine_Household->received_dividend = 0.0;
		current_xmachine_Household->received_dividend_in_calendar_month = 0.0;
		current_xmachine_Household->received_interest_daily = 0.0;
		current_xmachine_Household->received_interest_in_calendar_month = 0.0;
		current_xmachine_Household->flag_consumption_shifting = 0;
		current_xmachine_Household->excess_weekly_budget = 0.0;
		current_xmachine_Household->wealth_income_ratio_actual = 0.0;
		current_xmachine_Household->wealth_income_ratio_target = 0.0;
		current_xmachine_Household->last_weekly_budget = 0.0;
		current_xmachine_Household->risk_free_rate = 0.0;
		current_xmachine_Household->wealth = 0.0;
		init_Belief(&current_xmachine_Household->beliefs);
		init_index_portfolio(&current_xmachine_Household->assetsowned);
		current_xmachine_Household->logit_beta = 0.0;
		current_xmachine_Household->wage = 0.0;
		current_xmachine_Household->wage_reservation = 0.0;
		current_xmachine_Household->general_skill = 0;
		init_adt_list_adaptation_speed_array(&current_xmachine_Household->list_adaptation_speed_per_general_skill_group);
		current_xmachine_Household->on_the_job_search = 0;
		current_xmachine_Household->search_today = 0;
		current_xmachine_Household->last_labour_income = 0.0;
		current_xmachine_Household->specific_skill = 0.0;
		current_xmachine_Household->employee_firm_id = 0;
		current_xmachine_Household->hh_applications_per_day = 0;
		current_xmachine_Household->just_employed = 0;
		current_xmachine_Household->just_unemployed = 0;
		current_xmachine_Household->start_unemployed = 0;
		current_xmachine_Household->start_employed = 0;
		current_xmachine_Household->unemployed_duration = 0;
		current_xmachine_Household->enter_matching = 0;
		current_xmachine_Household->employer_region_id = 0;
		current_xmachine_Household->employer_igfirm = 0;
		current_xmachine_Household->day_of_month_receive_benefit = 0;
		current_xmachine_Household->unemployment_payment = 0.0;
		current_xmachine_Household->region_wide_mean_wage = 0.0;
		current_xmachine_Household->basic_security_benefits = 0.0;
		init_double_array(&current_xmachine_Household->last_net_income);
		current_xmachine_Household->mean_net_income = 0.0;
		init_household_balance_sheet_adt(&current_xmachine_Household->household_balance_sheet_calendar);
		init_household_stocks_adt(&current_xmachine_Household->household_stocks_calendar);
		init_household_outflows_adt(&current_xmachine_Household->household_outflows_calendar);
		init_household_inflows_adt(&current_xmachine_Household->household_inflows_calendar);
		current_xmachine_Household->unemployment_benefit_pct = 0.0;
		current_xmachine_Household->minimum_wage = 0.0;
		current_xmachine_Household->transfer_payment = 0.0;
		current_xmachine_Household->subsidy_pct = 0.0;
		current_xmachine_Household->monthly_interest_income = 0.0;
		current_xmachine_Household->total_income = 0.0;
		current_xmachine_Household->total_expenses = 0.0;
		current_xmachine_Household->total_assets = 0.0;
		current_xmachine_Household->total_liabilities = 0.0;
		current_xmachine_Household->monthly_consumption_expenditure = 0.0;
		current_xmachine_Household->monthly_bond_interest_income = 0.0;
		current_xmachine_Household->subsidy_payment = 0.0;
		current_xmachine_Household->region_mean_wage = 0.0;
		current_xmachine_Household->human_capital_policy_flag = 0;
		current_xmachine_Household->questionnaire_attending_propability = 0.0;
		current_xmachine_Household->willingness_to_attend = 0;
		current_xmachine_Household->interviewer_id = 0;
		current_xmachine_Household->random_no_test = 0;
		init_int_static_array(current_xmachine_Household->questionnaire, 40);
		init_consumption_goods_offer_array(&current_xmachine_Household->current_price_quality_list);
	
}

void unittest_free_Household_agent()
{
	free_int_array(&current_xmachine_Household->neighboring_region_ids);
	free_ordered_quantity_static_array(current_xmachine_Household->order_quantity, 2);
	free_received_quantities_static_array(current_xmachine_Household->received_quantity, 2);
	free_Belief(&current_xmachine_Household->beliefs);
	free_index_portfolio(&current_xmachine_Household->assetsowned);
	free_adt_list_adaptation_speed_array(&current_xmachine_Household->list_adaptation_speed_per_general_skill_group);
	free_double_array(&current_xmachine_Household->last_net_income);
	free_household_balance_sheet_adt(&current_xmachine_Household->household_balance_sheet_calendar);
	free_household_stocks_adt(&current_xmachine_Household->household_stocks_calendar);
	free_household_outflows_adt(&current_xmachine_Household->household_outflows_calendar);
	free_household_inflows_adt(&current_xmachine_Household->household_inflows_calendar);
	free_consumption_goods_offer_array(&current_xmachine_Household->current_price_quality_list);
	
	free(current_xmachine_Household);
}

void free_Household_agents()
{
	current_xmachine_Household_holder = Household_HH_MR_2_state->agents;
	while(current_xmachine_Household_holder)
	{
		temp_xmachine_Household_holder = current_xmachine_Household_holder->next;
		free_Household_agent(current_xmachine_Household_holder, Household_HH_MR_2_state);
		current_xmachine_Household_holder = temp_xmachine_Household_holder;
	}
	Household_HH_MR_2_state->count = 0;
	current_xmachine_Household_holder = Household_HH_MR_1_state->agents;
	while(current_xmachine_Household_holder)
	{
		temp_xmachine_Household_holder = current_xmachine_Household_holder->next;
		free_Household_agent(current_xmachine_Household_holder, Household_HH_MR_1_state);
		current_xmachine_Household_holder = temp_xmachine_Household_holder;
	}
	Household_HH_MR_1_state->count = 0;
	current_xmachine_Household_holder = Household_end_Household_state->agents;
	while(current_xmachine_Household_holder)
	{
		temp_xmachine_Household_holder = current_xmachine_Household_holder->next;
		free_Household_agent(current_xmachine_Household_holder, Household_end_Household_state);
		current_xmachine_Household_holder = temp_xmachine_Household_holder;
	}
	Household_end_Household_state->count = 0;
	current_xmachine_Household_holder = Household_17_state->agents;
	while(current_xmachine_Household_holder)
	{
		temp_xmachine_Household_holder = current_xmachine_Household_holder->next;
		free_Household_agent(current_xmachine_Household_holder, Household_17_state);
		current_xmachine_Household_holder = temp_xmachine_Household_holder;
	}
	Household_17_state->count = 0;
	current_xmachine_Household_holder = Household_Household_Start_Market_Research_Role_state->agents;
	while(current_xmachine_Household_holder)
	{
		temp_xmachine_Household_holder = current_xmachine_Household_holder->next;
		free_Household_agent(current_xmachine_Household_holder, Household_Household_Start_Market_Research_Role_state);
		current_xmachine_Household_holder = temp_xmachine_Household_holder;
	}
	Household_Household_Start_Market_Research_Role_state->count = 0;
	current_xmachine_Household_holder = Household_Household_Start_Policy_Data_state->agents;
	while(current_xmachine_Household_holder)
	{
		temp_xmachine_Household_holder = current_xmachine_Household_holder->next;
		free_Household_agent(current_xmachine_Household_holder, Household_Household_Start_Policy_Data_state);
		current_xmachine_Household_holder = temp_xmachine_Household_holder;
	}
	Household_Household_Start_Policy_Data_state->count = 0;
	current_xmachine_Household_holder = Household_Pol_01_state->agents;
	while(current_xmachine_Household_holder)
	{
		temp_xmachine_Household_holder = current_xmachine_Household_holder->next;
		free_Household_agent(current_xmachine_Household_holder, Household_Pol_01_state);
		current_xmachine_Household_holder = temp_xmachine_Household_holder;
	}
	Household_Pol_01_state->count = 0;
	current_xmachine_Household_holder = Household_Household_Start_Yearly_Loop_Top_state->agents;
	while(current_xmachine_Household_holder)
	{
		temp_xmachine_Household_holder = current_xmachine_Household_holder->next;
		free_Household_agent(current_xmachine_Household_holder, Household_Household_Start_Yearly_Loop_Top_state);
		current_xmachine_Household_holder = temp_xmachine_Household_holder;
	}
	Household_Household_Start_Yearly_Loop_Top_state->count = 0;
	current_xmachine_Household_holder = Household_Household_initialize_state->agents;
	while(current_xmachine_Household_holder)
	{
		temp_xmachine_Household_holder = current_xmachine_Household_holder->next;
		free_Household_agent(current_xmachine_Household_holder, Household_Household_initialize_state);
		current_xmachine_Household_holder = temp_xmachine_Household_holder;
	}
	Household_Household_initialize_state->count = 0;
	current_xmachine_Household_holder = Household_start_Household_state->agents;
	while(current_xmachine_Household_holder)
	{
		temp_xmachine_Household_holder = current_xmachine_Household_holder->next;
		free_Household_agent(current_xmachine_Household_holder, Household_start_Household_state);
		current_xmachine_Household_holder = temp_xmachine_Household_holder;
	}
	Household_start_Household_state->count = 0;
	current_xmachine_Household_holder = Household_08b_state->agents;
	while(current_xmachine_Household_holder)
	{
		temp_xmachine_Household_holder = current_xmachine_Household_holder->next;
		free_Household_agent(current_xmachine_Household_holder, Household_08b_state);
		current_xmachine_Household_holder = temp_xmachine_Household_holder;
	}
	Household_08b_state->count = 0;
	current_xmachine_Household_holder = Household_08_state->agents;
	while(current_xmachine_Household_holder)
	{
		temp_xmachine_Household_holder = current_xmachine_Household_holder->next;
		free_Household_agent(current_xmachine_Household_holder, Household_08_state);
		current_xmachine_Household_holder = temp_xmachine_Household_holder;
	}
	Household_08_state->count = 0;
	current_xmachine_Household_holder = Household_07_state->agents;
	while(current_xmachine_Household_holder)
	{
		temp_xmachine_Household_holder = current_xmachine_Household_holder->next;
		free_Household_agent(current_xmachine_Household_holder, Household_07_state);
		current_xmachine_Household_holder = temp_xmachine_Household_holder;
	}
	Household_07_state->count = 0;
	current_xmachine_Household_holder = Household_06e_state->agents;
	while(current_xmachine_Household_holder)
	{
		temp_xmachine_Household_holder = current_xmachine_Household_holder->next;
		free_Household_agent(current_xmachine_Household_holder, Household_06e_state);
		current_xmachine_Household_holder = temp_xmachine_Household_holder;
	}
	Household_06e_state->count = 0;
	current_xmachine_Household_holder = Household_06d_state->agents;
	while(current_xmachine_Household_holder)
	{
		temp_xmachine_Household_holder = current_xmachine_Household_holder->next;
		free_Household_agent(current_xmachine_Household_holder, Household_06d_state);
		current_xmachine_Household_holder = temp_xmachine_Household_holder;
	}
	Household_06d_state->count = 0;
	current_xmachine_Household_holder = Household_06c_state->agents;
	while(current_xmachine_Household_holder)
	{
		temp_xmachine_Household_holder = current_xmachine_Household_holder->next;
		free_Household_agent(current_xmachine_Household_holder, Household_06c_state);
		current_xmachine_Household_holder = temp_xmachine_Household_holder;
	}
	Household_06c_state->count = 0;
	current_xmachine_Household_holder = Household_06b_state->agents;
	while(current_xmachine_Household_holder)
	{
		temp_xmachine_Household_holder = current_xmachine_Household_holder->next;
		free_Household_agent(current_xmachine_Household_holder, Household_06b_state);
		current_xmachine_Household_holder = temp_xmachine_Household_holder;
	}
	Household_06b_state->count = 0;
	current_xmachine_Household_holder = Household_05_state->agents;
	while(current_xmachine_Household_holder)
	{
		temp_xmachine_Household_holder = current_xmachine_Household_holder->next;
		free_Household_agent(current_xmachine_Household_holder, Household_05_state);
		current_xmachine_Household_holder = temp_xmachine_Household_holder;
	}
	Household_05_state->count = 0;
	current_xmachine_Household_holder = Household_04_state->agents;
	while(current_xmachine_Household_holder)
	{
		temp_xmachine_Household_holder = current_xmachine_Household_holder->next;
		free_Household_agent(current_xmachine_Household_holder, Household_04_state);
		current_xmachine_Household_holder = temp_xmachine_Household_holder;
	}
	Household_04_state->count = 0;
	current_xmachine_Household_holder = Household_03_state->agents;
	while(current_xmachine_Household_holder)
	{
		temp_xmachine_Household_holder = current_xmachine_Household_holder->next;
		free_Household_agent(current_xmachine_Household_holder, Household_03_state);
		current_xmachine_Household_holder = temp_xmachine_Household_holder;
	}
	Household_03_state->count = 0;
	current_xmachine_Household_holder = Household_02_state->agents;
	while(current_xmachine_Household_holder)
	{
		temp_xmachine_Household_holder = current_xmachine_Household_holder->next;
		free_Household_agent(current_xmachine_Household_holder, Household_02_state);
		current_xmachine_Household_holder = temp_xmachine_Household_holder;
	}
	Household_02_state->count = 0;
	current_xmachine_Household_holder = Household_06_state->agents;
	while(current_xmachine_Household_holder)
	{
		temp_xmachine_Household_holder = current_xmachine_Household_holder->next;
		free_Household_agent(current_xmachine_Household_holder, Household_06_state);
		current_xmachine_Household_holder = temp_xmachine_Household_holder;
	}
	Household_06_state->count = 0;
	current_xmachine_Household_holder = Household_01_state->agents;
	while(current_xmachine_Household_holder)
	{
		temp_xmachine_Household_holder = current_xmachine_Household_holder->next;
		free_Household_agent(current_xmachine_Household_holder, Household_01_state);
		current_xmachine_Household_holder = temp_xmachine_Household_holder;
	}
	Household_01_state->count = 0;
	current_xmachine_Household_holder = Household_01a_state->agents;
	while(current_xmachine_Household_holder)
	{
		temp_xmachine_Household_holder = current_xmachine_Household_holder->next;
		free_Household_agent(current_xmachine_Household_holder, Household_01a_state);
		current_xmachine_Household_holder = temp_xmachine_Household_holder;
	}
	Household_01a_state->count = 0;
	current_xmachine_Household_holder = Household_01d_state->agents;
	while(current_xmachine_Household_holder)
	{
		temp_xmachine_Household_holder = current_xmachine_Household_holder->next;
		free_Household_agent(current_xmachine_Household_holder, Household_01d_state);
		current_xmachine_Household_holder = temp_xmachine_Household_holder;
	}
	Household_01d_state->count = 0;
	current_xmachine_Household_holder = Household_Household_Start_Labour_Role_state->agents;
	while(current_xmachine_Household_holder)
	{
		temp_xmachine_Household_holder = current_xmachine_Household_holder->next;
		free_Household_agent(current_xmachine_Household_holder, Household_Household_Start_Labour_Role_state);
		current_xmachine_Household_holder = temp_xmachine_Household_holder;
	}
	Household_Household_Start_Labour_Role_state->count = 0;
	current_xmachine_Household_holder = Household_AFM_002_state->agents;
	while(current_xmachine_Household_holder)
	{
		temp_xmachine_Household_holder = current_xmachine_Household_holder->next;
		free_Household_agent(current_xmachine_Household_holder, Household_AFM_002_state);
		current_xmachine_Household_holder = temp_xmachine_Household_holder;
	}
	Household_AFM_002_state->count = 0;
	current_xmachine_Household_holder = Household_AFM_001_state->agents;
	while(current_xmachine_Household_holder)
	{
		temp_xmachine_Household_holder = current_xmachine_Household_holder->next;
		free_Household_agent(current_xmachine_Household_holder, Household_AFM_001_state);
		current_xmachine_Household_holder = temp_xmachine_Household_holder;
	}
	Household_AFM_001_state->count = 0;
	current_xmachine_Household_holder = Household_AFM_000_state->agents;
	while(current_xmachine_Household_holder)
	{
		temp_xmachine_Household_holder = current_xmachine_Household_holder->next;
		free_Household_agent(current_xmachine_Household_holder, Household_AFM_000_state);
		current_xmachine_Household_holder = temp_xmachine_Household_holder;
	}
	Household_AFM_000_state->count = 0;
	current_xmachine_Household_holder = Household_Household_Start_Financial_Market_Role_state->agents;
	while(current_xmachine_Household_holder)
	{
		temp_xmachine_Household_holder = current_xmachine_Household_holder->next;
		free_Household_agent(current_xmachine_Household_holder, Household_Household_Start_Financial_Market_Role_state);
		current_xmachine_Household_holder = temp_xmachine_Household_holder;
	}
	Household_Household_Start_Financial_Market_Role_state->count = 0;
	current_xmachine_Household_holder = Household_16_state->agents;
	while(current_xmachine_Household_holder)
	{
		temp_xmachine_Household_holder = current_xmachine_Household_holder->next;
		free_Household_agent(current_xmachine_Household_holder, Household_16_state);
		current_xmachine_Household_holder = temp_xmachine_Household_holder;
	}
	Household_16_state->count = 0;
	current_xmachine_Household_holder = Household_12_state->agents;
	while(current_xmachine_Household_holder)
	{
		temp_xmachine_Household_holder = current_xmachine_Household_holder->next;
		free_Household_agent(current_xmachine_Household_holder, Household_12_state);
		current_xmachine_Household_holder = temp_xmachine_Household_holder;
	}
	Household_12_state->count = 0;
	current_xmachine_Household_holder = Household_14_state->agents;
	while(current_xmachine_Household_holder)
	{
		temp_xmachine_Household_holder = current_xmachine_Household_holder->next;
		free_Household_agent(current_xmachine_Household_holder, Household_14_state);
		current_xmachine_Household_holder = temp_xmachine_Household_holder;
	}
	Household_14_state->count = 0;
	current_xmachine_Household_holder = Household_11_state->agents;
	while(current_xmachine_Household_holder)
	{
		temp_xmachine_Household_holder = current_xmachine_Household_holder->next;
		free_Household_agent(current_xmachine_Household_holder, Household_11_state);
		current_xmachine_Household_holder = temp_xmachine_Household_holder;
	}
	Household_11_state->count = 0;
	current_xmachine_Household_holder = Household_10_state->agents;
	while(current_xmachine_Household_holder)
	{
		temp_xmachine_Household_holder = current_xmachine_Household_holder->next;
		free_Household_agent(current_xmachine_Household_holder, Household_10_state);
		current_xmachine_Household_holder = temp_xmachine_Household_holder;
	}
	Household_10_state->count = 0;
	current_xmachine_Household_holder = Household_15_state->agents;
	while(current_xmachine_Household_holder)
	{
		temp_xmachine_Household_holder = current_xmachine_Household_holder->next;
		free_Household_agent(current_xmachine_Household_holder, Household_15_state);
		current_xmachine_Household_holder = temp_xmachine_Household_holder;
	}
	Household_15_state->count = 0;
	current_xmachine_Household_holder = Household_09_state->agents;
	while(current_xmachine_Household_holder)
	{
		temp_xmachine_Household_holder = current_xmachine_Household_holder->next;
		free_Household_agent(current_xmachine_Household_holder, Household_09_state);
		current_xmachine_Household_holder = temp_xmachine_Household_holder;
	}
	Household_09_state->count = 0;
}

void free_Household_states()
{
	free(Household_HH_MR_2_state);
	free(Household_HH_MR_1_state);
	free(Household_end_Household_state);
	free(Household_17_state);
	free(Household_Household_Start_Market_Research_Role_state);
	free(Household_Household_Start_Policy_Data_state);
	free(Household_Pol_01_state);
	free(Household_Household_Start_Yearly_Loop_Top_state);
	free(Household_Household_initialize_state);
	free(Household_start_Household_state);
	free(Household_08b_state);
	free(Household_08_state);
	free(Household_07_state);
	free(Household_06e_state);
	free(Household_06d_state);
	free(Household_06c_state);
	free(Household_06b_state);
	free(Household_05_state);
	free(Household_04_state);
	free(Household_03_state);
	free(Household_02_state);
	free(Household_06_state);
	free(Household_01_state);
	free(Household_01a_state);
	free(Household_01d_state);
	free(Household_Household_Start_Labour_Role_state);
	free(Household_AFM_002_state);
	free(Household_AFM_001_state);
	free(Household_AFM_000_state);
	free(Household_Household_Start_Financial_Market_Role_state);
	free(Household_16_state);
	free(Household_12_state);
	free(Household_14_state);
	free(Household_11_state);
	free(Household_10_state);
	free(Household_15_state);
	free(Household_09_state);
}

void transition_Household_agent(xmachine_memory_Household_holder * tmp, xmachine_memory_Household_state * from_state, xmachine_memory_Household_state * to_state)
{
	if(tmp->prev == NULL) from_state->agents = tmp->next;
	else tmp->prev->next = tmp->next;
	if(tmp->next != NULL) tmp->next->prev = tmp->prev;

	add_Household_agent_internal(tmp->agent, to_state);
	free(tmp);
}

void add_Household_agent_internal(xmachine_memory_Household * agent, xmachine_memory_Household_state * state)
{
	xmachine_memory_Household_holder * current = (xmachine_memory_Household_holder *)malloc(sizeof(xmachine_memory_Household_holder));
	CHECK_POINTER(current);

	current->next = state->agents;
	current->prev = NULL;
	state->agents = current;
	if(current->next != NULL) current->next->prev = current;
	current->agent = agent;

	state->count++;

}

/** \fn void add_Household_agent(int id, int region_id, int_array * neighboring_region_ids, int gov_id, int day_of_month_to_act, double payment_account, int bank_id, int partition_id, int new_agent, int migration_status, double consumption_budget, double consumption_budget_in_month, int week_of_month, double weekly_budget, int rationed, int mall_completely_sold_out, ordered_quantity ** order_quantity, received_quantities ** received_quantity, int day_of_week_to_act, int day_of_month_receive_income, double current_productivity_employer, double current_mean_specific_skills_employer, double tax_payment, double cum_total_dividends, double tax_rate_hh_capital, double tax_rate_hh_labour, double price_index, double price_index_base_period, double commuting_costs_price_level_weight, double expenditures, double received_dividend, double received_dividend_in_calendar_month, double received_interest_daily, double received_interest_in_calendar_month, int flag_consumption_shifting, double excess_weekly_budget, double wealth_income_ratio_actual, double wealth_income_ratio_target, double last_weekly_budget, double risk_free_rate, double wealth, Belief * beliefs, index_portfolio * assetsowned, double logit_beta, double wage, double wage_reservation, int general_skill, adt_list_adaptation_speed_array * list_adaptation_speed_per_general_skill_group, int on_the_job_search, int search_today, double last_labour_income, double specific_skill, int employee_firm_id, int hh_applications_per_day, int just_employed, int just_unemployed, int start_unemployed, int start_employed, int unemployed_duration, int enter_matching, int employer_region_id, int employer_igfirm, int day_of_month_receive_benefit, double unemployment_payment, double region_wide_mean_wage, double basic_security_benefits, double_array * last_net_income, double mean_net_income, household_balance_sheet_adt * household_balance_sheet_calendar, household_stocks_adt * household_stocks_calendar, household_outflows_adt * household_outflows_calendar, household_inflows_adt * household_inflows_calendar, double unemployment_benefit_pct, double minimum_wage, double transfer_payment, double subsidy_pct, double monthly_interest_income, double total_income, double total_expenses, double total_assets, double total_liabilities, double monthly_consumption_expenditure, double monthly_bond_interest_income, double subsidy_payment, double region_mean_wage, int human_capital_policy_flag, double questionnaire_attending_propability, int willingness_to_attend, int interviewer_id, int random_no_test, int questionnaire[], consumption_goods_offer_array * current_price_quality_list)
 * \brief Add Household X-machine to the current being used X-machine list.
 * \param id Variable for the X-machine memory.
 * \param region_id Variable for the X-machine memory.
 * \param neighboring_region_ids Variable for the X-machine memory.
 * \param gov_id Variable for the X-machine memory.
 * \param day_of_month_to_act Variable for the X-machine memory.
 * \param payment_account Variable for the X-machine memory.
 * \param bank_id Variable for the X-machine memory.
 * \param partition_id Variable for the X-machine memory.
 * \param new_agent Variable for the X-machine memory.
 * \param migration_status Variable for the X-machine memory.
 * \param consumption_budget Variable for the X-machine memory.
 * \param consumption_budget_in_month Variable for the X-machine memory.
 * \param week_of_month Variable for the X-machine memory.
 * \param weekly_budget Variable for the X-machine memory.
 * \param rationed Variable for the X-machine memory.
 * \param mall_completely_sold_out Variable for the X-machine memory.
 * \param order_quantity Variable for the X-machine memory.
 * \param received_quantity Variable for the X-machine memory.
 * \param day_of_week_to_act Variable for the X-machine memory.
 * \param day_of_month_receive_income Variable for the X-machine memory.
 * \param current_productivity_employer Variable for the X-machine memory.
 * \param current_mean_specific_skills_employer Variable for the X-machine memory.
 * \param tax_payment Variable for the X-machine memory.
 * \param cum_total_dividends Variable for the X-machine memory.
 * \param tax_rate_hh_capital Variable for the X-machine memory.
 * \param tax_rate_hh_labour Variable for the X-machine memory.
 * \param price_index Variable for the X-machine memory.
 * \param price_index_base_period Variable for the X-machine memory.
 * \param commuting_costs_price_level_weight Variable for the X-machine memory.
 * \param expenditures Variable for the X-machine memory.
 * \param received_dividend Variable for the X-machine memory.
 * \param received_dividend_in_calendar_month Variable for the X-machine memory.
 * \param received_interest_daily Variable for the X-machine memory.
 * \param received_interest_in_calendar_month Variable for the X-machine memory.
 * \param flag_consumption_shifting Variable for the X-machine memory.
 * \param excess_weekly_budget Variable for the X-machine memory.
 * \param wealth_income_ratio_actual Variable for the X-machine memory.
 * \param wealth_income_ratio_target Variable for the X-machine memory.
 * \param last_weekly_budget Variable for the X-machine memory.
 * \param risk_free_rate Variable for the X-machine memory.
 * \param wealth Variable for the X-machine memory.
 * \param beliefs Variable for the X-machine memory.
 * \param assetsowned Variable for the X-machine memory.
 * \param logit_beta Variable for the X-machine memory.
 * \param wage Variable for the X-machine memory.
 * \param wage_reservation Variable for the X-machine memory.
 * \param general_skill Variable for the X-machine memory.
 * \param list_adaptation_speed_per_general_skill_group Variable for the X-machine memory.
 * \param on_the_job_search Variable for the X-machine memory.
 * \param search_today Variable for the X-machine memory.
 * \param last_labour_income Variable for the X-machine memory.
 * \param specific_skill Variable for the X-machine memory.
 * \param employee_firm_id Variable for the X-machine memory.
 * \param hh_applications_per_day Variable for the X-machine memory.
 * \param just_employed Variable for the X-machine memory.
 * \param just_unemployed Variable for the X-machine memory.
 * \param start_unemployed Variable for the X-machine memory.
 * \param start_employed Variable for the X-machine memory.
 * \param unemployed_duration Variable for the X-machine memory.
 * \param enter_matching Variable for the X-machine memory.
 * \param employer_region_id Variable for the X-machine memory.
 * \param employer_igfirm Variable for the X-machine memory.
 * \param day_of_month_receive_benefit Variable for the X-machine memory.
 * \param unemployment_payment Variable for the X-machine memory.
 * \param region_wide_mean_wage Variable for the X-machine memory.
 * \param basic_security_benefits Variable for the X-machine memory.
 * \param last_net_income Variable for the X-machine memory.
 * \param mean_net_income Variable for the X-machine memory.
 * \param household_balance_sheet_calendar Variable for the X-machine memory.
 * \param household_stocks_calendar Variable for the X-machine memory.
 * \param household_outflows_calendar Variable for the X-machine memory.
 * \param household_inflows_calendar Variable for the X-machine memory.
 * \param unemployment_benefit_pct Variable for the X-machine memory.
 * \param minimum_wage Variable for the X-machine memory.
 * \param transfer_payment Variable for the X-machine memory.
 * \param subsidy_pct Variable for the X-machine memory.
 * \param monthly_interest_income Variable for the X-machine memory.
 * \param total_income Variable for the X-machine memory.
 * \param total_expenses Variable for the X-machine memory.
 * \param total_assets Variable for the X-machine memory.
 * \param total_liabilities Variable for the X-machine memory.
 * \param monthly_consumption_expenditure Variable for the X-machine memory.
 * \param monthly_bond_interest_income Variable for the X-machine memory.
 * \param subsidy_payment Variable for the X-machine memory.
 * \param region_mean_wage Variable for the X-machine memory.
 * \param human_capital_policy_flag Variable for the X-machine memory.
 * \param questionnaire_attending_propability Variable for the X-machine memory.
 * \param willingness_to_attend Variable for the X-machine memory.
 * \param interviewer_id Variable for the X-machine memory.
 * \param random_no_test Variable for the X-machine memory.
 * \param questionnaire Variable for the X-machine memory.
 * \param current_price_quality_list Variable for the X-machine memory.
 */
void add_Household_agent(int id, int region_id, int_array * neighboring_region_ids, int gov_id, int day_of_month_to_act, double payment_account, int bank_id, int partition_id, int new_agent, int migration_status, double consumption_budget, double consumption_budget_in_month, int week_of_month, double weekly_budget, int rationed, int mall_completely_sold_out, ordered_quantity order_quantity[], received_quantities received_quantity[], int day_of_week_to_act, int day_of_month_receive_income, double current_productivity_employer, double current_mean_specific_skills_employer, double tax_payment, double cum_total_dividends, double tax_rate_hh_capital, double tax_rate_hh_labour, double price_index, double price_index_base_period, double commuting_costs_price_level_weight, double expenditures, double received_dividend, double received_dividend_in_calendar_month, double received_interest_daily, double received_interest_in_calendar_month, int flag_consumption_shifting, double excess_weekly_budget, double wealth_income_ratio_actual, double wealth_income_ratio_target, double last_weekly_budget, double risk_free_rate, double wealth, Belief beliefs, index_portfolio assetsowned, double logit_beta, double wage, double wage_reservation, int general_skill, adt_list_adaptation_speed_array * list_adaptation_speed_per_general_skill_group, int on_the_job_search, int search_today, double last_labour_income, double specific_skill, int employee_firm_id, int hh_applications_per_day, int just_employed, int just_unemployed, int start_unemployed, int start_employed, int unemployed_duration, int enter_matching, int employer_region_id, int employer_igfirm, int day_of_month_receive_benefit, double unemployment_payment, double region_wide_mean_wage, double basic_security_benefits, double_array * last_net_income, double mean_net_income, household_balance_sheet_adt household_balance_sheet_calendar, household_stocks_adt household_stocks_calendar, household_outflows_adt household_outflows_calendar, household_inflows_adt household_inflows_calendar, double unemployment_benefit_pct, double minimum_wage, double transfer_payment, double subsidy_pct, double monthly_interest_income, double total_income, double total_expenses, double total_assets, double total_liabilities, double monthly_consumption_expenditure, double monthly_bond_interest_income, double subsidy_payment, double region_mean_wage, int human_capital_policy_flag, double questionnaire_attending_propability, int willingness_to_attend, int interviewer_id, int random_no_test, int questionnaire[], consumption_goods_offer_array * current_price_quality_list)
{
	xmachine_memory_Household * current;

	current = init_Household_agent();
	/* new line added to handle dynamic agent creation*/
	current_xmachine_Household_next_state = Household_start_Household_state;
	add_Household_agent_internal(current, current_xmachine_Household_next_state);

	current->id = id;
	current->region_id = region_id;
	copy_int_array(neighboring_region_ids, &current->neighboring_region_ids);
	current->gov_id = gov_id;
	current->day_of_month_to_act = day_of_month_to_act;
	current->payment_account = payment_account;
	current->bank_id = bank_id;
	current->partition_id = partition_id;
	current->new_agent = new_agent;
	current->migration_status = migration_status;
	current->consumption_budget = consumption_budget;
	current->consumption_budget_in_month = consumption_budget_in_month;
	current->week_of_month = week_of_month;
	current->weekly_budget = weekly_budget;
	current->rationed = rationed;
	current->mall_completely_sold_out = mall_completely_sold_out;
	copy_ordered_quantity_static_array(order_quantity, current->order_quantity, 2);
	copy_received_quantities_static_array(received_quantity, current->received_quantity, 2);
	current->day_of_week_to_act = day_of_week_to_act;
	current->day_of_month_receive_income = day_of_month_receive_income;
	current->current_productivity_employer = current_productivity_employer;
	current->current_mean_specific_skills_employer = current_mean_specific_skills_employer;
	current->tax_payment = tax_payment;
	current->cum_total_dividends = cum_total_dividends;
	current->tax_rate_hh_capital = tax_rate_hh_capital;
	current->tax_rate_hh_labour = tax_rate_hh_labour;
	current->price_index = price_index;
	current->price_index_base_period = price_index_base_period;
	current->commuting_costs_price_level_weight = commuting_costs_price_level_weight;
	current->expenditures = expenditures;
	current->received_dividend = received_dividend;
	current->received_dividend_in_calendar_month = received_dividend_in_calendar_month;
	current->received_interest_daily = received_interest_daily;
	current->received_interest_in_calendar_month = received_interest_in_calendar_month;
	current->flag_consumption_shifting = flag_consumption_shifting;
	current->excess_weekly_budget = excess_weekly_budget;
	current->wealth_income_ratio_actual = wealth_income_ratio_actual;
	current->wealth_income_ratio_target = wealth_income_ratio_target;
	current->last_weekly_budget = last_weekly_budget;
	current->risk_free_rate = risk_free_rate;
	current->wealth = wealth;
	copy_Belief(&beliefs, &current->beliefs);
	copy_index_portfolio(&assetsowned, &current->assetsowned);
	current->logit_beta = logit_beta;
	current->wage = wage;
	current->wage_reservation = wage_reservation;
	current->general_skill = general_skill;
	copy_adt_list_adaptation_speed_array(list_adaptation_speed_per_general_skill_group, &current->list_adaptation_speed_per_general_skill_group);
	current->on_the_job_search = on_the_job_search;
	current->search_today = search_today;
	current->last_labour_income = last_labour_income;
	current->specific_skill = specific_skill;
	current->employee_firm_id = employee_firm_id;
	current->hh_applications_per_day = hh_applications_per_day;
	current->just_employed = just_employed;
	current->just_unemployed = just_unemployed;
	current->start_unemployed = start_unemployed;
	current->start_employed = start_employed;
	current->unemployed_duration = unemployed_duration;
	current->enter_matching = enter_matching;
	current->employer_region_id = employer_region_id;
	current->employer_igfirm = employer_igfirm;
	current->day_of_month_receive_benefit = day_of_month_receive_benefit;
	current->unemployment_payment = unemployment_payment;
	current->region_wide_mean_wage = region_wide_mean_wage;
	current->basic_security_benefits = basic_security_benefits;
	copy_double_array(last_net_income, &current->last_net_income);
	current->mean_net_income = mean_net_income;
	copy_household_balance_sheet_adt(&household_balance_sheet_calendar, &current->household_balance_sheet_calendar);
	copy_household_stocks_adt(&household_stocks_calendar, &current->household_stocks_calendar);
	copy_household_outflows_adt(&household_outflows_calendar, &current->household_outflows_calendar);
	copy_household_inflows_adt(&household_inflows_calendar, &current->household_inflows_calendar);
	current->unemployment_benefit_pct = unemployment_benefit_pct;
	current->minimum_wage = minimum_wage;
	current->transfer_payment = transfer_payment;
	current->subsidy_pct = subsidy_pct;
	current->monthly_interest_income = monthly_interest_income;
	current->total_income = total_income;
	current->total_expenses = total_expenses;
	current->total_assets = total_assets;
	current->total_liabilities = total_liabilities;
	current->monthly_consumption_expenditure = monthly_consumption_expenditure;
	current->monthly_bond_interest_income = monthly_bond_interest_income;
	current->subsidy_payment = subsidy_payment;
	current->region_mean_wage = region_mean_wage;
	current->human_capital_policy_flag = human_capital_policy_flag;
	current->questionnaire_attending_propability = questionnaire_attending_propability;
	current->willingness_to_attend = willingness_to_attend;
	current->interviewer_id = interviewer_id;
	current->random_no_test = random_no_test;
	memcpy(current->questionnaire, questionnaire, 40*sizeof(int));
	copy_consumption_goods_offer_array(current_price_quality_list, &current->current_price_quality_list);
}

xmachine_memory_Mall_state * init_Mall_state()
{
	xmachine_memory_Mall_state * current = (xmachine_memory_Mall_state *)malloc(sizeof(xmachine_memory_Mall_state));
	CHECK_POINTER(current);

	current->agents = NULL;
	current->count = 0;

	return current;
}

xmachine_memory_Mall * init_Mall_agent()
{
	xmachine_memory_Mall * current = (xmachine_memory_Mall *)malloc(sizeof(xmachine_memory_Mall));
	CHECK_POINTER(current);

	current->id = 0;
	current->region_id = 0;
	current->gov_id = 0;
	current->partition_id = 0;
	init_mall_stock_array(&current->current_stock);
	init_sales_in_mall_array(&current->firm_revenues);
	current->total_supply = 0.0;
	current->sales_per_month = 0.0;
	init_double_static_array(current->export_volume_matrix, 900);
	init_double_static_array(current->export_value_matrix, 900);
	init_double_static_array(current->export_previous_value_matrix, 900);

	return current;
}

void free_Mall_agent(xmachine_memory_Mall_holder * tmp, xmachine_memory_Mall_state * state)
{
	if(tmp->prev == NULL) state->agents = tmp->next;
	else tmp->prev->next = tmp->next;
	if(tmp->next != NULL) tmp->next->prev = tmp->prev;

	free_mall_stock_array(&tmp->agent->current_stock);
	free_sales_in_mall_array(&tmp->agent->firm_revenues);
	

	free(tmp->agent);
	free(tmp);
}

void unittest_init_Mall_agent()
{
	current_xmachine_Mall = (xmachine_memory_Mall *)malloc(sizeof(xmachine_memory_Mall));
	CHECK_POINTER(current);

		current_xmachine_Mall->id = 0;
		current_xmachine_Mall->region_id = 0;
		current_xmachine_Mall->gov_id = 0;
		current_xmachine_Mall->partition_id = 0;
		init_mall_stock_array(&current_xmachine_Mall->current_stock);
		init_sales_in_mall_array(&current_xmachine_Mall->firm_revenues);
		current_xmachine_Mall->total_supply = 0.0;
		current_xmachine_Mall->sales_per_month = 0.0;
		init_double_static_array(current_xmachine_Mall->export_volume_matrix, 900);
		init_double_static_array(current_xmachine_Mall->export_value_matrix, 900);
		init_double_static_array(current_xmachine_Mall->export_previous_value_matrix, 900);
	
}

void unittest_free_Mall_agent()
{
	free_mall_stock_array(&current_xmachine_Mall->current_stock);
	free_sales_in_mall_array(&current_xmachine_Mall->firm_revenues);
	
	free(current_xmachine_Mall);
}

void free_Mall_agents()
{
	current_xmachine_Mall_holder = Mall_Mall_initialize_state->agents;
	while(current_xmachine_Mall_holder)
	{
		temp_xmachine_Mall_holder = current_xmachine_Mall_holder->next;
		free_Mall_agent(current_xmachine_Mall_holder, Mall_Mall_initialize_state);
		current_xmachine_Mall_holder = temp_xmachine_Mall_holder;
	}
	Mall_Mall_initialize_state->count = 0;
	current_xmachine_Mall_holder = Mall_start_Mall_state->agents;
	while(current_xmachine_Mall_holder)
	{
		temp_xmachine_Mall_holder = current_xmachine_Mall_holder->next;
		free_Mall_agent(current_xmachine_Mall_holder, Mall_start_Mall_state);
		current_xmachine_Mall_holder = temp_xmachine_Mall_holder;
	}
	Mall_start_Mall_state->count = 0;
	current_xmachine_Mall_holder = Mall_end_Mall_state->agents;
	while(current_xmachine_Mall_holder)
	{
		temp_xmachine_Mall_holder = current_xmachine_Mall_holder->next;
		free_Mall_agent(current_xmachine_Mall_holder, Mall_end_Mall_state);
		current_xmachine_Mall_holder = temp_xmachine_Mall_holder;
	}
	Mall_end_Mall_state->count = 0;
	current_xmachine_Mall_holder = Mall_06_state->agents;
	while(current_xmachine_Mall_holder)
	{
		temp_xmachine_Mall_holder = current_xmachine_Mall_holder->next;
		free_Mall_agent(current_xmachine_Mall_holder, Mall_06_state);
		current_xmachine_Mall_holder = temp_xmachine_Mall_holder;
	}
	Mall_06_state->count = 0;
	current_xmachine_Mall_holder = Mall_05a_state->agents;
	while(current_xmachine_Mall_holder)
	{
		temp_xmachine_Mall_holder = current_xmachine_Mall_holder->next;
		free_Mall_agent(current_xmachine_Mall_holder, Mall_05a_state);
		current_xmachine_Mall_holder = temp_xmachine_Mall_holder;
	}
	Mall_05a_state->count = 0;
	current_xmachine_Mall_holder = Mall_05_state->agents;
	while(current_xmachine_Mall_holder)
	{
		temp_xmachine_Mall_holder = current_xmachine_Mall_holder->next;
		free_Mall_agent(current_xmachine_Mall_holder, Mall_05_state);
		current_xmachine_Mall_holder = temp_xmachine_Mall_holder;
	}
	Mall_05_state->count = 0;
	current_xmachine_Mall_holder = Mall_04_state->agents;
	while(current_xmachine_Mall_holder)
	{
		temp_xmachine_Mall_holder = current_xmachine_Mall_holder->next;
		free_Mall_agent(current_xmachine_Mall_holder, Mall_04_state);
		current_xmachine_Mall_holder = temp_xmachine_Mall_holder;
	}
	Mall_04_state->count = 0;
	current_xmachine_Mall_holder = Mall_03_state->agents;
	while(current_xmachine_Mall_holder)
	{
		temp_xmachine_Mall_holder = current_xmachine_Mall_holder->next;
		free_Mall_agent(current_xmachine_Mall_holder, Mall_03_state);
		current_xmachine_Mall_holder = temp_xmachine_Mall_holder;
	}
	Mall_03_state->count = 0;
	current_xmachine_Mall_holder = Mall_02_state->agents;
	while(current_xmachine_Mall_holder)
	{
		temp_xmachine_Mall_holder = current_xmachine_Mall_holder->next;
		free_Mall_agent(current_xmachine_Mall_holder, Mall_02_state);
		current_xmachine_Mall_holder = temp_xmachine_Mall_holder;
	}
	Mall_02_state->count = 0;
	current_xmachine_Mall_holder = Mall_01_state->agents;
	while(current_xmachine_Mall_holder)
	{
		temp_xmachine_Mall_holder = current_xmachine_Mall_holder->next;
		free_Mall_agent(current_xmachine_Mall_holder, Mall_01_state);
		current_xmachine_Mall_holder = temp_xmachine_Mall_holder;
	}
	Mall_01_state->count = 0;
	current_xmachine_Mall_holder = Mall_001_state->agents;
	while(current_xmachine_Mall_holder)
	{
		temp_xmachine_Mall_holder = current_xmachine_Mall_holder->next;
		free_Mall_agent(current_xmachine_Mall_holder, Mall_001_state);
		current_xmachine_Mall_holder = temp_xmachine_Mall_holder;
	}
	Mall_001_state->count = 0;
}

void free_Mall_states()
{
	free(Mall_Mall_initialize_state);
	free(Mall_start_Mall_state);
	free(Mall_end_Mall_state);
	free(Mall_06_state);
	free(Mall_05a_state);
	free(Mall_05_state);
	free(Mall_04_state);
	free(Mall_03_state);
	free(Mall_02_state);
	free(Mall_01_state);
	free(Mall_001_state);
}

void transition_Mall_agent(xmachine_memory_Mall_holder * tmp, xmachine_memory_Mall_state * from_state, xmachine_memory_Mall_state * to_state)
{
	if(tmp->prev == NULL) from_state->agents = tmp->next;
	else tmp->prev->next = tmp->next;
	if(tmp->next != NULL) tmp->next->prev = tmp->prev;

	add_Mall_agent_internal(tmp->agent, to_state);
	free(tmp);
}

void add_Mall_agent_internal(xmachine_memory_Mall * agent, xmachine_memory_Mall_state * state)
{
	xmachine_memory_Mall_holder * current = (xmachine_memory_Mall_holder *)malloc(sizeof(xmachine_memory_Mall_holder));
	CHECK_POINTER(current);

	current->next = state->agents;
	current->prev = NULL;
	state->agents = current;
	if(current->next != NULL) current->next->prev = current;
	current->agent = agent;

	state->count++;

}

/** \fn void add_Mall_agent(int id, int region_id, int gov_id, int partition_id, mall_stock_array * current_stock, sales_in_mall_array * firm_revenues, double total_supply, double sales_per_month, double export_volume_matrix[], double export_value_matrix[], double export_previous_value_matrix[])
 * \brief Add Mall X-machine to the current being used X-machine list.
 * \param id Variable for the X-machine memory.
 * \param region_id Variable for the X-machine memory.
 * \param gov_id Variable for the X-machine memory.
 * \param partition_id Variable for the X-machine memory.
 * \param current_stock Variable for the X-machine memory.
 * \param firm_revenues Variable for the X-machine memory.
 * \param total_supply Variable for the X-machine memory.
 * \param sales_per_month Variable for the X-machine memory.
 * \param export_volume_matrix Variable for the X-machine memory.
 * \param export_value_matrix Variable for the X-machine memory.
 * \param export_previous_value_matrix Variable for the X-machine memory.
 */
void add_Mall_agent(int id, int region_id, int gov_id, int partition_id, mall_stock_array * current_stock, sales_in_mall_array * firm_revenues, double total_supply, double sales_per_month, double export_volume_matrix[], double export_value_matrix[], double export_previous_value_matrix[])
{
	xmachine_memory_Mall * current;

	current = init_Mall_agent();
	/* new line added to handle dynamic agent creation*/
	current_xmachine_Mall_next_state = Mall_start_Mall_state;
	add_Mall_agent_internal(current, current_xmachine_Mall_next_state);

	current->id = id;
	current->region_id = region_id;
	current->gov_id = gov_id;
	current->partition_id = partition_id;
	copy_mall_stock_array(current_stock, &current->current_stock);
	copy_sales_in_mall_array(firm_revenues, &current->firm_revenues);
	current->total_supply = total_supply;
	current->sales_per_month = sales_per_month;
	memcpy(current->export_volume_matrix, export_volume_matrix, 900*sizeof(double));
	memcpy(current->export_value_matrix, export_value_matrix, 900*sizeof(double));
	memcpy(current->export_previous_value_matrix, export_previous_value_matrix, 900*sizeof(double));
}

xmachine_memory_IGFirm_state * init_IGFirm_state()
{
	xmachine_memory_IGFirm_state * current = (xmachine_memory_IGFirm_state *)malloc(sizeof(xmachine_memory_IGFirm_state));
	CHECK_POINTER(current);

	current->agents = NULL;
	current->count = 0;

	return current;
}

xmachine_memory_IGFirm * init_IGFirm_agent()
{
	xmachine_memory_IGFirm * current = (xmachine_memory_IGFirm *)malloc(sizeof(xmachine_memory_IGFirm));
	CHECK_POINTER(current);

	current->id = 0;
	current->region_id = 0;
	current->gov_id = 0;
	current->bank_id = 0;
	current->day_of_month_to_act = 0;
	current->last_day_of_month_to_act = 0;
	current->payment_account = 0.0;
	current->payment_account_balance_sheet = 0.0;
	current->partition_id = 0;
	current->received_interest_daily = 0.0;
	current->received_interest_in_calendar_month = 0.0;
	current->ebit = 0.0;
	current->earnings = 0.0;
	current->tax_rate_corporate = 0.0;
	current->tax_rate_vat = 0.0;
	current->tax_payment = 0.0;
	current->tax_payment_in_calendar_month = 0.0;
	current->net_earnings = 0.0;
	current->previous_net_earnings = 0.0;
	current->total_dividend_payment = 0.0;
	current->total_dividend_payment_in_calendar_month = 0.0;
	current->current_share_price = 0.0;
	current->previous_dividend_per_share = 0.0;
	current->current_dividend_per_share = 0.0;
	current->previous_earnings_per_share = 0.0;
	current->current_earnings_per_share = 0.0;
	current->previous_dividend_per_earnings = 0.0;
	current->current_dividend_per_earnings = 0.0;
	current->debt_earnings_ratio = 0.0;
	current->debt_equity_ratio = 0.0;
	current->price_earnings_ratio = 0.0;
	current->retained_earnings_ratio = 0.0;
	current->earnings_per_share_ratio_growth = 0.0;
	current->critical_price_earnings_ratio = 0.0;
	current->critical_earnings_per_share_ratio = 0.0;
	current->total_debt = 0.0;
	current->total_debt_balance_sheet = 0.0;
	current->total_assets = 0.0;
	current->equity = 0.0;
	current->equity_balance_sheet = 0.0;
	current->earnings_per_share = 0.0;
	current->total_payments = 0.0;
	current->previous_shares_outstanding = 0;
	current->total_income = 0.0;
	current->total_liabilities = 0.0;
	current->total_expenses = 0.0;
	current->calc_production_costs = 0.0;
	current->productivity = 0.0;
	current->capital_good_price = 0.0;
	init_vintage_array(&current->vintages);
	init_adt_sales_per_vintage_array(&current->sales_per_vintage);
	current->mean_productivity_of_sales = 0.0;
	current->ratio_sold_productivity_best_practice = 0.0;
	current->igfirm_endogenous_innovation_probability = 0.0;
	current->revenue_per_day = 0.0;
	current->net_profit = 0.0;
	current->current_shares_outstanding = 0;
	current->energy_price_markup = 0.0;
	current->energy_costs_per_day = 0.0;
	current->earnings_per_day = 0.0;
	current->cum_energy_costs = 0.0;
	init_double_array(&current->last_net_profits);
	current->mean_sales_last_months = 0.0;
	init_double_array(&current->last_sales);
	current->dividend_payment = 0.0;
	current->duration_until_next_innovation = 0;
	current->unit_costs = 0.0;
	current->sales = 0.0;
	current->capital_good_demand = 0.0;
	current->capital_good_demand_last_month = 0.0;
	current->sales_last_month = 0.0;
	current->cum_revenue = 0.0;
	current->cum_revenue_last_month = 0.0;
	init_int_array(&current->innovation_sheme_low_progress);
	init_int_array(&current->innovation_sheme_medium_progress);
	init_int_array(&current->innovation_sheme_high_progress);
	current->mean_general_skills = 0.0;
	current->mean_adaptation_speed = 0.0;
	init_adt_list_adaptation_speed_array(&current->list_adaptation_speed);
	current->productivity_progress_in_economy = 0.0;
	current->economy_wide_capital_stock = 0.0;
	current->dividend_buffer = 0.0;
	current->dividend_target = 0.0;
	init_igfirm_balance_sheet_adt(&current->igfirm_balance_sheet_calendar);
	init_igfirm_stocks_adt(&current->igfirm_stocks_calendar);
	init_igfirm_outflows_adt(&current->igfirm_outflows_calendar);
	init_igfirm_inflows_adt(&current->igfirm_inflows_calendar);
	current->age = 0;
	current->transfer_payment = 0.0;
	current->subsidy_pct = 0.0;
	current->active = 0;
	current->bankruptcy_idle_counter = 0;
	current->bankruptcy_state = 0;
	current->bankruptcy_insolvency_state = 0;
	current->bankruptcy_illiquidity_state = 0;
	current->financial_crisis_state = 0;
	current->economy_wide_general_skills_in_firms = 0.0;
	current->economy_wide_specific_skills_in_firms = 0.0;
	current->subsidy_payment = 0.0;
	current->wage_offer = 0.0;

	return current;
}

void free_IGFirm_agent(xmachine_memory_IGFirm_holder * tmp, xmachine_memory_IGFirm_state * state)
{
	if(tmp->prev == NULL) state->agents = tmp->next;
	else tmp->prev->next = tmp->next;
	if(tmp->next != NULL) tmp->next->prev = tmp->prev;

	free_vintage_array(&tmp->agent->vintages);
	free_adt_sales_per_vintage_array(&tmp->agent->sales_per_vintage);
	free_double_array(&tmp->agent->last_net_profits);
	free_double_array(&tmp->agent->last_sales);
	free_int_array(&tmp->agent->innovation_sheme_low_progress);
	free_int_array(&tmp->agent->innovation_sheme_medium_progress);
	free_int_array(&tmp->agent->innovation_sheme_high_progress);
	free_adt_list_adaptation_speed_array(&tmp->agent->list_adaptation_speed);
	free_igfirm_balance_sheet_adt(&tmp->agent->igfirm_balance_sheet_calendar);
	free_igfirm_stocks_adt(&tmp->agent->igfirm_stocks_calendar);
	free_igfirm_outflows_adt(&tmp->agent->igfirm_outflows_calendar);
	free_igfirm_inflows_adt(&tmp->agent->igfirm_inflows_calendar);
	

	free(tmp->agent);
	free(tmp);
}

void unittest_init_IGFirm_agent()
{
	current_xmachine_IGFirm = (xmachine_memory_IGFirm *)malloc(sizeof(xmachine_memory_IGFirm));
	CHECK_POINTER(current);

		current_xmachine_IGFirm->id = 0;
		current_xmachine_IGFirm->region_id = 0;
		current_xmachine_IGFirm->gov_id = 0;
		current_xmachine_IGFirm->bank_id = 0;
		current_xmachine_IGFirm->day_of_month_to_act = 0;
		current_xmachine_IGFirm->last_day_of_month_to_act = 0;
		current_xmachine_IGFirm->payment_account = 0.0;
		current_xmachine_IGFirm->payment_account_balance_sheet = 0.0;
		current_xmachine_IGFirm->partition_id = 0;
		current_xmachine_IGFirm->received_interest_daily = 0.0;
		current_xmachine_IGFirm->received_interest_in_calendar_month = 0.0;
		current_xmachine_IGFirm->ebit = 0.0;
		current_xmachine_IGFirm->earnings = 0.0;
		current_xmachine_IGFirm->tax_rate_corporate = 0.0;
		current_xmachine_IGFirm->tax_rate_vat = 0.0;
		current_xmachine_IGFirm->tax_payment = 0.0;
		current_xmachine_IGFirm->tax_payment_in_calendar_month = 0.0;
		current_xmachine_IGFirm->net_earnings = 0.0;
		current_xmachine_IGFirm->previous_net_earnings = 0.0;
		current_xmachine_IGFirm->total_dividend_payment = 0.0;
		current_xmachine_IGFirm->total_dividend_payment_in_calendar_month = 0.0;
		current_xmachine_IGFirm->current_share_price = 0.0;
		current_xmachine_IGFirm->previous_dividend_per_share = 0.0;
		current_xmachine_IGFirm->current_dividend_per_share = 0.0;
		current_xmachine_IGFirm->previous_earnings_per_share = 0.0;
		current_xmachine_IGFirm->current_earnings_per_share = 0.0;
		current_xmachine_IGFirm->previous_dividend_per_earnings = 0.0;
		current_xmachine_IGFirm->current_dividend_per_earnings = 0.0;
		current_xmachine_IGFirm->debt_earnings_ratio = 0.0;
		current_xmachine_IGFirm->debt_equity_ratio = 0.0;
		current_xmachine_IGFirm->price_earnings_ratio = 0.0;
		current_xmachine_IGFirm->retained_earnings_ratio = 0.0;
		current_xmachine_IGFirm->earnings_per_share_ratio_growth = 0.0;
		current_xmachine_IGFirm->critical_price_earnings_ratio = 0.0;
		current_xmachine_IGFirm->critical_earnings_per_share_ratio = 0.0;
		current_xmachine_IGFirm->total_debt = 0.0;
		current_xmachine_IGFirm->total_debt_balance_sheet = 0.0;
		current_xmachine_IGFirm->total_assets = 0.0;
		current_xmachine_IGFirm->equity = 0.0;
		current_xmachine_IGFirm->equity_balance_sheet = 0.0;
		current_xmachine_IGFirm->earnings_per_share = 0.0;
		current_xmachine_IGFirm->total_payments = 0.0;
		current_xmachine_IGFirm->previous_shares_outstanding = 0;
		current_xmachine_IGFirm->total_income = 0.0;
		current_xmachine_IGFirm->total_liabilities = 0.0;
		current_xmachine_IGFirm->total_expenses = 0.0;
		current_xmachine_IGFirm->calc_production_costs = 0.0;
		current_xmachine_IGFirm->productivity = 0.0;
		current_xmachine_IGFirm->capital_good_price = 0.0;
		init_vintage_array(&current_xmachine_IGFirm->vintages);
		init_adt_sales_per_vintage_array(&current_xmachine_IGFirm->sales_per_vintage);
		current_xmachine_IGFirm->mean_productivity_of_sales = 0.0;
		current_xmachine_IGFirm->ratio_sold_productivity_best_practice = 0.0;
		current_xmachine_IGFirm->igfirm_endogenous_innovation_probability = 0.0;
		current_xmachine_IGFirm->revenue_per_day = 0.0;
		current_xmachine_IGFirm->net_profit = 0.0;
		current_xmachine_IGFirm->current_shares_outstanding = 0;
		current_xmachine_IGFirm->energy_price_markup = 0.0;
		current_xmachine_IGFirm->energy_costs_per_day = 0.0;
		current_xmachine_IGFirm->earnings_per_day = 0.0;
		current_xmachine_IGFirm->cum_energy_costs = 0.0;
		init_double_array(&current_xmachine_IGFirm->last_net_profits);
		current_xmachine_IGFirm->mean_sales_last_months = 0.0;
		init_double_array(&current_xmachine_IGFirm->last_sales);
		current_xmachine_IGFirm->dividend_payment = 0.0;
		current_xmachine_IGFirm->duration_until_next_innovation = 0;
		current_xmachine_IGFirm->unit_costs = 0.0;
		current_xmachine_IGFirm->sales = 0.0;
		current_xmachine_IGFirm->capital_good_demand = 0.0;
		current_xmachine_IGFirm->capital_good_demand_last_month = 0.0;
		current_xmachine_IGFirm->sales_last_month = 0.0;
		current_xmachine_IGFirm->cum_revenue = 0.0;
		current_xmachine_IGFirm->cum_revenue_last_month = 0.0;
		init_int_array(&current_xmachine_IGFirm->innovation_sheme_low_progress);
		init_int_array(&current_xmachine_IGFirm->innovation_sheme_medium_progress);
		init_int_array(&current_xmachine_IGFirm->innovation_sheme_high_progress);
		current_xmachine_IGFirm->mean_general_skills = 0.0;
		current_xmachine_IGFirm->mean_adaptation_speed = 0.0;
		init_adt_list_adaptation_speed_array(&current_xmachine_IGFirm->list_adaptation_speed);
		current_xmachine_IGFirm->productivity_progress_in_economy = 0.0;
		current_xmachine_IGFirm->economy_wide_capital_stock = 0.0;
		current_xmachine_IGFirm->dividend_buffer = 0.0;
		current_xmachine_IGFirm->dividend_target = 0.0;
		init_igfirm_balance_sheet_adt(&current_xmachine_IGFirm->igfirm_balance_sheet_calendar);
		init_igfirm_stocks_adt(&current_xmachine_IGFirm->igfirm_stocks_calendar);
		init_igfirm_outflows_adt(&current_xmachine_IGFirm->igfirm_outflows_calendar);
		init_igfirm_inflows_adt(&current_xmachine_IGFirm->igfirm_inflows_calendar);
		current_xmachine_IGFirm->age = 0;
		current_xmachine_IGFirm->transfer_payment = 0.0;
		current_xmachine_IGFirm->subsidy_pct = 0.0;
		current_xmachine_IGFirm->active = 0;
		current_xmachine_IGFirm->bankruptcy_idle_counter = 0;
		current_xmachine_IGFirm->bankruptcy_state = 0;
		current_xmachine_IGFirm->bankruptcy_insolvency_state = 0;
		current_xmachine_IGFirm->bankruptcy_illiquidity_state = 0;
		current_xmachine_IGFirm->financial_crisis_state = 0;
		current_xmachine_IGFirm->economy_wide_general_skills_in_firms = 0.0;
		current_xmachine_IGFirm->economy_wide_specific_skills_in_firms = 0.0;
		current_xmachine_IGFirm->subsidy_payment = 0.0;
		current_xmachine_IGFirm->wage_offer = 0.0;
	
}

void unittest_free_IGFirm_agent()
{
	free_vintage_array(&current_xmachine_IGFirm->vintages);
	free_adt_sales_per_vintage_array(&current_xmachine_IGFirm->sales_per_vintage);
	free_double_array(&current_xmachine_IGFirm->last_net_profits);
	free_double_array(&current_xmachine_IGFirm->last_sales);
	free_int_array(&current_xmachine_IGFirm->innovation_sheme_low_progress);
	free_int_array(&current_xmachine_IGFirm->innovation_sheme_medium_progress);
	free_int_array(&current_xmachine_IGFirm->innovation_sheme_high_progress);
	free_adt_list_adaptation_speed_array(&current_xmachine_IGFirm->list_adaptation_speed);
	free_igfirm_balance_sheet_adt(&current_xmachine_IGFirm->igfirm_balance_sheet_calendar);
	free_igfirm_stocks_adt(&current_xmachine_IGFirm->igfirm_stocks_calendar);
	free_igfirm_outflows_adt(&current_xmachine_IGFirm->igfirm_outflows_calendar);
	free_igfirm_inflows_adt(&current_xmachine_IGFirm->igfirm_inflows_calendar);
	
	free(current_xmachine_IGFirm);
}

void free_IGFirm_agents()
{
	current_xmachine_IGFirm_holder = IGFirm_end_IGFirm_state->agents;
	while(current_xmachine_IGFirm_holder)
	{
		temp_xmachine_IGFirm_holder = current_xmachine_IGFirm_holder->next;
		free_IGFirm_agent(current_xmachine_IGFirm_holder, IGFirm_end_IGFirm_state);
		current_xmachine_IGFirm_holder = temp_xmachine_IGFirm_holder;
	}
	IGFirm_end_IGFirm_state->count = 0;
	current_xmachine_IGFirm_holder = IGFirm_IGFirm_Send_Data_state->agents;
	while(current_xmachine_IGFirm_holder)
	{
		temp_xmachine_IGFirm_holder = current_xmachine_IGFirm_holder->next;
		free_IGFirm_agent(current_xmachine_IGFirm_holder, IGFirm_IGFirm_Send_Data_state);
		current_xmachine_IGFirm_holder = temp_xmachine_IGFirm_holder;
	}
	IGFirm_IGFirm_Send_Data_state->count = 0;
	current_xmachine_IGFirm_holder = IGFirm_IGFirm_End_Branches_state->agents;
	while(current_xmachine_IGFirm_holder)
	{
		temp_xmachine_IGFirm_holder = current_xmachine_IGFirm_holder->next;
		free_IGFirm_agent(current_xmachine_IGFirm_holder, IGFirm_IGFirm_End_Branches_state);
		current_xmachine_IGFirm_holder = temp_xmachine_IGFirm_holder;
	}
	IGFirm_IGFirm_End_Branches_state->count = 0;
	current_xmachine_IGFirm_holder = IGFirm_IGFirm_init_01_state->agents;
	while(current_xmachine_IGFirm_holder)
	{
		temp_xmachine_IGFirm_holder = current_xmachine_IGFirm_holder->next;
		free_IGFirm_agent(current_xmachine_IGFirm_holder, IGFirm_IGFirm_init_01_state);
		current_xmachine_IGFirm_holder = temp_xmachine_IGFirm_holder;
	}
	IGFirm_IGFirm_init_01_state->count = 0;
	current_xmachine_IGFirm_holder = IGFirm_IGFirm_start_state->agents;
	while(current_xmachine_IGFirm_holder)
	{
		temp_xmachine_IGFirm_holder = current_xmachine_IGFirm_holder->next;
		free_IGFirm_agent(current_xmachine_IGFirm_holder, IGFirm_IGFirm_start_state);
		current_xmachine_IGFirm_holder = temp_xmachine_IGFirm_holder;
	}
	IGFirm_IGFirm_start_state->count = 0;
	current_xmachine_IGFirm_holder = IGFirm_03_state->agents;
	while(current_xmachine_IGFirm_holder)
	{
		temp_xmachine_IGFirm_holder = current_xmachine_IGFirm_holder->next;
		free_IGFirm_agent(current_xmachine_IGFirm_holder, IGFirm_03_state);
		current_xmachine_IGFirm_holder = temp_xmachine_IGFirm_holder;
	}
	IGFirm_03_state->count = 0;
	current_xmachine_IGFirm_holder = IGFirm_02_state->agents;
	while(current_xmachine_IGFirm_holder)
	{
		temp_xmachine_IGFirm_holder = current_xmachine_IGFirm_holder->next;
		free_IGFirm_agent(current_xmachine_IGFirm_holder, IGFirm_02_state);
		current_xmachine_IGFirm_holder = temp_xmachine_IGFirm_holder;
	}
	IGFirm_02_state->count = 0;
	current_xmachine_IGFirm_holder = IGFirm_01_state->agents;
	while(current_xmachine_IGFirm_holder)
	{
		temp_xmachine_IGFirm_holder = current_xmachine_IGFirm_holder->next;
		free_IGFirm_agent(current_xmachine_IGFirm_holder, IGFirm_01_state);
		current_xmachine_IGFirm_holder = temp_xmachine_IGFirm_holder;
	}
	IGFirm_01_state->count = 0;
	current_xmachine_IGFirm_holder = IGFirm_01a_state->agents;
	while(current_xmachine_IGFirm_holder)
	{
		temp_xmachine_IGFirm_holder = current_xmachine_IGFirm_holder->next;
		free_IGFirm_agent(current_xmachine_IGFirm_holder, IGFirm_01a_state);
		current_xmachine_IGFirm_holder = temp_xmachine_IGFirm_holder;
	}
	IGFirm_01a_state->count = 0;
	current_xmachine_IGFirm_holder = IGFirm_Start_IGFirm_Productivity_state->agents;
	while(current_xmachine_IGFirm_holder)
	{
		temp_xmachine_IGFirm_holder = current_xmachine_IGFirm_holder->next;
		free_IGFirm_agent(current_xmachine_IGFirm_holder, IGFirm_Start_IGFirm_Productivity_state);
		current_xmachine_IGFirm_holder = temp_xmachine_IGFirm_holder;
	}
	IGFirm_Start_IGFirm_Productivity_state->count = 0;
	current_xmachine_IGFirm_holder = IGFirm_07_state->agents;
	while(current_xmachine_IGFirm_holder)
	{
		temp_xmachine_IGFirm_holder = current_xmachine_IGFirm_holder->next;
		free_IGFirm_agent(current_xmachine_IGFirm_holder, IGFirm_07_state);
		current_xmachine_IGFirm_holder = temp_xmachine_IGFirm_holder;
	}
	IGFirm_07_state->count = 0;
	current_xmachine_IGFirm_holder = IGFirm_06_state->agents;
	while(current_xmachine_IGFirm_holder)
	{
		temp_xmachine_IGFirm_holder = current_xmachine_IGFirm_holder->next;
		free_IGFirm_agent(current_xmachine_IGFirm_holder, IGFirm_06_state);
		current_xmachine_IGFirm_holder = temp_xmachine_IGFirm_holder;
	}
	IGFirm_06_state->count = 0;
	current_xmachine_IGFirm_holder = IGFirm_004_state->agents;
	while(current_xmachine_IGFirm_holder)
	{
		temp_xmachine_IGFirm_holder = current_xmachine_IGFirm_holder->next;
		free_IGFirm_agent(current_xmachine_IGFirm_holder, IGFirm_004_state);
		current_xmachine_IGFirm_holder = temp_xmachine_IGFirm_holder;
	}
	IGFirm_004_state->count = 0;
	current_xmachine_IGFirm_holder = IGFirm_003_state->agents;
	while(current_xmachine_IGFirm_holder)
	{
		temp_xmachine_IGFirm_holder = current_xmachine_IGFirm_holder->next;
		free_IGFirm_agent(current_xmachine_IGFirm_holder, IGFirm_003_state);
		current_xmachine_IGFirm_holder = temp_xmachine_IGFirm_holder;
	}
	IGFirm_003_state->count = 0;
	current_xmachine_IGFirm_holder = IGFirm_002_state->agents;
	while(current_xmachine_IGFirm_holder)
	{
		temp_xmachine_IGFirm_holder = current_xmachine_IGFirm_holder->next;
		free_IGFirm_agent(current_xmachine_IGFirm_holder, IGFirm_002_state);
		current_xmachine_IGFirm_holder = temp_xmachine_IGFirm_holder;
	}
	IGFirm_002_state->count = 0;
	current_xmachine_IGFirm_holder = IGFirm_IGFirm_End_Public_Sector_Role_state->agents;
	while(current_xmachine_IGFirm_holder)
	{
		temp_xmachine_IGFirm_holder = current_xmachine_IGFirm_holder->next;
		free_IGFirm_agent(current_xmachine_IGFirm_holder, IGFirm_IGFirm_End_Public_Sector_Role_state);
		current_xmachine_IGFirm_holder = temp_xmachine_IGFirm_holder;
	}
	IGFirm_IGFirm_End_Public_Sector_Role_state->count = 0;
	current_xmachine_IGFirm_holder = IGFirm_05_state->agents;
	while(current_xmachine_IGFirm_holder)
	{
		temp_xmachine_IGFirm_holder = current_xmachine_IGFirm_holder->next;
		free_IGFirm_agent(current_xmachine_IGFirm_holder, IGFirm_05_state);
		current_xmachine_IGFirm_holder = temp_xmachine_IGFirm_holder;
	}
	IGFirm_05_state->count = 0;
	current_xmachine_IGFirm_holder = IGFirm_IGFirm_End_Financial_Management_Role_state->agents;
	while(current_xmachine_IGFirm_holder)
	{
		temp_xmachine_IGFirm_holder = current_xmachine_IGFirm_holder->next;
		free_IGFirm_agent(current_xmachine_IGFirm_holder, IGFirm_IGFirm_End_Financial_Management_Role_state);
		current_xmachine_IGFirm_holder = temp_xmachine_IGFirm_holder;
	}
	IGFirm_IGFirm_End_Financial_Management_Role_state->count = 0;
	current_xmachine_IGFirm_holder = IGFirm_IGFirm_Start_Financial_Management_Role_state->agents;
	while(current_xmachine_IGFirm_holder)
	{
		temp_xmachine_IGFirm_holder = current_xmachine_IGFirm_holder->next;
		free_IGFirm_agent(current_xmachine_IGFirm_holder, IGFirm_IGFirm_Start_Financial_Management_Role_state);
		current_xmachine_IGFirm_holder = temp_xmachine_IGFirm_holder;
	}
	IGFirm_IGFirm_Start_Financial_Management_Role_state->count = 0;
	current_xmachine_IGFirm_holder = IGFirm_IGFirm_End_Financial_Management_state->agents;
	while(current_xmachine_IGFirm_holder)
	{
		temp_xmachine_IGFirm_holder = current_xmachine_IGFirm_holder->next;
		free_IGFirm_agent(current_xmachine_IGFirm_holder, IGFirm_IGFirm_End_Financial_Management_state);
		current_xmachine_IGFirm_holder = temp_xmachine_IGFirm_holder;
	}
	IGFirm_IGFirm_End_Financial_Management_state->count = 0;
	current_xmachine_IGFirm_holder = IGFirm_01kk_state->agents;
	while(current_xmachine_IGFirm_holder)
	{
		temp_xmachine_IGFirm_holder = current_xmachine_IGFirm_holder->next;
		free_IGFirm_agent(current_xmachine_IGFirm_holder, IGFirm_01kk_state);
		current_xmachine_IGFirm_holder = temp_xmachine_IGFirm_holder;
	}
	IGFirm_01kk_state->count = 0;
	current_xmachine_IGFirm_holder = IGFirm_IGFirm_is_active_state->agents;
	while(current_xmachine_IGFirm_holder)
	{
		temp_xmachine_IGFirm_holder = current_xmachine_IGFirm_holder->next;
		free_IGFirm_agent(current_xmachine_IGFirm_holder, IGFirm_IGFirm_is_active_state);
		current_xmachine_IGFirm_holder = temp_xmachine_IGFirm_holder;
	}
	IGFirm_IGFirm_is_active_state->count = 0;
	current_xmachine_IGFirm_holder = IGFirm_IGFirm_checks_if_active_state->agents;
	while(current_xmachine_IGFirm_holder)
	{
		temp_xmachine_IGFirm_holder = current_xmachine_IGFirm_holder->next;
		free_IGFirm_agent(current_xmachine_IGFirm_holder, IGFirm_IGFirm_checks_if_active_state);
		current_xmachine_IGFirm_holder = temp_xmachine_IGFirm_holder;
	}
	IGFirm_IGFirm_checks_if_active_state->count = 0;
	current_xmachine_IGFirm_holder = IGFirm_IGFirm_interest_state->agents;
	while(current_xmachine_IGFirm_holder)
	{
		temp_xmachine_IGFirm_holder = current_xmachine_IGFirm_holder->next;
		free_IGFirm_agent(current_xmachine_IGFirm_holder, IGFirm_IGFirm_interest_state);
		current_xmachine_IGFirm_holder = temp_xmachine_IGFirm_holder;
	}
	IGFirm_IGFirm_interest_state->count = 0;
}

void free_IGFirm_states()
{
	free(IGFirm_end_IGFirm_state);
	free(IGFirm_IGFirm_Send_Data_state);
	free(IGFirm_IGFirm_End_Branches_state);
	free(IGFirm_IGFirm_init_01_state);
	free(IGFirm_IGFirm_start_state);
	free(IGFirm_03_state);
	free(IGFirm_02_state);
	free(IGFirm_01_state);
	free(IGFirm_01a_state);
	free(IGFirm_Start_IGFirm_Productivity_state);
	free(IGFirm_07_state);
	free(IGFirm_06_state);
	free(IGFirm_004_state);
	free(IGFirm_003_state);
	free(IGFirm_002_state);
	free(IGFirm_IGFirm_End_Public_Sector_Role_state);
	free(IGFirm_05_state);
	free(IGFirm_IGFirm_End_Financial_Management_Role_state);
	free(IGFirm_IGFirm_Start_Financial_Management_Role_state);
	free(IGFirm_IGFirm_End_Financial_Management_state);
	free(IGFirm_01kk_state);
	free(IGFirm_IGFirm_is_active_state);
	free(IGFirm_IGFirm_checks_if_active_state);
	free(IGFirm_IGFirm_interest_state);
}

void transition_IGFirm_agent(xmachine_memory_IGFirm_holder * tmp, xmachine_memory_IGFirm_state * from_state, xmachine_memory_IGFirm_state * to_state)
{
	if(tmp->prev == NULL) from_state->agents = tmp->next;
	else tmp->prev->next = tmp->next;
	if(tmp->next != NULL) tmp->next->prev = tmp->prev;

	add_IGFirm_agent_internal(tmp->agent, to_state);
	free(tmp);
}

void add_IGFirm_agent_internal(xmachine_memory_IGFirm * agent, xmachine_memory_IGFirm_state * state)
{
	xmachine_memory_IGFirm_holder * current = (xmachine_memory_IGFirm_holder *)malloc(sizeof(xmachine_memory_IGFirm_holder));
	CHECK_POINTER(current);

	current->next = state->agents;
	current->prev = NULL;
	state->agents = current;
	if(current->next != NULL) current->next->prev = current;
	current->agent = agent;

	state->count++;

}

/** \fn void add_IGFirm_agent(int id, int region_id, int gov_id, int bank_id, int day_of_month_to_act, int last_day_of_month_to_act, double payment_account, double payment_account_balance_sheet, int partition_id, double received_interest_daily, double received_interest_in_calendar_month, double ebit, double earnings, double tax_rate_corporate, double tax_rate_vat, double tax_payment, double tax_payment_in_calendar_month, double net_earnings, double previous_net_earnings, double total_dividend_payment, double total_dividend_payment_in_calendar_month, double current_share_price, double previous_dividend_per_share, double current_dividend_per_share, double previous_earnings_per_share, double current_earnings_per_share, double previous_dividend_per_earnings, double current_dividend_per_earnings, double debt_earnings_ratio, double debt_equity_ratio, double price_earnings_ratio, double retained_earnings_ratio, double earnings_per_share_ratio_growth, double critical_price_earnings_ratio, double critical_earnings_per_share_ratio, double total_debt, double total_debt_balance_sheet, double total_assets, double equity, double equity_balance_sheet, double earnings_per_share, double total_payments, int previous_shares_outstanding, double total_income, double total_liabilities, double total_expenses, double calc_production_costs, double productivity, double capital_good_price, vintage_array * vintages, adt_sales_per_vintage_array * sales_per_vintage, double mean_productivity_of_sales, double ratio_sold_productivity_best_practice, double igfirm_endogenous_innovation_probability, double revenue_per_day, double net_profit, int current_shares_outstanding, double energy_price_markup, double energy_costs_per_day, double earnings_per_day, double cum_energy_costs, double_array * last_net_profits, double mean_sales_last_months, double_array * last_sales, double dividend_payment, int duration_until_next_innovation, double unit_costs, double sales, double capital_good_demand, double capital_good_demand_last_month, double sales_last_month, double cum_revenue, double cum_revenue_last_month, int_array * innovation_sheme_low_progress, int_array * innovation_sheme_medium_progress, int_array * innovation_sheme_high_progress, double mean_general_skills, double mean_adaptation_speed, adt_list_adaptation_speed_array * list_adaptation_speed, double productivity_progress_in_economy, double economy_wide_capital_stock, double dividend_buffer, double dividend_target, igfirm_balance_sheet_adt * igfirm_balance_sheet_calendar, igfirm_stocks_adt * igfirm_stocks_calendar, igfirm_outflows_adt * igfirm_outflows_calendar, igfirm_inflows_adt * igfirm_inflows_calendar, int age, double transfer_payment, double subsidy_pct, int active, int bankruptcy_idle_counter, int bankruptcy_state, int bankruptcy_insolvency_state, int bankruptcy_illiquidity_state, int financial_crisis_state, double economy_wide_general_skills_in_firms, double economy_wide_specific_skills_in_firms, double subsidy_payment, double wage_offer)
 * \brief Add IGFirm X-machine to the current being used X-machine list.
 * \param id Variable for the X-machine memory.
 * \param region_id Variable for the X-machine memory.
 * \param gov_id Variable for the X-machine memory.
 * \param bank_id Variable for the X-machine memory.
 * \param day_of_month_to_act Variable for the X-machine memory.
 * \param last_day_of_month_to_act Variable for the X-machine memory.
 * \param payment_account Variable for the X-machine memory.
 * \param payment_account_balance_sheet Variable for the X-machine memory.
 * \param partition_id Variable for the X-machine memory.
 * \param received_interest_daily Variable for the X-machine memory.
 * \param received_interest_in_calendar_month Variable for the X-machine memory.
 * \param ebit Variable for the X-machine memory.
 * \param earnings Variable for the X-machine memory.
 * \param tax_rate_corporate Variable for the X-machine memory.
 * \param tax_rate_vat Variable for the X-machine memory.
 * \param tax_payment Variable for the X-machine memory.
 * \param tax_payment_in_calendar_month Variable for the X-machine memory.
 * \param net_earnings Variable for the X-machine memory.
 * \param previous_net_earnings Variable for the X-machine memory.
 * \param total_dividend_payment Variable for the X-machine memory.
 * \param total_dividend_payment_in_calendar_month Variable for the X-machine memory.
 * \param current_share_price Variable for the X-machine memory.
 * \param previous_dividend_per_share Variable for the X-machine memory.
 * \param current_dividend_per_share Variable for the X-machine memory.
 * \param previous_earnings_per_share Variable for the X-machine memory.
 * \param current_earnings_per_share Variable for the X-machine memory.
 * \param previous_dividend_per_earnings Variable for the X-machine memory.
 * \param current_dividend_per_earnings Variable for the X-machine memory.
 * \param debt_earnings_ratio Variable for the X-machine memory.
 * \param debt_equity_ratio Variable for the X-machine memory.
 * \param price_earnings_ratio Variable for the X-machine memory.
 * \param retained_earnings_ratio Variable for the X-machine memory.
 * \param earnings_per_share_ratio_growth Variable for the X-machine memory.
 * \param critical_price_earnings_ratio Variable for the X-machine memory.
 * \param critical_earnings_per_share_ratio Variable for the X-machine memory.
 * \param total_debt Variable for the X-machine memory.
 * \param total_debt_balance_sheet Variable for the X-machine memory.
 * \param total_assets Variable for the X-machine memory.
 * \param equity Variable for the X-machine memory.
 * \param equity_balance_sheet Variable for the X-machine memory.
 * \param earnings_per_share Variable for the X-machine memory.
 * \param total_payments Variable for the X-machine memory.
 * \param previous_shares_outstanding Variable for the X-machine memory.
 * \param total_income Variable for the X-machine memory.
 * \param total_liabilities Variable for the X-machine memory.
 * \param total_expenses Variable for the X-machine memory.
 * \param calc_production_costs Variable for the X-machine memory.
 * \param productivity Variable for the X-machine memory.
 * \param capital_good_price Variable for the X-machine memory.
 * \param vintages Variable for the X-machine memory.
 * \param sales_per_vintage Variable for the X-machine memory.
 * \param mean_productivity_of_sales Variable for the X-machine memory.
 * \param ratio_sold_productivity_best_practice Variable for the X-machine memory.
 * \param igfirm_endogenous_innovation_probability Variable for the X-machine memory.
 * \param revenue_per_day Variable for the X-machine memory.
 * \param net_profit Variable for the X-machine memory.
 * \param current_shares_outstanding Variable for the X-machine memory.
 * \param energy_price_markup Variable for the X-machine memory.
 * \param energy_costs_per_day Variable for the X-machine memory.
 * \param earnings_per_day Variable for the X-machine memory.
 * \param cum_energy_costs Variable for the X-machine memory.
 * \param last_net_profits Variable for the X-machine memory.
 * \param mean_sales_last_months Variable for the X-machine memory.
 * \param last_sales Variable for the X-machine memory.
 * \param dividend_payment Variable for the X-machine memory.
 * \param duration_until_next_innovation Variable for the X-machine memory.
 * \param unit_costs Variable for the X-machine memory.
 * \param sales Variable for the X-machine memory.
 * \param capital_good_demand Variable for the X-machine memory.
 * \param capital_good_demand_last_month Variable for the X-machine memory.
 * \param sales_last_month Variable for the X-machine memory.
 * \param cum_revenue Variable for the X-machine memory.
 * \param cum_revenue_last_month Variable for the X-machine memory.
 * \param innovation_sheme_low_progress Variable for the X-machine memory.
 * \param innovation_sheme_medium_progress Variable for the X-machine memory.
 * \param innovation_sheme_high_progress Variable for the X-machine memory.
 * \param mean_general_skills Variable for the X-machine memory.
 * \param mean_adaptation_speed Variable for the X-machine memory.
 * \param list_adaptation_speed Variable for the X-machine memory.
 * \param productivity_progress_in_economy Variable for the X-machine memory.
 * \param economy_wide_capital_stock Variable for the X-machine memory.
 * \param dividend_buffer Variable for the X-machine memory.
 * \param dividend_target Variable for the X-machine memory.
 * \param igfirm_balance_sheet_calendar Variable for the X-machine memory.
 * \param igfirm_stocks_calendar Variable for the X-machine memory.
 * \param igfirm_outflows_calendar Variable for the X-machine memory.
 * \param igfirm_inflows_calendar Variable for the X-machine memory.
 * \param age Variable for the X-machine memory.
 * \param transfer_payment Variable for the X-machine memory.
 * \param subsidy_pct Variable for the X-machine memory.
 * \param active Variable for the X-machine memory.
 * \param bankruptcy_idle_counter Variable for the X-machine memory.
 * \param bankruptcy_state Variable for the X-machine memory.
 * \param bankruptcy_insolvency_state Variable for the X-machine memory.
 * \param bankruptcy_illiquidity_state Variable for the X-machine memory.
 * \param financial_crisis_state Variable for the X-machine memory.
 * \param economy_wide_general_skills_in_firms Variable for the X-machine memory.
 * \param economy_wide_specific_skills_in_firms Variable for the X-machine memory.
 * \param subsidy_payment Variable for the X-machine memory.
 * \param wage_offer Variable for the X-machine memory.
 */
void add_IGFirm_agent(int id, int region_id, int gov_id, int bank_id, int day_of_month_to_act, int last_day_of_month_to_act, double payment_account, double payment_account_balance_sheet, int partition_id, double received_interest_daily, double received_interest_in_calendar_month, double ebit, double earnings, double tax_rate_corporate, double tax_rate_vat, double tax_payment, double tax_payment_in_calendar_month, double net_earnings, double previous_net_earnings, double total_dividend_payment, double total_dividend_payment_in_calendar_month, double current_share_price, double previous_dividend_per_share, double current_dividend_per_share, double previous_earnings_per_share, double current_earnings_per_share, double previous_dividend_per_earnings, double current_dividend_per_earnings, double debt_earnings_ratio, double debt_equity_ratio, double price_earnings_ratio, double retained_earnings_ratio, double earnings_per_share_ratio_growth, double critical_price_earnings_ratio, double critical_earnings_per_share_ratio, double total_debt, double total_debt_balance_sheet, double total_assets, double equity, double equity_balance_sheet, double earnings_per_share, double total_payments, int previous_shares_outstanding, double total_income, double total_liabilities, double total_expenses, double calc_production_costs, double productivity, double capital_good_price, vintage_array * vintages, adt_sales_per_vintage_array * sales_per_vintage, double mean_productivity_of_sales, double ratio_sold_productivity_best_practice, double igfirm_endogenous_innovation_probability, double revenue_per_day, double net_profit, int current_shares_outstanding, double energy_price_markup, double energy_costs_per_day, double earnings_per_day, double cum_energy_costs, double_array * last_net_profits, double mean_sales_last_months, double_array * last_sales, double dividend_payment, int duration_until_next_innovation, double unit_costs, double sales, double capital_good_demand, double capital_good_demand_last_month, double sales_last_month, double cum_revenue, double cum_revenue_last_month, int_array * innovation_sheme_low_progress, int_array * innovation_sheme_medium_progress, int_array * innovation_sheme_high_progress, double mean_general_skills, double mean_adaptation_speed, adt_list_adaptation_speed_array * list_adaptation_speed, double productivity_progress_in_economy, double economy_wide_capital_stock, double dividend_buffer, double dividend_target, igfirm_balance_sheet_adt igfirm_balance_sheet_calendar, igfirm_stocks_adt igfirm_stocks_calendar, igfirm_outflows_adt igfirm_outflows_calendar, igfirm_inflows_adt igfirm_inflows_calendar, int age, double transfer_payment, double subsidy_pct, int active, int bankruptcy_idle_counter, int bankruptcy_state, int bankruptcy_insolvency_state, int bankruptcy_illiquidity_state, int financial_crisis_state, double economy_wide_general_skills_in_firms, double economy_wide_specific_skills_in_firms, double subsidy_payment, double wage_offer)
{
	xmachine_memory_IGFirm * current;

	current = init_IGFirm_agent();
	/* new line added to handle dynamic agent creation*/
	current_xmachine_IGFirm_next_state = IGFirm_IGFirm_start_state;
	add_IGFirm_agent_internal(current, current_xmachine_IGFirm_next_state);

	current->id = id;
	current->region_id = region_id;
	current->gov_id = gov_id;
	current->bank_id = bank_id;
	current->day_of_month_to_act = day_of_month_to_act;
	current->last_day_of_month_to_act = last_day_of_month_to_act;
	current->payment_account = payment_account;
	current->payment_account_balance_sheet = payment_account_balance_sheet;
	current->partition_id = partition_id;
	current->received_interest_daily = received_interest_daily;
	current->received_interest_in_calendar_month = received_interest_in_calendar_month;
	current->ebit = ebit;
	current->earnings = earnings;
	current->tax_rate_corporate = tax_rate_corporate;
	current->tax_rate_vat = tax_rate_vat;
	current->tax_payment = tax_payment;
	current->tax_payment_in_calendar_month = tax_payment_in_calendar_month;
	current->net_earnings = net_earnings;
	current->previous_net_earnings = previous_net_earnings;
	current->total_dividend_payment = total_dividend_payment;
	current->total_dividend_payment_in_calendar_month = total_dividend_payment_in_calendar_month;
	current->current_share_price = current_share_price;
	current->previous_dividend_per_share = previous_dividend_per_share;
	current->current_dividend_per_share = current_dividend_per_share;
	current->previous_earnings_per_share = previous_earnings_per_share;
	current->current_earnings_per_share = current_earnings_per_share;
	current->previous_dividend_per_earnings = previous_dividend_per_earnings;
	current->current_dividend_per_earnings = current_dividend_per_earnings;
	current->debt_earnings_ratio = debt_earnings_ratio;
	current->debt_equity_ratio = debt_equity_ratio;
	current->price_earnings_ratio = price_earnings_ratio;
	current->retained_earnings_ratio = retained_earnings_ratio;
	current->earnings_per_share_ratio_growth = earnings_per_share_ratio_growth;
	current->critical_price_earnings_ratio = critical_price_earnings_ratio;
	current->critical_earnings_per_share_ratio = critical_earnings_per_share_ratio;
	current->total_debt = total_debt;
	current->total_debt_balance_sheet = total_debt_balance_sheet;
	current->total_assets = total_assets;
	current->equity = equity;
	current->equity_balance_sheet = equity_balance_sheet;
	current->earnings_per_share = earnings_per_share;
	current->total_payments = total_payments;
	current->previous_shares_outstanding = previous_shares_outstanding;
	current->total_income = total_income;
	current->total_liabilities = total_liabilities;
	current->total_expenses = total_expenses;
	current->calc_production_costs = calc_production_costs;
	current->productivity = productivity;
	current->capital_good_price = capital_good_price;
	copy_vintage_array(vintages, &current->vintages);
	copy_adt_sales_per_vintage_array(sales_per_vintage, &current->sales_per_vintage);
	current->mean_productivity_of_sales = mean_productivity_of_sales;
	current->ratio_sold_productivity_best_practice = ratio_sold_productivity_best_practice;
	current->igfirm_endogenous_innovation_probability = igfirm_endogenous_innovation_probability;
	current->revenue_per_day = revenue_per_day;
	current->net_profit = net_profit;
	current->current_shares_outstanding = current_shares_outstanding;
	current->energy_price_markup = energy_price_markup;
	current->energy_costs_per_day = energy_costs_per_day;
	current->earnings_per_day = earnings_per_day;
	current->cum_energy_costs = cum_energy_costs;
	copy_double_array(last_net_profits, &current->last_net_profits);
	current->mean_sales_last_months = mean_sales_last_months;
	copy_double_array(last_sales, &current->last_sales);
	current->dividend_payment = dividend_payment;
	current->duration_until_next_innovation = duration_until_next_innovation;
	current->unit_costs = unit_costs;
	current->sales = sales;
	current->capital_good_demand = capital_good_demand;
	current->capital_good_demand_last_month = capital_good_demand_last_month;
	current->sales_last_month = sales_last_month;
	current->cum_revenue = cum_revenue;
	current->cum_revenue_last_month = cum_revenue_last_month;
	copy_int_array(innovation_sheme_low_progress, &current->innovation_sheme_low_progress);
	copy_int_array(innovation_sheme_medium_progress, &current->innovation_sheme_medium_progress);
	copy_int_array(innovation_sheme_high_progress, &current->innovation_sheme_high_progress);
	current->mean_general_skills = mean_general_skills;
	current->mean_adaptation_speed = mean_adaptation_speed;
	copy_adt_list_adaptation_speed_array(list_adaptation_speed, &current->list_adaptation_speed);
	current->productivity_progress_in_economy = productivity_progress_in_economy;
	current->economy_wide_capital_stock = economy_wide_capital_stock;
	current->dividend_buffer = dividend_buffer;
	current->dividend_target = dividend_target;
	copy_igfirm_balance_sheet_adt(&igfirm_balance_sheet_calendar, &current->igfirm_balance_sheet_calendar);
	copy_igfirm_stocks_adt(&igfirm_stocks_calendar, &current->igfirm_stocks_calendar);
	copy_igfirm_outflows_adt(&igfirm_outflows_calendar, &current->igfirm_outflows_calendar);
	copy_igfirm_inflows_adt(&igfirm_inflows_calendar, &current->igfirm_inflows_calendar);
	current->age = age;
	current->transfer_payment = transfer_payment;
	current->subsidy_pct = subsidy_pct;
	current->active = active;
	current->bankruptcy_idle_counter = bankruptcy_idle_counter;
	current->bankruptcy_state = bankruptcy_state;
	current->bankruptcy_insolvency_state = bankruptcy_insolvency_state;
	current->bankruptcy_illiquidity_state = bankruptcy_illiquidity_state;
	current->financial_crisis_state = financial_crisis_state;
	current->economy_wide_general_skills_in_firms = economy_wide_general_skills_in_firms;
	current->economy_wide_specific_skills_in_firms = economy_wide_specific_skills_in_firms;
	current->subsidy_payment = subsidy_payment;
	current->wage_offer = wage_offer;
}

xmachine_memory_Eurostat_state * init_Eurostat_state()
{
	xmachine_memory_Eurostat_state * current = (xmachine_memory_Eurostat_state *)malloc(sizeof(xmachine_memory_Eurostat_state));
	CHECK_POINTER(current);

	current->agents = NULL;
	current->count = 0;

	return current;
}

xmachine_memory_Eurostat * init_Eurostat_agent()
{
	xmachine_memory_Eurostat * current = (xmachine_memory_Eurostat *)malloc(sizeof(xmachine_memory_Eurostat));
	CHECK_POINTER(current);

	current->id = 0;
	current->region_id = 0;
	current->partition_id = 0;
	current->switch_datastorage = 0;
	current->num_households = 0;
	current->no_households_skill_1 = 0;
	current->no_households_skill_2 = 0;
	current->no_households_skill_3 = 0;
	current->no_households_skill_4 = 0;
	current->no_households_skill_5 = 0;
	current->employed = 0;
	current->employed_skill_1 = 0;
	current->employed_skill_2 = 0;
	current->employed_skill_3 = 0;
	current->employed_skill_4 = 0;
	current->employed_skill_5 = 0;
	current->average_unit_labor_costs_reg_1 = 0.0;
	current->average_unit_labor_costs_reg_2 = 0.0;
	current->unemployed = 0;
	current->unemployment_rate = 0.0;
	current->employment_rate = 0.0;
	current->unemployment_rate_skill_1 = 0.0;
	current->unemployment_rate_skill_2 = 0.0;
	current->unemployment_rate_skill_3 = 0.0;
	current->unemployment_rate_skill_4 = 0.0;
	current->unemployment_rate_skill_5 = 0.0;
	current->unemployed_reg1 = 0;
	current->unemployed_reg2 = 0;
	current->unemployment_rate_reg1 = 0.0;
	current->unemployment_rate_reg2 = 0.0;
	current->v_u_ratio_reg1 = 0.0;
	current->v_u_ratio_reg2 = 0.0;
	current->average_wage = 0.0;
	current->average_wage_reservation = 0.0;
	current->average_wage_reservation_region_1 = 0.0;
	current->average_wage_reservation_region_2 = 0.0;
	current->average_wage_skill_1 = 0.0;
	current->average_wage_skill_2 = 0.0;
	current->average_wage_skill_3 = 0.0;
	current->average_wage_skill_4 = 0.0;
	current->average_wage_skill_5 = 0.0;
	current->sd_wage = 0.0;
	current->sd_income = 0.0;
	current->sd_wealth = 0.0;
	current->sd_specific_skills = 0.0;
	current->sd_wage_reg_1 = 0.0;
	current->sd_income_reg_1 = 0.0;
	current->sd_wealth_reg_1 = 0.0;
	current->sd_specific_skills_reg_1 = 0.0;
	current->sd_wage_reg_2 = 0.0;
	current->sd_income_reg_2 = 0.0;
	current->sd_wealth_reg_2 = 0.0;
	current->sd_specific_skills_reg_2 = 0.0;
	current->total_output_reg_2 = 0.0;
	current->total_output_reg_1 = 0.0;
	current->per_capita_output_reg_2 = 0.0;
	current->per_capita_output_reg_1 = 0.0;
	current->mean_price_reg_1 = 0.0;
	current->mean_price_reg_2 = 0.0;
	current->mean_technology_reg_1 = 0.0;
	current->mean_technology_reg_2 = 0.0;
	current->exports_reg1 = 0.0;
	current->exports_reg2 = 0.0;
	current->imports_reg1 = 0.0;
	current->trade_balance_reg1 = 0.0;
	current->trade_balance_reg2 = 0.0;
	current->imports_reg2 = 0.0;
	current->export_quota_reg1 = 0.0;
	current->export_quota_reg2 = 0.0;
	current->import_quota_reg1 = 0.0;
	current->import_quota_reg2 = 0.0;
	current->trade_balance_quota_reg1 = 0.0;
	current->trade_balance_quota_reg2 = 0.0;
	current->mean_wage_reg_1 = 0.0;
	current->mean_wage_reg_2 = 0.0;
	current->mean_wage_offer_reg_1 = 0.0;
	current->mean_wage_offer_reg_2 = 0.0;
	current->mean_s_skills_reg_1 = 0.0;
	current->mean_s_skills_reg_2 = 0.0;
	current->mean_mark_up_reg_1 = 0.0;
	current->mean_mark_up_reg_2 = 0.0;
	current->relative_price = 0.0;
	current->relative_reservation_wage = 0.0;
	current->relative_mark_up = 0.0;
	current->relative_wage = 0.0;
	current->relative_wage_offer = 0.0;
	current->relative_technology = 0.0;
	current->relative_s_skills = 0.0;
	current->relative_output = 0.0;
	current->government_consumption = 0.0;
	current->gini_wage = 0.0;
	current->gini_income = 0.0;
	current->gini_wealth = 0.0;
	current->gini_specific_skills = 0.0;
	current->gini_wage_reg_1 = 0.0;
	current->gini_income_reg_1 = 0.0;
	current->gini_wealth_reg_1 = 0.0;
	current->gini_specific_skills_reg_1 = 0.0;
	current->gini_wage_reg_2 = 0.0;
	current->gini_income_reg_2 = 0.0;
	current->gini_wealth_reg_2 = 0.0;
	current->gini_specific_skills_reg_2 = 0.0;
	current->labor_income_reg_1 = 0.0;
	current->labor_income_reg_2 = 0.0;
	current->dividend_income_reg_1 = 0.0;
	current->dividend_income_reg_2 = 0.0;
	current->interest_income_reg_1 = 0.0;
	current->interest_income_reg_2 = 0.0;
	current->financial_market_net_revenue_reg_1 = 0.0;
	current->financial_market_net_revenue_reg_2 = 0.0;
	current->average_s_skill = 0.0;
	current->average_s_skill_1 = 0.0;
	current->average_s_skill_2 = 0.0;
	current->average_s_skill_3 = 0.0;
	current->average_s_skill_4 = 0.0;
	current->average_s_skill_5 = 0.0;
	current->total_consumption_budget = 0.0;
	current->no_firms = 0;
	current->no_active_firms = 0;
	current->no_vacancies = 0;
	current->no_posted_vacancies = 0;
	current->no_employees = 0;
	current->no_employees_production = 0;
	current->no_employees_r_and_d = 0;
	current->no_employees_skill_1 = 0;
	current->no_employees_skill_2 = 0;
	current->no_employees_skill_3 = 0;
	current->no_employees_skill_4 = 0;
	current->no_employees_skill_5 = 0;
	init_price_quality_pair_array(&current->price_quality_combination);
	current->firm_average_wage = 0.0;
	current->firm_average_production_wage = 0.0;
	current->firm_average_r_and_d_wage = 0.0;
	current->firm_average_wage_skill_1 = 0.0;
	current->firm_average_wage_skill_2 = 0.0;
	current->firm_average_wage_skill_3 = 0.0;
	current->firm_average_wage_skill_4 = 0.0;
	current->firm_average_wage_skill_5 = 0.0;
	current->firm_average_g_skill = 0.0;
	current->firm_average_s_skill = 0.0;
	current->firm_average_s_skill_1 = 0.0;
	current->firm_average_s_skill_2 = 0.0;
	current->firm_average_s_skill_3 = 0.0;
	current->firm_average_s_skill_4 = 0.0;
	current->firm_average_s_skill_5 = 0.0;
	current->firm_average_quality = 0.0;
	current->firm_average_price = 0.0;
	init_firm_data_array(&current->region_firm_data);
	init_household_data_array(&current->region_household_data);
	init_government_data_array(&current->region_government_data);
	current->total_earnings = 0.0;
	current->total_debt = 0.0;
	current->total_assets = 0.0;
	current->total_equity = 0.0;
	current->average_debt_earnings_ratio = 0.0;
	current->average_debt_equity_ratio = 0.0;
	current->labour_share_ratio = 0.0;
	current->cpi = 0.0;
	current->hpi = 0.0;
	init_adt_subsidies_per_government_array(&current->subsidies_per_government);
	init_adt_subsidies_per_government_array(&current->subsidies_balanced);
	current->gdp = 0.0;
	current->monthly_investment_value = 0.0;
	current->monthly_sold_quantity = 0.0;
	current->herfindahl_index = 0.0;
	current->monthly_output = 0.0;
	current->monthly_revenue = 0.0;
	current->monthly_planned_output = 0.0;
	current->price_index = 0.0;
	init_history_item_static_array(current->history_monthly, 13);
	init_history_item_static_array(current->history_quarterly, 5);
	init_history_item(&current->monthly_growth_rates);
	init_history_item(&current->quarterly_growth_rates);
	init_history_item(&current->annual_growth_rates_monthly);
	init_history_item(&current->annual_growth_rates_quarterly);
	current->no_firm_births = 0;
	current->no_firm_deaths = 0;
	init_int_static_array(current->firm_age_distribution, 301);
	init_int_static_array(current->firm_age_distribution_multiperiod, 3612);
	init_int_static_array(current->firm_age_distribution_1_period_lag, 301);
	init_int_static_array(current->firm_age_distribution_2_period_lag, 301);
	current->firm_birth_rate = 0.0;
	current->firm_death_rate = 0.0;
	init_double_static_array(current->survival_rate, 301);
	init_double_static_array(current->survival_rate_multiperiod_1, 301);
	init_double_static_array(current->survival_rate_multiperiod_2, 301);
	init_double_static_array(current->survival_rate_multiperiod, 3612);
	current->max_firm_creation = 0;
	current->recession_started = 0;
	current->recession_duration = 0;
	init_double_static_array(current->export_volume_matrix, 100);
	init_double_static_array(current->export_value_matrix, 100);
	init_double_static_array(current->export_previous_value_matrix, 100);
	init_double_static_array(current->region_export_volume, 100);
	init_double_static_array(current->region_import_volume, 100);
	init_double_static_array(current->region_export_value, 100);
	init_double_static_array(current->region_import_value, 100);
	init_double_static_array(current->region_import_previous_value, 100);
	current->firm_average_productivity_progress = 0.0;
	current->firm_average_productivity = 0.0;
	current->investment_gdp_ratio = 0.0;
	current->total_capital_stock_units = 0.0;
	current->total_value_mall_inventories = 0.0;
	current->total_dividends = 0.0;
	current->base_wage_offer = 0.0;
	current->just_employed = 0;
	current->just_unemployed = 0;
	current->start_employed = 0;
	current->start_unemployed = 0;
	current->enter_matching = 0;
	current->unemployed_duration = 0;
	init_int_array(&current->all_region_ids);
	init_int_array(&current->all_gov_ids);
	current->job_seperation_rate = 0.0;
	current->job_finding_rate = 0.0;
	current->v_u_ratio = 0.0;
	current->matching_rate = 0.0;
	current->hh_payment_account = 0.0;
	current->mean_net_income = 0.0;

	return current;
}

void free_Eurostat_agent(xmachine_memory_Eurostat_holder * tmp, xmachine_memory_Eurostat_state * state)
{
	if(tmp->prev == NULL) state->agents = tmp->next;
	else tmp->prev->next = tmp->next;
	if(tmp->next != NULL) tmp->next->prev = tmp->prev;

	free_price_quality_pair_array(&tmp->agent->price_quality_combination);
	free_firm_data_array(&tmp->agent->region_firm_data);
	free_household_data_array(&tmp->agent->region_household_data);
	free_government_data_array(&tmp->agent->region_government_data);
	free_adt_subsidies_per_government_array(&tmp->agent->subsidies_per_government);
	free_adt_subsidies_per_government_array(&tmp->agent->subsidies_balanced);
	free_history_item_static_array(tmp->agent->history_monthly, 13);
	free_history_item_static_array(tmp->agent->history_quarterly, 5);
	free_history_item(&tmp->agent->monthly_growth_rates);
	free_history_item(&tmp->agent->quarterly_growth_rates);
	free_history_item(&tmp->agent->annual_growth_rates_monthly);
	free_history_item(&tmp->agent->annual_growth_rates_quarterly);
	free_int_array(&tmp->agent->all_region_ids);
	free_int_array(&tmp->agent->all_gov_ids);
	

	free(tmp->agent);
	free(tmp);
}

void unittest_init_Eurostat_agent()
{
	current_xmachine_Eurostat = (xmachine_memory_Eurostat *)malloc(sizeof(xmachine_memory_Eurostat));
	CHECK_POINTER(current);

		current_xmachine_Eurostat->id = 0;
		current_xmachine_Eurostat->region_id = 0;
		current_xmachine_Eurostat->partition_id = 0;
		current_xmachine_Eurostat->switch_datastorage = 0;
		current_xmachine_Eurostat->num_households = 0;
		current_xmachine_Eurostat->no_households_skill_1 = 0;
		current_xmachine_Eurostat->no_households_skill_2 = 0;
		current_xmachine_Eurostat->no_households_skill_3 = 0;
		current_xmachine_Eurostat->no_households_skill_4 = 0;
		current_xmachine_Eurostat->no_households_skill_5 = 0;
		current_xmachine_Eurostat->employed = 0;
		current_xmachine_Eurostat->employed_skill_1 = 0;
		current_xmachine_Eurostat->employed_skill_2 = 0;
		current_xmachine_Eurostat->employed_skill_3 = 0;
		current_xmachine_Eurostat->employed_skill_4 = 0;
		current_xmachine_Eurostat->employed_skill_5 = 0;
		current_xmachine_Eurostat->average_unit_labor_costs_reg_1 = 0.0;
		current_xmachine_Eurostat->average_unit_labor_costs_reg_2 = 0.0;
		current_xmachine_Eurostat->unemployed = 0;
		current_xmachine_Eurostat->unemployment_rate = 0.0;
		current_xmachine_Eurostat->employment_rate = 0.0;
		current_xmachine_Eurostat->unemployment_rate_skill_1 = 0.0;
		current_xmachine_Eurostat->unemployment_rate_skill_2 = 0.0;
		current_xmachine_Eurostat->unemployment_rate_skill_3 = 0.0;
		current_xmachine_Eurostat->unemployment_rate_skill_4 = 0.0;
		current_xmachine_Eurostat->unemployment_rate_skill_5 = 0.0;
		current_xmachine_Eurostat->unemployed_reg1 = 0;
		current_xmachine_Eurostat->unemployed_reg2 = 0;
		current_xmachine_Eurostat->unemployment_rate_reg1 = 0.0;
		current_xmachine_Eurostat->unemployment_rate_reg2 = 0.0;
		current_xmachine_Eurostat->v_u_ratio_reg1 = 0.0;
		current_xmachine_Eurostat->v_u_ratio_reg2 = 0.0;
		current_xmachine_Eurostat->average_wage = 0.0;
		current_xmachine_Eurostat->average_wage_reservation = 0.0;
		current_xmachine_Eurostat->average_wage_reservation_region_1 = 0.0;
		current_xmachine_Eurostat->average_wage_reservation_region_2 = 0.0;
		current_xmachine_Eurostat->average_wage_skill_1 = 0.0;
		current_xmachine_Eurostat->average_wage_skill_2 = 0.0;
		current_xmachine_Eurostat->average_wage_skill_3 = 0.0;
		current_xmachine_Eurostat->average_wage_skill_4 = 0.0;
		current_xmachine_Eurostat->average_wage_skill_5 = 0.0;
		current_xmachine_Eurostat->sd_wage = 0.0;
		current_xmachine_Eurostat->sd_income = 0.0;
		current_xmachine_Eurostat->sd_wealth = 0.0;
		current_xmachine_Eurostat->sd_specific_skills = 0.0;
		current_xmachine_Eurostat->sd_wage_reg_1 = 0.0;
		current_xmachine_Eurostat->sd_income_reg_1 = 0.0;
		current_xmachine_Eurostat->sd_wealth_reg_1 = 0.0;
		current_xmachine_Eurostat->sd_specific_skills_reg_1 = 0.0;
		current_xmachine_Eurostat->sd_wage_reg_2 = 0.0;
		current_xmachine_Eurostat->sd_income_reg_2 = 0.0;
		current_xmachine_Eurostat->sd_wealth_reg_2 = 0.0;
		current_xmachine_Eurostat->sd_specific_skills_reg_2 = 0.0;
		current_xmachine_Eurostat->total_output_reg_2 = 0.0;
		current_xmachine_Eurostat->total_output_reg_1 = 0.0;
		current_xmachine_Eurostat->per_capita_output_reg_2 = 0.0;
		current_xmachine_Eurostat->per_capita_output_reg_1 = 0.0;
		current_xmachine_Eurostat->mean_price_reg_1 = 0.0;
		current_xmachine_Eurostat->mean_price_reg_2 = 0.0;
		current_xmachine_Eurostat->mean_technology_reg_1 = 0.0;
		current_xmachine_Eurostat->mean_technology_reg_2 = 0.0;
		current_xmachine_Eurostat->exports_reg1 = 0.0;
		current_xmachine_Eurostat->exports_reg2 = 0.0;
		current_xmachine_Eurostat->imports_reg1 = 0.0;
		current_xmachine_Eurostat->trade_balance_reg1 = 0.0;
		current_xmachine_Eurostat->trade_balance_reg2 = 0.0;
		current_xmachine_Eurostat->imports_reg2 = 0.0;
		current_xmachine_Eurostat->export_quota_reg1 = 0.0;
		current_xmachine_Eurostat->export_quota_reg2 = 0.0;
		current_xmachine_Eurostat->import_quota_reg1 = 0.0;
		current_xmachine_Eurostat->import_quota_reg2 = 0.0;
		current_xmachine_Eurostat->trade_balance_quota_reg1 = 0.0;
		current_xmachine_Eurostat->trade_balance_quota_reg2 = 0.0;
		current_xmachine_Eurostat->mean_wage_reg_1 = 0.0;
		current_xmachine_Eurostat->mean_wage_reg_2 = 0.0;
		current_xmachine_Eurostat->mean_wage_offer_reg_1 = 0.0;
		current_xmachine_Eurostat->mean_wage_offer_reg_2 = 0.0;
		current_xmachine_Eurostat->mean_s_skills_reg_1 = 0.0;
		current_xmachine_Eurostat->mean_s_skills_reg_2 = 0.0;
		current_xmachine_Eurostat->mean_mark_up_reg_1 = 0.0;
		current_xmachine_Eurostat->mean_mark_up_reg_2 = 0.0;
		current_xmachine_Eurostat->relative_price = 0.0;
		current_xmachine_Eurostat->relative_reservation_wage = 0.0;
		current_xmachine_Eurostat->relative_mark_up = 0.0;
		current_xmachine_Eurostat->relative_wage = 0.0;
		current_xmachine_Eurostat->relative_wage_offer = 0.0;
		current_xmachine_Eurostat->relative_technology = 0.0;
		current_xmachine_Eurostat->relative_s_skills = 0.0;
		current_xmachine_Eurostat->relative_output = 0.0;
		current_xmachine_Eurostat->government_consumption = 0.0;
		current_xmachine_Eurostat->gini_wage = 0.0;
		current_xmachine_Eurostat->gini_income = 0.0;
		current_xmachine_Eurostat->gini_wealth = 0.0;
		current_xmachine_Eurostat->gini_specific_skills = 0.0;
		current_xmachine_Eurostat->gini_wage_reg_1 = 0.0;
		current_xmachine_Eurostat->gini_income_reg_1 = 0.0;
		current_xmachine_Eurostat->gini_wealth_reg_1 = 0.0;
		current_xmachine_Eurostat->gini_specific_skills_reg_1 = 0.0;
		current_xmachine_Eurostat->gini_wage_reg_2 = 0.0;
		current_xmachine_Eurostat->gini_income_reg_2 = 0.0;
		current_xmachine_Eurostat->gini_wealth_reg_2 = 0.0;
		current_xmachine_Eurostat->gini_specific_skills_reg_2 = 0.0;
		current_xmachine_Eurostat->labor_income_reg_1 = 0.0;
		current_xmachine_Eurostat->labor_income_reg_2 = 0.0;
		current_xmachine_Eurostat->dividend_income_reg_1 = 0.0;
		current_xmachine_Eurostat->dividend_income_reg_2 = 0.0;
		current_xmachine_Eurostat->interest_income_reg_1 = 0.0;
		current_xmachine_Eurostat->interest_income_reg_2 = 0.0;
		current_xmachine_Eurostat->financial_market_net_revenue_reg_1 = 0.0;
		current_xmachine_Eurostat->financial_market_net_revenue_reg_2 = 0.0;
		current_xmachine_Eurostat->average_s_skill = 0.0;
		current_xmachine_Eurostat->average_s_skill_1 = 0.0;
		current_xmachine_Eurostat->average_s_skill_2 = 0.0;
		current_xmachine_Eurostat->average_s_skill_3 = 0.0;
		current_xmachine_Eurostat->average_s_skill_4 = 0.0;
		current_xmachine_Eurostat->average_s_skill_5 = 0.0;
		current_xmachine_Eurostat->total_consumption_budget = 0.0;
		current_xmachine_Eurostat->no_firms = 0;
		current_xmachine_Eurostat->no_active_firms = 0;
		current_xmachine_Eurostat->no_vacancies = 0;
		current_xmachine_Eurostat->no_posted_vacancies = 0;
		current_xmachine_Eurostat->no_employees = 0;
		current_xmachine_Eurostat->no_employees_production = 0;
		current_xmachine_Eurostat->no_employees_r_and_d = 0;
		current_xmachine_Eurostat->no_employees_skill_1 = 0;
		current_xmachine_Eurostat->no_employees_skill_2 = 0;
		current_xmachine_Eurostat->no_employees_skill_3 = 0;
		current_xmachine_Eurostat->no_employees_skill_4 = 0;
		current_xmachine_Eurostat->no_employees_skill_5 = 0;
		init_price_quality_pair_array(&current_xmachine_Eurostat->price_quality_combination);
		current_xmachine_Eurostat->firm_average_wage = 0.0;
		current_xmachine_Eurostat->firm_average_production_wage = 0.0;
		current_xmachine_Eurostat->firm_average_r_and_d_wage = 0.0;
		current_xmachine_Eurostat->firm_average_wage_skill_1 = 0.0;
		current_xmachine_Eurostat->firm_average_wage_skill_2 = 0.0;
		current_xmachine_Eurostat->firm_average_wage_skill_3 = 0.0;
		current_xmachine_Eurostat->firm_average_wage_skill_4 = 0.0;
		current_xmachine_Eurostat->firm_average_wage_skill_5 = 0.0;
		current_xmachine_Eurostat->firm_average_g_skill = 0.0;
		current_xmachine_Eurostat->firm_average_s_skill = 0.0;
		current_xmachine_Eurostat->firm_average_s_skill_1 = 0.0;
		current_xmachine_Eurostat->firm_average_s_skill_2 = 0.0;
		current_xmachine_Eurostat->firm_average_s_skill_3 = 0.0;
		current_xmachine_Eurostat->firm_average_s_skill_4 = 0.0;
		current_xmachine_Eurostat->firm_average_s_skill_5 = 0.0;
		current_xmachine_Eurostat->firm_average_quality = 0.0;
		current_xmachine_Eurostat->firm_average_price = 0.0;
		init_firm_data_array(&current_xmachine_Eurostat->region_firm_data);
		init_household_data_array(&current_xmachine_Eurostat->region_household_data);
		init_government_data_array(&current_xmachine_Eurostat->region_government_data);
		current_xmachine_Eurostat->total_earnings = 0.0;
		current_xmachine_Eurostat->total_debt = 0.0;
		current_xmachine_Eurostat->total_assets = 0.0;
		current_xmachine_Eurostat->total_equity = 0.0;
		current_xmachine_Eurostat->average_debt_earnings_ratio = 0.0;
		current_xmachine_Eurostat->average_debt_equity_ratio = 0.0;
		current_xmachine_Eurostat->labour_share_ratio = 0.0;
		current_xmachine_Eurostat->cpi = 0.0;
		current_xmachine_Eurostat->hpi = 0.0;
		init_adt_subsidies_per_government_array(&current_xmachine_Eurostat->subsidies_per_government);
		init_adt_subsidies_per_government_array(&current_xmachine_Eurostat->subsidies_balanced);
		current_xmachine_Eurostat->gdp = 0.0;
		current_xmachine_Eurostat->monthly_investment_value = 0.0;
		current_xmachine_Eurostat->monthly_sold_quantity = 0.0;
		current_xmachine_Eurostat->herfindahl_index = 0.0;
		current_xmachine_Eurostat->monthly_output = 0.0;
		current_xmachine_Eurostat->monthly_revenue = 0.0;
		current_xmachine_Eurostat->monthly_planned_output = 0.0;
		current_xmachine_Eurostat->price_index = 0.0;
		init_history_item_static_array(current_xmachine_Eurostat->history_monthly, 13);
		init_history_item_static_array(current_xmachine_Eurostat->history_quarterly, 5);
		init_history_item(&current_xmachine_Eurostat->monthly_growth_rates);
		init_history_item(&current_xmachine_Eurostat->quarterly_growth_rates);
		init_history_item(&current_xmachine_Eurostat->annual_growth_rates_monthly);
		init_history_item(&current_xmachine_Eurostat->annual_growth_rates_quarterly);
		current_xmachine_Eurostat->no_firm_births = 0;
		current_xmachine_Eurostat->no_firm_deaths = 0;
		init_int_static_array(current_xmachine_Eurostat->firm_age_distribution, 301);
		init_int_static_array(current_xmachine_Eurostat->firm_age_distribution_multiperiod, 3612);
		init_int_static_array(current_xmachine_Eurostat->firm_age_distribution_1_period_lag, 301);
		init_int_static_array(current_xmachine_Eurostat->firm_age_distribution_2_period_lag, 301);
		current_xmachine_Eurostat->firm_birth_rate = 0.0;
		current_xmachine_Eurostat->firm_death_rate = 0.0;
		init_double_static_array(current_xmachine_Eurostat->survival_rate, 301);
		init_double_static_array(current_xmachine_Eurostat->survival_rate_multiperiod_1, 301);
		init_double_static_array(current_xmachine_Eurostat->survival_rate_multiperiod_2, 301);
		init_double_static_array(current_xmachine_Eurostat->survival_rate_multiperiod, 3612);
		current_xmachine_Eurostat->max_firm_creation = 0;
		current_xmachine_Eurostat->recession_started = 0;
		current_xmachine_Eurostat->recession_duration = 0;
		init_double_static_array(current_xmachine_Eurostat->export_volume_matrix, 100);
		init_double_static_array(current_xmachine_Eurostat->export_value_matrix, 100);
		init_double_static_array(current_xmachine_Eurostat->export_previous_value_matrix, 100);
		init_double_static_array(current_xmachine_Eurostat->region_export_volume, 100);
		init_double_static_array(current_xmachine_Eurostat->region_import_volume, 100);
		init_double_static_array(current_xmachine_Eurostat->region_export_value, 100);
		init_double_static_array(current_xmachine_Eurostat->region_import_value, 100);
		init_double_static_array(current_xmachine_Eurostat->region_import_previous_value, 100);
		current_xmachine_Eurostat->firm_average_productivity_progress = 0.0;
		current_xmachine_Eurostat->firm_average_productivity = 0.0;
		current_xmachine_Eurostat->investment_gdp_ratio = 0.0;
		current_xmachine_Eurostat->total_capital_stock_units = 0.0;
		current_xmachine_Eurostat->total_value_mall_inventories = 0.0;
		current_xmachine_Eurostat->total_dividends = 0.0;
		current_xmachine_Eurostat->base_wage_offer = 0.0;
		current_xmachine_Eurostat->just_employed = 0;
		current_xmachine_Eurostat->just_unemployed = 0;
		current_xmachine_Eurostat->start_employed = 0;
		current_xmachine_Eurostat->start_unemployed = 0;
		current_xmachine_Eurostat->enter_matching = 0;
		current_xmachine_Eurostat->unemployed_duration = 0;
		init_int_array(&current_xmachine_Eurostat->all_region_ids);
		init_int_array(&current_xmachine_Eurostat->all_gov_ids);
		current_xmachine_Eurostat->job_seperation_rate = 0.0;
		current_xmachine_Eurostat->job_finding_rate = 0.0;
		current_xmachine_Eurostat->v_u_ratio = 0.0;
		current_xmachine_Eurostat->matching_rate = 0.0;
		current_xmachine_Eurostat->hh_payment_account = 0.0;
		current_xmachine_Eurostat->mean_net_income = 0.0;
	
}

void unittest_free_Eurostat_agent()
{
	free_price_quality_pair_array(&current_xmachine_Eurostat->price_quality_combination);
	free_firm_data_array(&current_xmachine_Eurostat->region_firm_data);
	free_household_data_array(&current_xmachine_Eurostat->region_household_data);
	free_government_data_array(&current_xmachine_Eurostat->region_government_data);
	free_adt_subsidies_per_government_array(&current_xmachine_Eurostat->subsidies_per_government);
	free_adt_subsidies_per_government_array(&current_xmachine_Eurostat->subsidies_balanced);
	free_history_item_static_array(current_xmachine_Eurostat->history_monthly, 13);
	free_history_item_static_array(current_xmachine_Eurostat->history_quarterly, 5);
	free_history_item(&current_xmachine_Eurostat->monthly_growth_rates);
	free_history_item(&current_xmachine_Eurostat->quarterly_growth_rates);
	free_history_item(&current_xmachine_Eurostat->annual_growth_rates_monthly);
	free_history_item(&current_xmachine_Eurostat->annual_growth_rates_quarterly);
	free_int_array(&current_xmachine_Eurostat->all_region_ids);
	free_int_array(&current_xmachine_Eurostat->all_gov_ids);
	
	free(current_xmachine_Eurostat);
}

void free_Eurostat_agents()
{
	current_xmachine_Eurostat_holder = Eurostat_start_Eurostat_state->agents;
	while(current_xmachine_Eurostat_holder)
	{
		temp_xmachine_Eurostat_holder = current_xmachine_Eurostat_holder->next;
		free_Eurostat_agent(current_xmachine_Eurostat_holder, Eurostat_start_Eurostat_state);
		current_xmachine_Eurostat_holder = temp_xmachine_Eurostat_holder;
	}
	Eurostat_start_Eurostat_state->count = 0;
	current_xmachine_Eurostat_holder = Eurostat_end_Eurostat_state->agents;
	while(current_xmachine_Eurostat_holder)
	{
		temp_xmachine_Eurostat_holder = current_xmachine_Eurostat_holder->next;
		free_Eurostat_agent(current_xmachine_Eurostat_holder, Eurostat_end_Eurostat_state);
		current_xmachine_Eurostat_holder = temp_xmachine_Eurostat_holder;
	}
	Eurostat_end_Eurostat_state->count = 0;
	current_xmachine_Eurostat_holder = Eurostat_Eurostat_Start_EndOfYear_Loop_state->agents;
	while(current_xmachine_Eurostat_holder)
	{
		temp_xmachine_Eurostat_holder = current_xmachine_Eurostat_holder->next;
		free_Eurostat_agent(current_xmachine_Eurostat_holder, Eurostat_Eurostat_Start_EndOfYear_Loop_state);
		current_xmachine_Eurostat_holder = temp_xmachine_Eurostat_holder;
	}
	Eurostat_Eurostat_Start_EndOfYear_Loop_state->count = 0;
	current_xmachine_Eurostat_holder = Eurostat_05_state->agents;
	while(current_xmachine_Eurostat_holder)
	{
		temp_xmachine_Eurostat_holder = current_xmachine_Eurostat_holder->next;
		free_Eurostat_agent(current_xmachine_Eurostat_holder, Eurostat_05_state);
		current_xmachine_Eurostat_holder = temp_xmachine_Eurostat_holder;
	}
	Eurostat_05_state->count = 0;
	current_xmachine_Eurostat_holder = Eurostat_04_state->agents;
	while(current_xmachine_Eurostat_holder)
	{
		temp_xmachine_Eurostat_holder = current_xmachine_Eurostat_holder->next;
		free_Eurostat_agent(current_xmachine_Eurostat_holder, Eurostat_04_state);
		current_xmachine_Eurostat_holder = temp_xmachine_Eurostat_holder;
	}
	Eurostat_04_state->count = 0;
	current_xmachine_Eurostat_holder = Eurostat_Eurostat_Start_Quarterly_Loop_state->agents;
	while(current_xmachine_Eurostat_holder)
	{
		temp_xmachine_Eurostat_holder = current_xmachine_Eurostat_holder->next;
		free_Eurostat_agent(current_xmachine_Eurostat_holder, Eurostat_Eurostat_Start_Quarterly_Loop_state);
		current_xmachine_Eurostat_holder = temp_xmachine_Eurostat_holder;
	}
	Eurostat_Eurostat_Start_Quarterly_Loop_state->count = 0;
	current_xmachine_Eurostat_holder = Eurostat_02_state->agents;
	while(current_xmachine_Eurostat_holder)
	{
		temp_xmachine_Eurostat_holder = current_xmachine_Eurostat_holder->next;
		free_Eurostat_agent(current_xmachine_Eurostat_holder, Eurostat_02_state);
		current_xmachine_Eurostat_holder = temp_xmachine_Eurostat_holder;
	}
	Eurostat_02_state->count = 0;
	current_xmachine_Eurostat_holder = Eurostat_Eurostat_Start_Monthly_Loop_state->agents;
	while(current_xmachine_Eurostat_holder)
	{
		temp_xmachine_Eurostat_holder = current_xmachine_Eurostat_holder->next;
		free_Eurostat_agent(current_xmachine_Eurostat_holder, Eurostat_Eurostat_Start_Monthly_Loop_state);
		current_xmachine_Eurostat_holder = temp_xmachine_Eurostat_holder;
	}
	Eurostat_Eurostat_Start_Monthly_Loop_state->count = 0;
	current_xmachine_Eurostat_holder = Eurostat_01_state->agents;
	while(current_xmachine_Eurostat_holder)
	{
		temp_xmachine_Eurostat_holder = current_xmachine_Eurostat_holder->next;
		free_Eurostat_agent(current_xmachine_Eurostat_holder, Eurostat_01_state);
		current_xmachine_Eurostat_holder = temp_xmachine_Eurostat_holder;
	}
	Eurostat_01_state->count = 0;
	current_xmachine_Eurostat_holder = Eurostat_00_state->agents;
	while(current_xmachine_Eurostat_holder)
	{
		temp_xmachine_Eurostat_holder = current_xmachine_Eurostat_holder->next;
		free_Eurostat_agent(current_xmachine_Eurostat_holder, Eurostat_00_state);
		current_xmachine_Eurostat_holder = temp_xmachine_Eurostat_holder;
	}
	Eurostat_00_state->count = 0;
}

void free_Eurostat_states()
{
	free(Eurostat_start_Eurostat_state);
	free(Eurostat_end_Eurostat_state);
	free(Eurostat_Eurostat_Start_EndOfYear_Loop_state);
	free(Eurostat_05_state);
	free(Eurostat_04_state);
	free(Eurostat_Eurostat_Start_Quarterly_Loop_state);
	free(Eurostat_02_state);
	free(Eurostat_Eurostat_Start_Monthly_Loop_state);
	free(Eurostat_01_state);
	free(Eurostat_00_state);
}

void transition_Eurostat_agent(xmachine_memory_Eurostat_holder * tmp, xmachine_memory_Eurostat_state * from_state, xmachine_memory_Eurostat_state * to_state)
{
	if(tmp->prev == NULL) from_state->agents = tmp->next;
	else tmp->prev->next = tmp->next;
	if(tmp->next != NULL) tmp->next->prev = tmp->prev;

	add_Eurostat_agent_internal(tmp->agent, to_state);
	free(tmp);
}

void add_Eurostat_agent_internal(xmachine_memory_Eurostat * agent, xmachine_memory_Eurostat_state * state)
{
	xmachine_memory_Eurostat_holder * current = (xmachine_memory_Eurostat_holder *)malloc(sizeof(xmachine_memory_Eurostat_holder));
	CHECK_POINTER(current);

	current->next = state->agents;
	current->prev = NULL;
	state->agents = current;
	if(current->next != NULL) current->next->prev = current;
	current->agent = agent;

	state->count++;

}

/** \fn void add_Eurostat_agent(int id, int region_id, int partition_id, int switch_datastorage, int num_households, int no_households_skill_1, int no_households_skill_2, int no_households_skill_3, int no_households_skill_4, int no_households_skill_5, int employed, int employed_skill_1, int employed_skill_2, int employed_skill_3, int employed_skill_4, int employed_skill_5, double average_unit_labor_costs_reg_1, double average_unit_labor_costs_reg_2, int unemployed, double unemployment_rate, double employment_rate, double unemployment_rate_skill_1, double unemployment_rate_skill_2, double unemployment_rate_skill_3, double unemployment_rate_skill_4, double unemployment_rate_skill_5, int unemployed_reg1, int unemployed_reg2, double unemployment_rate_reg1, double unemployment_rate_reg2, double v_u_ratio_reg1, double v_u_ratio_reg2, double average_wage, double average_wage_reservation, double average_wage_reservation_region_1, double average_wage_reservation_region_2, double average_wage_skill_1, double average_wage_skill_2, double average_wage_skill_3, double average_wage_skill_4, double average_wage_skill_5, double sd_wage, double sd_income, double sd_wealth, double sd_specific_skills, double sd_wage_reg_1, double sd_income_reg_1, double sd_wealth_reg_1, double sd_specific_skills_reg_1, double sd_wage_reg_2, double sd_income_reg_2, double sd_wealth_reg_2, double sd_specific_skills_reg_2, double total_output_reg_2, double total_output_reg_1, double per_capita_output_reg_2, double per_capita_output_reg_1, double mean_price_reg_1, double mean_price_reg_2, double mean_technology_reg_1, double mean_technology_reg_2, double exports_reg1, double exports_reg2, double imports_reg1, double trade_balance_reg1, double trade_balance_reg2, double imports_reg2, double export_quota_reg1, double export_quota_reg2, double import_quota_reg1, double import_quota_reg2, double trade_balance_quota_reg1, double trade_balance_quota_reg2, double mean_wage_reg_1, double mean_wage_reg_2, double mean_wage_offer_reg_1, double mean_wage_offer_reg_2, double mean_s_skills_reg_1, double mean_s_skills_reg_2, double mean_mark_up_reg_1, double mean_mark_up_reg_2, double relative_price, double relative_reservation_wage, double relative_mark_up, double relative_wage, double relative_wage_offer, double relative_technology, double relative_s_skills, double relative_output, double government_consumption, double gini_wage, double gini_income, double gini_wealth, double gini_specific_skills, double gini_wage_reg_1, double gini_income_reg_1, double gini_wealth_reg_1, double gini_specific_skills_reg_1, double gini_wage_reg_2, double gini_income_reg_2, double gini_wealth_reg_2, double gini_specific_skills_reg_2, double labor_income_reg_1, double labor_income_reg_2, double dividend_income_reg_1, double dividend_income_reg_2, double interest_income_reg_1, double interest_income_reg_2, double financial_market_net_revenue_reg_1, double financial_market_net_revenue_reg_2, double average_s_skill, double average_s_skill_1, double average_s_skill_2, double average_s_skill_3, double average_s_skill_4, double average_s_skill_5, double total_consumption_budget, int no_firms, int no_active_firms, int no_vacancies, int no_posted_vacancies, int no_employees, int no_employees_production, int no_employees_r_and_d, int no_employees_skill_1, int no_employees_skill_2, int no_employees_skill_3, int no_employees_skill_4, int no_employees_skill_5, price_quality_pair_array * price_quality_combination, double firm_average_wage, double firm_average_production_wage, double firm_average_r_and_d_wage, double firm_average_wage_skill_1, double firm_average_wage_skill_2, double firm_average_wage_skill_3, double firm_average_wage_skill_4, double firm_average_wage_skill_5, double firm_average_g_skill, double firm_average_s_skill, double firm_average_s_skill_1, double firm_average_s_skill_2, double firm_average_s_skill_3, double firm_average_s_skill_4, double firm_average_s_skill_5, double firm_average_quality, double firm_average_price, firm_data_array * region_firm_data, household_data_array * region_household_data, government_data_array * region_government_data, double total_earnings, double total_debt, double total_assets, double total_equity, double average_debt_earnings_ratio, double average_debt_equity_ratio, double labour_share_ratio, double cpi, double hpi, adt_subsidies_per_government_array * subsidies_per_government, adt_subsidies_per_government_array * subsidies_balanced, double gdp, double monthly_investment_value, double monthly_sold_quantity, double herfindahl_index, double monthly_output, double monthly_revenue, double monthly_planned_output, double price_index, history_item ** history_monthly, history_item ** history_quarterly, history_item * monthly_growth_rates, history_item * quarterly_growth_rates, history_item * annual_growth_rates_monthly, history_item * annual_growth_rates_quarterly, int no_firm_births, int no_firm_deaths, int firm_age_distribution[], int firm_age_distribution_multiperiod[], int firm_age_distribution_1_period_lag[], int firm_age_distribution_2_period_lag[], double firm_birth_rate, double firm_death_rate, double survival_rate[], double survival_rate_multiperiod_1[], double survival_rate_multiperiod_2[], double survival_rate_multiperiod[], int max_firm_creation, int recession_started, int recession_duration, double export_volume_matrix[], double export_value_matrix[], double export_previous_value_matrix[], double region_export_volume[], double region_import_volume[], double region_export_value[], double region_import_value[], double region_import_previous_value[], double firm_average_productivity_progress, double firm_average_productivity, double investment_gdp_ratio, double total_capital_stock_units, double total_value_mall_inventories, double total_dividends, double base_wage_offer, int just_employed, int just_unemployed, int start_employed, int start_unemployed, int enter_matching, int unemployed_duration, int_array * all_region_ids, int_array * all_gov_ids, double job_seperation_rate, double job_finding_rate, double v_u_ratio, double matching_rate, double hh_payment_account, double mean_net_income)
 * \brief Add Eurostat X-machine to the current being used X-machine list.
 * \param id Variable for the X-machine memory.
 * \param region_id Variable for the X-machine memory.
 * \param partition_id Variable for the X-machine memory.
 * \param switch_datastorage Variable for the X-machine memory.
 * \param num_households Variable for the X-machine memory.
 * \param no_households_skill_1 Variable for the X-machine memory.
 * \param no_households_skill_2 Variable for the X-machine memory.
 * \param no_households_skill_3 Variable for the X-machine memory.
 * \param no_households_skill_4 Variable for the X-machine memory.
 * \param no_households_skill_5 Variable for the X-machine memory.
 * \param employed Variable for the X-machine memory.
 * \param employed_skill_1 Variable for the X-machine memory.
 * \param employed_skill_2 Variable for the X-machine memory.
 * \param employed_skill_3 Variable for the X-machine memory.
 * \param employed_skill_4 Variable for the X-machine memory.
 * \param employed_skill_5 Variable for the X-machine memory.
 * \param average_unit_labor_costs_reg_1 Variable for the X-machine memory.
 * \param average_unit_labor_costs_reg_2 Variable for the X-machine memory.
 * \param unemployed Variable for the X-machine memory.
 * \param unemployment_rate Variable for the X-machine memory.
 * \param employment_rate Variable for the X-machine memory.
 * \param unemployment_rate_skill_1 Variable for the X-machine memory.
 * \param unemployment_rate_skill_2 Variable for the X-machine memory.
 * \param unemployment_rate_skill_3 Variable for the X-machine memory.
 * \param unemployment_rate_skill_4 Variable for the X-machine memory.
 * \param unemployment_rate_skill_5 Variable for the X-machine memory.
 * \param unemployed_reg1 Variable for the X-machine memory.
 * \param unemployed_reg2 Variable for the X-machine memory.
 * \param unemployment_rate_reg1 Variable for the X-machine memory.
 * \param unemployment_rate_reg2 Variable for the X-machine memory.
 * \param v_u_ratio_reg1 Variable for the X-machine memory.
 * \param v_u_ratio_reg2 Variable for the X-machine memory.
 * \param average_wage Variable for the X-machine memory.
 * \param average_wage_reservation Variable for the X-machine memory.
 * \param average_wage_reservation_region_1 Variable for the X-machine memory.
 * \param average_wage_reservation_region_2 Variable for the X-machine memory.
 * \param average_wage_skill_1 Variable for the X-machine memory.
 * \param average_wage_skill_2 Variable for the X-machine memory.
 * \param average_wage_skill_3 Variable for the X-machine memory.
 * \param average_wage_skill_4 Variable for the X-machine memory.
 * \param average_wage_skill_5 Variable for the X-machine memory.
 * \param sd_wage Variable for the X-machine memory.
 * \param sd_income Variable for the X-machine memory.
 * \param sd_wealth Variable for the X-machine memory.
 * \param sd_specific_skills Variable for the X-machine memory.
 * \param sd_wage_reg_1 Variable for the X-machine memory.
 * \param sd_income_reg_1 Variable for the X-machine memory.
 * \param sd_wealth_reg_1 Variable for the X-machine memory.
 * \param sd_specific_skills_reg_1 Variable for the X-machine memory.
 * \param sd_wage_reg_2 Variable for the X-machine memory.
 * \param sd_income_reg_2 Variable for the X-machine memory.
 * \param sd_wealth_reg_2 Variable for the X-machine memory.
 * \param sd_specific_skills_reg_2 Variable for the X-machine memory.
 * \param total_output_reg_2 Variable for the X-machine memory.
 * \param total_output_reg_1 Variable for the X-machine memory.
 * \param per_capita_output_reg_2 Variable for the X-machine memory.
 * \param per_capita_output_reg_1 Variable for the X-machine memory.
 * \param mean_price_reg_1 Variable for the X-machine memory.
 * \param mean_price_reg_2 Variable for the X-machine memory.
 * \param mean_technology_reg_1 Variable for the X-machine memory.
 * \param mean_technology_reg_2 Variable for the X-machine memory.
 * \param exports_reg1 Variable for the X-machine memory.
 * \param exports_reg2 Variable for the X-machine memory.
 * \param imports_reg1 Variable for the X-machine memory.
 * \param trade_balance_reg1 Variable for the X-machine memory.
 * \param trade_balance_reg2 Variable for the X-machine memory.
 * \param imports_reg2 Variable for the X-machine memory.
 * \param export_quota_reg1 Variable for the X-machine memory.
 * \param export_quota_reg2 Variable for the X-machine memory.
 * \param import_quota_reg1 Variable for the X-machine memory.
 * \param import_quota_reg2 Variable for the X-machine memory.
 * \param trade_balance_quota_reg1 Variable for the X-machine memory.
 * \param trade_balance_quota_reg2 Variable for the X-machine memory.
 * \param mean_wage_reg_1 Variable for the X-machine memory.
 * \param mean_wage_reg_2 Variable for the X-machine memory.
 * \param mean_wage_offer_reg_1 Variable for the X-machine memory.
 * \param mean_wage_offer_reg_2 Variable for the X-machine memory.
 * \param mean_s_skills_reg_1 Variable for the X-machine memory.
 * \param mean_s_skills_reg_2 Variable for the X-machine memory.
 * \param mean_mark_up_reg_1 Variable for the X-machine memory.
 * \param mean_mark_up_reg_2 Variable for the X-machine memory.
 * \param relative_price Variable for the X-machine memory.
 * \param relative_reservation_wage Variable for the X-machine memory.
 * \param relative_mark_up Variable for the X-machine memory.
 * \param relative_wage Variable for the X-machine memory.
 * \param relative_wage_offer Variable for the X-machine memory.
 * \param relative_technology Variable for the X-machine memory.
 * \param relative_s_skills Variable for the X-machine memory.
 * \param relative_output Variable for the X-machine memory.
 * \param government_consumption Variable for the X-machine memory.
 * \param gini_wage Variable for the X-machine memory.
 * \param gini_income Variable for the X-machine memory.
 * \param gini_wealth Variable for the X-machine memory.
 * \param gini_specific_skills Variable for the X-machine memory.
 * \param gini_wage_reg_1 Variable for the X-machine memory.
 * \param gini_income_reg_1 Variable for the X-machine memory.
 * \param gini_wealth_reg_1 Variable for the X-machine memory.
 * \param gini_specific_skills_reg_1 Variable for the X-machine memory.
 * \param gini_wage_reg_2 Variable for the X-machine memory.
 * \param gini_income_reg_2 Variable for the X-machine memory.
 * \param gini_wealth_reg_2 Variable for the X-machine memory.
 * \param gini_specific_skills_reg_2 Variable for the X-machine memory.
 * \param labor_income_reg_1 Variable for the X-machine memory.
 * \param labor_income_reg_2 Variable for the X-machine memory.
 * \param dividend_income_reg_1 Variable for the X-machine memory.
 * \param dividend_income_reg_2 Variable for the X-machine memory.
 * \param interest_income_reg_1 Variable for the X-machine memory.
 * \param interest_income_reg_2 Variable for the X-machine memory.
 * \param financial_market_net_revenue_reg_1 Variable for the X-machine memory.
 * \param financial_market_net_revenue_reg_2 Variable for the X-machine memory.
 * \param average_s_skill Variable for the X-machine memory.
 * \param average_s_skill_1 Variable for the X-machine memory.
 * \param average_s_skill_2 Variable for the X-machine memory.
 * \param average_s_skill_3 Variable for the X-machine memory.
 * \param average_s_skill_4 Variable for the X-machine memory.
 * \param average_s_skill_5 Variable for the X-machine memory.
 * \param total_consumption_budget Variable for the X-machine memory.
 * \param no_firms Variable for the X-machine memory.
 * \param no_active_firms Variable for the X-machine memory.
 * \param no_vacancies Variable for the X-machine memory.
 * \param no_posted_vacancies Variable for the X-machine memory.
 * \param no_employees Variable for the X-machine memory.
 * \param no_employees_production Variable for the X-machine memory.
 * \param no_employees_r_and_d Variable for the X-machine memory.
 * \param no_employees_skill_1 Variable for the X-machine memory.
 * \param no_employees_skill_2 Variable for the X-machine memory.
 * \param no_employees_skill_3 Variable for the X-machine memory.
 * \param no_employees_skill_4 Variable for the X-machine memory.
 * \param no_employees_skill_5 Variable for the X-machine memory.
 * \param price_quality_combination Variable for the X-machine memory.
 * \param firm_average_wage Variable for the X-machine memory.
 * \param firm_average_production_wage Variable for the X-machine memory.
 * \param firm_average_r_and_d_wage Variable for the X-machine memory.
 * \param firm_average_wage_skill_1 Variable for the X-machine memory.
 * \param firm_average_wage_skill_2 Variable for the X-machine memory.
 * \param firm_average_wage_skill_3 Variable for the X-machine memory.
 * \param firm_average_wage_skill_4 Variable for the X-machine memory.
 * \param firm_average_wage_skill_5 Variable for the X-machine memory.
 * \param firm_average_g_skill Variable for the X-machine memory.
 * \param firm_average_s_skill Variable for the X-machine memory.
 * \param firm_average_s_skill_1 Variable for the X-machine memory.
 * \param firm_average_s_skill_2 Variable for the X-machine memory.
 * \param firm_average_s_skill_3 Variable for the X-machine memory.
 * \param firm_average_s_skill_4 Variable for the X-machine memory.
 * \param firm_average_s_skill_5 Variable for the X-machine memory.
 * \param firm_average_quality Variable for the X-machine memory.
 * \param firm_average_price Variable for the X-machine memory.
 * \param region_firm_data Variable for the X-machine memory.
 * \param region_household_data Variable for the X-machine memory.
 * \param region_government_data Variable for the X-machine memory.
 * \param total_earnings Variable for the X-machine memory.
 * \param total_debt Variable for the X-machine memory.
 * \param total_assets Variable for the X-machine memory.
 * \param total_equity Variable for the X-machine memory.
 * \param average_debt_earnings_ratio Variable for the X-machine memory.
 * \param average_debt_equity_ratio Variable for the X-machine memory.
 * \param labour_share_ratio Variable for the X-machine memory.
 * \param cpi Variable for the X-machine memory.
 * \param hpi Variable for the X-machine memory.
 * \param subsidies_per_government Variable for the X-machine memory.
 * \param subsidies_balanced Variable for the X-machine memory.
 * \param gdp Variable for the X-machine memory.
 * \param monthly_investment_value Variable for the X-machine memory.
 * \param monthly_sold_quantity Variable for the X-machine memory.
 * \param herfindahl_index Variable for the X-machine memory.
 * \param monthly_output Variable for the X-machine memory.
 * \param monthly_revenue Variable for the X-machine memory.
 * \param monthly_planned_output Variable for the X-machine memory.
 * \param price_index Variable for the X-machine memory.
 * \param history_monthly Variable for the X-machine memory.
 * \param history_quarterly Variable for the X-machine memory.
 * \param monthly_growth_rates Variable for the X-machine memory.
 * \param quarterly_growth_rates Variable for the X-machine memory.
 * \param annual_growth_rates_monthly Variable for the X-machine memory.
 * \param annual_growth_rates_quarterly Variable for the X-machine memory.
 * \param no_firm_births Variable for the X-machine memory.
 * \param no_firm_deaths Variable for the X-machine memory.
 * \param firm_age_distribution Variable for the X-machine memory.
 * \param firm_age_distribution_multiperiod Variable for the X-machine memory.
 * \param firm_age_distribution_1_period_lag Variable for the X-machine memory.
 * \param firm_age_distribution_2_period_lag Variable for the X-machine memory.
 * \param firm_birth_rate Variable for the X-machine memory.
 * \param firm_death_rate Variable for the X-machine memory.
 * \param survival_rate Variable for the X-machine memory.
 * \param survival_rate_multiperiod_1 Variable for the X-machine memory.
 * \param survival_rate_multiperiod_2 Variable for the X-machine memory.
 * \param survival_rate_multiperiod Variable for the X-machine memory.
 * \param max_firm_creation Variable for the X-machine memory.
 * \param recession_started Variable for the X-machine memory.
 * \param recession_duration Variable for the X-machine memory.
 * \param export_volume_matrix Variable for the X-machine memory.
 * \param export_value_matrix Variable for the X-machine memory.
 * \param export_previous_value_matrix Variable for the X-machine memory.
 * \param region_export_volume Variable for the X-machine memory.
 * \param region_import_volume Variable for the X-machine memory.
 * \param region_export_value Variable for the X-machine memory.
 * \param region_import_value Variable for the X-machine memory.
 * \param region_import_previous_value Variable for the X-machine memory.
 * \param firm_average_productivity_progress Variable for the X-machine memory.
 * \param firm_average_productivity Variable for the X-machine memory.
 * \param investment_gdp_ratio Variable for the X-machine memory.
 * \param total_capital_stock_units Variable for the X-machine memory.
 * \param total_value_mall_inventories Variable for the X-machine memory.
 * \param total_dividends Variable for the X-machine memory.
 * \param base_wage_offer Variable for the X-machine memory.
 * \param just_employed Variable for the X-machine memory.
 * \param just_unemployed Variable for the X-machine memory.
 * \param start_employed Variable for the X-machine memory.
 * \param start_unemployed Variable for the X-machine memory.
 * \param enter_matching Variable for the X-machine memory.
 * \param unemployed_duration Variable for the X-machine memory.
 * \param all_region_ids Variable for the X-machine memory.
 * \param all_gov_ids Variable for the X-machine memory.
 * \param job_seperation_rate Variable for the X-machine memory.
 * \param job_finding_rate Variable for the X-machine memory.
 * \param v_u_ratio Variable for the X-machine memory.
 * \param matching_rate Variable for the X-machine memory.
 * \param hh_payment_account Variable for the X-machine memory.
 * \param mean_net_income Variable for the X-machine memory.
 */
void add_Eurostat_agent(int id, int region_id, int partition_id, int switch_datastorage, int num_households, int no_households_skill_1, int no_households_skill_2, int no_households_skill_3, int no_households_skill_4, int no_households_skill_5, int employed, int employed_skill_1, int employed_skill_2, int employed_skill_3, int employed_skill_4, int employed_skill_5, double average_unit_labor_costs_reg_1, double average_unit_labor_costs_reg_2, int unemployed, double unemployment_rate, double employment_rate, double unemployment_rate_skill_1, double unemployment_rate_skill_2, double unemployment_rate_skill_3, double unemployment_rate_skill_4, double unemployment_rate_skill_5, int unemployed_reg1, int unemployed_reg2, double unemployment_rate_reg1, double unemployment_rate_reg2, double v_u_ratio_reg1, double v_u_ratio_reg2, double average_wage, double average_wage_reservation, double average_wage_reservation_region_1, double average_wage_reservation_region_2, double average_wage_skill_1, double average_wage_skill_2, double average_wage_skill_3, double average_wage_skill_4, double average_wage_skill_5, double sd_wage, double sd_income, double sd_wealth, double sd_specific_skills, double sd_wage_reg_1, double sd_income_reg_1, double sd_wealth_reg_1, double sd_specific_skills_reg_1, double sd_wage_reg_2, double sd_income_reg_2, double sd_wealth_reg_2, double sd_specific_skills_reg_2, double total_output_reg_2, double total_output_reg_1, double per_capita_output_reg_2, double per_capita_output_reg_1, double mean_price_reg_1, double mean_price_reg_2, double mean_technology_reg_1, double mean_technology_reg_2, double exports_reg1, double exports_reg2, double imports_reg1, double trade_balance_reg1, double trade_balance_reg2, double imports_reg2, double export_quota_reg1, double export_quota_reg2, double import_quota_reg1, double import_quota_reg2, double trade_balance_quota_reg1, double trade_balance_quota_reg2, double mean_wage_reg_1, double mean_wage_reg_2, double mean_wage_offer_reg_1, double mean_wage_offer_reg_2, double mean_s_skills_reg_1, double mean_s_skills_reg_2, double mean_mark_up_reg_1, double mean_mark_up_reg_2, double relative_price, double relative_reservation_wage, double relative_mark_up, double relative_wage, double relative_wage_offer, double relative_technology, double relative_s_skills, double relative_output, double government_consumption, double gini_wage, double gini_income, double gini_wealth, double gini_specific_skills, double gini_wage_reg_1, double gini_income_reg_1, double gini_wealth_reg_1, double gini_specific_skills_reg_1, double gini_wage_reg_2, double gini_income_reg_2, double gini_wealth_reg_2, double gini_specific_skills_reg_2, double labor_income_reg_1, double labor_income_reg_2, double dividend_income_reg_1, double dividend_income_reg_2, double interest_income_reg_1, double interest_income_reg_2, double financial_market_net_revenue_reg_1, double financial_market_net_revenue_reg_2, double average_s_skill, double average_s_skill_1, double average_s_skill_2, double average_s_skill_3, double average_s_skill_4, double average_s_skill_5, double total_consumption_budget, int no_firms, int no_active_firms, int no_vacancies, int no_posted_vacancies, int no_employees, int no_employees_production, int no_employees_r_and_d, int no_employees_skill_1, int no_employees_skill_2, int no_employees_skill_3, int no_employees_skill_4, int no_employees_skill_5, price_quality_pair_array * price_quality_combination, double firm_average_wage, double firm_average_production_wage, double firm_average_r_and_d_wage, double firm_average_wage_skill_1, double firm_average_wage_skill_2, double firm_average_wage_skill_3, double firm_average_wage_skill_4, double firm_average_wage_skill_5, double firm_average_g_skill, double firm_average_s_skill, double firm_average_s_skill_1, double firm_average_s_skill_2, double firm_average_s_skill_3, double firm_average_s_skill_4, double firm_average_s_skill_5, double firm_average_quality, double firm_average_price, firm_data_array * region_firm_data, household_data_array * region_household_data, government_data_array * region_government_data, double total_earnings, double total_debt, double total_assets, double total_equity, double average_debt_earnings_ratio, double average_debt_equity_ratio, double labour_share_ratio, double cpi, double hpi, adt_subsidies_per_government_array * subsidies_per_government, adt_subsidies_per_government_array * subsidies_balanced, double gdp, double monthly_investment_value, double monthly_sold_quantity, double herfindahl_index, double monthly_output, double monthly_revenue, double monthly_planned_output, double price_index, history_item history_monthly[], history_item history_quarterly[], history_item monthly_growth_rates, history_item quarterly_growth_rates, history_item annual_growth_rates_monthly, history_item annual_growth_rates_quarterly, int no_firm_births, int no_firm_deaths, int firm_age_distribution[], int firm_age_distribution_multiperiod[], int firm_age_distribution_1_period_lag[], int firm_age_distribution_2_period_lag[], double firm_birth_rate, double firm_death_rate, double survival_rate[], double survival_rate_multiperiod_1[], double survival_rate_multiperiod_2[], double survival_rate_multiperiod[], int max_firm_creation, int recession_started, int recession_duration, double export_volume_matrix[], double export_value_matrix[], double export_previous_value_matrix[], double region_export_volume[], double region_import_volume[], double region_export_value[], double region_import_value[], double region_import_previous_value[], double firm_average_productivity_progress, double firm_average_productivity, double investment_gdp_ratio, double total_capital_stock_units, double total_value_mall_inventories, double total_dividends, double base_wage_offer, int just_employed, int just_unemployed, int start_employed, int start_unemployed, int enter_matching, int unemployed_duration, int_array * all_region_ids, int_array * all_gov_ids, double job_seperation_rate, double job_finding_rate, double v_u_ratio, double matching_rate, double hh_payment_account, double mean_net_income)
{
	xmachine_memory_Eurostat * current;

	current = init_Eurostat_agent();
	/* new line added to handle dynamic agent creation*/
	current_xmachine_Eurostat_next_state = Eurostat_start_Eurostat_state;
	add_Eurostat_agent_internal(current, current_xmachine_Eurostat_next_state);

	current->id = id;
	current->region_id = region_id;
	current->partition_id = partition_id;
	current->switch_datastorage = switch_datastorage;
	current->num_households = num_households;
	current->no_households_skill_1 = no_households_skill_1;
	current->no_households_skill_2 = no_households_skill_2;
	current->no_households_skill_3 = no_households_skill_3;
	current->no_households_skill_4 = no_households_skill_4;
	current->no_households_skill_5 = no_households_skill_5;
	current->employed = employed;
	current->employed_skill_1 = employed_skill_1;
	current->employed_skill_2 = employed_skill_2;
	current->employed_skill_3 = employed_skill_3;
	current->employed_skill_4 = employed_skill_4;
	current->employed_skill_5 = employed_skill_5;
	current->average_unit_labor_costs_reg_1 = average_unit_labor_costs_reg_1;
	current->average_unit_labor_costs_reg_2 = average_unit_labor_costs_reg_2;
	current->unemployed = unemployed;
	current->unemployment_rate = unemployment_rate;
	current->employment_rate = employment_rate;
	current->unemployment_rate_skill_1 = unemployment_rate_skill_1;
	current->unemployment_rate_skill_2 = unemployment_rate_skill_2;
	current->unemployment_rate_skill_3 = unemployment_rate_skill_3;
	current->unemployment_rate_skill_4 = unemployment_rate_skill_4;
	current->unemployment_rate_skill_5 = unemployment_rate_skill_5;
	current->unemployed_reg1 = unemployed_reg1;
	current->unemployed_reg2 = unemployed_reg2;
	current->unemployment_rate_reg1 = unemployment_rate_reg1;
	current->unemployment_rate_reg2 = unemployment_rate_reg2;
	current->v_u_ratio_reg1 = v_u_ratio_reg1;
	current->v_u_ratio_reg2 = v_u_ratio_reg2;
	current->average_wage = average_wage;
	current->average_wage_reservation = average_wage_reservation;
	current->average_wage_reservation_region_1 = average_wage_reservation_region_1;
	current->average_wage_reservation_region_2 = average_wage_reservation_region_2;
	current->average_wage_skill_1 = average_wage_skill_1;
	current->average_wage_skill_2 = average_wage_skill_2;
	current->average_wage_skill_3 = average_wage_skill_3;
	current->average_wage_skill_4 = average_wage_skill_4;
	current->average_wage_skill_5 = average_wage_skill_5;
	current->sd_wage = sd_wage;
	current->sd_income = sd_income;
	current->sd_wealth = sd_wealth;
	current->sd_specific_skills = sd_specific_skills;
	current->sd_wage_reg_1 = sd_wage_reg_1;
	current->sd_income_reg_1 = sd_income_reg_1;
	current->sd_wealth_reg_1 = sd_wealth_reg_1;
	current->sd_specific_skills_reg_1 = sd_specific_skills_reg_1;
	current->sd_wage_reg_2 = sd_wage_reg_2;
	current->sd_income_reg_2 = sd_income_reg_2;
	current->sd_wealth_reg_2 = sd_wealth_reg_2;
	current->sd_specific_skills_reg_2 = sd_specific_skills_reg_2;
	current->total_output_reg_2 = total_output_reg_2;
	current->total_output_reg_1 = total_output_reg_1;
	current->per_capita_output_reg_2 = per_capita_output_reg_2;
	current->per_capita_output_reg_1 = per_capita_output_reg_1;
	current->mean_price_reg_1 = mean_price_reg_1;
	current->mean_price_reg_2 = mean_price_reg_2;
	current->mean_technology_reg_1 = mean_technology_reg_1;
	current->mean_technology_reg_2 = mean_technology_reg_2;
	current->exports_reg1 = exports_reg1;
	current->exports_reg2 = exports_reg2;
	current->imports_reg1 = imports_reg1;
	current->trade_balance_reg1 = trade_balance_reg1;
	current->trade_balance_reg2 = trade_balance_reg2;
	current->imports_reg2 = imports_reg2;
	current->export_quota_reg1 = export_quota_reg1;
	current->export_quota_reg2 = export_quota_reg2;
	current->import_quota_reg1 = import_quota_reg1;
	current->import_quota_reg2 = import_quota_reg2;
	current->trade_balance_quota_reg1 = trade_balance_quota_reg1;
	current->trade_balance_quota_reg2 = trade_balance_quota_reg2;
	current->mean_wage_reg_1 = mean_wage_reg_1;
	current->mean_wage_reg_2 = mean_wage_reg_2;
	current->mean_wage_offer_reg_1 = mean_wage_offer_reg_1;
	current->mean_wage_offer_reg_2 = mean_wage_offer_reg_2;
	current->mean_s_skills_reg_1 = mean_s_skills_reg_1;
	current->mean_s_skills_reg_2 = mean_s_skills_reg_2;
	current->mean_mark_up_reg_1 = mean_mark_up_reg_1;
	current->mean_mark_up_reg_2 = mean_mark_up_reg_2;
	current->relative_price = relative_price;
	current->relative_reservation_wage = relative_reservation_wage;
	current->relative_mark_up = relative_mark_up;
	current->relative_wage = relative_wage;
	current->relative_wage_offer = relative_wage_offer;
	current->relative_technology = relative_technology;
	current->relative_s_skills = relative_s_skills;
	current->relative_output = relative_output;
	current->government_consumption = government_consumption;
	current->gini_wage = gini_wage;
	current->gini_income = gini_income;
	current->gini_wealth = gini_wealth;
	current->gini_specific_skills = gini_specific_skills;
	current->gini_wage_reg_1 = gini_wage_reg_1;
	current->gini_income_reg_1 = gini_income_reg_1;
	current->gini_wealth_reg_1 = gini_wealth_reg_1;
	current->gini_specific_skills_reg_1 = gini_specific_skills_reg_1;
	current->gini_wage_reg_2 = gini_wage_reg_2;
	current->gini_income_reg_2 = gini_income_reg_2;
	current->gini_wealth_reg_2 = gini_wealth_reg_2;
	current->gini_specific_skills_reg_2 = gini_specific_skills_reg_2;
	current->labor_income_reg_1 = labor_income_reg_1;
	current->labor_income_reg_2 = labor_income_reg_2;
	current->dividend_income_reg_1 = dividend_income_reg_1;
	current->dividend_income_reg_2 = dividend_income_reg_2;
	current->interest_income_reg_1 = interest_income_reg_1;
	current->interest_income_reg_2 = interest_income_reg_2;
	current->financial_market_net_revenue_reg_1 = financial_market_net_revenue_reg_1;
	current->financial_market_net_revenue_reg_2 = financial_market_net_revenue_reg_2;
	current->average_s_skill = average_s_skill;
	current->average_s_skill_1 = average_s_skill_1;
	current->average_s_skill_2 = average_s_skill_2;
	current->average_s_skill_3 = average_s_skill_3;
	current->average_s_skill_4 = average_s_skill_4;
	current->average_s_skill_5 = average_s_skill_5;
	current->total_consumption_budget = total_consumption_budget;
	current->no_firms = no_firms;
	current->no_active_firms = no_active_firms;
	current->no_vacancies = no_vacancies;
	current->no_posted_vacancies = no_posted_vacancies;
	current->no_employees = no_employees;
	current->no_employees_production = no_employees_production;
	current->no_employees_r_and_d = no_employees_r_and_d;
	current->no_employees_skill_1 = no_employees_skill_1;
	current->no_employees_skill_2 = no_employees_skill_2;
	current->no_employees_skill_3 = no_employees_skill_3;
	current->no_employees_skill_4 = no_employees_skill_4;
	current->no_employees_skill_5 = no_employees_skill_5;
	copy_price_quality_pair_array(price_quality_combination, &current->price_quality_combination);
	current->firm_average_wage = firm_average_wage;
	current->firm_average_production_wage = firm_average_production_wage;
	current->firm_average_r_and_d_wage = firm_average_r_and_d_wage;
	current->firm_average_wage_skill_1 = firm_average_wage_skill_1;
	current->firm_average_wage_skill_2 = firm_average_wage_skill_2;
	current->firm_average_wage_skill_3 = firm_average_wage_skill_3;
	current->firm_average_wage_skill_4 = firm_average_wage_skill_4;
	current->firm_average_wage_skill_5 = firm_average_wage_skill_5;
	current->firm_average_g_skill = firm_average_g_skill;
	current->firm_average_s_skill = firm_average_s_skill;
	current->firm_average_s_skill_1 = firm_average_s_skill_1;
	current->firm_average_s_skill_2 = firm_average_s_skill_2;
	current->firm_average_s_skill_3 = firm_average_s_skill_3;
	current->firm_average_s_skill_4 = firm_average_s_skill_4;
	current->firm_average_s_skill_5 = firm_average_s_skill_5;
	current->firm_average_quality = firm_average_quality;
	current->firm_average_price = firm_average_price;
	copy_firm_data_array(region_firm_data, &current->region_firm_data);
	copy_household_data_array(region_household_data, &current->region_household_data);
	copy_government_data_array(region_government_data, &current->region_government_data);
	current->total_earnings = total_earnings;
	current->total_debt = total_debt;
	current->total_assets = total_assets;
	current->total_equity = total_equity;
	current->average_debt_earnings_ratio = average_debt_earnings_ratio;
	current->average_debt_equity_ratio = average_debt_equity_ratio;
	current->labour_share_ratio = labour_share_ratio;
	current->cpi = cpi;
	current->hpi = hpi;
	copy_adt_subsidies_per_government_array(subsidies_per_government, &current->subsidies_per_government);
	copy_adt_subsidies_per_government_array(subsidies_balanced, &current->subsidies_balanced);
	current->gdp = gdp;
	current->monthly_investment_value = monthly_investment_value;
	current->monthly_sold_quantity = monthly_sold_quantity;
	current->herfindahl_index = herfindahl_index;
	current->monthly_output = monthly_output;
	current->monthly_revenue = monthly_revenue;
	current->monthly_planned_output = monthly_planned_output;
	current->price_index = price_index;
	copy_history_item_static_array(history_monthly, current->history_monthly, 13);
	copy_history_item_static_array(history_quarterly, current->history_quarterly, 5);
	copy_history_item(&monthly_growth_rates, &current->monthly_growth_rates);
	copy_history_item(&quarterly_growth_rates, &current->quarterly_growth_rates);
	copy_history_item(&annual_growth_rates_monthly, &current->annual_growth_rates_monthly);
	copy_history_item(&annual_growth_rates_quarterly, &current->annual_growth_rates_quarterly);
	current->no_firm_births = no_firm_births;
	current->no_firm_deaths = no_firm_deaths;
	memcpy(current->firm_age_distribution, firm_age_distribution, 301*sizeof(int));
	memcpy(current->firm_age_distribution_multiperiod, firm_age_distribution_multiperiod, 3612*sizeof(int));
	memcpy(current->firm_age_distribution_1_period_lag, firm_age_distribution_1_period_lag, 301*sizeof(int));
	memcpy(current->firm_age_distribution_2_period_lag, firm_age_distribution_2_period_lag, 301*sizeof(int));
	current->firm_birth_rate = firm_birth_rate;
	current->firm_death_rate = firm_death_rate;
	memcpy(current->survival_rate, survival_rate, 301*sizeof(double));
	memcpy(current->survival_rate_multiperiod_1, survival_rate_multiperiod_1, 301*sizeof(double));
	memcpy(current->survival_rate_multiperiod_2, survival_rate_multiperiod_2, 301*sizeof(double));
	memcpy(current->survival_rate_multiperiod, survival_rate_multiperiod, 3612*sizeof(double));
	current->max_firm_creation = max_firm_creation;
	current->recession_started = recession_started;
	current->recession_duration = recession_duration;
	memcpy(current->export_volume_matrix, export_volume_matrix, 100*sizeof(double));
	memcpy(current->export_value_matrix, export_value_matrix, 100*sizeof(double));
	memcpy(current->export_previous_value_matrix, export_previous_value_matrix, 100*sizeof(double));
	memcpy(current->region_export_volume, region_export_volume, 100*sizeof(double));
	memcpy(current->region_import_volume, region_import_volume, 100*sizeof(double));
	memcpy(current->region_export_value, region_export_value, 100*sizeof(double));
	memcpy(current->region_import_value, region_import_value, 100*sizeof(double));
	memcpy(current->region_import_previous_value, region_import_previous_value, 100*sizeof(double));
	current->firm_average_productivity_progress = firm_average_productivity_progress;
	current->firm_average_productivity = firm_average_productivity;
	current->investment_gdp_ratio = investment_gdp_ratio;
	current->total_capital_stock_units = total_capital_stock_units;
	current->total_value_mall_inventories = total_value_mall_inventories;
	current->total_dividends = total_dividends;
	current->base_wage_offer = base_wage_offer;
	current->just_employed = just_employed;
	current->just_unemployed = just_unemployed;
	current->start_employed = start_employed;
	current->start_unemployed = start_unemployed;
	current->enter_matching = enter_matching;
	current->unemployed_duration = unemployed_duration;
	copy_int_array(all_region_ids, &current->all_region_ids);
	copy_int_array(all_gov_ids, &current->all_gov_ids);
	current->job_seperation_rate = job_seperation_rate;
	current->job_finding_rate = job_finding_rate;
	current->v_u_ratio = v_u_ratio;
	current->matching_rate = matching_rate;
	current->hh_payment_account = hh_payment_account;
	current->mean_net_income = mean_net_income;
}

xmachine_memory_Bank_state * init_Bank_state()
{
	xmachine_memory_Bank_state * current = (xmachine_memory_Bank_state *)malloc(sizeof(xmachine_memory_Bank_state));
	CHECK_POINTER(current);

	current->agents = NULL;
	current->count = 0;

	return current;
}

xmachine_memory_Bank * init_Bank_agent()
{
	xmachine_memory_Bank * current = (xmachine_memory_Bank *)malloc(sizeof(xmachine_memory_Bank));
	CHECK_POINTER(current);

	current->id = 0;
	current->region_id = 0;
	current->gov_id = 0;
	current->partition_id = 0;
	current->active = 0;
	current->inactive = 0;
	current->cash = 0.0;
	current->total_credit = 0.0;
	current->equity = 0.0;
	current->ecb_debt = 0.0;
	current->value_at_risk = 0.0;
	current->deposit_interest_rate = 0.0;
	init_double_static_array(current->bank_gamma, 2);
	init_double_static_array(current->profits, 2);
	current->bank_dividend_rate = 0.0;
	current->tax_rate_corporate = 0.0;
	current->current_shares_outstanding = 0;
	current->debt_period = 0.0;
	current->loan_request_message_found = 0;
	current->day_of_month_to_act = 0;
	current->deposits = 0.0;
	current->firm_loan_installments = 0.0;
	current->firm_loan_installments_in_calendar_month = 0.0;
	current->firm_interest_payments = 0.0;
	current->firm_interest_payments_in_calendar_month = 0.0;
	current->firm_loan_issues = 0.0;
	current->ecb_interest_payment = 0.0;
	current->total_dividend_payment = 0.0;
	current->total_dividends_in_calendar_month = 0.0;
	current->taxes = 0.0;
	current->dividend_per_share = 0.0;
	current->current_share_price = 0.0;
	current->leverage_ratio = 0.0;
	current->cash_deposit_ratio = 0.0;
	current->equity_asset_ratio = 0.0;
	current->mean_interest_rate = 0.0;
	current->sum_new_interest_rates_in_calendar_month = 0.0;
	current->no_new_loans_in_calendar_month = 0;
	current->paid_interest_daily = 0.0;
	current->paid_interest_in_calendar_month = 0.0;
	current->excess_var = 0.0;
	current->excess_liquidity = 0.0;
	current->total_bad_debt_calendar_month = 0.0;
	init_bank_balance_sheet_adt(&current->bank_balance_sheet_calendar);
	init_bank_stocks_adt(&current->bank_stocks_calendar);
	init_bank_outflows_adt(&current->bank_outflows_calendar);
	init_bank_inflows_adt(&current->bank_inflows_calendar);
	current->total_income = 0.0;
	current->total_expenses = 0.0;
	current->total_assets = 0.0;
	current->total_liabilities = 0.0;

	return current;
}

void free_Bank_agent(xmachine_memory_Bank_holder * tmp, xmachine_memory_Bank_state * state)
{
	if(tmp->prev == NULL) state->agents = tmp->next;
	else tmp->prev->next = tmp->next;
	if(tmp->next != NULL) tmp->next->prev = tmp->prev;

	free_bank_balance_sheet_adt(&tmp->agent->bank_balance_sheet_calendar);
	free_bank_stocks_adt(&tmp->agent->bank_stocks_calendar);
	free_bank_outflows_adt(&tmp->agent->bank_outflows_calendar);
	free_bank_inflows_adt(&tmp->agent->bank_inflows_calendar);
	

	free(tmp->agent);
	free(tmp);
}

void unittest_init_Bank_agent()
{
	current_xmachine_Bank = (xmachine_memory_Bank *)malloc(sizeof(xmachine_memory_Bank));
	CHECK_POINTER(current);

		current_xmachine_Bank->id = 0;
		current_xmachine_Bank->region_id = 0;
		current_xmachine_Bank->gov_id = 0;
		current_xmachine_Bank->partition_id = 0;
		current_xmachine_Bank->active = 0;
		current_xmachine_Bank->inactive = 0;
		current_xmachine_Bank->cash = 0.0;
		current_xmachine_Bank->total_credit = 0.0;
		current_xmachine_Bank->equity = 0.0;
		current_xmachine_Bank->ecb_debt = 0.0;
		current_xmachine_Bank->value_at_risk = 0.0;
		current_xmachine_Bank->deposit_interest_rate = 0.0;
		init_double_static_array(current_xmachine_Bank->bank_gamma, 2);
		init_double_static_array(current_xmachine_Bank->profits, 2);
		current_xmachine_Bank->bank_dividend_rate = 0.0;
		current_xmachine_Bank->tax_rate_corporate = 0.0;
		current_xmachine_Bank->current_shares_outstanding = 0;
		current_xmachine_Bank->debt_period = 0.0;
		current_xmachine_Bank->loan_request_message_found = 0;
		current_xmachine_Bank->day_of_month_to_act = 0;
		current_xmachine_Bank->deposits = 0.0;
		current_xmachine_Bank->firm_loan_installments = 0.0;
		current_xmachine_Bank->firm_loan_installments_in_calendar_month = 0.0;
		current_xmachine_Bank->firm_interest_payments = 0.0;
		current_xmachine_Bank->firm_interest_payments_in_calendar_month = 0.0;
		current_xmachine_Bank->firm_loan_issues = 0.0;
		current_xmachine_Bank->ecb_interest_payment = 0.0;
		current_xmachine_Bank->total_dividend_payment = 0.0;
		current_xmachine_Bank->total_dividends_in_calendar_month = 0.0;
		current_xmachine_Bank->taxes = 0.0;
		current_xmachine_Bank->dividend_per_share = 0.0;
		current_xmachine_Bank->current_share_price = 0.0;
		current_xmachine_Bank->leverage_ratio = 0.0;
		current_xmachine_Bank->cash_deposit_ratio = 0.0;
		current_xmachine_Bank->equity_asset_ratio = 0.0;
		current_xmachine_Bank->mean_interest_rate = 0.0;
		current_xmachine_Bank->sum_new_interest_rates_in_calendar_month = 0.0;
		current_xmachine_Bank->no_new_loans_in_calendar_month = 0;
		current_xmachine_Bank->paid_interest_daily = 0.0;
		current_xmachine_Bank->paid_interest_in_calendar_month = 0.0;
		current_xmachine_Bank->excess_var = 0.0;
		current_xmachine_Bank->excess_liquidity = 0.0;
		current_xmachine_Bank->total_bad_debt_calendar_month = 0.0;
		init_bank_balance_sheet_adt(&current_xmachine_Bank->bank_balance_sheet_calendar);
		init_bank_stocks_adt(&current_xmachine_Bank->bank_stocks_calendar);
		init_bank_outflows_adt(&current_xmachine_Bank->bank_outflows_calendar);
		init_bank_inflows_adt(&current_xmachine_Bank->bank_inflows_calendar);
		current_xmachine_Bank->total_income = 0.0;
		current_xmachine_Bank->total_expenses = 0.0;
		current_xmachine_Bank->total_assets = 0.0;
		current_xmachine_Bank->total_liabilities = 0.0;
	
}

void unittest_free_Bank_agent()
{
	free_bank_balance_sheet_adt(&current_xmachine_Bank->bank_balance_sheet_calendar);
	free_bank_stocks_adt(&current_xmachine_Bank->bank_stocks_calendar);
	free_bank_outflows_adt(&current_xmachine_Bank->bank_outflows_calendar);
	free_bank_inflows_adt(&current_xmachine_Bank->bank_inflows_calendar);
	
	free(current_xmachine_Bank);
}

void free_Bank_agents()
{
	current_xmachine_Bank_holder = Bank_Bank_reset_state->agents;
	while(current_xmachine_Bank_holder)
	{
		temp_xmachine_Bank_holder = current_xmachine_Bank_holder->next;
		free_Bank_agent(current_xmachine_Bank_holder, Bank_Bank_reset_state);
		current_xmachine_Bank_holder = temp_xmachine_Bank_holder;
	}
	Bank_Bank_reset_state->count = 0;
	current_xmachine_Bank_holder = Bank_start_Bank_state->agents;
	while(current_xmachine_Bank_holder)
	{
		temp_xmachine_Bank_holder = current_xmachine_Bank_holder->next;
		free_Bank_agent(current_xmachine_Bank_holder, Bank_start_Bank_state);
		current_xmachine_Bank_holder = temp_xmachine_Bank_holder;
	}
	Bank_start_Bank_state->count = 0;
	current_xmachine_Bank_holder = Bank_end_Bank_state->agents;
	while(current_xmachine_Bank_holder)
	{
		temp_xmachine_Bank_holder = current_xmachine_Bank_holder->next;
		free_Bank_agent(current_xmachine_Bank_holder, Bank_end_Bank_state);
		current_xmachine_Bank_holder = temp_xmachine_Bank_holder;
	}
	Bank_end_Bank_state->count = 0;
	current_xmachine_Bank_holder = Bank_Bank_08_state->agents;
	while(current_xmachine_Bank_holder)
	{
		temp_xmachine_Bank_holder = current_xmachine_Bank_holder->next;
		free_Bank_agent(current_xmachine_Bank_holder, Bank_Bank_08_state);
		current_xmachine_Bank_holder = temp_xmachine_Bank_holder;
	}
	Bank_Bank_08_state->count = 0;
	current_xmachine_Bank_holder = Bank_Bank_07_state->agents;
	while(current_xmachine_Bank_holder)
	{
		temp_xmachine_Bank_holder = current_xmachine_Bank_holder->next;
		free_Bank_agent(current_xmachine_Bank_holder, Bank_Bank_07_state);
		current_xmachine_Bank_holder = temp_xmachine_Bank_holder;
	}
	Bank_Bank_07_state->count = 0;
	current_xmachine_Bank_holder = Bank_Bank_06_state->agents;
	while(current_xmachine_Bank_holder)
	{
		temp_xmachine_Bank_holder = current_xmachine_Bank_holder->next;
		free_Bank_agent(current_xmachine_Bank_holder, Bank_Bank_06_state);
		current_xmachine_Bank_holder = temp_xmachine_Bank_holder;
	}
	Bank_Bank_06_state->count = 0;
	current_xmachine_Bank_holder = Bank_Bank_05_state->agents;
	while(current_xmachine_Bank_holder)
	{
		temp_xmachine_Bank_holder = current_xmachine_Bank_holder->next;
		free_Bank_agent(current_xmachine_Bank_holder, Bank_Bank_05_state);
		current_xmachine_Bank_holder = temp_xmachine_Bank_holder;
	}
	Bank_Bank_05_state->count = 0;
	current_xmachine_Bank_holder = Bank_Bank_04_state->agents;
	while(current_xmachine_Bank_holder)
	{
		temp_xmachine_Bank_holder = current_xmachine_Bank_holder->next;
		free_Bank_agent(current_xmachine_Bank_holder, Bank_Bank_04_state);
		current_xmachine_Bank_holder = temp_xmachine_Bank_holder;
	}
	Bank_Bank_04_state->count = 0;
	current_xmachine_Bank_holder = Bank_Bank_03_state->agents;
	while(current_xmachine_Bank_holder)
	{
		temp_xmachine_Bank_holder = current_xmachine_Bank_holder->next;
		free_Bank_agent(current_xmachine_Bank_holder, Bank_Bank_03_state);
		current_xmachine_Bank_holder = temp_xmachine_Bank_holder;
	}
	Bank_Bank_03_state->count = 0;
	current_xmachine_Bank_holder = Bank_Bank_021_state->agents;
	while(current_xmachine_Bank_holder)
	{
		temp_xmachine_Bank_holder = current_xmachine_Bank_holder->next;
		free_Bank_agent(current_xmachine_Bank_holder, Bank_Bank_021_state);
		current_xmachine_Bank_holder = temp_xmachine_Bank_holder;
	}
	Bank_Bank_021_state->count = 0;
	current_xmachine_Bank_holder = Bank_Bank_02_state->agents;
	while(current_xmachine_Bank_holder)
	{
		temp_xmachine_Bank_holder = current_xmachine_Bank_holder->next;
		free_Bank_agent(current_xmachine_Bank_holder, Bank_Bank_02_state);
		current_xmachine_Bank_holder = temp_xmachine_Bank_holder;
	}
	Bank_Bank_02_state->count = 0;
	current_xmachine_Bank_holder = Bank_Bank_01b_state->agents;
	while(current_xmachine_Bank_holder)
	{
		temp_xmachine_Bank_holder = current_xmachine_Bank_holder->next;
		free_Bank_agent(current_xmachine_Bank_holder, Bank_Bank_01b_state);
		current_xmachine_Bank_holder = temp_xmachine_Bank_holder;
	}
	Bank_Bank_01b_state->count = 0;
	current_xmachine_Bank_holder = Bank_Bank_01_state->agents;
	while(current_xmachine_Bank_holder)
	{
		temp_xmachine_Bank_holder = current_xmachine_Bank_holder->next;
		free_Bank_agent(current_xmachine_Bank_holder, Bank_Bank_01_state);
		current_xmachine_Bank_holder = temp_xmachine_Bank_holder;
	}
	Bank_Bank_01_state->count = 0;
	current_xmachine_Bank_holder = Bank_Bank_start_credit_market_role_state->agents;
	while(current_xmachine_Bank_holder)
	{
		temp_xmachine_Bank_holder = current_xmachine_Bank_holder->next;
		free_Bank_agent(current_xmachine_Bank_holder, Bank_Bank_start_credit_market_role_state);
		current_xmachine_Bank_holder = temp_xmachine_Bank_holder;
	}
	Bank_Bank_start_credit_market_role_state->count = 0;
	current_xmachine_Bank_holder = Bank_Bank_update_policy_rate_state->agents;
	while(current_xmachine_Bank_holder)
	{
		temp_xmachine_Bank_holder = current_xmachine_Bank_holder->next;
		free_Bank_agent(current_xmachine_Bank_holder, Bank_Bank_update_policy_rate_state);
		current_xmachine_Bank_holder = temp_xmachine_Bank_holder;
	}
	Bank_Bank_update_policy_rate_state->count = 0;
}

void free_Bank_states()
{
	free(Bank_Bank_reset_state);
	free(Bank_start_Bank_state);
	free(Bank_end_Bank_state);
	free(Bank_Bank_08_state);
	free(Bank_Bank_07_state);
	free(Bank_Bank_06_state);
	free(Bank_Bank_05_state);
	free(Bank_Bank_04_state);
	free(Bank_Bank_03_state);
	free(Bank_Bank_021_state);
	free(Bank_Bank_02_state);
	free(Bank_Bank_01b_state);
	free(Bank_Bank_01_state);
	free(Bank_Bank_start_credit_market_role_state);
	free(Bank_Bank_update_policy_rate_state);
}

void transition_Bank_agent(xmachine_memory_Bank_holder * tmp, xmachine_memory_Bank_state * from_state, xmachine_memory_Bank_state * to_state)
{
	if(tmp->prev == NULL) from_state->agents = tmp->next;
	else tmp->prev->next = tmp->next;
	if(tmp->next != NULL) tmp->next->prev = tmp->prev;

	add_Bank_agent_internal(tmp->agent, to_state);
	free(tmp);
}

void add_Bank_agent_internal(xmachine_memory_Bank * agent, xmachine_memory_Bank_state * state)
{
	xmachine_memory_Bank_holder * current = (xmachine_memory_Bank_holder *)malloc(sizeof(xmachine_memory_Bank_holder));
	CHECK_POINTER(current);

	current->next = state->agents;
	current->prev = NULL;
	state->agents = current;
	if(current->next != NULL) current->next->prev = current;
	current->agent = agent;

	state->count++;

}

/** \fn void add_Bank_agent(int id, int region_id, int gov_id, int partition_id, int active, int inactive, double cash, double total_credit, double equity, double ecb_debt, double value_at_risk, double deposit_interest_rate, double bank_gamma[], double profits[], double bank_dividend_rate, double tax_rate_corporate, int current_shares_outstanding, double debt_period, int loan_request_message_found, int day_of_month_to_act, double deposits, double firm_loan_installments, double firm_loan_installments_in_calendar_month, double firm_interest_payments, double firm_interest_payments_in_calendar_month, double firm_loan_issues, double ecb_interest_payment, double total_dividend_payment, double total_dividends_in_calendar_month, double taxes, double dividend_per_share, double current_share_price, double leverage_ratio, double cash_deposit_ratio, double equity_asset_ratio, double mean_interest_rate, double sum_new_interest_rates_in_calendar_month, int no_new_loans_in_calendar_month, double paid_interest_daily, double paid_interest_in_calendar_month, double excess_var, double excess_liquidity, double total_bad_debt_calendar_month, bank_balance_sheet_adt * bank_balance_sheet_calendar, bank_stocks_adt * bank_stocks_calendar, bank_outflows_adt * bank_outflows_calendar, bank_inflows_adt * bank_inflows_calendar, double total_income, double total_expenses, double total_assets, double total_liabilities)
 * \brief Add Bank X-machine to the current being used X-machine list.
 * \param id Variable for the X-machine memory.
 * \param region_id Variable for the X-machine memory.
 * \param gov_id Variable for the X-machine memory.
 * \param partition_id Variable for the X-machine memory.
 * \param active Variable for the X-machine memory.
 * \param inactive Variable for the X-machine memory.
 * \param cash Variable for the X-machine memory.
 * \param total_credit Variable for the X-machine memory.
 * \param equity Variable for the X-machine memory.
 * \param ecb_debt Variable for the X-machine memory.
 * \param value_at_risk Variable for the X-machine memory.
 * \param deposit_interest_rate Variable for the X-machine memory.
 * \param bank_gamma Variable for the X-machine memory.
 * \param profits Variable for the X-machine memory.
 * \param bank_dividend_rate Variable for the X-machine memory.
 * \param tax_rate_corporate Variable for the X-machine memory.
 * \param current_shares_outstanding Variable for the X-machine memory.
 * \param debt_period Variable for the X-machine memory.
 * \param loan_request_message_found Variable for the X-machine memory.
 * \param day_of_month_to_act Variable for the X-machine memory.
 * \param deposits Variable for the X-machine memory.
 * \param firm_loan_installments Variable for the X-machine memory.
 * \param firm_loan_installments_in_calendar_month Variable for the X-machine memory.
 * \param firm_interest_payments Variable for the X-machine memory.
 * \param firm_interest_payments_in_calendar_month Variable for the X-machine memory.
 * \param firm_loan_issues Variable for the X-machine memory.
 * \param ecb_interest_payment Variable for the X-machine memory.
 * \param total_dividend_payment Variable for the X-machine memory.
 * \param total_dividends_in_calendar_month Variable for the X-machine memory.
 * \param taxes Variable for the X-machine memory.
 * \param dividend_per_share Variable for the X-machine memory.
 * \param current_share_price Variable for the X-machine memory.
 * \param leverage_ratio Variable for the X-machine memory.
 * \param cash_deposit_ratio Variable for the X-machine memory.
 * \param equity_asset_ratio Variable for the X-machine memory.
 * \param mean_interest_rate Variable for the X-machine memory.
 * \param sum_new_interest_rates_in_calendar_month Variable for the X-machine memory.
 * \param no_new_loans_in_calendar_month Variable for the X-machine memory.
 * \param paid_interest_daily Variable for the X-machine memory.
 * \param paid_interest_in_calendar_month Variable for the X-machine memory.
 * \param excess_var Variable for the X-machine memory.
 * \param excess_liquidity Variable for the X-machine memory.
 * \param total_bad_debt_calendar_month Variable for the X-machine memory.
 * \param bank_balance_sheet_calendar Variable for the X-machine memory.
 * \param bank_stocks_calendar Variable for the X-machine memory.
 * \param bank_outflows_calendar Variable for the X-machine memory.
 * \param bank_inflows_calendar Variable for the X-machine memory.
 * \param total_income Variable for the X-machine memory.
 * \param total_expenses Variable for the X-machine memory.
 * \param total_assets Variable for the X-machine memory.
 * \param total_liabilities Variable for the X-machine memory.
 */
void add_Bank_agent(int id, int region_id, int gov_id, int partition_id, int active, int inactive, double cash, double total_credit, double equity, double ecb_debt, double value_at_risk, double deposit_interest_rate, double bank_gamma[], double profits[], double bank_dividend_rate, double tax_rate_corporate, int current_shares_outstanding, double debt_period, int loan_request_message_found, int day_of_month_to_act, double deposits, double firm_loan_installments, double firm_loan_installments_in_calendar_month, double firm_interest_payments, double firm_interest_payments_in_calendar_month, double firm_loan_issues, double ecb_interest_payment, double total_dividend_payment, double total_dividends_in_calendar_month, double taxes, double dividend_per_share, double current_share_price, double leverage_ratio, double cash_deposit_ratio, double equity_asset_ratio, double mean_interest_rate, double sum_new_interest_rates_in_calendar_month, int no_new_loans_in_calendar_month, double paid_interest_daily, double paid_interest_in_calendar_month, double excess_var, double excess_liquidity, double total_bad_debt_calendar_month, bank_balance_sheet_adt bank_balance_sheet_calendar, bank_stocks_adt bank_stocks_calendar, bank_outflows_adt bank_outflows_calendar, bank_inflows_adt bank_inflows_calendar, double total_income, double total_expenses, double total_assets, double total_liabilities)
{
	xmachine_memory_Bank * current;

	current = init_Bank_agent();
	/* new line added to handle dynamic agent creation*/
	current_xmachine_Bank_next_state = Bank_start_Bank_state;
	add_Bank_agent_internal(current, current_xmachine_Bank_next_state);

	current->id = id;
	current->region_id = region_id;
	current->gov_id = gov_id;
	current->partition_id = partition_id;
	current->active = active;
	current->inactive = inactive;
	current->cash = cash;
	current->total_credit = total_credit;
	current->equity = equity;
	current->ecb_debt = ecb_debt;
	current->value_at_risk = value_at_risk;
	current->deposit_interest_rate = deposit_interest_rate;
	memcpy(current->bank_gamma, bank_gamma, 2*sizeof(double));
	memcpy(current->profits, profits, 2*sizeof(double));
	current->bank_dividend_rate = bank_dividend_rate;
	current->tax_rate_corporate = tax_rate_corporate;
	current->current_shares_outstanding = current_shares_outstanding;
	current->debt_period = debt_period;
	current->loan_request_message_found = loan_request_message_found;
	current->day_of_month_to_act = day_of_month_to_act;
	current->deposits = deposits;
	current->firm_loan_installments = firm_loan_installments;
	current->firm_loan_installments_in_calendar_month = firm_loan_installments_in_calendar_month;
	current->firm_interest_payments = firm_interest_payments;
	current->firm_interest_payments_in_calendar_month = firm_interest_payments_in_calendar_month;
	current->firm_loan_issues = firm_loan_issues;
	current->ecb_interest_payment = ecb_interest_payment;
	current->total_dividend_payment = total_dividend_payment;
	current->total_dividends_in_calendar_month = total_dividends_in_calendar_month;
	current->taxes = taxes;
	current->dividend_per_share = dividend_per_share;
	current->current_share_price = current_share_price;
	current->leverage_ratio = leverage_ratio;
	current->cash_deposit_ratio = cash_deposit_ratio;
	current->equity_asset_ratio = equity_asset_ratio;
	current->mean_interest_rate = mean_interest_rate;
	current->sum_new_interest_rates_in_calendar_month = sum_new_interest_rates_in_calendar_month;
	current->no_new_loans_in_calendar_month = no_new_loans_in_calendar_month;
	current->paid_interest_daily = paid_interest_daily;
	current->paid_interest_in_calendar_month = paid_interest_in_calendar_month;
	current->excess_var = excess_var;
	current->excess_liquidity = excess_liquidity;
	current->total_bad_debt_calendar_month = total_bad_debt_calendar_month;
	copy_bank_balance_sheet_adt(&bank_balance_sheet_calendar, &current->bank_balance_sheet_calendar);
	copy_bank_stocks_adt(&bank_stocks_calendar, &current->bank_stocks_calendar);
	copy_bank_outflows_adt(&bank_outflows_calendar, &current->bank_outflows_calendar);
	copy_bank_inflows_adt(&bank_inflows_calendar, &current->bank_inflows_calendar);
	current->total_income = total_income;
	current->total_expenses = total_expenses;
	current->total_assets = total_assets;
	current->total_liabilities = total_liabilities;
}

xmachine_memory_Government_state * init_Government_state()
{
	xmachine_memory_Government_state * current = (xmachine_memory_Government_state *)malloc(sizeof(xmachine_memory_Government_state));
	CHECK_POINTER(current);

	current->agents = NULL;
	current->count = 0;

	return current;
}

xmachine_memory_Government * init_Government_agent()
{
	xmachine_memory_Government * current = (xmachine_memory_Government *)malloc(sizeof(xmachine_memory_Government));
	CHECK_POINTER(current);

	current->id = 0;
	init_int_array(&current->list_of_regions);
	current->payment_account = 0.0;
	current->day_of_month_to_act = 0;
	current->region_id = 0;
	current->partition_id = 0;
	current->unemployment_benefit_pct = 0.0;
	current->gdp_fraction_consumption = 0.0;
	current->gdp_fraction_investment = 0.0;
	current->tax_rate_corporate = 0.0;
	current->tax_rate_hh_labour = 0.0;
	current->tax_rate_hh_capital = 0.0;
	current->tax_rate_vat = 0.0;
	current->monthly_tax_revenues = 0.0;
	current->yearly_tax_revenues = 0.0;
	current->debt_gdp_ratio = 0.0;
	init_adt_gov_inflows_outflows_array(&current->gov_inflows_outflows);
	current->monthly_benefit_payment = 0.0;
	current->minimum_wage_pct = 0.0;
	current->gov_monthly_consumption_budget = 0.0;
	current->yearly_benefit_payment = 0.0;
	current->hh_transfer_payment = 0.0;
	current->firm_transfer_payment = 0.0;
	current->monthly_transfer_payment = 0.0;
	current->yearly_transfer_payment = 0.0;
	current->hh_subsidy_pct = 0.0;
	current->firm_subsidy_pct = 0.0;
	current->regional_firm_subsidy = 0;
	current->subsidy_flag = 0;
	current->gov_interest_rate = 0.0;
	current->monthly_bond_interest_payment = 0.0;
	current->monthly_subsidy_payment = 0.0;
	current->monthly_subsidy_payment_to_households = 0.0;
	current->monthly_subsidy_payment_to_firms = 0.0;
	current->austerity_phase = 0;
	current->monthly_consumption_expenditure = 0.0;
	current->foreign_debt = 0.0;
	current->add_foreign_debt = 0.0;
	current->foreign_debt_installment = 0.0;
	current->monthly_investment_expenditure = 0.0;
	current->monthly_budget_balance = 0.0;
	current->monthly_gdp = 0.0;
	init_double_array(&current->last_monthly_gdps);
	current->monthly_budget_balance_gdp_fraction = 0.0;
	current->monthly_consumption_budget = 0.0;
	current->monthly_investment_budget = 0.0;
	current->monthly_income = 0.0;
	current->monthly_expenditure = 0.0;
	current->yearly_subsidy_payment = 0.0;
	current->yearly_bond_interest_payment = 0.0;
	current->yearly_investment_expenditure = 0.0;
	current->yearly_consumption_expenditure = 0.0;
	current->yearly_income = 0.0;
	current->yearly_expenditure = 0.0;
	current->subsidy_transfer_received = 0.0;
	current->total_debt = 0.0;
	current->yearly_budget_balance = 0.0;
	current->total_money_financing = 0.0;
	current->total_bond_financing = 0.0;
	current->country_wide_mean_wage = 0.0;
	current->num_unemployed = 0;
	current->yearly_gdp = 0.0;
	current->previous_year_gdp = 0.0;
	current->subsidy_reported_to_eurostat = 0.0;
	current->gdp_growth = 0.0;
	current->gdp_forecast = 0.0;
	current->yearly_income_forecast = 0.0;
	current->yearly_expenditure_budget = 0.0;
	current->budget_balance_forecast = 0.0;
	init_ordered_quantity_array(&current->ordered_quantities);
	init_received_quantities_array(&current->gov_received_quantities);
	init_double_array(&current->consumption_budgets_per_capita);
	current->av_consumption_budget_per_capita = 0.0;
	init_double_array(&current->consumption_quotas_rel_to_reg1);
	current->av_consumption_quota_rel_to_reg1 = 0.0;
	current->yearly_consumption_budget = 0.0;
	current->yearly_investment_budget = 0.0;
	current->yearly_budget_balance_gdp_fraction = 0.0;
	current->total_assets = 0.0;
	current->total_liabilities = 0.0;
	current->cumulated_deficit = 0.0;
	current->inflation_rate = 0.0;
	current->unemployment_rate = 0.0;
	current->human_capital_policy_installation_date_in_years = 0;
	current->human_capital_policy_flag = 0;
	current->basic_security_benefits_pct = 0.0;
	current->basic_security_benefits = 0.0;
	init_adt_skill_distribution_array(&current->new_skill_distribution);
	current->minimum_wage = 0.0;
	init_int_array(&current->all_region_ids);
	init_int_array(&current->all_gov_ids);
	init_gov_balance_sheet_adt(&current->gov_balance_sheet_calendar);
	init_gov_stocks_adt(&current->gov_stocks_calendar);
	init_gov_outflows_adt(&current->gov_outflows_calendar);
	init_gov_inflows_adt(&current->gov_inflows_calendar);

	return current;
}

void free_Government_agent(xmachine_memory_Government_holder * tmp, xmachine_memory_Government_state * state)
{
	if(tmp->prev == NULL) state->agents = tmp->next;
	else tmp->prev->next = tmp->next;
	if(tmp->next != NULL) tmp->next->prev = tmp->prev;

	free_int_array(&tmp->agent->list_of_regions);
	free_adt_gov_inflows_outflows_array(&tmp->agent->gov_inflows_outflows);
	free_double_array(&tmp->agent->last_monthly_gdps);
	free_ordered_quantity_array(&tmp->agent->ordered_quantities);
	free_received_quantities_array(&tmp->agent->gov_received_quantities);
	free_double_array(&tmp->agent->consumption_budgets_per_capita);
	free_double_array(&tmp->agent->consumption_quotas_rel_to_reg1);
	free_adt_skill_distribution_array(&tmp->agent->new_skill_distribution);
	free_int_array(&tmp->agent->all_region_ids);
	free_int_array(&tmp->agent->all_gov_ids);
	free_gov_balance_sheet_adt(&tmp->agent->gov_balance_sheet_calendar);
	free_gov_stocks_adt(&tmp->agent->gov_stocks_calendar);
	free_gov_outflows_adt(&tmp->agent->gov_outflows_calendar);
	free_gov_inflows_adt(&tmp->agent->gov_inflows_calendar);
	

	free(tmp->agent);
	free(tmp);
}

void unittest_init_Government_agent()
{
	current_xmachine_Government = (xmachine_memory_Government *)malloc(sizeof(xmachine_memory_Government));
	CHECK_POINTER(current);

		current_xmachine_Government->id = 0;
		init_int_array(&current_xmachine_Government->list_of_regions);
		current_xmachine_Government->payment_account = 0.0;
		current_xmachine_Government->day_of_month_to_act = 0;
		current_xmachine_Government->region_id = 0;
		current_xmachine_Government->partition_id = 0;
		current_xmachine_Government->unemployment_benefit_pct = 0.0;
		current_xmachine_Government->gdp_fraction_consumption = 0.0;
		current_xmachine_Government->gdp_fraction_investment = 0.0;
		current_xmachine_Government->tax_rate_corporate = 0.0;
		current_xmachine_Government->tax_rate_hh_labour = 0.0;
		current_xmachine_Government->tax_rate_hh_capital = 0.0;
		current_xmachine_Government->tax_rate_vat = 0.0;
		current_xmachine_Government->monthly_tax_revenues = 0.0;
		current_xmachine_Government->yearly_tax_revenues = 0.0;
		current_xmachine_Government->debt_gdp_ratio = 0.0;
		init_adt_gov_inflows_outflows_array(&current_xmachine_Government->gov_inflows_outflows);
		current_xmachine_Government->monthly_benefit_payment = 0.0;
		current_xmachine_Government->minimum_wage_pct = 0.0;
		current_xmachine_Government->gov_monthly_consumption_budget = 0.0;
		current_xmachine_Government->yearly_benefit_payment = 0.0;
		current_xmachine_Government->hh_transfer_payment = 0.0;
		current_xmachine_Government->firm_transfer_payment = 0.0;
		current_xmachine_Government->monthly_transfer_payment = 0.0;
		current_xmachine_Government->yearly_transfer_payment = 0.0;
		current_xmachine_Government->hh_subsidy_pct = 0.0;
		current_xmachine_Government->firm_subsidy_pct = 0.0;
		current_xmachine_Government->regional_firm_subsidy = 0;
		current_xmachine_Government->subsidy_flag = 0;
		current_xmachine_Government->gov_interest_rate = 0.0;
		current_xmachine_Government->monthly_bond_interest_payment = 0.0;
		current_xmachine_Government->monthly_subsidy_payment = 0.0;
		current_xmachine_Government->monthly_subsidy_payment_to_households = 0.0;
		current_xmachine_Government->monthly_subsidy_payment_to_firms = 0.0;
		current_xmachine_Government->austerity_phase = 0;
		current_xmachine_Government->monthly_consumption_expenditure = 0.0;
		current_xmachine_Government->foreign_debt = 0.0;
		current_xmachine_Government->add_foreign_debt = 0.0;
		current_xmachine_Government->foreign_debt_installment = 0.0;
		current_xmachine_Government->monthly_investment_expenditure = 0.0;
		current_xmachine_Government->monthly_budget_balance = 0.0;
		current_xmachine_Government->monthly_gdp = 0.0;
		init_double_array(&current_xmachine_Government->last_monthly_gdps);
		current_xmachine_Government->monthly_budget_balance_gdp_fraction = 0.0;
		current_xmachine_Government->monthly_consumption_budget = 0.0;
		current_xmachine_Government->monthly_investment_budget = 0.0;
		current_xmachine_Government->monthly_income = 0.0;
		current_xmachine_Government->monthly_expenditure = 0.0;
		current_xmachine_Government->yearly_subsidy_payment = 0.0;
		current_xmachine_Government->yearly_bond_interest_payment = 0.0;
		current_xmachine_Government->yearly_investment_expenditure = 0.0;
		current_xmachine_Government->yearly_consumption_expenditure = 0.0;
		current_xmachine_Government->yearly_income = 0.0;
		current_xmachine_Government->yearly_expenditure = 0.0;
		current_xmachine_Government->subsidy_transfer_received = 0.0;
		current_xmachine_Government->total_debt = 0.0;
		current_xmachine_Government->yearly_budget_balance = 0.0;
		current_xmachine_Government->total_money_financing = 0.0;
		current_xmachine_Government->total_bond_financing = 0.0;
		current_xmachine_Government->country_wide_mean_wage = 0.0;
		current_xmachine_Government->num_unemployed = 0;
		current_xmachine_Government->yearly_gdp = 0.0;
		current_xmachine_Government->previous_year_gdp = 0.0;
		current_xmachine_Government->subsidy_reported_to_eurostat = 0.0;
		current_xmachine_Government->gdp_growth = 0.0;
		current_xmachine_Government->gdp_forecast = 0.0;
		current_xmachine_Government->yearly_income_forecast = 0.0;
		current_xmachine_Government->yearly_expenditure_budget = 0.0;
		current_xmachine_Government->budget_balance_forecast = 0.0;
		init_ordered_quantity_array(&current_xmachine_Government->ordered_quantities);
		init_received_quantities_array(&current_xmachine_Government->gov_received_quantities);
		init_double_array(&current_xmachine_Government->consumption_budgets_per_capita);
		current_xmachine_Government->av_consumption_budget_per_capita = 0.0;
		init_double_array(&current_xmachine_Government->consumption_quotas_rel_to_reg1);
		current_xmachine_Government->av_consumption_quota_rel_to_reg1 = 0.0;
		current_xmachine_Government->yearly_consumption_budget = 0.0;
		current_xmachine_Government->yearly_investment_budget = 0.0;
		current_xmachine_Government->yearly_budget_balance_gdp_fraction = 0.0;
		current_xmachine_Government->total_assets = 0.0;
		current_xmachine_Government->total_liabilities = 0.0;
		current_xmachine_Government->cumulated_deficit = 0.0;
		current_xmachine_Government->inflation_rate = 0.0;
		current_xmachine_Government->unemployment_rate = 0.0;
		current_xmachine_Government->human_capital_policy_installation_date_in_years = 0;
		current_xmachine_Government->human_capital_policy_flag = 0;
		current_xmachine_Government->basic_security_benefits_pct = 0.0;
		current_xmachine_Government->basic_security_benefits = 0.0;
		init_adt_skill_distribution_array(&current_xmachine_Government->new_skill_distribution);
		current_xmachine_Government->minimum_wage = 0.0;
		init_int_array(&current_xmachine_Government->all_region_ids);
		init_int_array(&current_xmachine_Government->all_gov_ids);
		init_gov_balance_sheet_adt(&current_xmachine_Government->gov_balance_sheet_calendar);
		init_gov_stocks_adt(&current_xmachine_Government->gov_stocks_calendar);
		init_gov_outflows_adt(&current_xmachine_Government->gov_outflows_calendar);
		init_gov_inflows_adt(&current_xmachine_Government->gov_inflows_calendar);
	
}

void unittest_free_Government_agent()
{
	free_int_array(&current_xmachine_Government->list_of_regions);
	free_adt_gov_inflows_outflows_array(&current_xmachine_Government->gov_inflows_outflows);
	free_double_array(&current_xmachine_Government->last_monthly_gdps);
	free_ordered_quantity_array(&current_xmachine_Government->ordered_quantities);
	free_received_quantities_array(&current_xmachine_Government->gov_received_quantities);
	free_double_array(&current_xmachine_Government->consumption_budgets_per_capita);
	free_double_array(&current_xmachine_Government->consumption_quotas_rel_to_reg1);
	free_adt_skill_distribution_array(&current_xmachine_Government->new_skill_distribution);
	free_int_array(&current_xmachine_Government->all_region_ids);
	free_int_array(&current_xmachine_Government->all_gov_ids);
	free_gov_balance_sheet_adt(&current_xmachine_Government->gov_balance_sheet_calendar);
	free_gov_stocks_adt(&current_xmachine_Government->gov_stocks_calendar);
	free_gov_outflows_adt(&current_xmachine_Government->gov_outflows_calendar);
	free_gov_inflows_adt(&current_xmachine_Government->gov_inflows_calendar);
	
	free(current_xmachine_Government);
}

void free_Government_agents()
{
	current_xmachine_Government_holder = Government_end_Government_state->agents;
	while(current_xmachine_Government_holder)
	{
		temp_xmachine_Government_holder = current_xmachine_Government_holder->next;
		free_Government_agent(current_xmachine_Government_holder, Government_end_Government_state);
		current_xmachine_Government_holder = temp_xmachine_Government_holder;
	}
	Government_end_Government_state->count = 0;
	current_xmachine_Government_holder = Government_Gov_Start_Yearly_Loop_state->agents;
	while(current_xmachine_Government_holder)
	{
		temp_xmachine_Government_holder = current_xmachine_Government_holder->next;
		free_Government_agent(current_xmachine_Government_holder, Government_Gov_Start_Yearly_Loop_state);
		current_xmachine_Government_holder = temp_xmachine_Government_holder;
	}
	Government_Gov_Start_Yearly_Loop_state->count = 0;
	current_xmachine_Government_holder = Government_08_state->agents;
	while(current_xmachine_Government_holder)
	{
		temp_xmachine_Government_holder = current_xmachine_Government_holder->next;
		free_Government_agent(current_xmachine_Government_holder, Government_08_state);
		current_xmachine_Government_holder = temp_xmachine_Government_holder;
	}
	Government_08_state->count = 0;
	current_xmachine_Government_holder = Government_07_state->agents;
	while(current_xmachine_Government_holder)
	{
		temp_xmachine_Government_holder = current_xmachine_Government_holder->next;
		free_Government_agent(current_xmachine_Government_holder, Government_07_state);
		current_xmachine_Government_holder = temp_xmachine_Government_holder;
	}
	Government_07_state->count = 0;
	current_xmachine_Government_holder = Government_Gov_bonds_decision_state->agents;
	while(current_xmachine_Government_holder)
	{
		temp_xmachine_Government_holder = current_xmachine_Government_holder->next;
		free_Government_agent(current_xmachine_Government_holder, Government_Gov_bonds_decision_state);
		current_xmachine_Government_holder = temp_xmachine_Government_holder;
	}
	Government_Gov_bonds_decision_state->count = 0;
	current_xmachine_Government_holder = Government_05a_state->agents;
	while(current_xmachine_Government_holder)
	{
		temp_xmachine_Government_holder = current_xmachine_Government_holder->next;
		free_Government_agent(current_xmachine_Government_holder, Government_05a_state);
		current_xmachine_Government_holder = temp_xmachine_Government_holder;
	}
	Government_05a_state->count = 0;
	current_xmachine_Government_holder = Government_06_state->agents;
	while(current_xmachine_Government_holder)
	{
		temp_xmachine_Government_holder = current_xmachine_Government_holder->next;
		free_Government_agent(current_xmachine_Government_holder, Government_06_state);
		current_xmachine_Government_holder = temp_xmachine_Government_holder;
	}
	Government_06_state->count = 0;
	current_xmachine_Government_holder = Government_Gov_Start_Monthly_Loop_state->agents;
	while(current_xmachine_Government_holder)
	{
		temp_xmachine_Government_holder = current_xmachine_Government_holder->next;
		free_Government_agent(current_xmachine_Government_holder, Government_Gov_Start_Monthly_Loop_state);
		current_xmachine_Government_holder = temp_xmachine_Government_holder;
	}
	Government_Gov_Start_Monthly_Loop_state->count = 0;
	current_xmachine_Government_holder = Government_04_state->agents;
	while(current_xmachine_Government_holder)
	{
		temp_xmachine_Government_holder = current_xmachine_Government_holder->next;
		free_Government_agent(current_xmachine_Government_holder, Government_04_state);
		current_xmachine_Government_holder = temp_xmachine_Government_holder;
	}
	Government_04_state->count = 0;
	current_xmachine_Government_holder = Government_03_state->agents;
	while(current_xmachine_Government_holder)
	{
		temp_xmachine_Government_holder = current_xmachine_Government_holder->next;
		free_Government_agent(current_xmachine_Government_holder, Government_03_state);
		current_xmachine_Government_holder = temp_xmachine_Government_holder;
	}
	Government_03_state->count = 0;
	current_xmachine_Government_holder = Government_02_state->agents;
	while(current_xmachine_Government_holder)
	{
		temp_xmachine_Government_holder = current_xmachine_Government_holder->next;
		free_Government_agent(current_xmachine_Government_holder, Government_02_state);
		current_xmachine_Government_holder = temp_xmachine_Government_holder;
	}
	Government_02_state->count = 0;
	current_xmachine_Government_holder = Government_End_Gov_Consumer_Role_state->agents;
	while(current_xmachine_Government_holder)
	{
		temp_xmachine_Government_holder = current_xmachine_Government_holder->next;
		free_Government_agent(current_xmachine_Government_holder, Government_End_Gov_Consumer_Role_state);
		current_xmachine_Government_holder = temp_xmachine_Government_holder;
	}
	Government_End_Gov_Consumer_Role_state->count = 0;
	current_xmachine_Government_holder = Government_Gov_Cons_5_state->agents;
	while(current_xmachine_Government_holder)
	{
		temp_xmachine_Government_holder = current_xmachine_Government_holder->next;
		free_Government_agent(current_xmachine_Government_holder, Government_Gov_Cons_5_state);
		current_xmachine_Government_holder = temp_xmachine_Government_holder;
	}
	Government_Gov_Cons_5_state->count = 0;
	current_xmachine_Government_holder = Government_Gov_Cons_4_state->agents;
	while(current_xmachine_Government_holder)
	{
		temp_xmachine_Government_holder = current_xmachine_Government_holder->next;
		free_Government_agent(current_xmachine_Government_holder, Government_Gov_Cons_4_state);
		current_xmachine_Government_holder = temp_xmachine_Government_holder;
	}
	Government_Gov_Cons_4_state->count = 0;
	current_xmachine_Government_holder = Government_Gov_Cons_3_state->agents;
	while(current_xmachine_Government_holder)
	{
		temp_xmachine_Government_holder = current_xmachine_Government_holder->next;
		free_Government_agent(current_xmachine_Government_holder, Government_Gov_Cons_3_state);
		current_xmachine_Government_holder = temp_xmachine_Government_holder;
	}
	Government_Gov_Cons_3_state->count = 0;
	current_xmachine_Government_holder = Government_Gov_Cons_2_state->agents;
	while(current_xmachine_Government_holder)
	{
		temp_xmachine_Government_holder = current_xmachine_Government_holder->next;
		free_Government_agent(current_xmachine_Government_holder, Government_Gov_Cons_2_state);
		current_xmachine_Government_holder = temp_xmachine_Government_holder;
	}
	Government_Gov_Cons_2_state->count = 0;
	current_xmachine_Government_holder = Government_Gov_Cons_1_state->agents;
	while(current_xmachine_Government_holder)
	{
		temp_xmachine_Government_holder = current_xmachine_Government_holder->next;
		free_Government_agent(current_xmachine_Government_holder, Government_Gov_Cons_1_state);
		current_xmachine_Government_holder = temp_xmachine_Government_holder;
	}
	Government_Gov_Cons_1_state->count = 0;
	current_xmachine_Government_holder = Government_003b_state->agents;
	while(current_xmachine_Government_holder)
	{
		temp_xmachine_Government_holder = current_xmachine_Government_holder->next;
		free_Government_agent(current_xmachine_Government_holder, Government_003b_state);
		current_xmachine_Government_holder = temp_xmachine_Government_holder;
	}
	Government_003b_state->count = 0;
	current_xmachine_Government_holder = Government_003a_state->agents;
	while(current_xmachine_Government_holder)
	{
		temp_xmachine_Government_holder = current_xmachine_Government_holder->next;
		free_Government_agent(current_xmachine_Government_holder, Government_003a_state);
		current_xmachine_Government_holder = temp_xmachine_Government_holder;
	}
	Government_003a_state->count = 0;
	current_xmachine_Government_holder = Government_003_state->agents;
	while(current_xmachine_Government_holder)
	{
		temp_xmachine_Government_holder = current_xmachine_Government_holder->next;
		free_Government_agent(current_xmachine_Government_holder, Government_003_state);
		current_xmachine_Government_holder = temp_xmachine_Government_holder;
	}
	Government_003_state->count = 0;
	current_xmachine_Government_holder = Government_002_state->agents;
	while(current_xmachine_Government_holder)
	{
		temp_xmachine_Government_holder = current_xmachine_Government_holder->next;
		free_Government_agent(current_xmachine_Government_holder, Government_002_state);
		current_xmachine_Government_holder = temp_xmachine_Government_holder;
	}
	Government_002_state->count = 0;
	current_xmachine_Government_holder = Government_Government_Start_Yearly_Loop_Top_state->agents;
	while(current_xmachine_Government_holder)
	{
		temp_xmachine_Government_holder = current_xmachine_Government_holder->next;
		free_Government_agent(current_xmachine_Government_holder, Government_Government_Start_Yearly_Loop_Top_state);
		current_xmachine_Government_holder = temp_xmachine_Government_holder;
	}
	Government_Government_Start_Yearly_Loop_Top_state->count = 0;
	current_xmachine_Government_holder = Government_001_state->agents;
	while(current_xmachine_Government_holder)
	{
		temp_xmachine_Government_holder = current_xmachine_Government_holder->next;
		free_Government_agent(current_xmachine_Government_holder, Government_001_state);
		current_xmachine_Government_holder = temp_xmachine_Government_holder;
	}
	Government_001_state->count = 0;
	current_xmachine_Government_holder = Government_Government_Start_Monthly_Loop_Top_state->agents;
	while(current_xmachine_Government_holder)
	{
		temp_xmachine_Government_holder = current_xmachine_Government_holder->next;
		free_Government_agent(current_xmachine_Government_holder, Government_Government_Start_Monthly_Loop_Top_state);
		current_xmachine_Government_holder = temp_xmachine_Government_holder;
	}
	Government_Government_Start_Monthly_Loop_Top_state->count = 0;
	current_xmachine_Government_holder = Government_start_Government_state->agents;
	while(current_xmachine_Government_holder)
	{
		temp_xmachine_Government_holder = current_xmachine_Government_holder->next;
		free_Government_agent(current_xmachine_Government_holder, Government_start_Government_state);
		current_xmachine_Government_holder = temp_xmachine_Government_holder;
	}
	Government_start_Government_state->count = 0;
	current_xmachine_Government_holder = Government_Start_Gov_Consumer_Role_state->agents;
	while(current_xmachine_Government_holder)
	{
		temp_xmachine_Government_holder = current_xmachine_Government_holder->next;
		free_Government_agent(current_xmachine_Government_holder, Government_Start_Gov_Consumer_Role_state);
		current_xmachine_Government_holder = temp_xmachine_Government_holder;
	}
	Government_Start_Gov_Consumer_Role_state->count = 0;
	current_xmachine_Government_holder = Government_Gov_Start_Bond_Market_state->agents;
	while(current_xmachine_Government_holder)
	{
		temp_xmachine_Government_holder = current_xmachine_Government_holder->next;
		free_Government_agent(current_xmachine_Government_holder, Government_Gov_Start_Bond_Market_state);
		current_xmachine_Government_holder = temp_xmachine_Government_holder;
	}
	Government_Gov_Start_Bond_Market_state->count = 0;
}

void free_Government_states()
{
	free(Government_end_Government_state);
	free(Government_Gov_Start_Yearly_Loop_state);
	free(Government_08_state);
	free(Government_07_state);
	free(Government_Gov_bonds_decision_state);
	free(Government_05a_state);
	free(Government_06_state);
	free(Government_Gov_Start_Monthly_Loop_state);
	free(Government_04_state);
	free(Government_03_state);
	free(Government_02_state);
	free(Government_End_Gov_Consumer_Role_state);
	free(Government_Gov_Cons_5_state);
	free(Government_Gov_Cons_4_state);
	free(Government_Gov_Cons_3_state);
	free(Government_Gov_Cons_2_state);
	free(Government_Gov_Cons_1_state);
	free(Government_003b_state);
	free(Government_003a_state);
	free(Government_003_state);
	free(Government_002_state);
	free(Government_Government_Start_Yearly_Loop_Top_state);
	free(Government_001_state);
	free(Government_Government_Start_Monthly_Loop_Top_state);
	free(Government_start_Government_state);
	free(Government_Start_Gov_Consumer_Role_state);
	free(Government_Gov_Start_Bond_Market_state);
}

void transition_Government_agent(xmachine_memory_Government_holder * tmp, xmachine_memory_Government_state * from_state, xmachine_memory_Government_state * to_state)
{
	if(tmp->prev == NULL) from_state->agents = tmp->next;
	else tmp->prev->next = tmp->next;
	if(tmp->next != NULL) tmp->next->prev = tmp->prev;

	add_Government_agent_internal(tmp->agent, to_state);
	free(tmp);
}

void add_Government_agent_internal(xmachine_memory_Government * agent, xmachine_memory_Government_state * state)
{
	xmachine_memory_Government_holder * current = (xmachine_memory_Government_holder *)malloc(sizeof(xmachine_memory_Government_holder));
	CHECK_POINTER(current);

	current->next = state->agents;
	current->prev = NULL;
	state->agents = current;
	if(current->next != NULL) current->next->prev = current;
	current->agent = agent;

	state->count++;

}

/** \fn void add_Government_agent(int id, int_array * list_of_regions, double payment_account, int day_of_month_to_act, int region_id, int partition_id, double unemployment_benefit_pct, double gdp_fraction_consumption, double gdp_fraction_investment, double tax_rate_corporate, double tax_rate_hh_labour, double tax_rate_hh_capital, double tax_rate_vat, double monthly_tax_revenues, double yearly_tax_revenues, double debt_gdp_ratio, adt_gov_inflows_outflows_array * gov_inflows_outflows, double monthly_benefit_payment, double minimum_wage_pct, double gov_monthly_consumption_budget, double yearly_benefit_payment, double hh_transfer_payment, double firm_transfer_payment, double monthly_transfer_payment, double yearly_transfer_payment, double hh_subsidy_pct, double firm_subsidy_pct, int regional_firm_subsidy, int subsidy_flag, double gov_interest_rate, double monthly_bond_interest_payment, double monthly_subsidy_payment, double monthly_subsidy_payment_to_households, double monthly_subsidy_payment_to_firms, int austerity_phase, double monthly_consumption_expenditure, double foreign_debt, double add_foreign_debt, double foreign_debt_installment, double monthly_investment_expenditure, double monthly_budget_balance, double monthly_gdp, double_array * last_monthly_gdps, double monthly_budget_balance_gdp_fraction, double monthly_consumption_budget, double monthly_investment_budget, double monthly_income, double monthly_expenditure, double yearly_subsidy_payment, double yearly_bond_interest_payment, double yearly_investment_expenditure, double yearly_consumption_expenditure, double yearly_income, double yearly_expenditure, double subsidy_transfer_received, double total_debt, double yearly_budget_balance, double total_money_financing, double total_bond_financing, double country_wide_mean_wage, int num_unemployed, double yearly_gdp, double previous_year_gdp, double subsidy_reported_to_eurostat, double gdp_growth, double gdp_forecast, double yearly_income_forecast, double yearly_expenditure_budget, double budget_balance_forecast, ordered_quantity_array * ordered_quantities, received_quantities_array * gov_received_quantities, double_array * consumption_budgets_per_capita, double av_consumption_budget_per_capita, double_array * consumption_quotas_rel_to_reg1, double av_consumption_quota_rel_to_reg1, double yearly_consumption_budget, double yearly_investment_budget, double yearly_budget_balance_gdp_fraction, double total_assets, double total_liabilities, double cumulated_deficit, double inflation_rate, double unemployment_rate, int human_capital_policy_installation_date_in_years, int human_capital_policy_flag, double basic_security_benefits_pct, double basic_security_benefits, adt_skill_distribution_array * new_skill_distribution, double minimum_wage, int_array * all_region_ids, int_array * all_gov_ids, gov_balance_sheet_adt * gov_balance_sheet_calendar, gov_stocks_adt * gov_stocks_calendar, gov_outflows_adt * gov_outflows_calendar, gov_inflows_adt * gov_inflows_calendar)
 * \brief Add Government X-machine to the current being used X-machine list.
 * \param id Variable for the X-machine memory.
 * \param list_of_regions Variable for the X-machine memory.
 * \param payment_account Variable for the X-machine memory.
 * \param day_of_month_to_act Variable for the X-machine memory.
 * \param region_id Variable for the X-machine memory.
 * \param partition_id Variable for the X-machine memory.
 * \param unemployment_benefit_pct Variable for the X-machine memory.
 * \param gdp_fraction_consumption Variable for the X-machine memory.
 * \param gdp_fraction_investment Variable for the X-machine memory.
 * \param tax_rate_corporate Variable for the X-machine memory.
 * \param tax_rate_hh_labour Variable for the X-machine memory.
 * \param tax_rate_hh_capital Variable for the X-machine memory.
 * \param tax_rate_vat Variable for the X-machine memory.
 * \param monthly_tax_revenues Variable for the X-machine memory.
 * \param yearly_tax_revenues Variable for the X-machine memory.
 * \param debt_gdp_ratio Variable for the X-machine memory.
 * \param gov_inflows_outflows Variable for the X-machine memory.
 * \param monthly_benefit_payment Variable for the X-machine memory.
 * \param minimum_wage_pct Variable for the X-machine memory.
 * \param gov_monthly_consumption_budget Variable for the X-machine memory.
 * \param yearly_benefit_payment Variable for the X-machine memory.
 * \param hh_transfer_payment Variable for the X-machine memory.
 * \param firm_transfer_payment Variable for the X-machine memory.
 * \param monthly_transfer_payment Variable for the X-machine memory.
 * \param yearly_transfer_payment Variable for the X-machine memory.
 * \param hh_subsidy_pct Variable for the X-machine memory.
 * \param firm_subsidy_pct Variable for the X-machine memory.
 * \param regional_firm_subsidy Variable for the X-machine memory.
 * \param subsidy_flag Variable for the X-machine memory.
 * \param gov_interest_rate Variable for the X-machine memory.
 * \param monthly_bond_interest_payment Variable for the X-machine memory.
 * \param monthly_subsidy_payment Variable for the X-machine memory.
 * \param monthly_subsidy_payment_to_households Variable for the X-machine memory.
 * \param monthly_subsidy_payment_to_firms Variable for the X-machine memory.
 * \param austerity_phase Variable for the X-machine memory.
 * \param monthly_consumption_expenditure Variable for the X-machine memory.
 * \param foreign_debt Variable for the X-machine memory.
 * \param add_foreign_debt Variable for the X-machine memory.
 * \param foreign_debt_installment Variable for the X-machine memory.
 * \param monthly_investment_expenditure Variable for the X-machine memory.
 * \param monthly_budget_balance Variable for the X-machine memory.
 * \param monthly_gdp Variable for the X-machine memory.
 * \param last_monthly_gdps Variable for the X-machine memory.
 * \param monthly_budget_balance_gdp_fraction Variable for the X-machine memory.
 * \param monthly_consumption_budget Variable for the X-machine memory.
 * \param monthly_investment_budget Variable for the X-machine memory.
 * \param monthly_income Variable for the X-machine memory.
 * \param monthly_expenditure Variable for the X-machine memory.
 * \param yearly_subsidy_payment Variable for the X-machine memory.
 * \param yearly_bond_interest_payment Variable for the X-machine memory.
 * \param yearly_investment_expenditure Variable for the X-machine memory.
 * \param yearly_consumption_expenditure Variable for the X-machine memory.
 * \param yearly_income Variable for the X-machine memory.
 * \param yearly_expenditure Variable for the X-machine memory.
 * \param subsidy_transfer_received Variable for the X-machine memory.
 * \param total_debt Variable for the X-machine memory.
 * \param yearly_budget_balance Variable for the X-machine memory.
 * \param total_money_financing Variable for the X-machine memory.
 * \param total_bond_financing Variable for the X-machine memory.
 * \param country_wide_mean_wage Variable for the X-machine memory.
 * \param num_unemployed Variable for the X-machine memory.
 * \param yearly_gdp Variable for the X-machine memory.
 * \param previous_year_gdp Variable for the X-machine memory.
 * \param subsidy_reported_to_eurostat Variable for the X-machine memory.
 * \param gdp_growth Variable for the X-machine memory.
 * \param gdp_forecast Variable for the X-machine memory.
 * \param yearly_income_forecast Variable for the X-machine memory.
 * \param yearly_expenditure_budget Variable for the X-machine memory.
 * \param budget_balance_forecast Variable for the X-machine memory.
 * \param ordered_quantities Variable for the X-machine memory.
 * \param gov_received_quantities Variable for the X-machine memory.
 * \param consumption_budgets_per_capita Variable for the X-machine memory.
 * \param av_consumption_budget_per_capita Variable for the X-machine memory.
 * \param consumption_quotas_rel_to_reg1 Variable for the X-machine memory.
 * \param av_consumption_quota_rel_to_reg1 Variable for the X-machine memory.
 * \param yearly_consumption_budget Variable for the X-machine memory.
 * \param yearly_investment_budget Variable for the X-machine memory.
 * \param yearly_budget_balance_gdp_fraction Variable for the X-machine memory.
 * \param total_assets Variable for the X-machine memory.
 * \param total_liabilities Variable for the X-machine memory.
 * \param cumulated_deficit Variable for the X-machine memory.
 * \param inflation_rate Variable for the X-machine memory.
 * \param unemployment_rate Variable for the X-machine memory.
 * \param human_capital_policy_installation_date_in_years Variable for the X-machine memory.
 * \param human_capital_policy_flag Variable for the X-machine memory.
 * \param basic_security_benefits_pct Variable for the X-machine memory.
 * \param basic_security_benefits Variable for the X-machine memory.
 * \param new_skill_distribution Variable for the X-machine memory.
 * \param minimum_wage Variable for the X-machine memory.
 * \param all_region_ids Variable for the X-machine memory.
 * \param all_gov_ids Variable for the X-machine memory.
 * \param gov_balance_sheet_calendar Variable for the X-machine memory.
 * \param gov_stocks_calendar Variable for the X-machine memory.
 * \param gov_outflows_calendar Variable for the X-machine memory.
 * \param gov_inflows_calendar Variable for the X-machine memory.
 */
void add_Government_agent(int id, int_array * list_of_regions, double payment_account, int day_of_month_to_act, int region_id, int partition_id, double unemployment_benefit_pct, double gdp_fraction_consumption, double gdp_fraction_investment, double tax_rate_corporate, double tax_rate_hh_labour, double tax_rate_hh_capital, double tax_rate_vat, double monthly_tax_revenues, double yearly_tax_revenues, double debt_gdp_ratio, adt_gov_inflows_outflows_array * gov_inflows_outflows, double monthly_benefit_payment, double minimum_wage_pct, double gov_monthly_consumption_budget, double yearly_benefit_payment, double hh_transfer_payment, double firm_transfer_payment, double monthly_transfer_payment, double yearly_transfer_payment, double hh_subsidy_pct, double firm_subsidy_pct, int regional_firm_subsidy, int subsidy_flag, double gov_interest_rate, double monthly_bond_interest_payment, double monthly_subsidy_payment, double monthly_subsidy_payment_to_households, double monthly_subsidy_payment_to_firms, int austerity_phase, double monthly_consumption_expenditure, double foreign_debt, double add_foreign_debt, double foreign_debt_installment, double monthly_investment_expenditure, double monthly_budget_balance, double monthly_gdp, double_array * last_monthly_gdps, double monthly_budget_balance_gdp_fraction, double monthly_consumption_budget, double monthly_investment_budget, double monthly_income, double monthly_expenditure, double yearly_subsidy_payment, double yearly_bond_interest_payment, double yearly_investment_expenditure, double yearly_consumption_expenditure, double yearly_income, double yearly_expenditure, double subsidy_transfer_received, double total_debt, double yearly_budget_balance, double total_money_financing, double total_bond_financing, double country_wide_mean_wage, int num_unemployed, double yearly_gdp, double previous_year_gdp, double subsidy_reported_to_eurostat, double gdp_growth, double gdp_forecast, double yearly_income_forecast, double yearly_expenditure_budget, double budget_balance_forecast, ordered_quantity_array * ordered_quantities, received_quantities_array * gov_received_quantities, double_array * consumption_budgets_per_capita, double av_consumption_budget_per_capita, double_array * consumption_quotas_rel_to_reg1, double av_consumption_quota_rel_to_reg1, double yearly_consumption_budget, double yearly_investment_budget, double yearly_budget_balance_gdp_fraction, double total_assets, double total_liabilities, double cumulated_deficit, double inflation_rate, double unemployment_rate, int human_capital_policy_installation_date_in_years, int human_capital_policy_flag, double basic_security_benefits_pct, double basic_security_benefits, adt_skill_distribution_array * new_skill_distribution, double minimum_wage, int_array * all_region_ids, int_array * all_gov_ids, gov_balance_sheet_adt gov_balance_sheet_calendar, gov_stocks_adt gov_stocks_calendar, gov_outflows_adt gov_outflows_calendar, gov_inflows_adt gov_inflows_calendar)
{
	xmachine_memory_Government * current;

	current = init_Government_agent();
	/* new line added to handle dynamic agent creation*/
	current_xmachine_Government_next_state = Government_start_Government_state;
	add_Government_agent_internal(current, current_xmachine_Government_next_state);

	current->id = id;
	copy_int_array(list_of_regions, &current->list_of_regions);
	current->payment_account = payment_account;
	current->day_of_month_to_act = day_of_month_to_act;
	current->region_id = region_id;
	current->partition_id = partition_id;
	current->unemployment_benefit_pct = unemployment_benefit_pct;
	current->gdp_fraction_consumption = gdp_fraction_consumption;
	current->gdp_fraction_investment = gdp_fraction_investment;
	current->tax_rate_corporate = tax_rate_corporate;
	current->tax_rate_hh_labour = tax_rate_hh_labour;
	current->tax_rate_hh_capital = tax_rate_hh_capital;
	current->tax_rate_vat = tax_rate_vat;
	current->monthly_tax_revenues = monthly_tax_revenues;
	current->yearly_tax_revenues = yearly_tax_revenues;
	current->debt_gdp_ratio = debt_gdp_ratio;
	copy_adt_gov_inflows_outflows_array(gov_inflows_outflows, &current->gov_inflows_outflows);
	current->monthly_benefit_payment = monthly_benefit_payment;
	current->minimum_wage_pct = minimum_wage_pct;
	current->gov_monthly_consumption_budget = gov_monthly_consumption_budget;
	current->yearly_benefit_payment = yearly_benefit_payment;
	current->hh_transfer_payment = hh_transfer_payment;
	current->firm_transfer_payment = firm_transfer_payment;
	current->monthly_transfer_payment = monthly_transfer_payment;
	current->yearly_transfer_payment = yearly_transfer_payment;
	current->hh_subsidy_pct = hh_subsidy_pct;
	current->firm_subsidy_pct = firm_subsidy_pct;
	current->regional_firm_subsidy = regional_firm_subsidy;
	current->subsidy_flag = subsidy_flag;
	current->gov_interest_rate = gov_interest_rate;
	current->monthly_bond_interest_payment = monthly_bond_interest_payment;
	current->monthly_subsidy_payment = monthly_subsidy_payment;
	current->monthly_subsidy_payment_to_households = monthly_subsidy_payment_to_households;
	current->monthly_subsidy_payment_to_firms = monthly_subsidy_payment_to_firms;
	current->austerity_phase = austerity_phase;
	current->monthly_consumption_expenditure = monthly_consumption_expenditure;
	current->foreign_debt = foreign_debt;
	current->add_foreign_debt = add_foreign_debt;
	current->foreign_debt_installment = foreign_debt_installment;
	current->monthly_investment_expenditure = monthly_investment_expenditure;
	current->monthly_budget_balance = monthly_budget_balance;
	current->monthly_gdp = monthly_gdp;
	copy_double_array(last_monthly_gdps, &current->last_monthly_gdps);
	current->monthly_budget_balance_gdp_fraction = monthly_budget_balance_gdp_fraction;
	current->monthly_consumption_budget = monthly_consumption_budget;
	current->monthly_investment_budget = monthly_investment_budget;
	current->monthly_income = monthly_income;
	current->monthly_expenditure = monthly_expenditure;
	current->yearly_subsidy_payment = yearly_subsidy_payment;
	current->yearly_bond_interest_payment = yearly_bond_interest_payment;
	current->yearly_investment_expenditure = yearly_investment_expenditure;
	current->yearly_consumption_expenditure = yearly_consumption_expenditure;
	current->yearly_income = yearly_income;
	current->yearly_expenditure = yearly_expenditure;
	current->subsidy_transfer_received = subsidy_transfer_received;
	current->total_debt = total_debt;
	current->yearly_budget_balance = yearly_budget_balance;
	current->total_money_financing = total_money_financing;
	current->total_bond_financing = total_bond_financing;
	current->country_wide_mean_wage = country_wide_mean_wage;
	current->num_unemployed = num_unemployed;
	current->yearly_gdp = yearly_gdp;
	current->previous_year_gdp = previous_year_gdp;
	current->subsidy_reported_to_eurostat = subsidy_reported_to_eurostat;
	current->gdp_growth = gdp_growth;
	current->gdp_forecast = gdp_forecast;
	current->yearly_income_forecast = yearly_income_forecast;
	current->yearly_expenditure_budget = yearly_expenditure_budget;
	current->budget_balance_forecast = budget_balance_forecast;
	copy_ordered_quantity_array(ordered_quantities, &current->ordered_quantities);
	copy_received_quantities_array(gov_received_quantities, &current->gov_received_quantities);
	copy_double_array(consumption_budgets_per_capita, &current->consumption_budgets_per_capita);
	current->av_consumption_budget_per_capita = av_consumption_budget_per_capita;
	copy_double_array(consumption_quotas_rel_to_reg1, &current->consumption_quotas_rel_to_reg1);
	current->av_consumption_quota_rel_to_reg1 = av_consumption_quota_rel_to_reg1;
	current->yearly_consumption_budget = yearly_consumption_budget;
	current->yearly_investment_budget = yearly_investment_budget;
	current->yearly_budget_balance_gdp_fraction = yearly_budget_balance_gdp_fraction;
	current->total_assets = total_assets;
	current->total_liabilities = total_liabilities;
	current->cumulated_deficit = cumulated_deficit;
	current->inflation_rate = inflation_rate;
	current->unemployment_rate = unemployment_rate;
	current->human_capital_policy_installation_date_in_years = human_capital_policy_installation_date_in_years;
	current->human_capital_policy_flag = human_capital_policy_flag;
	current->basic_security_benefits_pct = basic_security_benefits_pct;
	current->basic_security_benefits = basic_security_benefits;
	copy_adt_skill_distribution_array(new_skill_distribution, &current->new_skill_distribution);
	current->minimum_wage = minimum_wage;
	copy_int_array(all_region_ids, &current->all_region_ids);
	copy_int_array(all_gov_ids, &current->all_gov_ids);
	copy_gov_balance_sheet_adt(&gov_balance_sheet_calendar, &current->gov_balance_sheet_calendar);
	copy_gov_stocks_adt(&gov_stocks_calendar, &current->gov_stocks_calendar);
	copy_gov_outflows_adt(&gov_outflows_calendar, &current->gov_outflows_calendar);
	copy_gov_inflows_adt(&gov_inflows_calendar, &current->gov_inflows_calendar);
}

xmachine_memory_CentralBank_state * init_CentralBank_state()
{
	xmachine_memory_CentralBank_state * current = (xmachine_memory_CentralBank_state *)malloc(sizeof(xmachine_memory_CentralBank_state));
	CHECK_POINTER(current);

	current->agents = NULL;
	current->count = 0;

	return current;
}

xmachine_memory_CentralBank * init_CentralBank_agent()
{
	xmachine_memory_CentralBank * current = (xmachine_memory_CentralBank *)malloc(sizeof(xmachine_memory_CentralBank));
	CHECK_POINTER(current);

	current->id = 0;
	current->region_id = 0;
	current->partition_id = 0;
	current->equity = 0.0;
	current->dividend_payment = 0.0;
	current->fiat_money = 0.0;
	current->fiat_money_banks = 0.0;
	current->ecb_deposits = 0.0;
	init_account_item_array(&current->accounts_banks);
	init_account_item_array(&current->accounts_govs);
	init_account_item_array(&current->government_national_accounts);
	current->cash = 0.0;
	init_ecb_balance_sheet_adt(&current->ecb_balance_sheet_calendar);
	init_ecb_stocks_adt(&current->ecb_stocks_calendar);
	init_ecb_outflows_adt(&current->ecb_outflows_calendar);
	init_ecb_inflows_adt(&current->ecb_inflows_calendar);
	current->bond_holdings_value = 0.0;
	current->nr_gov_bonds = 0;
	current->fiat_money_govs = 0.0;
	current->fiat_money_bond_govs = 0.0;
	current->bank_interest = 0.0;
	current->gov_interest = 0.0;
	current->gov_bond_purchase = 0.0;
	current->total_income = 0.0;
	current->total_expenses = 0.0;
	current->total_assets = 0.0;
	current->total_liabilities = 0.0;

	return current;
}

void free_CentralBank_agent(xmachine_memory_CentralBank_holder * tmp, xmachine_memory_CentralBank_state * state)
{
	if(tmp->prev == NULL) state->agents = tmp->next;
	else tmp->prev->next = tmp->next;
	if(tmp->next != NULL) tmp->next->prev = tmp->prev;

	free_account_item_array(&tmp->agent->accounts_banks);
	free_account_item_array(&tmp->agent->accounts_govs);
	free_account_item_array(&tmp->agent->government_national_accounts);
	free_ecb_balance_sheet_adt(&tmp->agent->ecb_balance_sheet_calendar);
	free_ecb_stocks_adt(&tmp->agent->ecb_stocks_calendar);
	free_ecb_outflows_adt(&tmp->agent->ecb_outflows_calendar);
	free_ecb_inflows_adt(&tmp->agent->ecb_inflows_calendar);
	

	free(tmp->agent);
	free(tmp);
}

void unittest_init_CentralBank_agent()
{
	current_xmachine_CentralBank = (xmachine_memory_CentralBank *)malloc(sizeof(xmachine_memory_CentralBank));
	CHECK_POINTER(current);

		current_xmachine_CentralBank->id = 0;
		current_xmachine_CentralBank->region_id = 0;
		current_xmachine_CentralBank->partition_id = 0;
		current_xmachine_CentralBank->equity = 0.0;
		current_xmachine_CentralBank->dividend_payment = 0.0;
		current_xmachine_CentralBank->fiat_money = 0.0;
		current_xmachine_CentralBank->fiat_money_banks = 0.0;
		current_xmachine_CentralBank->ecb_deposits = 0.0;
		init_account_item_array(&current_xmachine_CentralBank->accounts_banks);
		init_account_item_array(&current_xmachine_CentralBank->accounts_govs);
		init_account_item_array(&current_xmachine_CentralBank->government_national_accounts);
		current_xmachine_CentralBank->cash = 0.0;
		init_ecb_balance_sheet_adt(&current_xmachine_CentralBank->ecb_balance_sheet_calendar);
		init_ecb_stocks_adt(&current_xmachine_CentralBank->ecb_stocks_calendar);
		init_ecb_outflows_adt(&current_xmachine_CentralBank->ecb_outflows_calendar);
		init_ecb_inflows_adt(&current_xmachine_CentralBank->ecb_inflows_calendar);
		current_xmachine_CentralBank->bond_holdings_value = 0.0;
		current_xmachine_CentralBank->nr_gov_bonds = 0;
		current_xmachine_CentralBank->fiat_money_govs = 0.0;
		current_xmachine_CentralBank->fiat_money_bond_govs = 0.0;
		current_xmachine_CentralBank->bank_interest = 0.0;
		current_xmachine_CentralBank->gov_interest = 0.0;
		current_xmachine_CentralBank->gov_bond_purchase = 0.0;
		current_xmachine_CentralBank->total_income = 0.0;
		current_xmachine_CentralBank->total_expenses = 0.0;
		current_xmachine_CentralBank->total_assets = 0.0;
		current_xmachine_CentralBank->total_liabilities = 0.0;
	
}

void unittest_free_CentralBank_agent()
{
	free_account_item_array(&current_xmachine_CentralBank->accounts_banks);
	free_account_item_array(&current_xmachine_CentralBank->accounts_govs);
	free_account_item_array(&current_xmachine_CentralBank->government_national_accounts);
	free_ecb_balance_sheet_adt(&current_xmachine_CentralBank->ecb_balance_sheet_calendar);
	free_ecb_stocks_adt(&current_xmachine_CentralBank->ecb_stocks_calendar);
	free_ecb_outflows_adt(&current_xmachine_CentralBank->ecb_outflows_calendar);
	free_ecb_inflows_adt(&current_xmachine_CentralBank->ecb_inflows_calendar);
	
	free(current_xmachine_CentralBank);
}

void free_CentralBank_agents()
{
	current_xmachine_CentralBank_holder = CentralBank_CB_financial_operations_end_state->agents;
	while(current_xmachine_CentralBank_holder)
	{
		temp_xmachine_CentralBank_holder = current_xmachine_CentralBank_holder->next;
		free_CentralBank_agent(current_xmachine_CentralBank_holder, CentralBank_CB_financial_operations_end_state);
		current_xmachine_CentralBank_holder = temp_xmachine_CentralBank_holder;
	}
	CentralBank_CB_financial_operations_end_state->count = 0;
	current_xmachine_CentralBank_holder = CentralBank_CB_market_operations_state->agents;
	while(current_xmachine_CentralBank_holder)
	{
		temp_xmachine_CentralBank_holder = current_xmachine_CentralBank_holder->next;
		free_CentralBank_agent(current_xmachine_CentralBank_holder, CentralBank_CB_market_operations_state);
		current_xmachine_CentralBank_holder = temp_xmachine_CentralBank_holder;
	}
	CentralBank_CB_market_operations_state->count = 0;
	current_xmachine_CentralBank_holder = CentralBank_CB_reset_state->agents;
	while(current_xmachine_CentralBank_holder)
	{
		temp_xmachine_CentralBank_holder = current_xmachine_CentralBank_holder->next;
		free_CentralBank_agent(current_xmachine_CentralBank_holder, CentralBank_CB_reset_state);
		current_xmachine_CentralBank_holder = temp_xmachine_CentralBank_holder;
	}
	CentralBank_CB_reset_state->count = 0;
	current_xmachine_CentralBank_holder = CentralBank_start_Central_Bank_state->agents;
	while(current_xmachine_CentralBank_holder)
	{
		temp_xmachine_CentralBank_holder = current_xmachine_CentralBank_holder->next;
		free_CentralBank_agent(current_xmachine_CentralBank_holder, CentralBank_start_Central_Bank_state);
		current_xmachine_CentralBank_holder = temp_xmachine_CentralBank_holder;
	}
	CentralBank_start_Central_Bank_state->count = 0;
	current_xmachine_CentralBank_holder = CentralBank_end_Central_Bank_state->agents;
	while(current_xmachine_CentralBank_holder)
	{
		temp_xmachine_CentralBank_holder = current_xmachine_CentralBank_holder->next;
		free_CentralBank_agent(current_xmachine_CentralBank_holder, CentralBank_end_Central_Bank_state);
		current_xmachine_CentralBank_holder = temp_xmachine_CentralBank_holder;
	}
	CentralBank_end_Central_Bank_state->count = 0;
	current_xmachine_CentralBank_holder = CentralBank_00_state->agents;
	while(current_xmachine_CentralBank_holder)
	{
		temp_xmachine_CentralBank_holder = current_xmachine_CentralBank_holder->next;
		free_CentralBank_agent(current_xmachine_CentralBank_holder, CentralBank_00_state);
		current_xmachine_CentralBank_holder = temp_xmachine_CentralBank_holder;
	}
	CentralBank_00_state->count = 0;
}

void free_CentralBank_states()
{
	free(CentralBank_CB_financial_operations_end_state);
	free(CentralBank_CB_market_operations_state);
	free(CentralBank_CB_reset_state);
	free(CentralBank_start_Central_Bank_state);
	free(CentralBank_end_Central_Bank_state);
	free(CentralBank_00_state);
}

void transition_CentralBank_agent(xmachine_memory_CentralBank_holder * tmp, xmachine_memory_CentralBank_state * from_state, xmachine_memory_CentralBank_state * to_state)
{
	if(tmp->prev == NULL) from_state->agents = tmp->next;
	else tmp->prev->next = tmp->next;
	if(tmp->next != NULL) tmp->next->prev = tmp->prev;

	add_CentralBank_agent_internal(tmp->agent, to_state);
	free(tmp);
}

void add_CentralBank_agent_internal(xmachine_memory_CentralBank * agent, xmachine_memory_CentralBank_state * state)
{
	xmachine_memory_CentralBank_holder * current = (xmachine_memory_CentralBank_holder *)malloc(sizeof(xmachine_memory_CentralBank_holder));
	CHECK_POINTER(current);

	current->next = state->agents;
	current->prev = NULL;
	state->agents = current;
	if(current->next != NULL) current->next->prev = current;
	current->agent = agent;

	state->count++;

}

/** \fn void add_CentralBank_agent(int id, int region_id, int partition_id, double equity, double dividend_payment, double fiat_money, double fiat_money_banks, double ecb_deposits, account_item_array * accounts_banks, account_item_array * accounts_govs, account_item_array * government_national_accounts, double cash, ecb_balance_sheet_adt * ecb_balance_sheet_calendar, ecb_stocks_adt * ecb_stocks_calendar, ecb_outflows_adt * ecb_outflows_calendar, ecb_inflows_adt * ecb_inflows_calendar, double bond_holdings_value, int nr_gov_bonds, double fiat_money_govs, double fiat_money_bond_govs, double bank_interest, double gov_interest, double gov_bond_purchase, double total_income, double total_expenses, double total_assets, double total_liabilities)
 * \brief Add CentralBank X-machine to the current being used X-machine list.
 * \param id Variable for the X-machine memory.
 * \param region_id Variable for the X-machine memory.
 * \param partition_id Variable for the X-machine memory.
 * \param equity Variable for the X-machine memory.
 * \param dividend_payment Variable for the X-machine memory.
 * \param fiat_money Variable for the X-machine memory.
 * \param fiat_money_banks Variable for the X-machine memory.
 * \param ecb_deposits Variable for the X-machine memory.
 * \param accounts_banks Variable for the X-machine memory.
 * \param accounts_govs Variable for the X-machine memory.
 * \param government_national_accounts Variable for the X-machine memory.
 * \param cash Variable for the X-machine memory.
 * \param ecb_balance_sheet_calendar Variable for the X-machine memory.
 * \param ecb_stocks_calendar Variable for the X-machine memory.
 * \param ecb_outflows_calendar Variable for the X-machine memory.
 * \param ecb_inflows_calendar Variable for the X-machine memory.
 * \param bond_holdings_value Variable for the X-machine memory.
 * \param nr_gov_bonds Variable for the X-machine memory.
 * \param fiat_money_govs Variable for the X-machine memory.
 * \param fiat_money_bond_govs Variable for the X-machine memory.
 * \param bank_interest Variable for the X-machine memory.
 * \param gov_interest Variable for the X-machine memory.
 * \param gov_bond_purchase Variable for the X-machine memory.
 * \param total_income Variable for the X-machine memory.
 * \param total_expenses Variable for the X-machine memory.
 * \param total_assets Variable for the X-machine memory.
 * \param total_liabilities Variable for the X-machine memory.
 */
void add_CentralBank_agent(int id, int region_id, int partition_id, double equity, double dividend_payment, double fiat_money, double fiat_money_banks, double ecb_deposits, account_item_array * accounts_banks, account_item_array * accounts_govs, account_item_array * government_national_accounts, double cash, ecb_balance_sheet_adt ecb_balance_sheet_calendar, ecb_stocks_adt ecb_stocks_calendar, ecb_outflows_adt ecb_outflows_calendar, ecb_inflows_adt ecb_inflows_calendar, double bond_holdings_value, int nr_gov_bonds, double fiat_money_govs, double fiat_money_bond_govs, double bank_interest, double gov_interest, double gov_bond_purchase, double total_income, double total_expenses, double total_assets, double total_liabilities)
{
	xmachine_memory_CentralBank * current;

	current = init_CentralBank_agent();
	/* new line added to handle dynamic agent creation*/
	current_xmachine_CentralBank_next_state = CentralBank_start_Central_Bank_state;
	add_CentralBank_agent_internal(current, current_xmachine_CentralBank_next_state);

	current->id = id;
	current->region_id = region_id;
	current->partition_id = partition_id;
	current->equity = equity;
	current->dividend_payment = dividend_payment;
	current->fiat_money = fiat_money;
	current->fiat_money_banks = fiat_money_banks;
	current->ecb_deposits = ecb_deposits;
	copy_account_item_array(accounts_banks, &current->accounts_banks);
	copy_account_item_array(accounts_govs, &current->accounts_govs);
	copy_account_item_array(government_national_accounts, &current->government_national_accounts);
	current->cash = cash;
	copy_ecb_balance_sheet_adt(&ecb_balance_sheet_calendar, &current->ecb_balance_sheet_calendar);
	copy_ecb_stocks_adt(&ecb_stocks_calendar, &current->ecb_stocks_calendar);
	copy_ecb_outflows_adt(&ecb_outflows_calendar, &current->ecb_outflows_calendar);
	copy_ecb_inflows_adt(&ecb_inflows_calendar, &current->ecb_inflows_calendar);
	current->bond_holdings_value = bond_holdings_value;
	current->nr_gov_bonds = nr_gov_bonds;
	current->fiat_money_govs = fiat_money_govs;
	current->fiat_money_bond_govs = fiat_money_bond_govs;
	current->bank_interest = bank_interest;
	current->gov_interest = gov_interest;
	current->gov_bond_purchase = gov_bond_purchase;
	current->total_income = total_income;
	current->total_expenses = total_expenses;
	current->total_assets = total_assets;
	current->total_liabilities = total_liabilities;
}

xmachine_memory_ClearingHouse_state * init_ClearingHouse_state()
{
	xmachine_memory_ClearingHouse_state * current = (xmachine_memory_ClearingHouse_state *)malloc(sizeof(xmachine_memory_ClearingHouse_state));
	CHECK_POINTER(current);

	current->agents = NULL;
	current->count = 0;

	return current;
}

xmachine_memory_ClearingHouse * init_ClearingHouse_agent()
{
	xmachine_memory_ClearingHouse * current = (xmachine_memory_ClearingHouse *)malloc(sizeof(xmachine_memory_ClearingHouse));
	CHECK_POINTER(current);

	current->id = 0;
	current->region_id = 0;
	current->partition_id = 0;
	init_order_array(&current->pending_orders);
	init_order_array(&current->processed_orders);
	init_index_adt(&current->stock_index);
	current->dsratio = 0.0;
	init_double_array(&current->random_numbers_normal);
	current->monthly_counter_total_dividend = 0.0;
	current->stock_index_price = 0.0;

	return current;
}

void free_ClearingHouse_agent(xmachine_memory_ClearingHouse_holder * tmp, xmachine_memory_ClearingHouse_state * state)
{
	if(tmp->prev == NULL) state->agents = tmp->next;
	else tmp->prev->next = tmp->next;
	if(tmp->next != NULL) tmp->next->prev = tmp->prev;

	free_order_array(&tmp->agent->pending_orders);
	free_order_array(&tmp->agent->processed_orders);
	free_index_adt(&tmp->agent->stock_index);
	free_double_array(&tmp->agent->random_numbers_normal);
	

	free(tmp->agent);
	free(tmp);
}

void unittest_init_ClearingHouse_agent()
{
	current_xmachine_ClearingHouse = (xmachine_memory_ClearingHouse *)malloc(sizeof(xmachine_memory_ClearingHouse));
	CHECK_POINTER(current);

		current_xmachine_ClearingHouse->id = 0;
		current_xmachine_ClearingHouse->region_id = 0;
		current_xmachine_ClearingHouse->partition_id = 0;
		init_order_array(&current_xmachine_ClearingHouse->pending_orders);
		init_order_array(&current_xmachine_ClearingHouse->processed_orders);
		init_index_adt(&current_xmachine_ClearingHouse->stock_index);
		current_xmachine_ClearingHouse->dsratio = 0.0;
		init_double_array(&current_xmachine_ClearingHouse->random_numbers_normal);
		current_xmachine_ClearingHouse->monthly_counter_total_dividend = 0.0;
		current_xmachine_ClearingHouse->stock_index_price = 0.0;
	
}

void unittest_free_ClearingHouse_agent()
{
	free_order_array(&current_xmachine_ClearingHouse->pending_orders);
	free_order_array(&current_xmachine_ClearingHouse->processed_orders);
	free_index_adt(&current_xmachine_ClearingHouse->stock_index);
	free_double_array(&current_xmachine_ClearingHouse->random_numbers_normal);
	
	free(current_xmachine_ClearingHouse);
}

void free_ClearingHouse_agents()
{
	current_xmachine_ClearingHouse_holder = ClearingHouse_end_Clearinghouse_state->agents;
	while(current_xmachine_ClearingHouse_holder)
	{
		temp_xmachine_ClearingHouse_holder = current_xmachine_ClearingHouse_holder->next;
		free_ClearingHouse_agent(current_xmachine_ClearingHouse_holder, ClearingHouse_end_Clearinghouse_state);
		current_xmachine_ClearingHouse_holder = temp_xmachine_ClearingHouse_holder;
	}
	ClearingHouse_end_Clearinghouse_state->count = 0;
	current_xmachine_ClearingHouse_holder = ClearingHouse_AFM_05_state->agents;
	while(current_xmachine_ClearingHouse_holder)
	{
		temp_xmachine_ClearingHouse_holder = current_xmachine_ClearingHouse_holder->next;
		free_ClearingHouse_agent(current_xmachine_ClearingHouse_holder, ClearingHouse_AFM_05_state);
		current_xmachine_ClearingHouse_holder = temp_xmachine_ClearingHouse_holder;
	}
	ClearingHouse_AFM_05_state->count = 0;
	current_xmachine_ClearingHouse_holder = ClearingHouse_AFM_04_state->agents;
	while(current_xmachine_ClearingHouse_holder)
	{
		temp_xmachine_ClearingHouse_holder = current_xmachine_ClearingHouse_holder->next;
		free_ClearingHouse_agent(current_xmachine_ClearingHouse_holder, ClearingHouse_AFM_04_state);
		current_xmachine_ClearingHouse_holder = temp_xmachine_ClearingHouse_holder;
	}
	ClearingHouse_AFM_04_state->count = 0;
	current_xmachine_ClearingHouse_holder = ClearingHouse_AFM_03_state->agents;
	while(current_xmachine_ClearingHouse_holder)
	{
		temp_xmachine_ClearingHouse_holder = current_xmachine_ClearingHouse_holder->next;
		free_ClearingHouse_agent(current_xmachine_ClearingHouse_holder, ClearingHouse_AFM_03_state);
		current_xmachine_ClearingHouse_holder = temp_xmachine_ClearingHouse_holder;
	}
	ClearingHouse_AFM_03_state->count = 0;
	current_xmachine_ClearingHouse_holder = ClearingHouse_AFM_02_state->agents;
	while(current_xmachine_ClearingHouse_holder)
	{
		temp_xmachine_ClearingHouse_holder = current_xmachine_ClearingHouse_holder->next;
		free_ClearingHouse_agent(current_xmachine_ClearingHouse_holder, ClearingHouse_AFM_02_state);
		current_xmachine_ClearingHouse_holder = temp_xmachine_ClearingHouse_holder;
	}
	ClearingHouse_AFM_02_state->count = 0;
	current_xmachine_ClearingHouse_holder = ClearingHouse_AFM_01_state->agents;
	while(current_xmachine_ClearingHouse_holder)
	{
		temp_xmachine_ClearingHouse_holder = current_xmachine_ClearingHouse_holder->next;
		free_ClearingHouse_agent(current_xmachine_ClearingHouse_holder, ClearingHouse_AFM_01_state);
		current_xmachine_ClearingHouse_holder = temp_xmachine_ClearingHouse_holder;
	}
	ClearingHouse_AFM_01_state->count = 0;
	current_xmachine_ClearingHouse_holder = ClearingHouse_AFM_00_state->agents;
	while(current_xmachine_ClearingHouse_holder)
	{
		temp_xmachine_ClearingHouse_holder = current_xmachine_ClearingHouse_holder->next;
		free_ClearingHouse_agent(current_xmachine_ClearingHouse_holder, ClearingHouse_AFM_00_state);
		current_xmachine_ClearingHouse_holder = temp_xmachine_ClearingHouse_holder;
	}
	ClearingHouse_AFM_00_state->count = 0;
	current_xmachine_ClearingHouse_holder = ClearingHouse_start_Clearinghouse_state->agents;
	while(current_xmachine_ClearingHouse_holder)
	{
		temp_xmachine_ClearingHouse_holder = current_xmachine_ClearingHouse_holder->next;
		free_ClearingHouse_agent(current_xmachine_ClearingHouse_holder, ClearingHouse_start_Clearinghouse_state);
		current_xmachine_ClearingHouse_holder = temp_xmachine_ClearingHouse_holder;
	}
	ClearingHouse_start_Clearinghouse_state->count = 0;
}

void free_ClearingHouse_states()
{
	free(ClearingHouse_end_Clearinghouse_state);
	free(ClearingHouse_AFM_05_state);
	free(ClearingHouse_AFM_04_state);
	free(ClearingHouse_AFM_03_state);
	free(ClearingHouse_AFM_02_state);
	free(ClearingHouse_AFM_01_state);
	free(ClearingHouse_AFM_00_state);
	free(ClearingHouse_start_Clearinghouse_state);
}

void transition_ClearingHouse_agent(xmachine_memory_ClearingHouse_holder * tmp, xmachine_memory_ClearingHouse_state * from_state, xmachine_memory_ClearingHouse_state * to_state)
{
	if(tmp->prev == NULL) from_state->agents = tmp->next;
	else tmp->prev->next = tmp->next;
	if(tmp->next != NULL) tmp->next->prev = tmp->prev;

	add_ClearingHouse_agent_internal(tmp->agent, to_state);
	free(tmp);
}

void add_ClearingHouse_agent_internal(xmachine_memory_ClearingHouse * agent, xmachine_memory_ClearingHouse_state * state)
{
	xmachine_memory_ClearingHouse_holder * current = (xmachine_memory_ClearingHouse_holder *)malloc(sizeof(xmachine_memory_ClearingHouse_holder));
	CHECK_POINTER(current);

	current->next = state->agents;
	current->prev = NULL;
	state->agents = current;
	if(current->next != NULL) current->next->prev = current;
	current->agent = agent;

	state->count++;

}

/** \fn void add_ClearingHouse_agent(int id, int region_id, int partition_id, order_array * pending_orders, order_array * processed_orders, index_adt * stock_index, double dsratio, double_array * random_numbers_normal, double monthly_counter_total_dividend, double stock_index_price)
 * \brief Add ClearingHouse X-machine to the current being used X-machine list.
 * \param id Variable for the X-machine memory.
 * \param region_id Variable for the X-machine memory.
 * \param partition_id Variable for the X-machine memory.
 * \param pending_orders Variable for the X-machine memory.
 * \param processed_orders Variable for the X-machine memory.
 * \param stock_index Variable for the X-machine memory.
 * \param dsratio Variable for the X-machine memory.
 * \param random_numbers_normal Variable for the X-machine memory.
 * \param monthly_counter_total_dividend Variable for the X-machine memory.
 * \param stock_index_price Variable for the X-machine memory.
 */
void add_ClearingHouse_agent(int id, int region_id, int partition_id, order_array * pending_orders, order_array * processed_orders, index_adt stock_index, double dsratio, double_array * random_numbers_normal, double monthly_counter_total_dividend, double stock_index_price)
{
	xmachine_memory_ClearingHouse * current;

	current = init_ClearingHouse_agent();
	/* new line added to handle dynamic agent creation*/
	current_xmachine_ClearingHouse_next_state = ClearingHouse_start_Clearinghouse_state;
	add_ClearingHouse_agent_internal(current, current_xmachine_ClearingHouse_next_state);

	current->id = id;
	current->region_id = region_id;
	current->partition_id = partition_id;
	copy_order_array(pending_orders, &current->pending_orders);
	copy_order_array(processed_orders, &current->processed_orders);
	copy_index_adt(&stock_index, &current->stock_index);
	current->dsratio = dsratio;
	copy_double_array(random_numbers_normal, &current->random_numbers_normal);
	current->monthly_counter_total_dividend = monthly_counter_total_dividend;
	current->stock_index_price = stock_index_price;
}


/* freexmachines */
/** \fn void freexmachines()
 * \brief Free the currently being used X-machine list.
 */
void freexmachines()
{
	free_Firm_agents();
	free_Household_agents();
	free_Mall_agents();
	free_IGFirm_agents();
	free_Eurostat_agents();
	free_Bank_agents();
	free_Government_agents();
	free_CentralBank_agents();
	free_ClearingHouse_agents();
	
}


/** \fn void set_id(int id)
 * \brief Set id memory variable for current X-machine.
 * \param id New value for variable.
 */
void set_id(int id)
{
	if(current_xmachine->xmachine_Firm) (*current_xmachine->xmachine_Firm).id = id;
	if(current_xmachine->xmachine_Household) (*current_xmachine->xmachine_Household).id = id;
	if(current_xmachine->xmachine_Mall) (*current_xmachine->xmachine_Mall).id = id;
	if(current_xmachine->xmachine_IGFirm) (*current_xmachine->xmachine_IGFirm).id = id;
	if(current_xmachine->xmachine_Eurostat) (*current_xmachine->xmachine_Eurostat).id = id;
	if(current_xmachine->xmachine_Bank) (*current_xmachine->xmachine_Bank).id = id;
	if(current_xmachine->xmachine_Government) (*current_xmachine->xmachine_Government).id = id;
	if(current_xmachine->xmachine_CentralBank) (*current_xmachine->xmachine_CentralBank).id = id;
	if(current_xmachine->xmachine_ClearingHouse) (*current_xmachine->xmachine_ClearingHouse).id = id;
}

/** \fn int get_id()
 * \brief Get id memory variable from current X-machine.
 * \return Value for variable.
 */
int get_id()
{
	if(current_xmachine->xmachine_Firm) return (*current_xmachine->xmachine_Firm).id;
	if(current_xmachine->xmachine_Household) return (*current_xmachine->xmachine_Household).id;
	if(current_xmachine->xmachine_Mall) return (*current_xmachine->xmachine_Mall).id;
	if(current_xmachine->xmachine_IGFirm) return (*current_xmachine->xmachine_IGFirm).id;
	if(current_xmachine->xmachine_Eurostat) return (*current_xmachine->xmachine_Eurostat).id;
	if(current_xmachine->xmachine_Bank) return (*current_xmachine->xmachine_Bank).id;
	if(current_xmachine->xmachine_Government) return (*current_xmachine->xmachine_Government).id;
	if(current_xmachine->xmachine_CentralBank) return (*current_xmachine->xmachine_CentralBank).id;
	if(current_xmachine->xmachine_ClearingHouse) return (*current_xmachine->xmachine_ClearingHouse).id;

    // suppress compiler warning by returning dummy value /
    // this statement should rightfully NEVER be reached /
    return (int)0;
}

/** \fn void set_region_id(int region_id)
 * \brief Set region_id memory variable for current X-machine.
 * \param region_id New value for variable.
 */
void set_region_id(int region_id)
{
	if(current_xmachine->xmachine_Firm) (*current_xmachine->xmachine_Firm).region_id = region_id;
	if(current_xmachine->xmachine_Household) (*current_xmachine->xmachine_Household).region_id = region_id;
	if(current_xmachine->xmachine_Mall) (*current_xmachine->xmachine_Mall).region_id = region_id;
	if(current_xmachine->xmachine_IGFirm) (*current_xmachine->xmachine_IGFirm).region_id = region_id;
	if(current_xmachine->xmachine_Eurostat) (*current_xmachine->xmachine_Eurostat).region_id = region_id;
	if(current_xmachine->xmachine_Bank) (*current_xmachine->xmachine_Bank).region_id = region_id;
	if(current_xmachine->xmachine_Government) (*current_xmachine->xmachine_Government).region_id = region_id;
	if(current_xmachine->xmachine_CentralBank) (*current_xmachine->xmachine_CentralBank).region_id = region_id;
	if(current_xmachine->xmachine_ClearingHouse) (*current_xmachine->xmachine_ClearingHouse).region_id = region_id;
}

/** \fn int get_region_id()
 * \brief Get region_id memory variable from current X-machine.
 * \return Value for variable.
 */
int get_region_id()
{
	if(current_xmachine->xmachine_Firm) return (*current_xmachine->xmachine_Firm).region_id;
	if(current_xmachine->xmachine_Household) return (*current_xmachine->xmachine_Household).region_id;
	if(current_xmachine->xmachine_Mall) return (*current_xmachine->xmachine_Mall).region_id;
	if(current_xmachine->xmachine_IGFirm) return (*current_xmachine->xmachine_IGFirm).region_id;
	if(current_xmachine->xmachine_Eurostat) return (*current_xmachine->xmachine_Eurostat).region_id;
	if(current_xmachine->xmachine_Bank) return (*current_xmachine->xmachine_Bank).region_id;
	if(current_xmachine->xmachine_Government) return (*current_xmachine->xmachine_Government).region_id;
	if(current_xmachine->xmachine_CentralBank) return (*current_xmachine->xmachine_CentralBank).region_id;
	if(current_xmachine->xmachine_ClearingHouse) return (*current_xmachine->xmachine_ClearingHouse).region_id;

    // suppress compiler warning by returning dummy value /
    // this statement should rightfully NEVER be reached /
    return (int)0;
}

/** \fn void set_gov_id(int gov_id)
 * \brief Set gov_id memory variable for current X-machine.
 * \param gov_id New value for variable.
 */
void set_gov_id(int gov_id)
{
	if(current_xmachine->xmachine_Firm) (*current_xmachine->xmachine_Firm).gov_id = gov_id;
	if(current_xmachine->xmachine_Household) (*current_xmachine->xmachine_Household).gov_id = gov_id;
	if(current_xmachine->xmachine_Mall) (*current_xmachine->xmachine_Mall).gov_id = gov_id;
	if(current_xmachine->xmachine_IGFirm) (*current_xmachine->xmachine_IGFirm).gov_id = gov_id;
	if(current_xmachine->xmachine_Bank) (*current_xmachine->xmachine_Bank).gov_id = gov_id;
}

/** \fn int get_gov_id()
 * \brief Get gov_id memory variable from current X-machine.
 * \return Value for variable.
 */
int get_gov_id()
{
	if(current_xmachine->xmachine_Firm) return (*current_xmachine->xmachine_Firm).gov_id;
	if(current_xmachine->xmachine_Household) return (*current_xmachine->xmachine_Household).gov_id;
	if(current_xmachine->xmachine_Mall) return (*current_xmachine->xmachine_Mall).gov_id;
	if(current_xmachine->xmachine_IGFirm) return (*current_xmachine->xmachine_IGFirm).gov_id;
	if(current_xmachine->xmachine_Bank) return (*current_xmachine->xmachine_Bank).gov_id;

    // suppress compiler warning by returning dummy value /
    // this statement should rightfully NEVER be reached /
    return (int)0;
}

/** \fn void set_day_of_month_to_act(int day_of_month_to_act)
 * \brief Set day_of_month_to_act memory variable for current X-machine.
 * \param day_of_month_to_act New value for variable.
 */
void set_day_of_month_to_act(int day_of_month_to_act)
{
	if(current_xmachine->xmachine_Firm) (*current_xmachine->xmachine_Firm).day_of_month_to_act = day_of_month_to_act;
	if(current_xmachine->xmachine_Household) (*current_xmachine->xmachine_Household).day_of_month_to_act = day_of_month_to_act;
	if(current_xmachine->xmachine_IGFirm) (*current_xmachine->xmachine_IGFirm).day_of_month_to_act = day_of_month_to_act;
	if(current_xmachine->xmachine_Bank) (*current_xmachine->xmachine_Bank).day_of_month_to_act = day_of_month_to_act;
	if(current_xmachine->xmachine_Government) (*current_xmachine->xmachine_Government).day_of_month_to_act = day_of_month_to_act;
}

/** \fn int get_day_of_month_to_act()
 * \brief Get day_of_month_to_act memory variable from current X-machine.
 * \return Value for variable.
 */
int get_day_of_month_to_act()
{
	if(current_xmachine->xmachine_Firm) return (*current_xmachine->xmachine_Firm).day_of_month_to_act;
	if(current_xmachine->xmachine_Household) return (*current_xmachine->xmachine_Household).day_of_month_to_act;
	if(current_xmachine->xmachine_IGFirm) return (*current_xmachine->xmachine_IGFirm).day_of_month_to_act;
	if(current_xmachine->xmachine_Bank) return (*current_xmachine->xmachine_Bank).day_of_month_to_act;
	if(current_xmachine->xmachine_Government) return (*current_xmachine->xmachine_Government).day_of_month_to_act;

    // suppress compiler warning by returning dummy value /
    // this statement should rightfully NEVER be reached /
    return (int)0;
}

/** \fn void set_last_day_of_month_to_act(int last_day_of_month_to_act)
 * \brief Set last_day_of_month_to_act memory variable for current X-machine.
 * \param last_day_of_month_to_act New value for variable.
 */
void set_last_day_of_month_to_act(int last_day_of_month_to_act)
{
	if(current_xmachine->xmachine_Firm) (*current_xmachine->xmachine_Firm).last_day_of_month_to_act = last_day_of_month_to_act;
	if(current_xmachine->xmachine_IGFirm) (*current_xmachine->xmachine_IGFirm).last_day_of_month_to_act = last_day_of_month_to_act;
}

/** \fn int get_last_day_of_month_to_act()
 * \brief Get last_day_of_month_to_act memory variable from current X-machine.
 * \return Value for variable.
 */
int get_last_day_of_month_to_act()
{
	if(current_xmachine->xmachine_Firm) return (*current_xmachine->xmachine_Firm).last_day_of_month_to_act;
	if(current_xmachine->xmachine_IGFirm) return (*current_xmachine->xmachine_IGFirm).last_day_of_month_to_act;

    // suppress compiler warning by returning dummy value /
    // this statement should rightfully NEVER be reached /
    return (int)0;
}

/** \fn void set_payment_account(double payment_account)
 * \brief Set payment_account memory variable for current X-machine.
 * \param payment_account New value for variable.
 */
void set_payment_account(double payment_account)
{
	if(current_xmachine->xmachine_Firm) (*current_xmachine->xmachine_Firm).payment_account = payment_account;
	if(current_xmachine->xmachine_Household) (*current_xmachine->xmachine_Household).payment_account = payment_account;
	if(current_xmachine->xmachine_IGFirm) (*current_xmachine->xmachine_IGFirm).payment_account = payment_account;
	if(current_xmachine->xmachine_Government) (*current_xmachine->xmachine_Government).payment_account = payment_account;
}

/** \fn double get_payment_account()
 * \brief Get payment_account memory variable from current X-machine.
 * \return Value for variable.
 */
double get_payment_account()
{
	if(current_xmachine->xmachine_Firm) return (*current_xmachine->xmachine_Firm).payment_account;
	if(current_xmachine->xmachine_Household) return (*current_xmachine->xmachine_Household).payment_account;
	if(current_xmachine->xmachine_IGFirm) return (*current_xmachine->xmachine_IGFirm).payment_account;
	if(current_xmachine->xmachine_Government) return (*current_xmachine->xmachine_Government).payment_account;

    // suppress compiler warning by returning dummy value /
    // this statement should rightfully NEVER be reached /
    return (double)0;
}

/** \fn void set_payment_account_balance_sheet(double payment_account_balance_sheet)
 * \brief Set payment_account_balance_sheet memory variable for current X-machine.
 * \param payment_account_balance_sheet New value for variable.
 */
void set_payment_account_balance_sheet(double payment_account_balance_sheet)
{
	if(current_xmachine->xmachine_Firm) (*current_xmachine->xmachine_Firm).payment_account_balance_sheet = payment_account_balance_sheet;
	if(current_xmachine->xmachine_IGFirm) (*current_xmachine->xmachine_IGFirm).payment_account_balance_sheet = payment_account_balance_sheet;
}

/** \fn double get_payment_account_balance_sheet()
 * \brief Get payment_account_balance_sheet memory variable from current X-machine.
 * \return Value for variable.
 */
double get_payment_account_balance_sheet()
{
	if(current_xmachine->xmachine_Firm) return (*current_xmachine->xmachine_Firm).payment_account_balance_sheet;
	if(current_xmachine->xmachine_IGFirm) return (*current_xmachine->xmachine_IGFirm).payment_account_balance_sheet;

    // suppress compiler warning by returning dummy value /
    // this statement should rightfully NEVER be reached /
    return (double)0;
}

/** \fn void set_bank_id(int bank_id)
 * \brief Set bank_id memory variable for current X-machine.
 * \param bank_id New value for variable.
 */
void set_bank_id(int bank_id)
{
	if(current_xmachine->xmachine_Firm) (*current_xmachine->xmachine_Firm).bank_id = bank_id;
	if(current_xmachine->xmachine_Household) (*current_xmachine->xmachine_Household).bank_id = bank_id;
	if(current_xmachine->xmachine_IGFirm) (*current_xmachine->xmachine_IGFirm).bank_id = bank_id;
}

/** \fn int get_bank_id()
 * \brief Get bank_id memory variable from current X-machine.
 * \return Value for variable.
 */
int get_bank_id()
{
	if(current_xmachine->xmachine_Firm) return (*current_xmachine->xmachine_Firm).bank_id;
	if(current_xmachine->xmachine_Household) return (*current_xmachine->xmachine_Household).bank_id;
	if(current_xmachine->xmachine_IGFirm) return (*current_xmachine->xmachine_IGFirm).bank_id;

    // suppress compiler warning by returning dummy value /
    // this statement should rightfully NEVER be reached /
    return (int)0;
}

/** \fn void set_partition_id(int partition_id)
 * \brief Set partition_id memory variable for current X-machine.
 * \param partition_id New value for variable.
 */
void set_partition_id(int partition_id)
{
	if(current_xmachine->xmachine_Firm) (*current_xmachine->xmachine_Firm).partition_id = partition_id;
	if(current_xmachine->xmachine_Household) (*current_xmachine->xmachine_Household).partition_id = partition_id;
	if(current_xmachine->xmachine_Mall) (*current_xmachine->xmachine_Mall).partition_id = partition_id;
	if(current_xmachine->xmachine_IGFirm) (*current_xmachine->xmachine_IGFirm).partition_id = partition_id;
	if(current_xmachine->xmachine_Eurostat) (*current_xmachine->xmachine_Eurostat).partition_id = partition_id;
	if(current_xmachine->xmachine_Bank) (*current_xmachine->xmachine_Bank).partition_id = partition_id;
	if(current_xmachine->xmachine_Government) (*current_xmachine->xmachine_Government).partition_id = partition_id;
	if(current_xmachine->xmachine_CentralBank) (*current_xmachine->xmachine_CentralBank).partition_id = partition_id;
	if(current_xmachine->xmachine_ClearingHouse) (*current_xmachine->xmachine_ClearingHouse).partition_id = partition_id;
}

/** \fn int get_partition_id()
 * \brief Get partition_id memory variable from current X-machine.
 * \return Value for variable.
 */
int get_partition_id()
{
	if(current_xmachine->xmachine_Firm) return (*current_xmachine->xmachine_Firm).partition_id;
	if(current_xmachine->xmachine_Household) return (*current_xmachine->xmachine_Household).partition_id;
	if(current_xmachine->xmachine_Mall) return (*current_xmachine->xmachine_Mall).partition_id;
	if(current_xmachine->xmachine_IGFirm) return (*current_xmachine->xmachine_IGFirm).partition_id;
	if(current_xmachine->xmachine_Eurostat) return (*current_xmachine->xmachine_Eurostat).partition_id;
	if(current_xmachine->xmachine_Bank) return (*current_xmachine->xmachine_Bank).partition_id;
	if(current_xmachine->xmachine_Government) return (*current_xmachine->xmachine_Government).partition_id;
	if(current_xmachine->xmachine_CentralBank) return (*current_xmachine->xmachine_CentralBank).partition_id;
	if(current_xmachine->xmachine_ClearingHouse) return (*current_xmachine->xmachine_ClearingHouse).partition_id;

    // suppress compiler warning by returning dummy value /
    // this statement should rightfully NEVER be reached /
    return (int)0;
}

/** \fn void set_cpi(double cpi)
 * \brief Set cpi memory variable for current X-machine.
 * \param cpi New value for variable.
 */
void set_cpi(double cpi)
{
	if(current_xmachine->xmachine_Firm) (*current_xmachine->xmachine_Firm).cpi = cpi;
	if(current_xmachine->xmachine_Eurostat) (*current_xmachine->xmachine_Eurostat).cpi = cpi;
}

/** \fn double get_cpi()
 * \brief Get cpi memory variable from current X-machine.
 * \return Value for variable.
 */
double get_cpi()
{
	if(current_xmachine->xmachine_Firm) return (*current_xmachine->xmachine_Firm).cpi;
	if(current_xmachine->xmachine_Eurostat) return (*current_xmachine->xmachine_Eurostat).cpi;

    // suppress compiler warning by returning dummy value /
    // this statement should rightfully NEVER be reached /
    return (double)0;
}

/** \fn void set_mean_wage(double mean_wage)
 * \brief Set mean_wage memory variable for current X-machine.
 * \param mean_wage New value for variable.
 */
void set_mean_wage(double mean_wage)
{
	if(current_xmachine->xmachine_Firm) (*current_xmachine->xmachine_Firm).mean_wage = mean_wage;
}

/** \fn double get_mean_wage()
 * \brief Get mean_wage memory variable from current X-machine.
 * \return Value for variable.
 */
double get_mean_wage()
{
	if(current_xmachine->xmachine_Firm) return (*current_xmachine->xmachine_Firm).mean_wage;

    // suppress compiler warning by returning dummy value /
    // this statement should rightfully NEVER be reached /
    return (double)0;
}

/** \fn void set_total_mean_wage(double total_mean_wage)
 * \brief Set total_mean_wage memory variable for current X-machine.
 * \param total_mean_wage New value for variable.
 */
void set_total_mean_wage(double total_mean_wage)
{
	if(current_xmachine->xmachine_Firm) (*current_xmachine->xmachine_Firm).total_mean_wage = total_mean_wage;
}

/** \fn double get_total_mean_wage()
 * \brief Get total_mean_wage memory variable from current X-machine.
 * \return Value for variable.
 */
double get_total_mean_wage()
{
	if(current_xmachine->xmachine_Firm) return (*current_xmachine->xmachine_Firm).total_mean_wage;

    // suppress compiler warning by returning dummy value /
    // this statement should rightfully NEVER be reached /
    return (double)0;
}

/** \fn void set_mean_wage_r_and_d(double mean_wage_r_and_d)
 * \brief Set mean_wage_r_and_d memory variable for current X-machine.
 * \param mean_wage_r_and_d New value for variable.
 */
void set_mean_wage_r_and_d(double mean_wage_r_and_d)
{
	if(current_xmachine->xmachine_Firm) (*current_xmachine->xmachine_Firm).mean_wage_r_and_d = mean_wage_r_and_d;
}

/** \fn double get_mean_wage_r_and_d()
 * \brief Get mean_wage_r_and_d memory variable from current X-machine.
 * \return Value for variable.
 */
double get_mean_wage_r_and_d()
{
	if(current_xmachine->xmachine_Firm) return (*current_xmachine->xmachine_Firm).mean_wage_r_and_d;

    // suppress compiler warning by returning dummy value /
    // this statement should rightfully NEVER be reached /
    return (double)0;
}

/** \fn void set_needed_capital_stock(double needed_capital_stock)
 * \brief Set needed_capital_stock memory variable for current X-machine.
 * \param needed_capital_stock New value for variable.
 */
void set_needed_capital_stock(double needed_capital_stock)
{
	if(current_xmachine->xmachine_Firm) (*current_xmachine->xmachine_Firm).needed_capital_stock = needed_capital_stock;
}

/** \fn double get_needed_capital_stock()
 * \brief Get needed_capital_stock memory variable from current X-machine.
 * \return Value for variable.
 */
double get_needed_capital_stock()
{
	if(current_xmachine->xmachine_Firm) return (*current_xmachine->xmachine_Firm).needed_capital_stock;

    // suppress compiler warning by returning dummy value /
    // this statement should rightfully NEVER be reached /
    return (double)0;
}

/** \fn void set_stock(double stock)
 * \brief Set stock memory variable for current X-machine.
 * \param stock New value for variable.
 */
void set_stock(double stock)
{
	if(current_xmachine->xmachine_Firm) (*current_xmachine->xmachine_Firm).stock = stock;
}

/** \fn double get_stock()
 * \brief Get stock memory variable from current X-machine.
 * \return Value for variable.
 */
double get_stock()
{
	if(current_xmachine->xmachine_Firm) return (*current_xmachine->xmachine_Firm).stock;

    // suppress compiler warning by returning dummy value /
    // this statement should rightfully NEVER be reached /
    return (double)0;
}

/** \fn void set_critical_stock(double critical_stock)
 * \brief Set critical_stock memory variable for current X-machine.
 * \param critical_stock New value for variable.
 */
void set_critical_stock(double critical_stock)
{
	if(current_xmachine->xmachine_Firm) (*current_xmachine->xmachine_Firm).critical_stock = critical_stock;
}

/** \fn double get_critical_stock()
 * \brief Get critical_stock memory variable from current X-machine.
 * \return Value for variable.
 */
double get_critical_stock()
{
	if(current_xmachine->xmachine_Firm) return (*current_xmachine->xmachine_Firm).critical_stock;

    // suppress compiler warning by returning dummy value /
    // this statement should rightfully NEVER be reached /
    return (double)0;
}

/** \fn void set_actual_cap_price(double actual_cap_price)
 * \brief Set actual_cap_price memory variable for current X-machine.
 * \param actual_cap_price New value for variable.
 */
void set_actual_cap_price(double actual_cap_price)
{
	if(current_xmachine->xmachine_Firm) (*current_xmachine->xmachine_Firm).actual_cap_price = actual_cap_price;
}

/** \fn double get_actual_cap_price()
 * \brief Get actual_cap_price memory variable from current X-machine.
 * \return Value for variable.
 */
double get_actual_cap_price()
{
	if(current_xmachine->xmachine_Firm) return (*current_xmachine->xmachine_Firm).actual_cap_price;

    // suppress compiler warning by returning dummy value /
    // this statement should rightfully NEVER be reached /
    return (double)0;
}

/** \fn void set_mean_specific_skills(double mean_specific_skills)
 * \brief Set mean_specific_skills memory variable for current X-machine.
 * \param mean_specific_skills New value for variable.
 */
void set_mean_specific_skills(double mean_specific_skills)
{
	if(current_xmachine->xmachine_Firm) (*current_xmachine->xmachine_Firm).mean_specific_skills = mean_specific_skills;
}

/** \fn double get_mean_specific_skills()
 * \brief Get mean_specific_skills memory variable from current X-machine.
 * \return Value for variable.
 */
double get_mean_specific_skills()
{
	if(current_xmachine->xmachine_Firm) return (*current_xmachine->xmachine_Firm).mean_specific_skills;

    // suppress compiler warning by returning dummy value /
    // this statement should rightfully NEVER be reached /
    return (double)0;
}

/** \fn void set_planned_production_quantity(double planned_production_quantity)
 * \brief Set planned_production_quantity memory variable for current X-machine.
 * \param planned_production_quantity New value for variable.
 */
void set_planned_production_quantity(double planned_production_quantity)
{
	if(current_xmachine->xmachine_Firm) (*current_xmachine->xmachine_Firm).planned_production_quantity = planned_production_quantity;
}

/** \fn double get_planned_production_quantity()
 * \brief Get planned_production_quantity memory variable from current X-machine.
 * \return Value for variable.
 */
double get_planned_production_quantity()
{
	if(current_xmachine->xmachine_Firm) return (*current_xmachine->xmachine_Firm).planned_production_quantity;

    // suppress compiler warning by returning dummy value /
    // this statement should rightfully NEVER be reached /
    return (double)0;
}

/** \fn void set_production_quantity(double production_quantity)
 * \brief Set production_quantity memory variable for current X-machine.
 * \param production_quantity New value for variable.
 */
void set_production_quantity(double production_quantity)
{
	if(current_xmachine->xmachine_Firm) (*current_xmachine->xmachine_Firm).production_quantity = production_quantity;
}

/** \fn double get_production_quantity()
 * \brief Get production_quantity memory variable from current X-machine.
 * \return Value for variable.
 */
double get_production_quantity()
{
	if(current_xmachine->xmachine_Firm) return (*current_xmachine->xmachine_Firm).production_quantity;

    // suppress compiler warning by returning dummy value /
    // this statement should rightfully NEVER be reached /
    return (double)0;
}

/** \fn void set_planned_output(double planned_output)
 * \brief Set planned_output memory variable for current X-machine.
 * \param planned_output New value for variable.
 */
void set_planned_output(double planned_output)
{
	if(current_xmachine->xmachine_Firm) (*current_xmachine->xmachine_Firm).planned_output = planned_output;
}

/** \fn double get_planned_output()
 * \brief Get planned_output memory variable from current X-machine.
 * \return Value for variable.
 */
double get_planned_output()
{
	if(current_xmachine->xmachine_Firm) return (*current_xmachine->xmachine_Firm).planned_output;

    // suppress compiler warning by returning dummy value /
    // this statement should rightfully NEVER be reached /
    return (double)0;
}

/** \fn void set_output(double output)
 * \brief Set output memory variable for current X-machine.
 * \param output New value for variable.
 */
void set_output(double output)
{
	if(current_xmachine->xmachine_Firm) (*current_xmachine->xmachine_Firm).output = output;
}

/** \fn double get_output()
 * \brief Get output memory variable from current X-machine.
 * \return Value for variable.
 */
double get_output()
{
	if(current_xmachine->xmachine_Firm) return (*current_xmachine->xmachine_Firm).output;

    // suppress compiler warning by returning dummy value /
    // this statement should rightfully NEVER be reached /
    return (double)0;
}

/** \fn void set_unit_costs(double unit_costs)
 * \brief Set unit_costs memory variable for current X-machine.
 * \param unit_costs New value for variable.
 */
void set_unit_costs(double unit_costs)
{
	if(current_xmachine->xmachine_Firm) (*current_xmachine->xmachine_Firm).unit_costs = unit_costs;
	if(current_xmachine->xmachine_IGFirm) (*current_xmachine->xmachine_IGFirm).unit_costs = unit_costs;
}

/** \fn double get_unit_costs()
 * \brief Get unit_costs memory variable from current X-machine.
 * \return Value for variable.
 */
double get_unit_costs()
{
	if(current_xmachine->xmachine_Firm) return (*current_xmachine->xmachine_Firm).unit_costs;
	if(current_xmachine->xmachine_IGFirm) return (*current_xmachine->xmachine_IGFirm).unit_costs;

    // suppress compiler warning by returning dummy value /
    // this statement should rightfully NEVER be reached /
    return (double)0;
}

/** \fn void set_total_supply(double total_supply)
 * \brief Set total_supply memory variable for current X-machine.
 * \param total_supply New value for variable.
 */
void set_total_supply(double total_supply)
{
	if(current_xmachine->xmachine_Firm) (*current_xmachine->xmachine_Firm).total_supply = total_supply;
	if(current_xmachine->xmachine_Mall) (*current_xmachine->xmachine_Mall).total_supply = total_supply;
}

/** \fn double get_total_supply()
 * \brief Get total_supply memory variable from current X-machine.
 * \return Value for variable.
 */
double get_total_supply()
{
	if(current_xmachine->xmachine_Firm) return (*current_xmachine->xmachine_Firm).total_supply;
	if(current_xmachine->xmachine_Mall) return (*current_xmachine->xmachine_Mall).total_supply;

    // suppress compiler warning by returning dummy value /
    // this statement should rightfully NEVER be reached /
    return (double)0;
}

/** \fn void set_production_costs(double production_costs)
 * \brief Set production_costs memory variable for current X-machine.
 * \param production_costs New value for variable.
 */
void set_production_costs(double production_costs)
{
	if(current_xmachine->xmachine_Firm) (*current_xmachine->xmachine_Firm).production_costs = production_costs;
}

/** \fn double get_production_costs()
 * \brief Get production_costs memory variable from current X-machine.
 * \return Value for variable.
 */
double get_production_costs()
{
	if(current_xmachine->xmachine_Firm) return (*current_xmachine->xmachine_Firm).production_costs;

    // suppress compiler warning by returning dummy value /
    // this statement should rightfully NEVER be reached /
    return (double)0;
}

/** \fn void set_total_buffer(double total_buffer)
 * \brief Set total_buffer memory variable for current X-machine.
 * \param total_buffer New value for variable.
 */
void set_total_buffer(double total_buffer)
{
	if(current_xmachine->xmachine_Firm) (*current_xmachine->xmachine_Firm).total_buffer = total_buffer;
}

/** \fn double get_total_buffer()
 * \brief Get total_buffer memory variable from current X-machine.
 * \return Value for variable.
 */
double get_total_buffer()
{
	if(current_xmachine->xmachine_Firm) return (*current_xmachine->xmachine_Firm).total_buffer;

    // suppress compiler warning by returning dummy value /
    // this statement should rightfully NEVER be reached /
    return (double)0;
}

/** \fn void set_revenue_per_day(double revenue_per_day)
 * \brief Set revenue_per_day memory variable for current X-machine.
 * \param revenue_per_day New value for variable.
 */
void set_revenue_per_day(double revenue_per_day)
{
	if(current_xmachine->xmachine_Firm) (*current_xmachine->xmachine_Firm).revenue_per_day = revenue_per_day;
	if(current_xmachine->xmachine_IGFirm) (*current_xmachine->xmachine_IGFirm).revenue_per_day = revenue_per_day;
}

/** \fn double get_revenue_per_day()
 * \brief Get revenue_per_day memory variable from current X-machine.
 * \return Value for variable.
 */
double get_revenue_per_day()
{
	if(current_xmachine->xmachine_Firm) return (*current_xmachine->xmachine_Firm).revenue_per_day;
	if(current_xmachine->xmachine_IGFirm) return (*current_xmachine->xmachine_IGFirm).revenue_per_day;

    // suppress compiler warning by returning dummy value /
    // this statement should rightfully NEVER be reached /
    return (double)0;
}

/** \fn estimators_linear_regression_array get_linear_regression_estimators()
 * \brief Get linear_regression_estimators memory variable from current X-machine.
 * \return Value for variable.
 */
estimators_linear_regression_array * get_linear_regression_estimators()
{
	if(current_xmachine->xmachine_Firm) return &(*current_xmachine->xmachine_Firm).linear_regression_estimators;

    // suppress compiler warning by returning dummy value /
    // this statement should rightfully NEVER be reached /
    return NULL;
}

/** \fn void set_technological_frontier(double technological_frontier)
 * \brief Set technological_frontier memory variable for current X-machine.
 * \param technological_frontier New value for variable.
 */
void set_technological_frontier(double technological_frontier)
{
	if(current_xmachine->xmachine_Firm) (*current_xmachine->xmachine_Firm).technological_frontier = technological_frontier;
}

/** \fn double get_technological_frontier()
 * \brief Get technological_frontier memory variable from current X-machine.
 * \return Value for variable.
 */
double get_technological_frontier()
{
	if(current_xmachine->xmachine_Firm) return (*current_xmachine->xmachine_Firm).technological_frontier;

    // suppress compiler warning by returning dummy value /
    // this statement should rightfully NEVER be reached /
    return (double)0;
}

/** \fn adt_technology_vintages_array get_technology_vintages()
 * \brief Get technology_vintages memory variable from current X-machine.
 * \return Value for variable.
 */
adt_technology_vintages_array * get_technology_vintages()
{
	if(current_xmachine->xmachine_Firm) return &(*current_xmachine->xmachine_Firm).technology_vintages;

    // suppress compiler warning by returning dummy value /
    // this statement should rightfully NEVER be reached /
    return NULL;
}

/** \fn void set_vintage_selected(int vintage_selected)
 * \brief Set vintage_selected memory variable for current X-machine.
 * \param vintage_selected New value for variable.
 */
void set_vintage_selected(int vintage_selected)
{
	if(current_xmachine->xmachine_Firm) (*current_xmachine->xmachine_Firm).vintage_selected = vintage_selected;
}

/** \fn int get_vintage_selected()
 * \brief Get vintage_selected memory variable from current X-machine.
 * \return Value for variable.
 */
int get_vintage_selected()
{
	if(current_xmachine->xmachine_Firm) return (*current_xmachine->xmachine_Firm).vintage_selected;

    // suppress compiler warning by returning dummy value /
    // this statement should rightfully NEVER be reached /
    return (int)0;
}

/** \fn void set_investment_subsidy_type(int investment_subsidy_type)
 * \brief Set investment_subsidy_type memory variable for current X-machine.
 * \param investment_subsidy_type New value for variable.
 */
void set_investment_subsidy_type(int investment_subsidy_type)
{
	if(current_xmachine->xmachine_Firm) (*current_xmachine->xmachine_Firm).investment_subsidy_type = investment_subsidy_type;
}

/** \fn int get_investment_subsidy_type()
 * \brief Get investment_subsidy_type memory variable from current X-machine.
 * \return Value for variable.
 */
int get_investment_subsidy_type()
{
	if(current_xmachine->xmachine_Firm) return (*current_xmachine->xmachine_Firm).investment_subsidy_type;

    // suppress compiler warning by returning dummy value /
    // this statement should rightfully NEVER be reached /
    return (int)0;
}

/** \fn void set_initial_market_size(double initial_market_size)
 * \brief Set initial_market_size memory variable for current X-machine.
 * \param initial_market_size New value for variable.
 */
void set_initial_market_size(double initial_market_size)
{
	if(current_xmachine->xmachine_Firm) (*current_xmachine->xmachine_Firm).initial_market_size = initial_market_size;
}

/** \fn double get_initial_market_size()
 * \brief Get initial_market_size memory variable from current X-machine.
 * \return Value for variable.
 */
double get_initial_market_size()
{
	if(current_xmachine->xmachine_Firm) return (*current_xmachine->xmachine_Firm).initial_market_size;

    // suppress compiler warning by returning dummy value /
    // this statement should rightfully NEVER be reached /
    return (double)0;
}

/** \fn void set_initial_technology(double initial_technology)
 * \brief Set initial_technology memory variable for current X-machine.
 * \param initial_technology New value for variable.
 */
void set_initial_technology(double initial_technology)
{
	if(current_xmachine->xmachine_Firm) (*current_xmachine->xmachine_Firm).initial_technology = initial_technology;
}

/** \fn double get_initial_technology()
 * \brief Get initial_technology memory variable from current X-machine.
 * \return Value for variable.
 */
double get_initial_technology()
{
	if(current_xmachine->xmachine_Firm) return (*current_xmachine->xmachine_Firm).initial_technology;

    // suppress compiler warning by returning dummy value /
    // this statement should rightfully NEVER be reached /
    return (double)0;
}

/** \fn void set_utilization_capacity(double utilization_capacity)
 * \brief Set utilization_capacity memory variable for current X-machine.
 * \param utilization_capacity New value for variable.
 */
void set_utilization_capacity(double utilization_capacity)
{
	if(current_xmachine->xmachine_Firm) (*current_xmachine->xmachine_Firm).utilization_capacity = utilization_capacity;
}

/** \fn double get_utilization_capacity()
 * \brief Get utilization_capacity memory variable from current X-machine.
 * \return Value for variable.
 */
double get_utilization_capacity()
{
	if(current_xmachine->xmachine_Firm) return (*current_xmachine->xmachine_Firm).utilization_capacity;

    // suppress compiler warning by returning dummy value /
    // this statement should rightfully NEVER be reached /
    return (double)0;
}

/** \fn void set_used_capital_units(double used_capital_units)
 * \brief Set used_capital_units memory variable for current X-machine.
 * \param used_capital_units New value for variable.
 */
void set_used_capital_units(double used_capital_units)
{
	if(current_xmachine->xmachine_Firm) (*current_xmachine->xmachine_Firm).used_capital_units = used_capital_units;
}

/** \fn double get_used_capital_units()
 * \brief Get used_capital_units memory variable from current X-machine.
 * \return Value for variable.
 */
double get_used_capital_units()
{
	if(current_xmachine->xmachine_Firm) return (*current_xmachine->xmachine_Firm).used_capital_units;

    // suppress compiler warning by returning dummy value /
    // this statement should rightfully NEVER be reached /
    return (double)0;
}

/** \fn void set_cum_revenue(double cum_revenue)
 * \brief Set cum_revenue memory variable for current X-machine.
 * \param cum_revenue New value for variable.
 */
void set_cum_revenue(double cum_revenue)
{
	if(current_xmachine->xmachine_Firm) (*current_xmachine->xmachine_Firm).cum_revenue = cum_revenue;
	if(current_xmachine->xmachine_IGFirm) (*current_xmachine->xmachine_IGFirm).cum_revenue = cum_revenue;
}

/** \fn double get_cum_revenue()
 * \brief Get cum_revenue memory variable from current X-machine.
 * \return Value for variable.
 */
double get_cum_revenue()
{
	if(current_xmachine->xmachine_Firm) return (*current_xmachine->xmachine_Firm).cum_revenue;
	if(current_xmachine->xmachine_IGFirm) return (*current_xmachine->xmachine_IGFirm).cum_revenue;

    // suppress compiler warning by returning dummy value /
    // this statement should rightfully NEVER be reached /
    return (double)0;
}

/** \fn sales_statistics_array get_malls_sales_statistics()
 * \brief Get malls_sales_statistics memory variable from current X-machine.
 * \return Value for variable.
 */
sales_statistics_array * get_malls_sales_statistics()
{
	if(current_xmachine->xmachine_Firm) return &(*current_xmachine->xmachine_Firm).malls_sales_statistics;

    // suppress compiler warning by returning dummy value /
    // this statement should rightfully NEVER be reached /
    return NULL;
}

/** \fn void set_quality(double quality)
 * \brief Set quality memory variable for current X-machine.
 * \param quality New value for variable.
 */
void set_quality(double quality)
{
	if(current_xmachine->xmachine_Firm) (*current_xmachine->xmachine_Firm).quality = quality;
}

/** \fn double get_quality()
 * \brief Get quality memory variable from current X-machine.
 * \return Value for variable.
 */
double get_quality()
{
	if(current_xmachine->xmachine_Firm) return (*current_xmachine->xmachine_Firm).quality;

    // suppress compiler warning by returning dummy value /
    // this statement should rightfully NEVER be reached /
    return (double)0;
}

/** \fn void set_price(double price)
 * \brief Set price memory variable for current X-machine.
 * \param price New value for variable.
 */
void set_price(double price)
{
	if(current_xmachine->xmachine_Firm) (*current_xmachine->xmachine_Firm).price = price;
}

/** \fn double get_price()
 * \brief Get price memory variable from current X-machine.
 * \return Value for variable.
 */
double get_price()
{
	if(current_xmachine->xmachine_Firm) return (*current_xmachine->xmachine_Firm).price;

    // suppress compiler warning by returning dummy value /
    // this statement should rightfully NEVER be reached /
    return (double)0;
}

/** \fn void set_price_last_month(double price_last_month)
 * \brief Set price_last_month memory variable for current X-machine.
 * \param price_last_month New value for variable.
 */
void set_price_last_month(double price_last_month)
{
	if(current_xmachine->xmachine_Firm) (*current_xmachine->xmachine_Firm).price_last_month = price_last_month;
}

/** \fn double get_price_last_month()
 * \brief Get price_last_month memory variable from current X-machine.
 * \return Value for variable.
 */
double get_price_last_month()
{
	if(current_xmachine->xmachine_Firm) return (*current_xmachine->xmachine_Firm).price_last_month;

    // suppress compiler warning by returning dummy value /
    // this statement should rightfully NEVER be reached /
    return (double)0;
}

/** \fn void set_actual_mark_up(double actual_mark_up)
 * \brief Set actual_mark_up memory variable for current X-machine.
 * \param actual_mark_up New value for variable.
 */
void set_actual_mark_up(double actual_mark_up)
{
	if(current_xmachine->xmachine_Firm) (*current_xmachine->xmachine_Firm).actual_mark_up = actual_mark_up;
}

/** \fn double get_actual_mark_up()
 * \brief Get actual_mark_up memory variable from current X-machine.
 * \return Value for variable.
 */
double get_actual_mark_up()
{
	if(current_xmachine->xmachine_Firm) return (*current_xmachine->xmachine_Firm).actual_mark_up;

    // suppress compiler warning by returning dummy value /
    // this statement should rightfully NEVER be reached /
    return (double)0;
}

/** \fn void set_demand_capital_stock(double demand_capital_stock)
 * \brief Set demand_capital_stock memory variable for current X-machine.
 * \param demand_capital_stock New value for variable.
 */
void set_demand_capital_stock(double demand_capital_stock)
{
	if(current_xmachine->xmachine_Firm) (*current_xmachine->xmachine_Firm).demand_capital_stock = demand_capital_stock;
}

/** \fn double get_demand_capital_stock()
 * \brief Get demand_capital_stock memory variable from current X-machine.
 * \return Value for variable.
 */
double get_demand_capital_stock()
{
	if(current_xmachine->xmachine_Firm) return (*current_xmachine->xmachine_Firm).demand_capital_stock;

    // suppress compiler warning by returning dummy value /
    // this statement should rightfully NEVER be reached /
    return (double)0;
}

/** \fn void set_effective_investments(double effective_investments)
 * \brief Set effective_investments memory variable for current X-machine.
 * \param effective_investments New value for variable.
 */
void set_effective_investments(double effective_investments)
{
	if(current_xmachine->xmachine_Firm) (*current_xmachine->xmachine_Firm).effective_investments = effective_investments;
}

/** \fn double get_effective_investments()
 * \brief Get effective_investments memory variable from current X-machine.
 * \return Value for variable.
 */
double get_effective_investments()
{
	if(current_xmachine->xmachine_Firm) return (*current_xmachine->xmachine_Firm).effective_investments;

    // suppress compiler warning by returning dummy value /
    // this statement should rightfully NEVER be reached /
    return (double)0;
}

/** \fn void set_effective_capital_stock(double effective_capital_stock)
 * \brief Set effective_capital_stock memory variable for current X-machine.
 * \param effective_capital_stock New value for variable.
 */
void set_effective_capital_stock(double effective_capital_stock)
{
	if(current_xmachine->xmachine_Firm) (*current_xmachine->xmachine_Firm).effective_capital_stock = effective_capital_stock;
}

/** \fn double get_effective_capital_stock()
 * \brief Get effective_capital_stock memory variable from current X-machine.
 * \return Value for variable.
 */
double get_effective_capital_stock()
{
	if(current_xmachine->xmachine_Firm) return (*current_xmachine->xmachine_Firm).effective_capital_stock;

    // suppress compiler warning by returning dummy value /
    // this statement should rightfully NEVER be reached /
    return (double)0;
}

/** \fn void set_planned_production_costs(double planned_production_costs)
 * \brief Set planned_production_costs memory variable for current X-machine.
 * \param planned_production_costs New value for variable.
 */
void set_planned_production_costs(double planned_production_costs)
{
	if(current_xmachine->xmachine_Firm) (*current_xmachine->xmachine_Firm).planned_production_costs = planned_production_costs;
}

/** \fn double get_planned_production_costs()
 * \brief Get planned_production_costs memory variable from current X-machine.
 * \return Value for variable.
 */
double get_planned_production_costs()
{
	if(current_xmachine->xmachine_Firm) return (*current_xmachine->xmachine_Firm).planned_production_costs;

    // suppress compiler warning by returning dummy value /
    // this statement should rightfully NEVER be reached /
    return (double)0;
}

/** \fn void set_labour_costs_production(double labour_costs_production)
 * \brief Set labour_costs_production memory variable for current X-machine.
 * \param labour_costs_production New value for variable.
 */
void set_labour_costs_production(double labour_costs_production)
{
	if(current_xmachine->xmachine_Firm) (*current_xmachine->xmachine_Firm).labour_costs_production = labour_costs_production;
}

/** \fn double get_labour_costs_production()
 * \brief Get labour_costs_production memory variable from current X-machine.
 * \return Value for variable.
 */
double get_labour_costs_production()
{
	if(current_xmachine->xmachine_Firm) return (*current_xmachine->xmachine_Firm).labour_costs_production;

    // suppress compiler warning by returning dummy value /
    // this statement should rightfully NEVER be reached /
    return (double)0;
}

/** \fn void set_labour_costs_innovation(double labour_costs_innovation)
 * \brief Set labour_costs_innovation memory variable for current X-machine.
 * \param labour_costs_innovation New value for variable.
 */
void set_labour_costs_innovation(double labour_costs_innovation)
{
	if(current_xmachine->xmachine_Firm) (*current_xmachine->xmachine_Firm).labour_costs_innovation = labour_costs_innovation;
}

/** \fn double get_labour_costs_innovation()
 * \brief Get labour_costs_innovation memory variable from current X-machine.
 * \return Value for variable.
 */
double get_labour_costs_innovation()
{
	if(current_xmachine->xmachine_Firm) return (*current_xmachine->xmachine_Firm).labour_costs_innovation;

    // suppress compiler warning by returning dummy value /
    // this statement should rightfully NEVER be reached /
    return (double)0;
}

/** \fn void set_intermediate_quality_level_developing(double intermediate_quality_level_developing)
 * \brief Set intermediate_quality_level_developing memory variable for current X-machine.
 * \param intermediate_quality_level_developing New value for variable.
 */
void set_intermediate_quality_level_developing(double intermediate_quality_level_developing)
{
	if(current_xmachine->xmachine_Firm) (*current_xmachine->xmachine_Firm).intermediate_quality_level_developing = intermediate_quality_level_developing;
}

/** \fn double get_intermediate_quality_level_developing()
 * \brief Get intermediate_quality_level_developing memory variable from current X-machine.
 * \return Value for variable.
 */
double get_intermediate_quality_level_developing()
{
	if(current_xmachine->xmachine_Firm) return (*current_xmachine->xmachine_Firm).intermediate_quality_level_developing;

    // suppress compiler warning by returning dummy value /
    // this statement should rightfully NEVER be reached /
    return (double)0;
}

/** \fn void set_adaption_production_volume_due_to_insufficient_finances(double adaption_production_volume_due_to_insufficient_finances)
 * \brief Set adaption_production_volume_due_to_insufficient_finances memory variable for current X-machine.
 * \param adaption_production_volume_due_to_insufficient_finances New value for variable.
 */
void set_adaption_production_volume_due_to_insufficient_finances(double adaption_production_volume_due_to_insufficient_finances)
{
	if(current_xmachine->xmachine_Firm) (*current_xmachine->xmachine_Firm).adaption_production_volume_due_to_insufficient_finances = adaption_production_volume_due_to_insufficient_finances;
}

/** \fn double get_adaption_production_volume_due_to_insufficient_finances()
 * \brief Get adaption_production_volume_due_to_insufficient_finances memory variable from current X-machine.
 * \return Value for variable.
 */
double get_adaption_production_volume_due_to_insufficient_finances()
{
	if(current_xmachine->xmachine_Firm) return (*current_xmachine->xmachine_Firm).adaption_production_volume_due_to_insufficient_finances;

    // suppress compiler warning by returning dummy value /
    // this statement should rightfully NEVER be reached /
    return (double)0;
}

/** \fn sold_quantities_per_mall_array get_sold_quantities()
 * \brief Get sold_quantities memory variable from current X-machine.
 * \return Value for variable.
 */
sold_quantities_per_mall_array * get_sold_quantities()
{
	if(current_xmachine->xmachine_Firm) return &(*current_xmachine->xmachine_Firm).sold_quantities;

    // suppress compiler warning by returning dummy value /
    // this statement should rightfully NEVER be reached /
    return NULL;
}

/** \fn void set_total_sold_quantity(double total_sold_quantity)
 * \brief Set total_sold_quantity memory variable for current X-machine.
 * \param total_sold_quantity New value for variable.
 */
void set_total_sold_quantity(double total_sold_quantity)
{
	if(current_xmachine->xmachine_Firm) (*current_xmachine->xmachine_Firm).total_sold_quantity = total_sold_quantity;
}

/** \fn double get_total_sold_quantity()
 * \brief Get total_sold_quantity memory variable from current X-machine.
 * \return Value for variable.
 */
double get_total_sold_quantity()
{
	if(current_xmachine->xmachine_Firm) return (*current_xmachine->xmachine_Firm).total_sold_quantity;

    // suppress compiler warning by returning dummy value /
    // this statement should rightfully NEVER be reached /
    return (double)0;
}

/** \fn void set_cum_total_sold_quantity(double cum_total_sold_quantity)
 * \brief Set cum_total_sold_quantity memory variable for current X-machine.
 * \param cum_total_sold_quantity New value for variable.
 */
void set_cum_total_sold_quantity(double cum_total_sold_quantity)
{
	if(current_xmachine->xmachine_Firm) (*current_xmachine->xmachine_Firm).cum_total_sold_quantity = cum_total_sold_quantity;
}

/** \fn double get_cum_total_sold_quantity()
 * \brief Get cum_total_sold_quantity memory variable from current X-machine.
 * \return Value for variable.
 */
double get_cum_total_sold_quantity()
{
	if(current_xmachine->xmachine_Firm) return (*current_xmachine->xmachine_Firm).cum_total_sold_quantity;

    // suppress compiler warning by returning dummy value /
    // this statement should rightfully NEVER be reached /
    return (double)0;
}

/** \fn void set_sold_quantity_in_calendar_month(double sold_quantity_in_calendar_month)
 * \brief Set sold_quantity_in_calendar_month memory variable for current X-machine.
 * \param sold_quantity_in_calendar_month New value for variable.
 */
void set_sold_quantity_in_calendar_month(double sold_quantity_in_calendar_month)
{
	if(current_xmachine->xmachine_Firm) (*current_xmachine->xmachine_Firm).sold_quantity_in_calendar_month = sold_quantity_in_calendar_month;
}

/** \fn double get_sold_quantity_in_calendar_month()
 * \brief Get sold_quantity_in_calendar_month memory variable from current X-machine.
 * \return Value for variable.
 */
double get_sold_quantity_in_calendar_month()
{
	if(current_xmachine->xmachine_Firm) return (*current_xmachine->xmachine_Firm).sold_quantity_in_calendar_month;

    // suppress compiler warning by returning dummy value /
    // this statement should rightfully NEVER be reached /
    return (double)0;
}

/** \fn delivery_volume_per_mall_array get_delivery_volume()
 * \brief Get delivery_volume memory variable from current X-machine.
 * \return Value for variable.
 */
delivery_volume_per_mall_array * get_delivery_volume()
{
	if(current_xmachine->xmachine_Firm) return &(*current_xmachine->xmachine_Firm).delivery_volume;

    // suppress compiler warning by returning dummy value /
    // this statement should rightfully NEVER be reached /
    return NULL;
}

/** \fn delivery_volume_per_mall_array get_planned_delivery_volume()
 * \brief Get planned_delivery_volume memory variable from current X-machine.
 * \return Value for variable.
 */
delivery_volume_per_mall_array * get_planned_delivery_volume()
{
	if(current_xmachine->xmachine_Firm) return &(*current_xmachine->xmachine_Firm).planned_delivery_volume;

    // suppress compiler warning by returning dummy value /
    // this statement should rightfully NEVER be reached /
    return NULL;
}

/** \fn mall_info_array get_current_mall_stocks()
 * \brief Get current_mall_stocks memory variable from current X-machine.
 * \return Value for variable.
 */
mall_info_array * get_current_mall_stocks()
{
	if(current_xmachine->xmachine_Firm) return &(*current_xmachine->xmachine_Firm).current_mall_stocks;

    // suppress compiler warning by returning dummy value /
    // this statement should rightfully NEVER be reached /
    return NULL;
}

/** \fn double_array get_last_planned_production_quantities()
 * \brief Get last_planned_production_quantities memory variable from current X-machine.
 * \return Value for variable.
 */
double_array * get_last_planned_production_quantities()
{
	if(current_xmachine->xmachine_Firm) return &(*current_xmachine->xmachine_Firm).last_planned_production_quantities;

    // suppress compiler warning by returning dummy value /
    // this statement should rightfully NEVER be reached /
    return NULL;
}

/** \fn void set_total_external_financing_obtained(double total_external_financing_obtained)
 * \brief Set total_external_financing_obtained memory variable for current X-machine.
 * \param total_external_financing_obtained New value for variable.
 */
void set_total_external_financing_obtained(double total_external_financing_obtained)
{
	if(current_xmachine->xmachine_Firm) (*current_xmachine->xmachine_Firm).total_external_financing_obtained = total_external_financing_obtained;
}

/** \fn double get_total_external_financing_obtained()
 * \brief Get total_external_financing_obtained memory variable from current X-machine.
 * \return Value for variable.
 */
double get_total_external_financing_obtained()
{
	if(current_xmachine->xmachine_Firm) return (*current_xmachine->xmachine_Firm).total_external_financing_obtained;

    // suppress compiler warning by returning dummy value /
    // this statement should rightfully NEVER be reached /
    return (double)0;
}

/** \fn void set_capital_costs(double capital_costs)
 * \brief Set capital_costs memory variable for current X-machine.
 * \param capital_costs New value for variable.
 */
void set_capital_costs(double capital_costs)
{
	if(current_xmachine->xmachine_Firm) (*current_xmachine->xmachine_Firm).capital_costs = capital_costs;
}

/** \fn double get_capital_costs()
 * \brief Get capital_costs memory variable from current X-machine.
 * \return Value for variable.
 */
double get_capital_costs()
{
	if(current_xmachine->xmachine_Firm) return (*current_xmachine->xmachine_Firm).capital_costs;

    // suppress compiler warning by returning dummy value /
    // this statement should rightfully NEVER be reached /
    return (double)0;
}

/** \fn void set_employees_needed_production(int employees_needed_production)
 * \brief Set employees_needed_production memory variable for current X-machine.
 * \param employees_needed_production New value for variable.
 */
void set_employees_needed_production(int employees_needed_production)
{
	if(current_xmachine->xmachine_Firm) (*current_xmachine->xmachine_Firm).employees_needed_production = employees_needed_production;
}

/** \fn int get_employees_needed_production()
 * \brief Get employees_needed_production memory variable from current X-machine.
 * \return Value for variable.
 */
int get_employees_needed_production()
{
	if(current_xmachine->xmachine_Firm) return (*current_xmachine->xmachine_Firm).employees_needed_production;

    // suppress compiler warning by returning dummy value /
    // this statement should rightfully NEVER be reached /
    return (int)0;
}

/** \fn void set_no_employees_production(int no_employees_production)
 * \brief Set no_employees_production memory variable for current X-machine.
 * \param no_employees_production New value for variable.
 */
void set_no_employees_production(int no_employees_production)
{
	if(current_xmachine->xmachine_Firm) (*current_xmachine->xmachine_Firm).no_employees_production = no_employees_production;
	if(current_xmachine->xmachine_Eurostat) (*current_xmachine->xmachine_Eurostat).no_employees_production = no_employees_production;
}

/** \fn int get_no_employees_production()
 * \brief Get no_employees_production memory variable from current X-machine.
 * \return Value for variable.
 */
int get_no_employees_production()
{
	if(current_xmachine->xmachine_Firm) return (*current_xmachine->xmachine_Firm).no_employees_production;
	if(current_xmachine->xmachine_Eurostat) return (*current_xmachine->xmachine_Eurostat).no_employees_production;

    // suppress compiler warning by returning dummy value /
    // this statement should rightfully NEVER be reached /
    return (int)0;
}

/** \fn void set_planned_innovation_expenditures(double planned_innovation_expenditures)
 * \brief Set planned_innovation_expenditures memory variable for current X-machine.
 * \param planned_innovation_expenditures New value for variable.
 */
void set_planned_innovation_expenditures(double planned_innovation_expenditures)
{
	if(current_xmachine->xmachine_Firm) (*current_xmachine->xmachine_Firm).planned_innovation_expenditures = planned_innovation_expenditures;
}

/** \fn double get_planned_innovation_expenditures()
 * \brief Get planned_innovation_expenditures memory variable from current X-machine.
 * \return Value for variable.
 */
double get_planned_innovation_expenditures()
{
	if(current_xmachine->xmachine_Firm) return (*current_xmachine->xmachine_Firm).planned_innovation_expenditures;

    // suppress compiler warning by returning dummy value /
    // this statement should rightfully NEVER be reached /
    return (double)0;
}

/** \fn void set_planned_expenditures_production_innovation(double planned_expenditures_production_innovation)
 * \brief Set planned_expenditures_production_innovation memory variable for current X-machine.
 * \param planned_expenditures_production_innovation New value for variable.
 */
void set_planned_expenditures_production_innovation(double planned_expenditures_production_innovation)
{
	if(current_xmachine->xmachine_Firm) (*current_xmachine->xmachine_Firm).planned_expenditures_production_innovation = planned_expenditures_production_innovation;
}

/** \fn double get_planned_expenditures_production_innovation()
 * \brief Get planned_expenditures_production_innovation memory variable from current X-machine.
 * \return Value for variable.
 */
double get_planned_expenditures_production_innovation()
{
	if(current_xmachine->xmachine_Firm) return (*current_xmachine->xmachine_Firm).planned_expenditures_production_innovation;

    // suppress compiler warning by returning dummy value /
    // this statement should rightfully NEVER be reached /
    return (double)0;
}

/** \fn void set_labour_costs(double labour_costs)
 * \brief Set labour_costs memory variable for current X-machine.
 * \param labour_costs New value for variable.
 */
void set_labour_costs(double labour_costs)
{
	if(current_xmachine->xmachine_Firm) (*current_xmachine->xmachine_Firm).labour_costs = labour_costs;
}

/** \fn double get_labour_costs()
 * \brief Get labour_costs memory variable from current X-machine.
 * \return Value for variable.
 */
double get_labour_costs()
{
	if(current_xmachine->xmachine_Firm) return (*current_xmachine->xmachine_Firm).labour_costs;

    // suppress compiler warning by returning dummy value /
    // this statement should rightfully NEVER be reached /
    return (double)0;
}

/** \fn void set_labour_costs_per_unit(double labour_costs_per_unit)
 * \brief Set labour_costs_per_unit memory variable for current X-machine.
 * \param labour_costs_per_unit New value for variable.
 */
void set_labour_costs_per_unit(double labour_costs_per_unit)
{
	if(current_xmachine->xmachine_Firm) (*current_xmachine->xmachine_Firm).labour_costs_per_unit = labour_costs_per_unit;
}

/** \fn double get_labour_costs_per_unit()
 * \brief Get labour_costs_per_unit memory variable from current X-machine.
 * \return Value for variable.
 */
double get_labour_costs_per_unit()
{
	if(current_xmachine->xmachine_Firm) return (*current_xmachine->xmachine_Firm).labour_costs_per_unit;

    // suppress compiler warning by returning dummy value /
    // this statement should rightfully NEVER be reached /
    return (double)0;
}

/** \fn adt_capital_stock_vintages_array get_capital_stock_vintages()
 * \brief Get capital_stock_vintages memory variable from current X-machine.
 * \return Value for variable.
 */
adt_capital_stock_vintages_array * get_capital_stock_vintages()
{
	if(current_xmachine->xmachine_Firm) return &(*current_xmachine->xmachine_Firm).capital_stock_vintages;

    // suppress compiler warning by returning dummy value /
    // this statement should rightfully NEVER be reached /
    return NULL;
}

/** \fn void set_vintage_choice_taken(int vintage_choice_taken)
 * \brief Set vintage_choice_taken memory variable for current X-machine.
 * \param vintage_choice_taken New value for variable.
 */
void set_vintage_choice_taken(int vintage_choice_taken)
{
	if(current_xmachine->xmachine_Firm) (*current_xmachine->xmachine_Firm).vintage_choice_taken = vintage_choice_taken;
}

/** \fn int get_vintage_choice_taken()
 * \brief Get vintage_choice_taken memory variable from current X-machine.
 * \return Value for variable.
 */
int get_vintage_choice_taken()
{
	if(current_xmachine->xmachine_Firm) return (*current_xmachine->xmachine_Firm).vintage_choice_taken;

    // suppress compiler warning by returning dummy value /
    // this statement should rightfully NEVER be reached /
    return (int)0;
}

/** \fn financing_capital_array get_capital_financing()
 * \brief Get capital_financing memory variable from current X-machine.
 * \return Value for variable.
 */
financing_capital_array * get_capital_financing()
{
	if(current_xmachine->xmachine_Firm) return &(*current_xmachine->xmachine_Firm).capital_financing;

    // suppress compiler warning by returning dummy value /
    // this statement should rightfully NEVER be reached /
    return NULL;
}

/** \fn void set_financial_resources_for_production(double financial_resources_for_production)
 * \brief Set financial_resources_for_production memory variable for current X-machine.
 * \param financial_resources_for_production New value for variable.
 */
void set_financial_resources_for_production(double financial_resources_for_production)
{
	if(current_xmachine->xmachine_Firm) (*current_xmachine->xmachine_Firm).financial_resources_for_production = financial_resources_for_production;
}

/** \fn double get_financial_resources_for_production()
 * \brief Get financial_resources_for_production memory variable from current X-machine.
 * \return Value for variable.
 */
double get_financial_resources_for_production()
{
	if(current_xmachine->xmachine_Firm) return (*current_xmachine->xmachine_Firm).financial_resources_for_production;

    // suppress compiler warning by returning dummy value /
    // this statement should rightfully NEVER be reached /
    return (double)0;
}

/** \fn void set_total_units_local_inventory(double total_units_local_inventory)
 * \brief Set total_units_local_inventory memory variable for current X-machine.
 * \param total_units_local_inventory New value for variable.
 */
void set_total_units_local_inventory(double total_units_local_inventory)
{
	if(current_xmachine->xmachine_Firm) (*current_xmachine->xmachine_Firm).total_units_local_inventory = total_units_local_inventory;
}

/** \fn double get_total_units_local_inventory()
 * \brief Get total_units_local_inventory memory variable from current X-machine.
 * \return Value for variable.
 */
double get_total_units_local_inventory()
{
	if(current_xmachine->xmachine_Firm) return (*current_xmachine->xmachine_Firm).total_units_local_inventory;

    // suppress compiler warning by returning dummy value /
    // this statement should rightfully NEVER be reached /
    return (double)0;
}

/** \fn void set_calc_capital_costs(double calc_capital_costs)
 * \brief Set calc_capital_costs memory variable for current X-machine.
 * \param calc_capital_costs New value for variable.
 */
void set_calc_capital_costs(double calc_capital_costs)
{
	if(current_xmachine->xmachine_Firm) (*current_xmachine->xmachine_Firm).calc_capital_costs = calc_capital_costs;
}

/** \fn double get_calc_capital_costs()
 * \brief Get calc_capital_costs memory variable from current X-machine.
 * \return Value for variable.
 */
double get_calc_capital_costs()
{
	if(current_xmachine->xmachine_Firm) return (*current_xmachine->xmachine_Firm).calc_capital_costs;

    // suppress compiler warning by returning dummy value /
    // this statement should rightfully NEVER be reached /
    return (double)0;
}

/** \fn void set_calc_production_costs(double calc_production_costs)
 * \brief Set calc_production_costs memory variable for current X-machine.
 * \param calc_production_costs New value for variable.
 */
void set_calc_production_costs(double calc_production_costs)
{
	if(current_xmachine->xmachine_Firm) (*current_xmachine->xmachine_Firm).calc_production_costs = calc_production_costs;
	if(current_xmachine->xmachine_IGFirm) (*current_xmachine->xmachine_IGFirm).calc_production_costs = calc_production_costs;
}

/** \fn double get_calc_production_costs()
 * \brief Get calc_production_costs memory variable from current X-machine.
 * \return Value for variable.
 */
double get_calc_production_costs()
{
	if(current_xmachine->xmachine_Firm) return (*current_xmachine->xmachine_Firm).calc_production_costs;
	if(current_xmachine->xmachine_IGFirm) return (*current_xmachine->xmachine_IGFirm).calc_production_costs;

    // suppress compiler warning by returning dummy value /
    // this statement should rightfully NEVER be reached /
    return (double)0;
}

/** \fn void set_firm_productivity(double firm_productivity)
 * \brief Set firm_productivity memory variable for current X-machine.
 * \param firm_productivity New value for variable.
 */
void set_firm_productivity(double firm_productivity)
{
	if(current_xmachine->xmachine_Firm) (*current_xmachine->xmachine_Firm).firm_productivity = firm_productivity;
}

/** \fn double get_firm_productivity()
 * \brief Get firm_productivity memory variable from current X-machine.
 * \return Value for variable.
 */
double get_firm_productivity()
{
	if(current_xmachine->xmachine_Firm) return (*current_xmachine->xmachine_Firm).firm_productivity;

    // suppress compiler warning by returning dummy value /
    // this statement should rightfully NEVER be reached /
    return (double)0;
}

/** \fn void set_total_productivity_capital_stock(double total_productivity_capital_stock)
 * \brief Set total_productivity_capital_stock memory variable for current X-machine.
 * \param total_productivity_capital_stock New value for variable.
 */
void set_total_productivity_capital_stock(double total_productivity_capital_stock)
{
	if(current_xmachine->xmachine_Firm) (*current_xmachine->xmachine_Firm).total_productivity_capital_stock = total_productivity_capital_stock;
}

/** \fn double get_total_productivity_capital_stock()
 * \brief Get total_productivity_capital_stock memory variable from current X-machine.
 * \return Value for variable.
 */
double get_total_productivity_capital_stock()
{
	if(current_xmachine->xmachine_Firm) return (*current_xmachine->xmachine_Firm).total_productivity_capital_stock;

    // suppress compiler warning by returning dummy value /
    // this statement should rightfully NEVER be reached /
    return (double)0;
}

/** \fn void set_firm_productivity_last_year(double firm_productivity_last_year)
 * \brief Set firm_productivity_last_year memory variable for current X-machine.
 * \param firm_productivity_last_year New value for variable.
 */
void set_firm_productivity_last_year(double firm_productivity_last_year)
{
	if(current_xmachine->xmachine_Firm) (*current_xmachine->xmachine_Firm).firm_productivity_last_year = firm_productivity_last_year;
}

/** \fn double get_firm_productivity_last_year()
 * \brief Get firm_productivity_last_year memory variable from current X-machine.
 * \return Value for variable.
 */
double get_firm_productivity_last_year()
{
	if(current_xmachine->xmachine_Firm) return (*current_xmachine->xmachine_Firm).firm_productivity_last_year;

    // suppress compiler warning by returning dummy value /
    // this statement should rightfully NEVER be reached /
    return (double)0;
}

/** \fn void set_firm_productivity_progress(double firm_productivity_progress)
 * \brief Set firm_productivity_progress memory variable for current X-machine.
 * \param firm_productivity_progress New value for variable.
 */
void set_firm_productivity_progress(double firm_productivity_progress)
{
	if(current_xmachine->xmachine_Firm) (*current_xmachine->xmachine_Firm).firm_productivity_progress = firm_productivity_progress;
}

/** \fn double get_firm_productivity_progress()
 * \brief Get firm_productivity_progress memory variable from current X-machine.
 * \return Value for variable.
 */
double get_firm_productivity_progress()
{
	if(current_xmachine->xmachine_Firm) return (*current_xmachine->xmachine_Firm).firm_productivity_progress;

    // suppress compiler warning by returning dummy value /
    // this statement should rightfully NEVER be reached /
    return (double)0;
}

/** \fn void set_sold_quantity_in_last_calendar_month(double sold_quantity_in_last_calendar_month)
 * \brief Set sold_quantity_in_last_calendar_month memory variable for current X-machine.
 * \param sold_quantity_in_last_calendar_month New value for variable.
 */
void set_sold_quantity_in_last_calendar_month(double sold_quantity_in_last_calendar_month)
{
	if(current_xmachine->xmachine_Firm) (*current_xmachine->xmachine_Firm).sold_quantity_in_last_calendar_month = sold_quantity_in_last_calendar_month;
}

/** \fn double get_sold_quantity_in_last_calendar_month()
 * \brief Get sold_quantity_in_last_calendar_month memory variable from current X-machine.
 * \return Value for variable.
 */
double get_sold_quantity_in_last_calendar_month()
{
	if(current_xmachine->xmachine_Firm) return (*current_xmachine->xmachine_Firm).sold_quantity_in_last_calendar_month;

    // suppress compiler warning by returning dummy value /
    // this statement should rightfully NEVER be reached /
    return (double)0;
}

/** \fn double_array get_last_sold_quantities()
 * \brief Get last_sold_quantities memory variable from current X-machine.
 * \return Value for variable.
 */
double_array * get_last_sold_quantities()
{
	if(current_xmachine->xmachine_Firm) return &(*current_xmachine->xmachine_Firm).last_sold_quantities;

    // suppress compiler warning by returning dummy value /
    // this statement should rightfully NEVER be reached /
    return NULL;
}

/** \fn double_array get_last_revenues()
 * \brief Get last_revenues memory variable from current X-machine.
 * \return Value for variable.
 */
double_array * get_last_revenues()
{
	if(current_xmachine->xmachine_Firm) return &(*current_xmachine->xmachine_Firm).last_revenues;

    // suppress compiler warning by returning dummy value /
    // this statement should rightfully NEVER be reached /
    return NULL;
}

/** \fn int_array get_set_of_lenders()
 * \brief Get set_of_lenders memory variable from current X-machine.
 * \return Value for variable.
 */
int_array * get_set_of_lenders()
{
	if(current_xmachine->xmachine_Firm) return &(*current_xmachine->xmachine_Firm).set_of_lenders;

    // suppress compiler warning by returning dummy value /
    // this statement should rightfully NEVER be reached /
    return NULL;
}

/** \fn int_array get_potential_lenders()
 * \brief Get potential_lenders memory variable from current X-machine.
 * \return Value for variable.
 */
int_array * get_potential_lenders()
{
	if(current_xmachine->xmachine_Firm) return &(*current_xmachine->xmachine_Firm).potential_lenders;

    // suppress compiler warning by returning dummy value /
    // this statement should rightfully NEVER be reached /
    return NULL;
}

/** \fn void set_number_of_banks_asked(int number_of_banks_asked)
 * \brief Set number_of_banks_asked memory variable for current X-machine.
 * \param number_of_banks_asked New value for variable.
 */
void set_number_of_banks_asked(int number_of_banks_asked)
{
	if(current_xmachine->xmachine_Firm) (*current_xmachine->xmachine_Firm).number_of_banks_asked = number_of_banks_asked;
}

/** \fn int get_number_of_banks_asked()
 * \brief Get number_of_banks_asked memory variable from current X-machine.
 * \return Value for variable.
 */
int get_number_of_banks_asked()
{
	if(current_xmachine->xmachine_Firm) return (*current_xmachine->xmachine_Firm).number_of_banks_asked;

    // suppress compiler warning by returning dummy value /
    // this statement should rightfully NEVER be reached /
    return (int)0;
}

/** \fn void set_received_interest_daily(double received_interest_daily)
 * \brief Set received_interest_daily memory variable for current X-machine.
 * \param received_interest_daily New value for variable.
 */
void set_received_interest_daily(double received_interest_daily)
{
	if(current_xmachine->xmachine_Firm) (*current_xmachine->xmachine_Firm).received_interest_daily = received_interest_daily;
	if(current_xmachine->xmachine_Household) (*current_xmachine->xmachine_Household).received_interest_daily = received_interest_daily;
	if(current_xmachine->xmachine_IGFirm) (*current_xmachine->xmachine_IGFirm).received_interest_daily = received_interest_daily;
}

/** \fn double get_received_interest_daily()
 * \brief Get received_interest_daily memory variable from current X-machine.
 * \return Value for variable.
 */
double get_received_interest_daily()
{
	if(current_xmachine->xmachine_Firm) return (*current_xmachine->xmachine_Firm).received_interest_daily;
	if(current_xmachine->xmachine_Household) return (*current_xmachine->xmachine_Household).received_interest_daily;
	if(current_xmachine->xmachine_IGFirm) return (*current_xmachine->xmachine_IGFirm).received_interest_daily;

    // suppress compiler warning by returning dummy value /
    // this statement should rightfully NEVER be reached /
    return (double)0;
}

/** \fn void set_received_interest_in_calendar_month(double received_interest_in_calendar_month)
 * \brief Set received_interest_in_calendar_month memory variable for current X-machine.
 * \param received_interest_in_calendar_month New value for variable.
 */
void set_received_interest_in_calendar_month(double received_interest_in_calendar_month)
{
	if(current_xmachine->xmachine_Firm) (*current_xmachine->xmachine_Firm).received_interest_in_calendar_month = received_interest_in_calendar_month;
	if(current_xmachine->xmachine_Household) (*current_xmachine->xmachine_Household).received_interest_in_calendar_month = received_interest_in_calendar_month;
	if(current_xmachine->xmachine_IGFirm) (*current_xmachine->xmachine_IGFirm).received_interest_in_calendar_month = received_interest_in_calendar_month;
}

/** \fn double get_received_interest_in_calendar_month()
 * \brief Get received_interest_in_calendar_month memory variable from current X-machine.
 * \return Value for variable.
 */
double get_received_interest_in_calendar_month()
{
	if(current_xmachine->xmachine_Firm) return (*current_xmachine->xmachine_Firm).received_interest_in_calendar_month;
	if(current_xmachine->xmachine_Household) return (*current_xmachine->xmachine_Household).received_interest_in_calendar_month;
	if(current_xmachine->xmachine_IGFirm) return (*current_xmachine->xmachine_IGFirm).received_interest_in_calendar_month;

    // suppress compiler warning by returning dummy value /
    // this statement should rightfully NEVER be reached /
    return (double)0;
}

/** \fn void set_flag_illiquidity_correction(int flag_illiquidity_correction)
 * \brief Set flag_illiquidity_correction memory variable for current X-machine.
 * \param flag_illiquidity_correction New value for variable.
 */
void set_flag_illiquidity_correction(int flag_illiquidity_correction)
{
	if(current_xmachine->xmachine_Firm) (*current_xmachine->xmachine_Firm).flag_illiquidity_correction = flag_illiquidity_correction;
}

/** \fn int get_flag_illiquidity_correction()
 * \brief Get flag_illiquidity_correction memory variable from current X-machine.
 * \return Value for variable.
 */
int get_flag_illiquidity_correction()
{
	if(current_xmachine->xmachine_Firm) return (*current_xmachine->xmachine_Firm).flag_illiquidity_correction;

    // suppress compiler warning by returning dummy value /
    // this statement should rightfully NEVER be reached /
    return (int)0;
}

/** \fn void set_ebit(double ebit)
 * \brief Set ebit memory variable for current X-machine.
 * \param ebit New value for variable.
 */
void set_ebit(double ebit)
{
	if(current_xmachine->xmachine_Firm) (*current_xmachine->xmachine_Firm).ebit = ebit;
	if(current_xmachine->xmachine_IGFirm) (*current_xmachine->xmachine_IGFirm).ebit = ebit;
}

/** \fn double get_ebit()
 * \brief Get ebit memory variable from current X-machine.
 * \return Value for variable.
 */
double get_ebit()
{
	if(current_xmachine->xmachine_Firm) return (*current_xmachine->xmachine_Firm).ebit;
	if(current_xmachine->xmachine_IGFirm) return (*current_xmachine->xmachine_IGFirm).ebit;

    // suppress compiler warning by returning dummy value /
    // this statement should rightfully NEVER be reached /
    return (double)0;
}

/** \fn void set_earnings(double earnings)
 * \brief Set earnings memory variable for current X-machine.
 * \param earnings New value for variable.
 */
void set_earnings(double earnings)
{
	if(current_xmachine->xmachine_Firm) (*current_xmachine->xmachine_Firm).earnings = earnings;
	if(current_xmachine->xmachine_IGFirm) (*current_xmachine->xmachine_IGFirm).earnings = earnings;
}

/** \fn double get_earnings()
 * \brief Get earnings memory variable from current X-machine.
 * \return Value for variable.
 */
double get_earnings()
{
	if(current_xmachine->xmachine_Firm) return (*current_xmachine->xmachine_Firm).earnings;
	if(current_xmachine->xmachine_IGFirm) return (*current_xmachine->xmachine_IGFirm).earnings;

    // suppress compiler warning by returning dummy value /
    // this statement should rightfully NEVER be reached /
    return (double)0;
}

/** \fn void set_tax_rate_corporate(double tax_rate_corporate)
 * \brief Set tax_rate_corporate memory variable for current X-machine.
 * \param tax_rate_corporate New value for variable.
 */
void set_tax_rate_corporate(double tax_rate_corporate)
{
	if(current_xmachine->xmachine_Firm) (*current_xmachine->xmachine_Firm).tax_rate_corporate = tax_rate_corporate;
	if(current_xmachine->xmachine_IGFirm) (*current_xmachine->xmachine_IGFirm).tax_rate_corporate = tax_rate_corporate;
	if(current_xmachine->xmachine_Bank) (*current_xmachine->xmachine_Bank).tax_rate_corporate = tax_rate_corporate;
	if(current_xmachine->xmachine_Government) (*current_xmachine->xmachine_Government).tax_rate_corporate = tax_rate_corporate;
}

/** \fn double get_tax_rate_corporate()
 * \brief Get tax_rate_corporate memory variable from current X-machine.
 * \return Value for variable.
 */
double get_tax_rate_corporate()
{
	if(current_xmachine->xmachine_Firm) return (*current_xmachine->xmachine_Firm).tax_rate_corporate;
	if(current_xmachine->xmachine_IGFirm) return (*current_xmachine->xmachine_IGFirm).tax_rate_corporate;
	if(current_xmachine->xmachine_Bank) return (*current_xmachine->xmachine_Bank).tax_rate_corporate;
	if(current_xmachine->xmachine_Government) return (*current_xmachine->xmachine_Government).tax_rate_corporate;

    // suppress compiler warning by returning dummy value /
    // this statement should rightfully NEVER be reached /
    return (double)0;
}

/** \fn void set_tax_rate_vat(double tax_rate_vat)
 * \brief Set tax_rate_vat memory variable for current X-machine.
 * \param tax_rate_vat New value for variable.
 */
void set_tax_rate_vat(double tax_rate_vat)
{
	if(current_xmachine->xmachine_Firm) (*current_xmachine->xmachine_Firm).tax_rate_vat = tax_rate_vat;
	if(current_xmachine->xmachine_IGFirm) (*current_xmachine->xmachine_IGFirm).tax_rate_vat = tax_rate_vat;
	if(current_xmachine->xmachine_Government) (*current_xmachine->xmachine_Government).tax_rate_vat = tax_rate_vat;
}

/** \fn double get_tax_rate_vat()
 * \brief Get tax_rate_vat memory variable from current X-machine.
 * \return Value for variable.
 */
double get_tax_rate_vat()
{
	if(current_xmachine->xmachine_Firm) return (*current_xmachine->xmachine_Firm).tax_rate_vat;
	if(current_xmachine->xmachine_IGFirm) return (*current_xmachine->xmachine_IGFirm).tax_rate_vat;
	if(current_xmachine->xmachine_Government) return (*current_xmachine->xmachine_Government).tax_rate_vat;

    // suppress compiler warning by returning dummy value /
    // this statement should rightfully NEVER be reached /
    return (double)0;
}

/** \fn void set_tax_payment(double tax_payment)
 * \brief Set tax_payment memory variable for current X-machine.
 * \param tax_payment New value for variable.
 */
void set_tax_payment(double tax_payment)
{
	if(current_xmachine->xmachine_Firm) (*current_xmachine->xmachine_Firm).tax_payment = tax_payment;
	if(current_xmachine->xmachine_Household) (*current_xmachine->xmachine_Household).tax_payment = tax_payment;
	if(current_xmachine->xmachine_IGFirm) (*current_xmachine->xmachine_IGFirm).tax_payment = tax_payment;
}

/** \fn double get_tax_payment()
 * \brief Get tax_payment memory variable from current X-machine.
 * \return Value for variable.
 */
double get_tax_payment()
{
	if(current_xmachine->xmachine_Firm) return (*current_xmachine->xmachine_Firm).tax_payment;
	if(current_xmachine->xmachine_Household) return (*current_xmachine->xmachine_Household).tax_payment;
	if(current_xmachine->xmachine_IGFirm) return (*current_xmachine->xmachine_IGFirm).tax_payment;

    // suppress compiler warning by returning dummy value /
    // this statement should rightfully NEVER be reached /
    return (double)0;
}

/** \fn void set_tax_payment_in_calendar_month(double tax_payment_in_calendar_month)
 * \brief Set tax_payment_in_calendar_month memory variable for current X-machine.
 * \param tax_payment_in_calendar_month New value for variable.
 */
void set_tax_payment_in_calendar_month(double tax_payment_in_calendar_month)
{
	if(current_xmachine->xmachine_Firm) (*current_xmachine->xmachine_Firm).tax_payment_in_calendar_month = tax_payment_in_calendar_month;
	if(current_xmachine->xmachine_IGFirm) (*current_xmachine->xmachine_IGFirm).tax_payment_in_calendar_month = tax_payment_in_calendar_month;
}

/** \fn double get_tax_payment_in_calendar_month()
 * \brief Get tax_payment_in_calendar_month memory variable from current X-machine.
 * \return Value for variable.
 */
double get_tax_payment_in_calendar_month()
{
	if(current_xmachine->xmachine_Firm) return (*current_xmachine->xmachine_Firm).tax_payment_in_calendar_month;
	if(current_xmachine->xmachine_IGFirm) return (*current_xmachine->xmachine_IGFirm).tax_payment_in_calendar_month;

    // suppress compiler warning by returning dummy value /
    // this statement should rightfully NEVER be reached /
    return (double)0;
}

/** \fn void set_net_earnings(double net_earnings)
 * \brief Set net_earnings memory variable for current X-machine.
 * \param net_earnings New value for variable.
 */
void set_net_earnings(double net_earnings)
{
	if(current_xmachine->xmachine_Firm) (*current_xmachine->xmachine_Firm).net_earnings = net_earnings;
	if(current_xmachine->xmachine_IGFirm) (*current_xmachine->xmachine_IGFirm).net_earnings = net_earnings;
}

/** \fn double get_net_earnings()
 * \brief Get net_earnings memory variable from current X-machine.
 * \return Value for variable.
 */
double get_net_earnings()
{
	if(current_xmachine->xmachine_Firm) return (*current_xmachine->xmachine_Firm).net_earnings;
	if(current_xmachine->xmachine_IGFirm) return (*current_xmachine->xmachine_IGFirm).net_earnings;

    // suppress compiler warning by returning dummy value /
    // this statement should rightfully NEVER be reached /
    return (double)0;
}

/** \fn double_array get_earnings_history()
 * \brief Get earnings_history memory variable from current X-machine.
 * \return Value for variable.
 */
double_array * get_earnings_history()
{
	if(current_xmachine->xmachine_Firm) return &(*current_xmachine->xmachine_Firm).earnings_history;

    // suppress compiler warning by returning dummy value /
    // this statement should rightfully NEVER be reached /
    return NULL;
}

/** \fn void set_previous_net_earnings(double previous_net_earnings)
 * \brief Set previous_net_earnings memory variable for current X-machine.
 * \param previous_net_earnings New value for variable.
 */
void set_previous_net_earnings(double previous_net_earnings)
{
	if(current_xmachine->xmachine_Firm) (*current_xmachine->xmachine_Firm).previous_net_earnings = previous_net_earnings;
	if(current_xmachine->xmachine_IGFirm) (*current_xmachine->xmachine_IGFirm).previous_net_earnings = previous_net_earnings;
}

/** \fn double get_previous_net_earnings()
 * \brief Get previous_net_earnings memory variable from current X-machine.
 * \return Value for variable.
 */
double get_previous_net_earnings()
{
	if(current_xmachine->xmachine_Firm) return (*current_xmachine->xmachine_Firm).previous_net_earnings;
	if(current_xmachine->xmachine_IGFirm) return (*current_xmachine->xmachine_IGFirm).previous_net_earnings;

    // suppress compiler warning by returning dummy value /
    // this statement should rightfully NEVER be reached /
    return (double)0;
}

/** \fn void set_total_interest_payment(double total_interest_payment)
 * \brief Set total_interest_payment memory variable for current X-machine.
 * \param total_interest_payment New value for variable.
 */
void set_total_interest_payment(double total_interest_payment)
{
	if(current_xmachine->xmachine_Firm) (*current_xmachine->xmachine_Firm).total_interest_payment = total_interest_payment;
}

/** \fn double get_total_interest_payment()
 * \brief Get total_interest_payment memory variable from current X-machine.
 * \return Value for variable.
 */
double get_total_interest_payment()
{
	if(current_xmachine->xmachine_Firm) return (*current_xmachine->xmachine_Firm).total_interest_payment;

    // suppress compiler warning by returning dummy value /
    // this statement should rightfully NEVER be reached /
    return (double)0;
}

/** \fn void set_total_interest_payment_in_calendar_month(double total_interest_payment_in_calendar_month)
 * \brief Set total_interest_payment_in_calendar_month memory variable for current X-machine.
 * \param total_interest_payment_in_calendar_month New value for variable.
 */
void set_total_interest_payment_in_calendar_month(double total_interest_payment_in_calendar_month)
{
	if(current_xmachine->xmachine_Firm) (*current_xmachine->xmachine_Firm).total_interest_payment_in_calendar_month = total_interest_payment_in_calendar_month;
}

/** \fn double get_total_interest_payment_in_calendar_month()
 * \brief Get total_interest_payment_in_calendar_month memory variable from current X-machine.
 * \return Value for variable.
 */
double get_total_interest_payment_in_calendar_month()
{
	if(current_xmachine->xmachine_Firm) return (*current_xmachine->xmachine_Firm).total_interest_payment_in_calendar_month;

    // suppress compiler warning by returning dummy value /
    // this statement should rightfully NEVER be reached /
    return (double)0;
}

/** \fn void set_total_debt_installment_payment(double total_debt_installment_payment)
 * \brief Set total_debt_installment_payment memory variable for current X-machine.
 * \param total_debt_installment_payment New value for variable.
 */
void set_total_debt_installment_payment(double total_debt_installment_payment)
{
	if(current_xmachine->xmachine_Firm) (*current_xmachine->xmachine_Firm).total_debt_installment_payment = total_debt_installment_payment;
}

/** \fn double get_total_debt_installment_payment()
 * \brief Get total_debt_installment_payment memory variable from current X-machine.
 * \return Value for variable.
 */
double get_total_debt_installment_payment()
{
	if(current_xmachine->xmachine_Firm) return (*current_xmachine->xmachine_Firm).total_debt_installment_payment;

    // suppress compiler warning by returning dummy value /
    // this statement should rightfully NEVER be reached /
    return (double)0;
}

/** \fn void set_total_debt_installment_payment_in_calendar_month(double total_debt_installment_payment_in_calendar_month)
 * \brief Set total_debt_installment_payment_in_calendar_month memory variable for current X-machine.
 * \param total_debt_installment_payment_in_calendar_month New value for variable.
 */
void set_total_debt_installment_payment_in_calendar_month(double total_debt_installment_payment_in_calendar_month)
{
	if(current_xmachine->xmachine_Firm) (*current_xmachine->xmachine_Firm).total_debt_installment_payment_in_calendar_month = total_debt_installment_payment_in_calendar_month;
}

/** \fn double get_total_debt_installment_payment_in_calendar_month()
 * \brief Get total_debt_installment_payment_in_calendar_month memory variable from current X-machine.
 * \return Value for variable.
 */
double get_total_debt_installment_payment_in_calendar_month()
{
	if(current_xmachine->xmachine_Firm) return (*current_xmachine->xmachine_Firm).total_debt_installment_payment_in_calendar_month;

    // suppress compiler warning by returning dummy value /
    // this statement should rightfully NEVER be reached /
    return (double)0;
}

/** \fn void set_total_dividend_payment(double total_dividend_payment)
 * \brief Set total_dividend_payment memory variable for current X-machine.
 * \param total_dividend_payment New value for variable.
 */
void set_total_dividend_payment(double total_dividend_payment)
{
	if(current_xmachine->xmachine_Firm) (*current_xmachine->xmachine_Firm).total_dividend_payment = total_dividend_payment;
	if(current_xmachine->xmachine_IGFirm) (*current_xmachine->xmachine_IGFirm).total_dividend_payment = total_dividend_payment;
	if(current_xmachine->xmachine_Bank) (*current_xmachine->xmachine_Bank).total_dividend_payment = total_dividend_payment;
}

/** \fn double get_total_dividend_payment()
 * \brief Get total_dividend_payment memory variable from current X-machine.
 * \return Value for variable.
 */
double get_total_dividend_payment()
{
	if(current_xmachine->xmachine_Firm) return (*current_xmachine->xmachine_Firm).total_dividend_payment;
	if(current_xmachine->xmachine_IGFirm) return (*current_xmachine->xmachine_IGFirm).total_dividend_payment;
	if(current_xmachine->xmachine_Bank) return (*current_xmachine->xmachine_Bank).total_dividend_payment;

    // suppress compiler warning by returning dummy value /
    // this statement should rightfully NEVER be reached /
    return (double)0;
}

/** \fn void set_total_dividend_payment_in_calendar_month(double total_dividend_payment_in_calendar_month)
 * \brief Set total_dividend_payment_in_calendar_month memory variable for current X-machine.
 * \param total_dividend_payment_in_calendar_month New value for variable.
 */
void set_total_dividend_payment_in_calendar_month(double total_dividend_payment_in_calendar_month)
{
	if(current_xmachine->xmachine_Firm) (*current_xmachine->xmachine_Firm).total_dividend_payment_in_calendar_month = total_dividend_payment_in_calendar_month;
	if(current_xmachine->xmachine_IGFirm) (*current_xmachine->xmachine_IGFirm).total_dividend_payment_in_calendar_month = total_dividend_payment_in_calendar_month;
}

/** \fn double get_total_dividend_payment_in_calendar_month()
 * \brief Get total_dividend_payment_in_calendar_month memory variable from current X-machine.
 * \return Value for variable.
 */
double get_total_dividend_payment_in_calendar_month()
{
	if(current_xmachine->xmachine_Firm) return (*current_xmachine->xmachine_Firm).total_dividend_payment_in_calendar_month;
	if(current_xmachine->xmachine_IGFirm) return (*current_xmachine->xmachine_IGFirm).total_dividend_payment_in_calendar_month;

    // suppress compiler warning by returning dummy value /
    // this statement should rightfully NEVER be reached /
    return (double)0;
}

/** \fn void set_flag_full_dividend(int flag_full_dividend)
 * \brief Set flag_full_dividend memory variable for current X-machine.
 * \param flag_full_dividend New value for variable.
 */
void set_flag_full_dividend(int flag_full_dividend)
{
	if(current_xmachine->xmachine_Firm) (*current_xmachine->xmachine_Firm).flag_full_dividend = flag_full_dividend;
}

/** \fn int get_flag_full_dividend()
 * \brief Get flag_full_dividend memory variable from current X-machine.
 * \return Value for variable.
 */
int get_flag_full_dividend()
{
	if(current_xmachine->xmachine_Firm) return (*current_xmachine->xmachine_Firm).flag_full_dividend;

    // suppress compiler warning by returning dummy value /
    // this statement should rightfully NEVER be reached /
    return (int)0;
}

/** \fn void set_current_share_price(double current_share_price)
 * \brief Set current_share_price memory variable for current X-machine.
 * \param current_share_price New value for variable.
 */
void set_current_share_price(double current_share_price)
{
	if(current_xmachine->xmachine_Firm) (*current_xmachine->xmachine_Firm).current_share_price = current_share_price;
	if(current_xmachine->xmachine_IGFirm) (*current_xmachine->xmachine_IGFirm).current_share_price = current_share_price;
	if(current_xmachine->xmachine_Bank) (*current_xmachine->xmachine_Bank).current_share_price = current_share_price;
}

/** \fn double get_current_share_price()
 * \brief Get current_share_price memory variable from current X-machine.
 * \return Value for variable.
 */
double get_current_share_price()
{
	if(current_xmachine->xmachine_Firm) return (*current_xmachine->xmachine_Firm).current_share_price;
	if(current_xmachine->xmachine_IGFirm) return (*current_xmachine->xmachine_IGFirm).current_share_price;
	if(current_xmachine->xmachine_Bank) return (*current_xmachine->xmachine_Bank).current_share_price;

    // suppress compiler warning by returning dummy value /
    // this statement should rightfully NEVER be reached /
    return (double)0;
}

/** \fn void set_previous_dividend_per_share(double previous_dividend_per_share)
 * \brief Set previous_dividend_per_share memory variable for current X-machine.
 * \param previous_dividend_per_share New value for variable.
 */
void set_previous_dividend_per_share(double previous_dividend_per_share)
{
	if(current_xmachine->xmachine_Firm) (*current_xmachine->xmachine_Firm).previous_dividend_per_share = previous_dividend_per_share;
	if(current_xmachine->xmachine_IGFirm) (*current_xmachine->xmachine_IGFirm).previous_dividend_per_share = previous_dividend_per_share;
}

/** \fn double get_previous_dividend_per_share()
 * \brief Get previous_dividend_per_share memory variable from current X-machine.
 * \return Value for variable.
 */
double get_previous_dividend_per_share()
{
	if(current_xmachine->xmachine_Firm) return (*current_xmachine->xmachine_Firm).previous_dividend_per_share;
	if(current_xmachine->xmachine_IGFirm) return (*current_xmachine->xmachine_IGFirm).previous_dividend_per_share;

    // suppress compiler warning by returning dummy value /
    // this statement should rightfully NEVER be reached /
    return (double)0;
}

/** \fn void set_current_dividend_per_share(double current_dividend_per_share)
 * \brief Set current_dividend_per_share memory variable for current X-machine.
 * \param current_dividend_per_share New value for variable.
 */
void set_current_dividend_per_share(double current_dividend_per_share)
{
	if(current_xmachine->xmachine_Firm) (*current_xmachine->xmachine_Firm).current_dividend_per_share = current_dividend_per_share;
	if(current_xmachine->xmachine_IGFirm) (*current_xmachine->xmachine_IGFirm).current_dividend_per_share = current_dividend_per_share;
}

/** \fn double get_current_dividend_per_share()
 * \brief Get current_dividend_per_share memory variable from current X-machine.
 * \return Value for variable.
 */
double get_current_dividend_per_share()
{
	if(current_xmachine->xmachine_Firm) return (*current_xmachine->xmachine_Firm).current_dividend_per_share;
	if(current_xmachine->xmachine_IGFirm) return (*current_xmachine->xmachine_IGFirm).current_dividend_per_share;

    // suppress compiler warning by returning dummy value /
    // this statement should rightfully NEVER be reached /
    return (double)0;
}

/** \fn void set_previous_earnings_per_share(double previous_earnings_per_share)
 * \brief Set previous_earnings_per_share memory variable for current X-machine.
 * \param previous_earnings_per_share New value for variable.
 */
void set_previous_earnings_per_share(double previous_earnings_per_share)
{
	if(current_xmachine->xmachine_Firm) (*current_xmachine->xmachine_Firm).previous_earnings_per_share = previous_earnings_per_share;
	if(current_xmachine->xmachine_IGFirm) (*current_xmachine->xmachine_IGFirm).previous_earnings_per_share = previous_earnings_per_share;
}

/** \fn double get_previous_earnings_per_share()
 * \brief Get previous_earnings_per_share memory variable from current X-machine.
 * \return Value for variable.
 */
double get_previous_earnings_per_share()
{
	if(current_xmachine->xmachine_Firm) return (*current_xmachine->xmachine_Firm).previous_earnings_per_share;
	if(current_xmachine->xmachine_IGFirm) return (*current_xmachine->xmachine_IGFirm).previous_earnings_per_share;

    // suppress compiler warning by returning dummy value /
    // this statement should rightfully NEVER be reached /
    return (double)0;
}

/** \fn void set_current_earnings_per_share(double current_earnings_per_share)
 * \brief Set current_earnings_per_share memory variable for current X-machine.
 * \param current_earnings_per_share New value for variable.
 */
void set_current_earnings_per_share(double current_earnings_per_share)
{
	if(current_xmachine->xmachine_Firm) (*current_xmachine->xmachine_Firm).current_earnings_per_share = current_earnings_per_share;
	if(current_xmachine->xmachine_IGFirm) (*current_xmachine->xmachine_IGFirm).current_earnings_per_share = current_earnings_per_share;
}

/** \fn double get_current_earnings_per_share()
 * \brief Get current_earnings_per_share memory variable from current X-machine.
 * \return Value for variable.
 */
double get_current_earnings_per_share()
{
	if(current_xmachine->xmachine_Firm) return (*current_xmachine->xmachine_Firm).current_earnings_per_share;
	if(current_xmachine->xmachine_IGFirm) return (*current_xmachine->xmachine_IGFirm).current_earnings_per_share;

    // suppress compiler warning by returning dummy value /
    // this statement should rightfully NEVER be reached /
    return (double)0;
}

/** \fn void set_previous_dividend_per_earnings(double previous_dividend_per_earnings)
 * \brief Set previous_dividend_per_earnings memory variable for current X-machine.
 * \param previous_dividend_per_earnings New value for variable.
 */
void set_previous_dividend_per_earnings(double previous_dividend_per_earnings)
{
	if(current_xmachine->xmachine_Firm) (*current_xmachine->xmachine_Firm).previous_dividend_per_earnings = previous_dividend_per_earnings;
	if(current_xmachine->xmachine_IGFirm) (*current_xmachine->xmachine_IGFirm).previous_dividend_per_earnings = previous_dividend_per_earnings;
}

/** \fn double get_previous_dividend_per_earnings()
 * \brief Get previous_dividend_per_earnings memory variable from current X-machine.
 * \return Value for variable.
 */
double get_previous_dividend_per_earnings()
{
	if(current_xmachine->xmachine_Firm) return (*current_xmachine->xmachine_Firm).previous_dividend_per_earnings;
	if(current_xmachine->xmachine_IGFirm) return (*current_xmachine->xmachine_IGFirm).previous_dividend_per_earnings;

    // suppress compiler warning by returning dummy value /
    // this statement should rightfully NEVER be reached /
    return (double)0;
}

/** \fn void set_current_dividend_per_earnings(double current_dividend_per_earnings)
 * \brief Set current_dividend_per_earnings memory variable for current X-machine.
 * \param current_dividend_per_earnings New value for variable.
 */
void set_current_dividend_per_earnings(double current_dividend_per_earnings)
{
	if(current_xmachine->xmachine_Firm) (*current_xmachine->xmachine_Firm).current_dividend_per_earnings = current_dividend_per_earnings;
	if(current_xmachine->xmachine_IGFirm) (*current_xmachine->xmachine_IGFirm).current_dividend_per_earnings = current_dividend_per_earnings;
}

/** \fn double get_current_dividend_per_earnings()
 * \brief Get current_dividend_per_earnings memory variable from current X-machine.
 * \return Value for variable.
 */
double get_current_dividend_per_earnings()
{
	if(current_xmachine->xmachine_Firm) return (*current_xmachine->xmachine_Firm).current_dividend_per_earnings;
	if(current_xmachine->xmachine_IGFirm) return (*current_xmachine->xmachine_IGFirm).current_dividend_per_earnings;

    // suppress compiler warning by returning dummy value /
    // this statement should rightfully NEVER be reached /
    return (double)0;
}

/** \fn void set_debt_earnings_ratio(double debt_earnings_ratio)
 * \brief Set debt_earnings_ratio memory variable for current X-machine.
 * \param debt_earnings_ratio New value for variable.
 */
void set_debt_earnings_ratio(double debt_earnings_ratio)
{
	if(current_xmachine->xmachine_Firm) (*current_xmachine->xmachine_Firm).debt_earnings_ratio = debt_earnings_ratio;
	if(current_xmachine->xmachine_IGFirm) (*current_xmachine->xmachine_IGFirm).debt_earnings_ratio = debt_earnings_ratio;
}

/** \fn double get_debt_earnings_ratio()
 * \brief Get debt_earnings_ratio memory variable from current X-machine.
 * \return Value for variable.
 */
double get_debt_earnings_ratio()
{
	if(current_xmachine->xmachine_Firm) return (*current_xmachine->xmachine_Firm).debt_earnings_ratio;
	if(current_xmachine->xmachine_IGFirm) return (*current_xmachine->xmachine_IGFirm).debt_earnings_ratio;

    // suppress compiler warning by returning dummy value /
    // this statement should rightfully NEVER be reached /
    return (double)0;
}

/** \fn void set_debt_equity_ratio(double debt_equity_ratio)
 * \brief Set debt_equity_ratio memory variable for current X-machine.
 * \param debt_equity_ratio New value for variable.
 */
void set_debt_equity_ratio(double debt_equity_ratio)
{
	if(current_xmachine->xmachine_Firm) (*current_xmachine->xmachine_Firm).debt_equity_ratio = debt_equity_ratio;
	if(current_xmachine->xmachine_IGFirm) (*current_xmachine->xmachine_IGFirm).debt_equity_ratio = debt_equity_ratio;
}

/** \fn double get_debt_equity_ratio()
 * \brief Get debt_equity_ratio memory variable from current X-machine.
 * \return Value for variable.
 */
double get_debt_equity_ratio()
{
	if(current_xmachine->xmachine_Firm) return (*current_xmachine->xmachine_Firm).debt_equity_ratio;
	if(current_xmachine->xmachine_IGFirm) return (*current_xmachine->xmachine_IGFirm).debt_equity_ratio;

    // suppress compiler warning by returning dummy value /
    // this statement should rightfully NEVER be reached /
    return (double)0;
}

/** \fn void set_price_earnings_ratio(double price_earnings_ratio)
 * \brief Set price_earnings_ratio memory variable for current X-machine.
 * \param price_earnings_ratio New value for variable.
 */
void set_price_earnings_ratio(double price_earnings_ratio)
{
	if(current_xmachine->xmachine_Firm) (*current_xmachine->xmachine_Firm).price_earnings_ratio = price_earnings_ratio;
	if(current_xmachine->xmachine_IGFirm) (*current_xmachine->xmachine_IGFirm).price_earnings_ratio = price_earnings_ratio;
}

/** \fn double get_price_earnings_ratio()
 * \brief Get price_earnings_ratio memory variable from current X-machine.
 * \return Value for variable.
 */
double get_price_earnings_ratio()
{
	if(current_xmachine->xmachine_Firm) return (*current_xmachine->xmachine_Firm).price_earnings_ratio;
	if(current_xmachine->xmachine_IGFirm) return (*current_xmachine->xmachine_IGFirm).price_earnings_ratio;

    // suppress compiler warning by returning dummy value /
    // this statement should rightfully NEVER be reached /
    return (double)0;
}

/** \fn void set_retained_earnings_ratio(double retained_earnings_ratio)
 * \brief Set retained_earnings_ratio memory variable for current X-machine.
 * \param retained_earnings_ratio New value for variable.
 */
void set_retained_earnings_ratio(double retained_earnings_ratio)
{
	if(current_xmachine->xmachine_Firm) (*current_xmachine->xmachine_Firm).retained_earnings_ratio = retained_earnings_ratio;
	if(current_xmachine->xmachine_IGFirm) (*current_xmachine->xmachine_IGFirm).retained_earnings_ratio = retained_earnings_ratio;
}

/** \fn double get_retained_earnings_ratio()
 * \brief Get retained_earnings_ratio memory variable from current X-machine.
 * \return Value for variable.
 */
double get_retained_earnings_ratio()
{
	if(current_xmachine->xmachine_Firm) return (*current_xmachine->xmachine_Firm).retained_earnings_ratio;
	if(current_xmachine->xmachine_IGFirm) return (*current_xmachine->xmachine_IGFirm).retained_earnings_ratio;

    // suppress compiler warning by returning dummy value /
    // this statement should rightfully NEVER be reached /
    return (double)0;
}

/** \fn void set_earnings_per_share_ratio_growth(double earnings_per_share_ratio_growth)
 * \brief Set earnings_per_share_ratio_growth memory variable for current X-machine.
 * \param earnings_per_share_ratio_growth New value for variable.
 */
void set_earnings_per_share_ratio_growth(double earnings_per_share_ratio_growth)
{
	if(current_xmachine->xmachine_Firm) (*current_xmachine->xmachine_Firm).earnings_per_share_ratio_growth = earnings_per_share_ratio_growth;
	if(current_xmachine->xmachine_IGFirm) (*current_xmachine->xmachine_IGFirm).earnings_per_share_ratio_growth = earnings_per_share_ratio_growth;
}

/** \fn double get_earnings_per_share_ratio_growth()
 * \brief Get earnings_per_share_ratio_growth memory variable from current X-machine.
 * \return Value for variable.
 */
double get_earnings_per_share_ratio_growth()
{
	if(current_xmachine->xmachine_Firm) return (*current_xmachine->xmachine_Firm).earnings_per_share_ratio_growth;
	if(current_xmachine->xmachine_IGFirm) return (*current_xmachine->xmachine_IGFirm).earnings_per_share_ratio_growth;

    // suppress compiler warning by returning dummy value /
    // this statement should rightfully NEVER be reached /
    return (double)0;
}

/** \fn void set_critical_price_earnings_ratio(double critical_price_earnings_ratio)
 * \brief Set critical_price_earnings_ratio memory variable for current X-machine.
 * \param critical_price_earnings_ratio New value for variable.
 */
void set_critical_price_earnings_ratio(double critical_price_earnings_ratio)
{
	if(current_xmachine->xmachine_Firm) (*current_xmachine->xmachine_Firm).critical_price_earnings_ratio = critical_price_earnings_ratio;
	if(current_xmachine->xmachine_IGFirm) (*current_xmachine->xmachine_IGFirm).critical_price_earnings_ratio = critical_price_earnings_ratio;
}

/** \fn double get_critical_price_earnings_ratio()
 * \brief Get critical_price_earnings_ratio memory variable from current X-machine.
 * \return Value for variable.
 */
double get_critical_price_earnings_ratio()
{
	if(current_xmachine->xmachine_Firm) return (*current_xmachine->xmachine_Firm).critical_price_earnings_ratio;
	if(current_xmachine->xmachine_IGFirm) return (*current_xmachine->xmachine_IGFirm).critical_price_earnings_ratio;

    // suppress compiler warning by returning dummy value /
    // this statement should rightfully NEVER be reached /
    return (double)0;
}

/** \fn void set_critical_earnings_per_share_ratio(double critical_earnings_per_share_ratio)
 * \brief Set critical_earnings_per_share_ratio memory variable for current X-machine.
 * \param critical_earnings_per_share_ratio New value for variable.
 */
void set_critical_earnings_per_share_ratio(double critical_earnings_per_share_ratio)
{
	if(current_xmachine->xmachine_Firm) (*current_xmachine->xmachine_Firm).critical_earnings_per_share_ratio = critical_earnings_per_share_ratio;
	if(current_xmachine->xmachine_IGFirm) (*current_xmachine->xmachine_IGFirm).critical_earnings_per_share_ratio = critical_earnings_per_share_ratio;
}

/** \fn double get_critical_earnings_per_share_ratio()
 * \brief Get critical_earnings_per_share_ratio memory variable from current X-machine.
 * \return Value for variable.
 */
double get_critical_earnings_per_share_ratio()
{
	if(current_xmachine->xmachine_Firm) return (*current_xmachine->xmachine_Firm).critical_earnings_per_share_ratio;
	if(current_xmachine->xmachine_IGFirm) return (*current_xmachine->xmachine_IGFirm).critical_earnings_per_share_ratio;

    // suppress compiler warning by returning dummy value /
    // this statement should rightfully NEVER be reached /
    return (double)0;
}

/** \fn debt_item_array get_loans()
 * \brief Get loans memory variable from current X-machine.
 * \return Value for variable.
 */
debt_item_array * get_loans()
{
	if(current_xmachine->xmachine_Firm) return &(*current_xmachine->xmachine_Firm).loans;

    // suppress compiler warning by returning dummy value /
    // this statement should rightfully NEVER be reached /
    return NULL;
}

/** \fn void set_total_debt(double total_debt)
 * \brief Set total_debt memory variable for current X-machine.
 * \param total_debt New value for variable.
 */
void set_total_debt(double total_debt)
{
	if(current_xmachine->xmachine_Firm) (*current_xmachine->xmachine_Firm).total_debt = total_debt;
	if(current_xmachine->xmachine_IGFirm) (*current_xmachine->xmachine_IGFirm).total_debt = total_debt;
	if(current_xmachine->xmachine_Eurostat) (*current_xmachine->xmachine_Eurostat).total_debt = total_debt;
	if(current_xmachine->xmachine_Government) (*current_xmachine->xmachine_Government).total_debt = total_debt;
}

/** \fn double get_total_debt()
 * \brief Get total_debt memory variable from current X-machine.
 * \return Value for variable.
 */
double get_total_debt()
{
	if(current_xmachine->xmachine_Firm) return (*current_xmachine->xmachine_Firm).total_debt;
	if(current_xmachine->xmachine_IGFirm) return (*current_xmachine->xmachine_IGFirm).total_debt;
	if(current_xmachine->xmachine_Eurostat) return (*current_xmachine->xmachine_Eurostat).total_debt;
	if(current_xmachine->xmachine_Government) return (*current_xmachine->xmachine_Government).total_debt;

    // suppress compiler warning by returning dummy value /
    // this statement should rightfully NEVER be reached /
    return (double)0;
}

/** \fn void set_target_debt(double target_debt)
 * \brief Set target_debt memory variable for current X-machine.
 * \param target_debt New value for variable.
 */
void set_target_debt(double target_debt)
{
	if(current_xmachine->xmachine_Firm) (*current_xmachine->xmachine_Firm).target_debt = target_debt;
}

/** \fn double get_target_debt()
 * \brief Get target_debt memory variable from current X-machine.
 * \return Value for variable.
 */
double get_target_debt()
{
	if(current_xmachine->xmachine_Firm) return (*current_xmachine->xmachine_Firm).target_debt;

    // suppress compiler warning by returning dummy value /
    // this statement should rightfully NEVER be reached /
    return (double)0;
}

/** \fn void set_total_debt_balance_sheet(double total_debt_balance_sheet)
 * \brief Set total_debt_balance_sheet memory variable for current X-machine.
 * \param total_debt_balance_sheet New value for variable.
 */
void set_total_debt_balance_sheet(double total_debt_balance_sheet)
{
	if(current_xmachine->xmachine_Firm) (*current_xmachine->xmachine_Firm).total_debt_balance_sheet = total_debt_balance_sheet;
	if(current_xmachine->xmachine_IGFirm) (*current_xmachine->xmachine_IGFirm).total_debt_balance_sheet = total_debt_balance_sheet;
}

/** \fn double get_total_debt_balance_sheet()
 * \brief Get total_debt_balance_sheet memory variable from current X-machine.
 * \return Value for variable.
 */
double get_total_debt_balance_sheet()
{
	if(current_xmachine->xmachine_Firm) return (*current_xmachine->xmachine_Firm).total_debt_balance_sheet;
	if(current_xmachine->xmachine_IGFirm) return (*current_xmachine->xmachine_IGFirm).total_debt_balance_sheet;

    // suppress compiler warning by returning dummy value /
    // this statement should rightfully NEVER be reached /
    return (double)0;
}

/** \fn void set_total_value_local_inventory(double total_value_local_inventory)
 * \brief Set total_value_local_inventory memory variable for current X-machine.
 * \param total_value_local_inventory New value for variable.
 */
void set_total_value_local_inventory(double total_value_local_inventory)
{
	if(current_xmachine->xmachine_Firm) (*current_xmachine->xmachine_Firm).total_value_local_inventory = total_value_local_inventory;
}

/** \fn double get_total_value_local_inventory()
 * \brief Get total_value_local_inventory memory variable from current X-machine.
 * \return Value for variable.
 */
double get_total_value_local_inventory()
{
	if(current_xmachine->xmachine_Firm) return (*current_xmachine->xmachine_Firm).total_value_local_inventory;

    // suppress compiler warning by returning dummy value /
    // this statement should rightfully NEVER be reached /
    return (double)0;
}

/** \fn void set_total_value_local_inventory_balance_sheet(double total_value_local_inventory_balance_sheet)
 * \brief Set total_value_local_inventory_balance_sheet memory variable for current X-machine.
 * \param total_value_local_inventory_balance_sheet New value for variable.
 */
void set_total_value_local_inventory_balance_sheet(double total_value_local_inventory_balance_sheet)
{
	if(current_xmachine->xmachine_Firm) (*current_xmachine->xmachine_Firm).total_value_local_inventory_balance_sheet = total_value_local_inventory_balance_sheet;
}

/** \fn double get_total_value_local_inventory_balance_sheet()
 * \brief Get total_value_local_inventory_balance_sheet memory variable from current X-machine.
 * \return Value for variable.
 */
double get_total_value_local_inventory_balance_sheet()
{
	if(current_xmachine->xmachine_Firm) return (*current_xmachine->xmachine_Firm).total_value_local_inventory_balance_sheet;

    // suppress compiler warning by returning dummy value /
    // this statement should rightfully NEVER be reached /
    return (double)0;
}

/** \fn void set_total_units_capital_stock(double total_units_capital_stock)
 * \brief Set total_units_capital_stock memory variable for current X-machine.
 * \param total_units_capital_stock New value for variable.
 */
void set_total_units_capital_stock(double total_units_capital_stock)
{
	if(current_xmachine->xmachine_Firm) (*current_xmachine->xmachine_Firm).total_units_capital_stock = total_units_capital_stock;
}

/** \fn double get_total_units_capital_stock()
 * \brief Get total_units_capital_stock memory variable from current X-machine.
 * \return Value for variable.
 */
double get_total_units_capital_stock()
{
	if(current_xmachine->xmachine_Firm) return (*current_xmachine->xmachine_Firm).total_units_capital_stock;

    // suppress compiler warning by returning dummy value /
    // this statement should rightfully NEVER be reached /
    return (double)0;
}

/** \fn void set_total_value_capital_stock(double total_value_capital_stock)
 * \brief Set total_value_capital_stock memory variable for current X-machine.
 * \param total_value_capital_stock New value for variable.
 */
void set_total_value_capital_stock(double total_value_capital_stock)
{
	if(current_xmachine->xmachine_Firm) (*current_xmachine->xmachine_Firm).total_value_capital_stock = total_value_capital_stock;
}

/** \fn double get_total_value_capital_stock()
 * \brief Get total_value_capital_stock memory variable from current X-machine.
 * \return Value for variable.
 */
double get_total_value_capital_stock()
{
	if(current_xmachine->xmachine_Firm) return (*current_xmachine->xmachine_Firm).total_value_capital_stock;

    // suppress compiler warning by returning dummy value /
    // this statement should rightfully NEVER be reached /
    return (double)0;
}

/** \fn void set_total_value_capital_stock_balance_sheet(double total_value_capital_stock_balance_sheet)
 * \brief Set total_value_capital_stock_balance_sheet memory variable for current X-machine.
 * \param total_value_capital_stock_balance_sheet New value for variable.
 */
void set_total_value_capital_stock_balance_sheet(double total_value_capital_stock_balance_sheet)
{
	if(current_xmachine->xmachine_Firm) (*current_xmachine->xmachine_Firm).total_value_capital_stock_balance_sheet = total_value_capital_stock_balance_sheet;
}

/** \fn double get_total_value_capital_stock_balance_sheet()
 * \brief Get total_value_capital_stock_balance_sheet memory variable from current X-machine.
 * \return Value for variable.
 */
double get_total_value_capital_stock_balance_sheet()
{
	if(current_xmachine->xmachine_Firm) return (*current_xmachine->xmachine_Firm).total_value_capital_stock_balance_sheet;

    // suppress compiler warning by returning dummy value /
    // this statement should rightfully NEVER be reached /
    return (double)0;
}

/** \fn void set_total_capital_depreciation_value(double total_capital_depreciation_value)
 * \brief Set total_capital_depreciation_value memory variable for current X-machine.
 * \param total_capital_depreciation_value New value for variable.
 */
void set_total_capital_depreciation_value(double total_capital_depreciation_value)
{
	if(current_xmachine->xmachine_Firm) (*current_xmachine->xmachine_Firm).total_capital_depreciation_value = total_capital_depreciation_value;
}

/** \fn double get_total_capital_depreciation_value()
 * \brief Get total_capital_depreciation_value memory variable from current X-machine.
 * \return Value for variable.
 */
double get_total_capital_depreciation_value()
{
	if(current_xmachine->xmachine_Firm) return (*current_xmachine->xmachine_Firm).total_capital_depreciation_value;

    // suppress compiler warning by returning dummy value /
    // this statement should rightfully NEVER be reached /
    return (double)0;
}

/** \fn void set_total_capital_depreciation_units(double total_capital_depreciation_units)
 * \brief Set total_capital_depreciation_units memory variable for current X-machine.
 * \param total_capital_depreciation_units New value for variable.
 */
void set_total_capital_depreciation_units(double total_capital_depreciation_units)
{
	if(current_xmachine->xmachine_Firm) (*current_xmachine->xmachine_Firm).total_capital_depreciation_units = total_capital_depreciation_units;
}

/** \fn double get_total_capital_depreciation_units()
 * \brief Get total_capital_depreciation_units memory variable from current X-machine.
 * \return Value for variable.
 */
double get_total_capital_depreciation_units()
{
	if(current_xmachine->xmachine_Firm) return (*current_xmachine->xmachine_Firm).total_capital_depreciation_units;

    // suppress compiler warning by returning dummy value /
    // this statement should rightfully NEVER be reached /
    return (double)0;
}

/** \fn void set_total_assets(double total_assets)
 * \brief Set total_assets memory variable for current X-machine.
 * \param total_assets New value for variable.
 */
void set_total_assets(double total_assets)
{
	if(current_xmachine->xmachine_Firm) (*current_xmachine->xmachine_Firm).total_assets = total_assets;
	if(current_xmachine->xmachine_Household) (*current_xmachine->xmachine_Household).total_assets = total_assets;
	if(current_xmachine->xmachine_IGFirm) (*current_xmachine->xmachine_IGFirm).total_assets = total_assets;
	if(current_xmachine->xmachine_Eurostat) (*current_xmachine->xmachine_Eurostat).total_assets = total_assets;
	if(current_xmachine->xmachine_Bank) (*current_xmachine->xmachine_Bank).total_assets = total_assets;
	if(current_xmachine->xmachine_Government) (*current_xmachine->xmachine_Government).total_assets = total_assets;
	if(current_xmachine->xmachine_CentralBank) (*current_xmachine->xmachine_CentralBank).total_assets = total_assets;
}

/** \fn double get_total_assets()
 * \brief Get total_assets memory variable from current X-machine.
 * \return Value for variable.
 */
double get_total_assets()
{
	if(current_xmachine->xmachine_Firm) return (*current_xmachine->xmachine_Firm).total_assets;
	if(current_xmachine->xmachine_Household) return (*current_xmachine->xmachine_Household).total_assets;
	if(current_xmachine->xmachine_IGFirm) return (*current_xmachine->xmachine_IGFirm).total_assets;
	if(current_xmachine->xmachine_Eurostat) return (*current_xmachine->xmachine_Eurostat).total_assets;
	if(current_xmachine->xmachine_Bank) return (*current_xmachine->xmachine_Bank).total_assets;
	if(current_xmachine->xmachine_Government) return (*current_xmachine->xmachine_Government).total_assets;
	if(current_xmachine->xmachine_CentralBank) return (*current_xmachine->xmachine_CentralBank).total_assets;

    // suppress compiler warning by returning dummy value /
    // this statement should rightfully NEVER be reached /
    return (double)0;
}

/** \fn void set_equity(double equity)
 * \brief Set equity memory variable for current X-machine.
 * \param equity New value for variable.
 */
void set_equity(double equity)
{
	if(current_xmachine->xmachine_Firm) (*current_xmachine->xmachine_Firm).equity = equity;
	if(current_xmachine->xmachine_IGFirm) (*current_xmachine->xmachine_IGFirm).equity = equity;
	if(current_xmachine->xmachine_Bank) (*current_xmachine->xmachine_Bank).equity = equity;
	if(current_xmachine->xmachine_CentralBank) (*current_xmachine->xmachine_CentralBank).equity = equity;
}

/** \fn double get_equity()
 * \brief Get equity memory variable from current X-machine.
 * \return Value for variable.
 */
double get_equity()
{
	if(current_xmachine->xmachine_Firm) return (*current_xmachine->xmachine_Firm).equity;
	if(current_xmachine->xmachine_IGFirm) return (*current_xmachine->xmachine_IGFirm).equity;
	if(current_xmachine->xmachine_Bank) return (*current_xmachine->xmachine_Bank).equity;
	if(current_xmachine->xmachine_CentralBank) return (*current_xmachine->xmachine_CentralBank).equity;

    // suppress compiler warning by returning dummy value /
    // this statement should rightfully NEVER be reached /
    return (double)0;
}

/** \fn void set_equity_balance_sheet(double equity_balance_sheet)
 * \brief Set equity_balance_sheet memory variable for current X-machine.
 * \param equity_balance_sheet New value for variable.
 */
void set_equity_balance_sheet(double equity_balance_sheet)
{
	if(current_xmachine->xmachine_Firm) (*current_xmachine->xmachine_Firm).equity_balance_sheet = equity_balance_sheet;
	if(current_xmachine->xmachine_IGFirm) (*current_xmachine->xmachine_IGFirm).equity_balance_sheet = equity_balance_sheet;
}

/** \fn double get_equity_balance_sheet()
 * \brief Get equity_balance_sheet memory variable from current X-machine.
 * \return Value for variable.
 */
double get_equity_balance_sheet()
{
	if(current_xmachine->xmachine_Firm) return (*current_xmachine->xmachine_Firm).equity_balance_sheet;
	if(current_xmachine->xmachine_IGFirm) return (*current_xmachine->xmachine_IGFirm).equity_balance_sheet;

    // suppress compiler warning by returning dummy value /
    // this statement should rightfully NEVER be reached /
    return (double)0;
}

/** \fn void set_production_liquidity_needs(double production_liquidity_needs)
 * \brief Set production_liquidity_needs memory variable for current X-machine.
 * \param production_liquidity_needs New value for variable.
 */
void set_production_liquidity_needs(double production_liquidity_needs)
{
	if(current_xmachine->xmachine_Firm) (*current_xmachine->xmachine_Firm).production_liquidity_needs = production_liquidity_needs;
}

/** \fn double get_production_liquidity_needs()
 * \brief Get production_liquidity_needs memory variable from current X-machine.
 * \return Value for variable.
 */
double get_production_liquidity_needs()
{
	if(current_xmachine->xmachine_Firm) return (*current_xmachine->xmachine_Firm).production_liquidity_needs;

    // suppress compiler warning by returning dummy value /
    // this statement should rightfully NEVER be reached /
    return (double)0;
}

/** \fn void set_financial_liquidity_needs(double financial_liquidity_needs)
 * \brief Set financial_liquidity_needs memory variable for current X-machine.
 * \param financial_liquidity_needs New value for variable.
 */
void set_financial_liquidity_needs(double financial_liquidity_needs)
{
	if(current_xmachine->xmachine_Firm) (*current_xmachine->xmachine_Firm).financial_liquidity_needs = financial_liquidity_needs;
}

/** \fn double get_financial_liquidity_needs()
 * \brief Get financial_liquidity_needs memory variable from current X-machine.
 * \return Value for variable.
 */
double get_financial_liquidity_needs()
{
	if(current_xmachine->xmachine_Firm) return (*current_xmachine->xmachine_Firm).financial_liquidity_needs;

    // suppress compiler warning by returning dummy value /
    // this statement should rightfully NEVER be reached /
    return (double)0;
}

/** \fn void set_total_financial_needs(double total_financial_needs)
 * \brief Set total_financial_needs memory variable for current X-machine.
 * \param total_financial_needs New value for variable.
 */
void set_total_financial_needs(double total_financial_needs)
{
	if(current_xmachine->xmachine_Firm) (*current_xmachine->xmachine_Firm).total_financial_needs = total_financial_needs;
}

/** \fn double get_total_financial_needs()
 * \brief Get total_financial_needs memory variable from current X-machine.
 * \return Value for variable.
 */
double get_total_financial_needs()
{
	if(current_xmachine->xmachine_Firm) return (*current_xmachine->xmachine_Firm).total_financial_needs;

    // suppress compiler warning by returning dummy value /
    // this statement should rightfully NEVER be reached /
    return (double)0;
}

/** \fn void set_external_financial_needs(double external_financial_needs)
 * \brief Set external_financial_needs memory variable for current X-machine.
 * \param external_financial_needs New value for variable.
 */
void set_external_financial_needs(double external_financial_needs)
{
	if(current_xmachine->xmachine_Firm) (*current_xmachine->xmachine_Firm).external_financial_needs = external_financial_needs;
}

/** \fn double get_external_financial_needs()
 * \brief Get external_financial_needs memory variable from current X-machine.
 * \return Value for variable.
 */
double get_external_financial_needs()
{
	if(current_xmachine->xmachine_Firm) return (*current_xmachine->xmachine_Firm).external_financial_needs;

    // suppress compiler warning by returning dummy value /
    // this statement should rightfully NEVER be reached /
    return (double)0;
}

/** \fn void set_earnings_per_share(double earnings_per_share)
 * \brief Set earnings_per_share memory variable for current X-machine.
 * \param earnings_per_share New value for variable.
 */
void set_earnings_per_share(double earnings_per_share)
{
	if(current_xmachine->xmachine_Firm) (*current_xmachine->xmachine_Firm).earnings_per_share = earnings_per_share;
	if(current_xmachine->xmachine_IGFirm) (*current_xmachine->xmachine_IGFirm).earnings_per_share = earnings_per_share;
}

/** \fn double get_earnings_per_share()
 * \brief Get earnings_per_share memory variable from current X-machine.
 * \return Value for variable.
 */
double get_earnings_per_share()
{
	if(current_xmachine->xmachine_Firm) return (*current_xmachine->xmachine_Firm).earnings_per_share;
	if(current_xmachine->xmachine_IGFirm) return (*current_xmachine->xmachine_IGFirm).earnings_per_share;

    // suppress compiler warning by returning dummy value /
    // this statement should rightfully NEVER be reached /
    return (double)0;
}

/** \fn void set_retained_earnings(double retained_earnings)
 * \brief Set retained_earnings memory variable for current X-machine.
 * \param retained_earnings New value for variable.
 */
void set_retained_earnings(double retained_earnings)
{
	if(current_xmachine->xmachine_Firm) (*current_xmachine->xmachine_Firm).retained_earnings = retained_earnings;
}

/** \fn double get_retained_earnings()
 * \brief Get retained_earnings memory variable from current X-machine.
 * \return Value for variable.
 */
double get_retained_earnings()
{
	if(current_xmachine->xmachine_Firm) return (*current_xmachine->xmachine_Firm).retained_earnings;

    // suppress compiler warning by returning dummy value /
    // this statement should rightfully NEVER be reached /
    return (double)0;
}

/** \fn void set_total_payments(double total_payments)
 * \brief Set total_payments memory variable for current X-machine.
 * \param total_payments New value for variable.
 */
void set_total_payments(double total_payments)
{
	if(current_xmachine->xmachine_Firm) (*current_xmachine->xmachine_Firm).total_payments = total_payments;
	if(current_xmachine->xmachine_IGFirm) (*current_xmachine->xmachine_IGFirm).total_payments = total_payments;
}

/** \fn double get_total_payments()
 * \brief Get total_payments memory variable from current X-machine.
 * \return Value for variable.
 */
double get_total_payments()
{
	if(current_xmachine->xmachine_Firm) return (*current_xmachine->xmachine_Firm).total_payments;
	if(current_xmachine->xmachine_IGFirm) return (*current_xmachine->xmachine_IGFirm).total_payments;

    // suppress compiler warning by returning dummy value /
    // this statement should rightfully NEVER be reached /
    return (double)0;
}

/** \fn void set_previous_shares_outstanding(int previous_shares_outstanding)
 * \brief Set previous_shares_outstanding memory variable for current X-machine.
 * \param previous_shares_outstanding New value for variable.
 */
void set_previous_shares_outstanding(int previous_shares_outstanding)
{
	if(current_xmachine->xmachine_Firm) (*current_xmachine->xmachine_Firm).previous_shares_outstanding = previous_shares_outstanding;
	if(current_xmachine->xmachine_IGFirm) (*current_xmachine->xmachine_IGFirm).previous_shares_outstanding = previous_shares_outstanding;
}

/** \fn int get_previous_shares_outstanding()
 * \brief Get previous_shares_outstanding memory variable from current X-machine.
 * \return Value for variable.
 */
int get_previous_shares_outstanding()
{
	if(current_xmachine->xmachine_Firm) return (*current_xmachine->xmachine_Firm).previous_shares_outstanding;
	if(current_xmachine->xmachine_IGFirm) return (*current_xmachine->xmachine_IGFirm).previous_shares_outstanding;

    // suppress compiler warning by returning dummy value /
    // this statement should rightfully NEVER be reached /
    return (int)0;
}

/** \fn void set_minsky_state(int minsky_state)
 * \brief Set minsky_state memory variable for current X-machine.
 * \param minsky_state New value for variable.
 */
void set_minsky_state(int minsky_state)
{
	if(current_xmachine->xmachine_Firm) (*current_xmachine->xmachine_Firm).minsky_state = minsky_state;
}

/** \fn int get_minsky_state()
 * \brief Get minsky_state memory variable from current X-machine.
 * \return Value for variable.
 */
int get_minsky_state()
{
	if(current_xmachine->xmachine_Firm) return (*current_xmachine->xmachine_Firm).minsky_state;

    // suppress compiler warning by returning dummy value /
    // this statement should rightfully NEVER be reached /
    return (int)0;
}

/** \fn void set_minsky_state_1(int minsky_state_1)
 * \brief Set minsky_state_1 memory variable for current X-machine.
 * \param minsky_state_1 New value for variable.
 */
void set_minsky_state_1(int minsky_state_1)
{
	if(current_xmachine->xmachine_Firm) (*current_xmachine->xmachine_Firm).minsky_state_1 = minsky_state_1;
}

/** \fn int get_minsky_state_1()
 * \brief Get minsky_state_1 memory variable from current X-machine.
 * \return Value for variable.
 */
int get_minsky_state_1()
{
	if(current_xmachine->xmachine_Firm) return (*current_xmachine->xmachine_Firm).minsky_state_1;

    // suppress compiler warning by returning dummy value /
    // this statement should rightfully NEVER be reached /
    return (int)0;
}

/** \fn void set_minsky_state_2(int minsky_state_2)
 * \brief Set minsky_state_2 memory variable for current X-machine.
 * \param minsky_state_2 New value for variable.
 */
void set_minsky_state_2(int minsky_state_2)
{
	if(current_xmachine->xmachine_Firm) (*current_xmachine->xmachine_Firm).minsky_state_2 = minsky_state_2;
}

/** \fn int get_minsky_state_2()
 * \brief Get minsky_state_2 memory variable from current X-machine.
 * \return Value for variable.
 */
int get_minsky_state_2()
{
	if(current_xmachine->xmachine_Firm) return (*current_xmachine->xmachine_Firm).minsky_state_2;

    // suppress compiler warning by returning dummy value /
    // this statement should rightfully NEVER be reached /
    return (int)0;
}

/** \fn void set_minsky_state_3(int minsky_state_3)
 * \brief Set minsky_state_3 memory variable for current X-machine.
 * \param minsky_state_3 New value for variable.
 */
void set_minsky_state_3(int minsky_state_3)
{
	if(current_xmachine->xmachine_Firm) (*current_xmachine->xmachine_Firm).minsky_state_3 = minsky_state_3;
}

/** \fn int get_minsky_state_3()
 * \brief Get minsky_state_3 memory variable from current X-machine.
 * \return Value for variable.
 */
int get_minsky_state_3()
{
	if(current_xmachine->xmachine_Firm) return (*current_xmachine->xmachine_Firm).minsky_state_3;

    // suppress compiler warning by returning dummy value /
    // this statement should rightfully NEVER be reached /
    return (int)0;
}

/** \fn void set_minsky_state_4(int minsky_state_4)
 * \brief Set minsky_state_4 memory variable for current X-machine.
 * \param minsky_state_4 New value for variable.
 */
void set_minsky_state_4(int minsky_state_4)
{
	if(current_xmachine->xmachine_Firm) (*current_xmachine->xmachine_Firm).minsky_state_4 = minsky_state_4;
}

/** \fn int get_minsky_state_4()
 * \brief Get minsky_state_4 memory variable from current X-machine.
 * \return Value for variable.
 */
int get_minsky_state_4()
{
	if(current_xmachine->xmachine_Firm) return (*current_xmachine->xmachine_Firm).minsky_state_4;

    // suppress compiler warning by returning dummy value /
    // this statement should rightfully NEVER be reached /
    return (int)0;
}

/** \fn void set_minsky_state_5(int minsky_state_5)
 * \brief Set minsky_state_5 memory variable for current X-machine.
 * \param minsky_state_5 New value for variable.
 */
void set_minsky_state_5(int minsky_state_5)
{
	if(current_xmachine->xmachine_Firm) (*current_xmachine->xmachine_Firm).minsky_state_5 = minsky_state_5;
}

/** \fn int get_minsky_state_5()
 * \brief Get minsky_state_5 memory variable from current X-machine.
 * \return Value for variable.
 */
int get_minsky_state_5()
{
	if(current_xmachine->xmachine_Firm) return (*current_xmachine->xmachine_Firm).minsky_state_5;

    // suppress compiler warning by returning dummy value /
    // this statement should rightfully NEVER be reached /
    return (int)0;
}

/** \fn void set_minsky_state_20(int minsky_state_20)
 * \brief Set minsky_state_20 memory variable for current X-machine.
 * \param minsky_state_20 New value for variable.
 */
void set_minsky_state_20(int minsky_state_20)
{
	if(current_xmachine->xmachine_Firm) (*current_xmachine->xmachine_Firm).minsky_state_20 = minsky_state_20;
}

/** \fn int get_minsky_state_20()
 * \brief Get minsky_state_20 memory variable from current X-machine.
 * \return Value for variable.
 */
int get_minsky_state_20()
{
	if(current_xmachine->xmachine_Firm) return (*current_xmachine->xmachine_Firm).minsky_state_20;

    // suppress compiler warning by returning dummy value /
    // this statement should rightfully NEVER be reached /
    return (int)0;
}

/** \fn void set_minsky_state_21(int minsky_state_21)
 * \brief Set minsky_state_21 memory variable for current X-machine.
 * \param minsky_state_21 New value for variable.
 */
void set_minsky_state_21(int minsky_state_21)
{
	if(current_xmachine->xmachine_Firm) (*current_xmachine->xmachine_Firm).minsky_state_21 = minsky_state_21;
}

/** \fn int get_minsky_state_21()
 * \brief Get minsky_state_21 memory variable from current X-machine.
 * \return Value for variable.
 */
int get_minsky_state_21()
{
	if(current_xmachine->xmachine_Firm) return (*current_xmachine->xmachine_Firm).minsky_state_21;

    // suppress compiler warning by returning dummy value /
    // this statement should rightfully NEVER be reached /
    return (int)0;
}

/** \fn void set_minsky_state_22(int minsky_state_22)
 * \brief Set minsky_state_22 memory variable for current X-machine.
 * \param minsky_state_22 New value for variable.
 */
void set_minsky_state_22(int minsky_state_22)
{
	if(current_xmachine->xmachine_Firm) (*current_xmachine->xmachine_Firm).minsky_state_22 = minsky_state_22;
}

/** \fn int get_minsky_state_22()
 * \brief Get minsky_state_22 memory variable from current X-machine.
 * \return Value for variable.
 */
int get_minsky_state_22()
{
	if(current_xmachine->xmachine_Firm) return (*current_xmachine->xmachine_Firm).minsky_state_22;

    // suppress compiler warning by returning dummy value /
    // this statement should rightfully NEVER be reached /
    return (int)0;
}

/** \fn void set_minsky_state_23(int minsky_state_23)
 * \brief Set minsky_state_23 memory variable for current X-machine.
 * \param minsky_state_23 New value for variable.
 */
void set_minsky_state_23(int minsky_state_23)
{
	if(current_xmachine->xmachine_Firm) (*current_xmachine->xmachine_Firm).minsky_state_23 = minsky_state_23;
}

/** \fn int get_minsky_state_23()
 * \brief Get minsky_state_23 memory variable from current X-machine.
 * \return Value for variable.
 */
int get_minsky_state_23()
{
	if(current_xmachine->xmachine_Firm) return (*current_xmachine->xmachine_Firm).minsky_state_23;

    // suppress compiler warning by returning dummy value /
    // this statement should rightfully NEVER be reached /
    return (int)0;
}

/** \fn void set_minsky_state_30(int minsky_state_30)
 * \brief Set minsky_state_30 memory variable for current X-machine.
 * \param minsky_state_30 New value for variable.
 */
void set_minsky_state_30(int minsky_state_30)
{
	if(current_xmachine->xmachine_Firm) (*current_xmachine->xmachine_Firm).minsky_state_30 = minsky_state_30;
}

/** \fn int get_minsky_state_30()
 * \brief Get minsky_state_30 memory variable from current X-machine.
 * \return Value for variable.
 */
int get_minsky_state_30()
{
	if(current_xmachine->xmachine_Firm) return (*current_xmachine->xmachine_Firm).minsky_state_30;

    // suppress compiler warning by returning dummy value /
    // this statement should rightfully NEVER be reached /
    return (int)0;
}

/** \fn void set_minsky_state_31(int minsky_state_31)
 * \brief Set minsky_state_31 memory variable for current X-machine.
 * \param minsky_state_31 New value for variable.
 */
void set_minsky_state_31(int minsky_state_31)
{
	if(current_xmachine->xmachine_Firm) (*current_xmachine->xmachine_Firm).minsky_state_31 = minsky_state_31;
}

/** \fn int get_minsky_state_31()
 * \brief Get minsky_state_31 memory variable from current X-machine.
 * \return Value for variable.
 */
int get_minsky_state_31()
{
	if(current_xmachine->xmachine_Firm) return (*current_xmachine->xmachine_Firm).minsky_state_31;

    // suppress compiler warning by returning dummy value /
    // this statement should rightfully NEVER be reached /
    return (int)0;
}

/** \fn void set_minsky_state_32(int minsky_state_32)
 * \brief Set minsky_state_32 memory variable for current X-machine.
 * \param minsky_state_32 New value for variable.
 */
void set_minsky_state_32(int minsky_state_32)
{
	if(current_xmachine->xmachine_Firm) (*current_xmachine->xmachine_Firm).minsky_state_32 = minsky_state_32;
}

/** \fn int get_minsky_state_32()
 * \brief Get minsky_state_32 memory variable from current X-machine.
 * \return Value for variable.
 */
int get_minsky_state_32()
{
	if(current_xmachine->xmachine_Firm) return (*current_xmachine->xmachine_Firm).minsky_state_32;

    // suppress compiler warning by returning dummy value /
    // this statement should rightfully NEVER be reached /
    return (int)0;
}

/** \fn void set_minsky_state_33(int minsky_state_33)
 * \brief Set minsky_state_33 memory variable for current X-machine.
 * \param minsky_state_33 New value for variable.
 */
void set_minsky_state_33(int minsky_state_33)
{
	if(current_xmachine->xmachine_Firm) (*current_xmachine->xmachine_Firm).minsky_state_33 = minsky_state_33;
}

/** \fn int get_minsky_state_33()
 * \brief Get minsky_state_33 memory variable from current X-machine.
 * \return Value for variable.
 */
int get_minsky_state_33()
{
	if(current_xmachine->xmachine_Firm) return (*current_xmachine->xmachine_Firm).minsky_state_33;

    // suppress compiler warning by returning dummy value /
    // this statement should rightfully NEVER be reached /
    return (int)0;
}

/** \fn void set_minsky_state_40(int minsky_state_40)
 * \brief Set minsky_state_40 memory variable for current X-machine.
 * \param minsky_state_40 New value for variable.
 */
void set_minsky_state_40(int minsky_state_40)
{
	if(current_xmachine->xmachine_Firm) (*current_xmachine->xmachine_Firm).minsky_state_40 = minsky_state_40;
}

/** \fn int get_minsky_state_40()
 * \brief Get minsky_state_40 memory variable from current X-machine.
 * \return Value for variable.
 */
int get_minsky_state_40()
{
	if(current_xmachine->xmachine_Firm) return (*current_xmachine->xmachine_Firm).minsky_state_40;

    // suppress compiler warning by returning dummy value /
    // this statement should rightfully NEVER be reached /
    return (int)0;
}

/** \fn void set_minsky_state_41(int minsky_state_41)
 * \brief Set minsky_state_41 memory variable for current X-machine.
 * \param minsky_state_41 New value for variable.
 */
void set_minsky_state_41(int minsky_state_41)
{
	if(current_xmachine->xmachine_Firm) (*current_xmachine->xmachine_Firm).minsky_state_41 = minsky_state_41;
}

/** \fn int get_minsky_state_41()
 * \brief Get minsky_state_41 memory variable from current X-machine.
 * \return Value for variable.
 */
int get_minsky_state_41()
{
	if(current_xmachine->xmachine_Firm) return (*current_xmachine->xmachine_Firm).minsky_state_41;

    // suppress compiler warning by returning dummy value /
    // this statement should rightfully NEVER be reached /
    return (int)0;
}

/** \fn void set_minsky_state_42(int minsky_state_42)
 * \brief Set minsky_state_42 memory variable for current X-machine.
 * \param minsky_state_42 New value for variable.
 */
void set_minsky_state_42(int minsky_state_42)
{
	if(current_xmachine->xmachine_Firm) (*current_xmachine->xmachine_Firm).minsky_state_42 = minsky_state_42;
}

/** \fn int get_minsky_state_42()
 * \brief Get minsky_state_42 memory variable from current X-machine.
 * \return Value for variable.
 */
int get_minsky_state_42()
{
	if(current_xmachine->xmachine_Firm) return (*current_xmachine->xmachine_Firm).minsky_state_42;

    // suppress compiler warning by returning dummy value /
    // this statement should rightfully NEVER be reached /
    return (int)0;
}

/** \fn void set_minsky_state_43(int minsky_state_43)
 * \brief Set minsky_state_43 memory variable for current X-machine.
 * \param minsky_state_43 New value for variable.
 */
void set_minsky_state_43(int minsky_state_43)
{
	if(current_xmachine->xmachine_Firm) (*current_xmachine->xmachine_Firm).minsky_state_43 = minsky_state_43;
}

/** \fn int get_minsky_state_43()
 * \brief Get minsky_state_43 memory variable from current X-machine.
 * \return Value for variable.
 */
int get_minsky_state_43()
{
	if(current_xmachine->xmachine_Firm) return (*current_xmachine->xmachine_Firm).minsky_state_43;

    // suppress compiler warning by returning dummy value /
    // this statement should rightfully NEVER be reached /
    return (int)0;
}

/** \fn void set_age_at_bankruptcy(int age_at_bankruptcy)
 * \brief Set age_at_bankruptcy memory variable for current X-machine.
 * \param age_at_bankruptcy New value for variable.
 */
void set_age_at_bankruptcy(int age_at_bankruptcy)
{
	if(current_xmachine->xmachine_Firm) (*current_xmachine->xmachine_Firm).age_at_bankruptcy = age_at_bankruptcy;
}

/** \fn int get_age_at_bankruptcy()
 * \brief Get age_at_bankruptcy memory variable from current X-machine.
 * \return Value for variable.
 */
int get_age_at_bankruptcy()
{
	if(current_xmachine->xmachine_Firm) return (*current_xmachine->xmachine_Firm).age_at_bankruptcy;

    // suppress compiler warning by returning dummy value /
    // this statement should rightfully NEVER be reached /
    return (int)0;
}

/** \fn void set_debt_at_bankruptcy(double debt_at_bankruptcy)
 * \brief Set debt_at_bankruptcy memory variable for current X-machine.
 * \param debt_at_bankruptcy New value for variable.
 */
void set_debt_at_bankruptcy(double debt_at_bankruptcy)
{
	if(current_xmachine->xmachine_Firm) (*current_xmachine->xmachine_Firm).debt_at_bankruptcy = debt_at_bankruptcy;
}

/** \fn double get_debt_at_bankruptcy()
 * \brief Get debt_at_bankruptcy memory variable from current X-machine.
 * \return Value for variable.
 */
double get_debt_at_bankruptcy()
{
	if(current_xmachine->xmachine_Firm) return (*current_xmachine->xmachine_Firm).debt_at_bankruptcy;

    // suppress compiler warning by returning dummy value /
    // this statement should rightfully NEVER be reached /
    return (double)0;
}

/** \fn void set_equity_at_bankruptcy(double equity_at_bankruptcy)
 * \brief Set equity_at_bankruptcy memory variable for current X-machine.
 * \param equity_at_bankruptcy New value for variable.
 */
void set_equity_at_bankruptcy(double equity_at_bankruptcy)
{
	if(current_xmachine->xmachine_Firm) (*current_xmachine->xmachine_Firm).equity_at_bankruptcy = equity_at_bankruptcy;
}

/** \fn double get_equity_at_bankruptcy()
 * \brief Get equity_at_bankruptcy memory variable from current X-machine.
 * \return Value for variable.
 */
double get_equity_at_bankruptcy()
{
	if(current_xmachine->xmachine_Firm) return (*current_xmachine->xmachine_Firm).equity_at_bankruptcy;

    // suppress compiler warning by returning dummy value /
    // this statement should rightfully NEVER be reached /
    return (double)0;
}

/** \fn void set_no_employees_at_bankruptcy(int no_employees_at_bankruptcy)
 * \brief Set no_employees_at_bankruptcy memory variable for current X-machine.
 * \param no_employees_at_bankruptcy New value for variable.
 */
void set_no_employees_at_bankruptcy(int no_employees_at_bankruptcy)
{
	if(current_xmachine->xmachine_Firm) (*current_xmachine->xmachine_Firm).no_employees_at_bankruptcy = no_employees_at_bankruptcy;
}

/** \fn int get_no_employees_at_bankruptcy()
 * \brief Get no_employees_at_bankruptcy memory variable from current X-machine.
 * \return Value for variable.
 */
int get_no_employees_at_bankruptcy()
{
	if(current_xmachine->xmachine_Firm) return (*current_xmachine->xmachine_Firm).no_employees_at_bankruptcy;

    // suppress compiler warning by returning dummy value /
    // this statement should rightfully NEVER be reached /
    return (int)0;
}

/** \fn void set_equity_asset_ratio(double equity_asset_ratio)
 * \brief Set equity_asset_ratio memory variable for current X-machine.
 * \param equity_asset_ratio New value for variable.
 */
void set_equity_asset_ratio(double equity_asset_ratio)
{
	if(current_xmachine->xmachine_Firm) (*current_xmachine->xmachine_Firm).equity_asset_ratio = equity_asset_ratio;
	if(current_xmachine->xmachine_Bank) (*current_xmachine->xmachine_Bank).equity_asset_ratio = equity_asset_ratio;
}

/** \fn double get_equity_asset_ratio()
 * \brief Get equity_asset_ratio memory variable from current X-machine.
 * \return Value for variable.
 */
double get_equity_asset_ratio()
{
	if(current_xmachine->xmachine_Firm) return (*current_xmachine->xmachine_Firm).equity_asset_ratio;
	if(current_xmachine->xmachine_Bank) return (*current_xmachine->xmachine_Bank).equity_asset_ratio;

    // suppress compiler warning by returning dummy value /
    // this statement should rightfully NEVER be reached /
    return (double)0;
}

/** \fn void set_profit_asset_ratio(double profit_asset_ratio)
 * \brief Set profit_asset_ratio memory variable for current X-machine.
 * \param profit_asset_ratio New value for variable.
 */
void set_profit_asset_ratio(double profit_asset_ratio)
{
	if(current_xmachine->xmachine_Firm) (*current_xmachine->xmachine_Firm).profit_asset_ratio = profit_asset_ratio;
}

/** \fn double get_profit_asset_ratio()
 * \brief Get profit_asset_ratio memory variable from current X-machine.
 * \return Value for variable.
 */
double get_profit_asset_ratio()
{
	if(current_xmachine->xmachine_Firm) return (*current_xmachine->xmachine_Firm).profit_asset_ratio;

    // suppress compiler warning by returning dummy value /
    // this statement should rightfully NEVER be reached /
    return (double)0;
}

/** \fn void set_sales_asset_ratio(double sales_asset_ratio)
 * \brief Set sales_asset_ratio memory variable for current X-machine.
 * \param sales_asset_ratio New value for variable.
 */
void set_sales_asset_ratio(double sales_asset_ratio)
{
	if(current_xmachine->xmachine_Firm) (*current_xmachine->xmachine_Firm).sales_asset_ratio = sales_asset_ratio;
}

/** \fn double get_sales_asset_ratio()
 * \brief Get sales_asset_ratio memory variable from current X-machine.
 * \return Value for variable.
 */
double get_sales_asset_ratio()
{
	if(current_xmachine->xmachine_Firm) return (*current_xmachine->xmachine_Firm).sales_asset_ratio;

    // suppress compiler warning by returning dummy value /
    // this statement should rightfully NEVER be reached /
    return (double)0;
}

/** \fn void set_investment_asset_ratio(double investment_asset_ratio)
 * \brief Set investment_asset_ratio memory variable for current X-machine.
 * \param investment_asset_ratio New value for variable.
 */
void set_investment_asset_ratio(double investment_asset_ratio)
{
	if(current_xmachine->xmachine_Firm) (*current_xmachine->xmachine_Firm).investment_asset_ratio = investment_asset_ratio;
}

/** \fn double get_investment_asset_ratio()
 * \brief Get investment_asset_ratio memory variable from current X-machine.
 * \return Value for variable.
 */
double get_investment_asset_ratio()
{
	if(current_xmachine->xmachine_Firm) return (*current_xmachine->xmachine_Firm).investment_asset_ratio;

    // suppress compiler warning by returning dummy value /
    // this statement should rightfully NEVER be reached /
    return (double)0;
}

/** \fn void set_total_income(double total_income)
 * \brief Set total_income memory variable for current X-machine.
 * \param total_income New value for variable.
 */
void set_total_income(double total_income)
{
	if(current_xmachine->xmachine_Firm) (*current_xmachine->xmachine_Firm).total_income = total_income;
	if(current_xmachine->xmachine_Household) (*current_xmachine->xmachine_Household).total_income = total_income;
	if(current_xmachine->xmachine_IGFirm) (*current_xmachine->xmachine_IGFirm).total_income = total_income;
	if(current_xmachine->xmachine_Bank) (*current_xmachine->xmachine_Bank).total_income = total_income;
	if(current_xmachine->xmachine_CentralBank) (*current_xmachine->xmachine_CentralBank).total_income = total_income;
}

/** \fn double get_total_income()
 * \brief Get total_income memory variable from current X-machine.
 * \return Value for variable.
 */
double get_total_income()
{
	if(current_xmachine->xmachine_Firm) return (*current_xmachine->xmachine_Firm).total_income;
	if(current_xmachine->xmachine_Household) return (*current_xmachine->xmachine_Household).total_income;
	if(current_xmachine->xmachine_IGFirm) return (*current_xmachine->xmachine_IGFirm).total_income;
	if(current_xmachine->xmachine_Bank) return (*current_xmachine->xmachine_Bank).total_income;
	if(current_xmachine->xmachine_CentralBank) return (*current_xmachine->xmachine_CentralBank).total_income;

    // suppress compiler warning by returning dummy value /
    // this statement should rightfully NEVER be reached /
    return (double)0;
}

/** \fn void set_total_liabilities(double total_liabilities)
 * \brief Set total_liabilities memory variable for current X-machine.
 * \param total_liabilities New value for variable.
 */
void set_total_liabilities(double total_liabilities)
{
	if(current_xmachine->xmachine_Firm) (*current_xmachine->xmachine_Firm).total_liabilities = total_liabilities;
	if(current_xmachine->xmachine_Household) (*current_xmachine->xmachine_Household).total_liabilities = total_liabilities;
	if(current_xmachine->xmachine_IGFirm) (*current_xmachine->xmachine_IGFirm).total_liabilities = total_liabilities;
	if(current_xmachine->xmachine_Bank) (*current_xmachine->xmachine_Bank).total_liabilities = total_liabilities;
	if(current_xmachine->xmachine_Government) (*current_xmachine->xmachine_Government).total_liabilities = total_liabilities;
	if(current_xmachine->xmachine_CentralBank) (*current_xmachine->xmachine_CentralBank).total_liabilities = total_liabilities;
}

/** \fn double get_total_liabilities()
 * \brief Get total_liabilities memory variable from current X-machine.
 * \return Value for variable.
 */
double get_total_liabilities()
{
	if(current_xmachine->xmachine_Firm) return (*current_xmachine->xmachine_Firm).total_liabilities;
	if(current_xmachine->xmachine_Household) return (*current_xmachine->xmachine_Household).total_liabilities;
	if(current_xmachine->xmachine_IGFirm) return (*current_xmachine->xmachine_IGFirm).total_liabilities;
	if(current_xmachine->xmachine_Bank) return (*current_xmachine->xmachine_Bank).total_liabilities;
	if(current_xmachine->xmachine_Government) return (*current_xmachine->xmachine_Government).total_liabilities;
	if(current_xmachine->xmachine_CentralBank) return (*current_xmachine->xmachine_CentralBank).total_liabilities;

    // suppress compiler warning by returning dummy value /
    // this statement should rightfully NEVER be reached /
    return (double)0;
}

/** \fn void set_total_expenses(double total_expenses)
 * \brief Set total_expenses memory variable for current X-machine.
 * \param total_expenses New value for variable.
 */
void set_total_expenses(double total_expenses)
{
	if(current_xmachine->xmachine_Firm) (*current_xmachine->xmachine_Firm).total_expenses = total_expenses;
	if(current_xmachine->xmachine_Household) (*current_xmachine->xmachine_Household).total_expenses = total_expenses;
	if(current_xmachine->xmachine_IGFirm) (*current_xmachine->xmachine_IGFirm).total_expenses = total_expenses;
	if(current_xmachine->xmachine_Bank) (*current_xmachine->xmachine_Bank).total_expenses = total_expenses;
	if(current_xmachine->xmachine_CentralBank) (*current_xmachine->xmachine_CentralBank).total_expenses = total_expenses;
}

/** \fn double get_total_expenses()
 * \brief Get total_expenses memory variable from current X-machine.
 * \return Value for variable.
 */
double get_total_expenses()
{
	if(current_xmachine->xmachine_Firm) return (*current_xmachine->xmachine_Firm).total_expenses;
	if(current_xmachine->xmachine_Household) return (*current_xmachine->xmachine_Household).total_expenses;
	if(current_xmachine->xmachine_IGFirm) return (*current_xmachine->xmachine_IGFirm).total_expenses;
	if(current_xmachine->xmachine_Bank) return (*current_xmachine->xmachine_Bank).total_expenses;
	if(current_xmachine->xmachine_CentralBank) return (*current_xmachine->xmachine_CentralBank).total_expenses;

    // suppress compiler warning by returning dummy value /
    // this statement should rightfully NEVER be reached /
    return (double)0;
}

/** \fn void set_current_shares_outstanding(int current_shares_outstanding)
 * \brief Set current_shares_outstanding memory variable for current X-machine.
 * \param current_shares_outstanding New value for variable.
 */
void set_current_shares_outstanding(int current_shares_outstanding)
{
	if(current_xmachine->xmachine_Firm) (*current_xmachine->xmachine_Firm).current_shares_outstanding = current_shares_outstanding;
	if(current_xmachine->xmachine_IGFirm) (*current_xmachine->xmachine_IGFirm).current_shares_outstanding = current_shares_outstanding;
	if(current_xmachine->xmachine_Bank) (*current_xmachine->xmachine_Bank).current_shares_outstanding = current_shares_outstanding;
}

/** \fn int get_current_shares_outstanding()
 * \brief Get current_shares_outstanding memory variable from current X-machine.
 * \return Value for variable.
 */
int get_current_shares_outstanding()
{
	if(current_xmachine->xmachine_Firm) return (*current_xmachine->xmachine_Firm).current_shares_outstanding;
	if(current_xmachine->xmachine_IGFirm) return (*current_xmachine->xmachine_IGFirm).current_shares_outstanding;
	if(current_xmachine->xmachine_Bank) return (*current_xmachine->xmachine_Bank).current_shares_outstanding;

    // suppress compiler warning by returning dummy value /
    // this statement should rightfully NEVER be reached /
    return (int)0;
}

/** \fn employee_array get_employees()
 * \brief Get employees memory variable from current X-machine.
 * \return Value for variable.
 */
employee_array * get_employees()
{
	if(current_xmachine->xmachine_Firm) return &(*current_xmachine->xmachine_Firm).employees;

    // suppress compiler warning by returning dummy value /
    // this statement should rightfully NEVER be reached /
    return NULL;
}

/** \fn employee_array get_r_and_d_employees()
 * \brief Get r_and_d_employees memory variable from current X-machine.
 * \return Value for variable.
 */
employee_array * get_r_and_d_employees()
{
	if(current_xmachine->xmachine_Firm) return &(*current_xmachine->xmachine_Firm).r_and_d_employees;

    // suppress compiler warning by returning dummy value /
    // this statement should rightfully NEVER be reached /
    return NULL;
}

/** \fn void set_wage_offer(double wage_offer)
 * \brief Set wage_offer memory variable for current X-machine.
 * \param wage_offer New value for variable.
 */
void set_wage_offer(double wage_offer)
{
	if(current_xmachine->xmachine_Firm) (*current_xmachine->xmachine_Firm).wage_offer = wage_offer;
	if(current_xmachine->xmachine_IGFirm) (*current_xmachine->xmachine_IGFirm).wage_offer = wage_offer;
}

/** \fn double get_wage_offer()
 * \brief Get wage_offer memory variable from current X-machine.
 * \return Value for variable.
 */
double get_wage_offer()
{
	if(current_xmachine->xmachine_Firm) return (*current_xmachine->xmachine_Firm).wage_offer;
	if(current_xmachine->xmachine_IGFirm) return (*current_xmachine->xmachine_IGFirm).wage_offer;

    // suppress compiler warning by returning dummy value /
    // this statement should rightfully NEVER be reached /
    return (double)0;
}

/** \fn void set_technology(double technology)
 * \brief Set technology memory variable for current X-machine.
 * \param technology New value for variable.
 */
void set_technology(double technology)
{
	if(current_xmachine->xmachine_Firm) (*current_xmachine->xmachine_Firm).technology = technology;
}

/** \fn double get_technology()
 * \brief Get technology memory variable from current X-machine.
 * \return Value for variable.
 */
double get_technology()
{
	if(current_xmachine->xmachine_Firm) return (*current_xmachine->xmachine_Firm).technology;

    // suppress compiler warning by returning dummy value /
    // this statement should rightfully NEVER be reached /
    return (double)0;
}

/** \fn void set_no_employees(int no_employees)
 * \brief Set no_employees memory variable for current X-machine.
 * \param no_employees New value for variable.
 */
void set_no_employees(int no_employees)
{
	if(current_xmachine->xmachine_Firm) (*current_xmachine->xmachine_Firm).no_employees = no_employees;
	if(current_xmachine->xmachine_Eurostat) (*current_xmachine->xmachine_Eurostat).no_employees = no_employees;
}

/** \fn int get_no_employees()
 * \brief Get no_employees memory variable from current X-machine.
 * \return Value for variable.
 */
int get_no_employees()
{
	if(current_xmachine->xmachine_Firm) return (*current_xmachine->xmachine_Firm).no_employees;
	if(current_xmachine->xmachine_Eurostat) return (*current_xmachine->xmachine_Eurostat).no_employees;

    // suppress compiler warning by returning dummy value /
    // this statement should rightfully NEVER be reached /
    return (int)0;
}

/** \fn void set_no_employees_skill_1(int no_employees_skill_1)
 * \brief Set no_employees_skill_1 memory variable for current X-machine.
 * \param no_employees_skill_1 New value for variable.
 */
void set_no_employees_skill_1(int no_employees_skill_1)
{
	if(current_xmachine->xmachine_Firm) (*current_xmachine->xmachine_Firm).no_employees_skill_1 = no_employees_skill_1;
	if(current_xmachine->xmachine_Eurostat) (*current_xmachine->xmachine_Eurostat).no_employees_skill_1 = no_employees_skill_1;
}

/** \fn int get_no_employees_skill_1()
 * \brief Get no_employees_skill_1 memory variable from current X-machine.
 * \return Value for variable.
 */
int get_no_employees_skill_1()
{
	if(current_xmachine->xmachine_Firm) return (*current_xmachine->xmachine_Firm).no_employees_skill_1;
	if(current_xmachine->xmachine_Eurostat) return (*current_xmachine->xmachine_Eurostat).no_employees_skill_1;

    // suppress compiler warning by returning dummy value /
    // this statement should rightfully NEVER be reached /
    return (int)0;
}

/** \fn void set_no_employees_skill_2(int no_employees_skill_2)
 * \brief Set no_employees_skill_2 memory variable for current X-machine.
 * \param no_employees_skill_2 New value for variable.
 */
void set_no_employees_skill_2(int no_employees_skill_2)
{
	if(current_xmachine->xmachine_Firm) (*current_xmachine->xmachine_Firm).no_employees_skill_2 = no_employees_skill_2;
	if(current_xmachine->xmachine_Eurostat) (*current_xmachine->xmachine_Eurostat).no_employees_skill_2 = no_employees_skill_2;
}

/** \fn int get_no_employees_skill_2()
 * \brief Get no_employees_skill_2 memory variable from current X-machine.
 * \return Value for variable.
 */
int get_no_employees_skill_2()
{
	if(current_xmachine->xmachine_Firm) return (*current_xmachine->xmachine_Firm).no_employees_skill_2;
	if(current_xmachine->xmachine_Eurostat) return (*current_xmachine->xmachine_Eurostat).no_employees_skill_2;

    // suppress compiler warning by returning dummy value /
    // this statement should rightfully NEVER be reached /
    return (int)0;
}

/** \fn void set_no_employees_skill_3(int no_employees_skill_3)
 * \brief Set no_employees_skill_3 memory variable for current X-machine.
 * \param no_employees_skill_3 New value for variable.
 */
void set_no_employees_skill_3(int no_employees_skill_3)
{
	if(current_xmachine->xmachine_Firm) (*current_xmachine->xmachine_Firm).no_employees_skill_3 = no_employees_skill_3;
	if(current_xmachine->xmachine_Eurostat) (*current_xmachine->xmachine_Eurostat).no_employees_skill_3 = no_employees_skill_3;
}

/** \fn int get_no_employees_skill_3()
 * \brief Get no_employees_skill_3 memory variable from current X-machine.
 * \return Value for variable.
 */
int get_no_employees_skill_3()
{
	if(current_xmachine->xmachine_Firm) return (*current_xmachine->xmachine_Firm).no_employees_skill_3;
	if(current_xmachine->xmachine_Eurostat) return (*current_xmachine->xmachine_Eurostat).no_employees_skill_3;

    // suppress compiler warning by returning dummy value /
    // this statement should rightfully NEVER be reached /
    return (int)0;
}

/** \fn void set_no_employees_skill_4(int no_employees_skill_4)
 * \brief Set no_employees_skill_4 memory variable for current X-machine.
 * \param no_employees_skill_4 New value for variable.
 */
void set_no_employees_skill_4(int no_employees_skill_4)
{
	if(current_xmachine->xmachine_Firm) (*current_xmachine->xmachine_Firm).no_employees_skill_4 = no_employees_skill_4;
	if(current_xmachine->xmachine_Eurostat) (*current_xmachine->xmachine_Eurostat).no_employees_skill_4 = no_employees_skill_4;
}

/** \fn int get_no_employees_skill_4()
 * \brief Get no_employees_skill_4 memory variable from current X-machine.
 * \return Value for variable.
 */
int get_no_employees_skill_4()
{
	if(current_xmachine->xmachine_Firm) return (*current_xmachine->xmachine_Firm).no_employees_skill_4;
	if(current_xmachine->xmachine_Eurostat) return (*current_xmachine->xmachine_Eurostat).no_employees_skill_4;

    // suppress compiler warning by returning dummy value /
    // this statement should rightfully NEVER be reached /
    return (int)0;
}

/** \fn void set_no_employees_skill_5(int no_employees_skill_5)
 * \brief Set no_employees_skill_5 memory variable for current X-machine.
 * \param no_employees_skill_5 New value for variable.
 */
void set_no_employees_skill_5(int no_employees_skill_5)
{
	if(current_xmachine->xmachine_Firm) (*current_xmachine->xmachine_Firm).no_employees_skill_5 = no_employees_skill_5;
	if(current_xmachine->xmachine_Eurostat) (*current_xmachine->xmachine_Eurostat).no_employees_skill_5 = no_employees_skill_5;
}

/** \fn int get_no_employees_skill_5()
 * \brief Get no_employees_skill_5 memory variable from current X-machine.
 * \return Value for variable.
 */
int get_no_employees_skill_5()
{
	if(current_xmachine->xmachine_Firm) return (*current_xmachine->xmachine_Firm).no_employees_skill_5;
	if(current_xmachine->xmachine_Eurostat) return (*current_xmachine->xmachine_Eurostat).no_employees_skill_5;

    // suppress compiler warning by returning dummy value /
    // this statement should rightfully NEVER be reached /
    return (int)0;
}

/** \fn void set_no_employees_subsidized(int no_employees_subsidized)
 * \brief Set no_employees_subsidized memory variable for current X-machine.
 * \param no_employees_subsidized New value for variable.
 */
void set_no_employees_subsidized(int no_employees_subsidized)
{
	if(current_xmachine->xmachine_Firm) (*current_xmachine->xmachine_Firm).no_employees_subsidized = no_employees_subsidized;
}

/** \fn int get_no_employees_subsidized()
 * \brief Get no_employees_subsidized memory variable from current X-machine.
 * \return Value for variable.
 */
int get_no_employees_subsidized()
{
	if(current_xmachine->xmachine_Firm) return (*current_xmachine->xmachine_Firm).no_employees_subsidized;

    // suppress compiler warning by returning dummy value /
    // this statement should rightfully NEVER be reached /
    return (int)0;
}

/** \fn void set_fraction_employees_subsidized(double fraction_employees_subsidized)
 * \brief Set fraction_employees_subsidized memory variable for current X-machine.
 * \param fraction_employees_subsidized New value for variable.
 */
void set_fraction_employees_subsidized(double fraction_employees_subsidized)
{
	if(current_xmachine->xmachine_Firm) (*current_xmachine->xmachine_Firm).fraction_employees_subsidized = fraction_employees_subsidized;
}

/** \fn double get_fraction_employees_subsidized()
 * \brief Get fraction_employees_subsidized memory variable from current X-machine.
 * \return Value for variable.
 */
double get_fraction_employees_subsidized()
{
	if(current_xmachine->xmachine_Firm) return (*current_xmachine->xmachine_Firm).fraction_employees_subsidized;

    // suppress compiler warning by returning dummy value /
    // this statement should rightfully NEVER be reached /
    return (double)0;
}

/** \fn void set_vacancies(int vacancies)
 * \brief Set vacancies memory variable for current X-machine.
 * \param vacancies New value for variable.
 */
void set_vacancies(int vacancies)
{
	if(current_xmachine->xmachine_Firm) (*current_xmachine->xmachine_Firm).vacancies = vacancies;
}

/** \fn int get_vacancies()
 * \brief Get vacancies memory variable from current X-machine.
 * \return Value for variable.
 */
int get_vacancies()
{
	if(current_xmachine->xmachine_Firm) return (*current_xmachine->xmachine_Firm).vacancies;

    // suppress compiler warning by returning dummy value /
    // this statement should rightfully NEVER be reached /
    return (int)0;
}

/** \fn void set_no_redundancies(int no_redundancies)
 * \brief Set no_redundancies memory variable for current X-machine.
 * \param no_redundancies New value for variable.
 */
void set_no_redundancies(int no_redundancies)
{
	if(current_xmachine->xmachine_Firm) (*current_xmachine->xmachine_Firm).no_redundancies = no_redundancies;
}

/** \fn int get_no_redundancies()
 * \brief Get no_redundancies memory variable from current X-machine.
 * \return Value for variable.
 */
int get_no_redundancies()
{
	if(current_xmachine->xmachine_Firm) return (*current_xmachine->xmachine_Firm).no_redundancies;

    // suppress compiler warning by returning dummy value /
    // this statement should rightfully NEVER be reached /
    return (int)0;
}

/** \fn void set_no_applications_round_1(int no_applications_round_1)
 * \brief Set no_applications_round_1 memory variable for current X-machine.
 * \param no_applications_round_1 New value for variable.
 */
void set_no_applications_round_1(int no_applications_round_1)
{
	if(current_xmachine->xmachine_Firm) (*current_xmachine->xmachine_Firm).no_applications_round_1 = no_applications_round_1;
}

/** \fn int get_no_applications_round_1()
 * \brief Get no_applications_round_1 memory variable from current X-machine.
 * \return Value for variable.
 */
int get_no_applications_round_1()
{
	if(current_xmachine->xmachine_Firm) return (*current_xmachine->xmachine_Firm).no_applications_round_1;

    // suppress compiler warning by returning dummy value /
    // this statement should rightfully NEVER be reached /
    return (int)0;
}

/** \fn void set_no_applications_round_2(int no_applications_round_2)
 * \brief Set no_applications_round_2 memory variable for current X-machine.
 * \param no_applications_round_2 New value for variable.
 */
void set_no_applications_round_2(int no_applications_round_2)
{
	if(current_xmachine->xmachine_Firm) (*current_xmachine->xmachine_Firm).no_applications_round_2 = no_applications_round_2;
}

/** \fn int get_no_applications_round_2()
 * \brief Get no_applications_round_2 memory variable from current X-machine.
 * \return Value for variable.
 */
int get_no_applications_round_2()
{
	if(current_xmachine->xmachine_Firm) return (*current_xmachine->xmachine_Firm).no_applications_round_2;

    // suppress compiler warning by returning dummy value /
    // this statement should rightfully NEVER be reached /
    return (int)0;
}

/** \fn void set_no_redundancies_r_and_d_employees(int no_redundancies_r_and_d_employees)
 * \brief Set no_redundancies_r_and_d_employees memory variable for current X-machine.
 * \param no_redundancies_r_and_d_employees New value for variable.
 */
void set_no_redundancies_r_and_d_employees(int no_redundancies_r_and_d_employees)
{
	if(current_xmachine->xmachine_Firm) (*current_xmachine->xmachine_Firm).no_redundancies_r_and_d_employees = no_redundancies_r_and_d_employees;
}

/** \fn int get_no_redundancies_r_and_d_employees()
 * \brief Get no_redundancies_r_and_d_employees memory variable from current X-machine.
 * \return Value for variable.
 */
int get_no_redundancies_r_and_d_employees()
{
	if(current_xmachine->xmachine_Firm) return (*current_xmachine->xmachine_Firm).no_redundancies_r_and_d_employees;

    // suppress compiler warning by returning dummy value /
    // this statement should rightfully NEVER be reached /
    return (int)0;
}

/** \fn void set_vacancies_r_and_d_employees(int vacancies_r_and_d_employees)
 * \brief Set vacancies_r_and_d_employees memory variable for current X-machine.
 * \param vacancies_r_and_d_employees New value for variable.
 */
void set_vacancies_r_and_d_employees(int vacancies_r_and_d_employees)
{
	if(current_xmachine->xmachine_Firm) (*current_xmachine->xmachine_Firm).vacancies_r_and_d_employees = vacancies_r_and_d_employees;
}

/** \fn int get_vacancies_r_and_d_employees()
 * \brief Get vacancies_r_and_d_employees memory variable from current X-machine.
 * \return Value for variable.
 */
int get_vacancies_r_and_d_employees()
{
	if(current_xmachine->xmachine_Firm) return (*current_xmachine->xmachine_Firm).vacancies_r_and_d_employees;

    // suppress compiler warning by returning dummy value /
    // this statement should rightfully NEVER be reached /
    return (int)0;
}

/** \fn void set_posted_vacancies(int posted_vacancies)
 * \brief Set posted_vacancies memory variable for current X-machine.
 * \param posted_vacancies New value for variable.
 */
void set_posted_vacancies(int posted_vacancies)
{
	if(current_xmachine->xmachine_Firm) (*current_xmachine->xmachine_Firm).posted_vacancies = posted_vacancies;
}

/** \fn int get_posted_vacancies()
 * \brief Get posted_vacancies memory variable from current X-machine.
 * \return Value for variable.
 */
int get_posted_vacancies()
{
	if(current_xmachine->xmachine_Firm) return (*current_xmachine->xmachine_Firm).posted_vacancies;

    // suppress compiler warning by returning dummy value /
    // this statement should rightfully NEVER be reached /
    return (int)0;
}

/** \fn void set_posted_vacancies_r_and_d_employees(int posted_vacancies_r_and_d_employees)
 * \brief Set posted_vacancies_r_and_d_employees memory variable for current X-machine.
 * \param posted_vacancies_r_and_d_employees New value for variable.
 */
void set_posted_vacancies_r_and_d_employees(int posted_vacancies_r_and_d_employees)
{
	if(current_xmachine->xmachine_Firm) (*current_xmachine->xmachine_Firm).posted_vacancies_r_and_d_employees = posted_vacancies_r_and_d_employees;
}

/** \fn int get_posted_vacancies_r_and_d_employees()
 * \brief Get posted_vacancies_r_and_d_employees memory variable from current X-machine.
 * \return Value for variable.
 */
int get_posted_vacancies_r_and_d_employees()
{
	if(current_xmachine->xmachine_Firm) return (*current_xmachine->xmachine_Firm).posted_vacancies_r_and_d_employees;

    // suppress compiler warning by returning dummy value /
    // this statement should rightfully NEVER be reached /
    return (int)0;
}

/** \fn void set_average_g_skill(double average_g_skill)
 * \brief Set average_g_skill memory variable for current X-machine.
 * \param average_g_skill New value for variable.
 */
void set_average_g_skill(double average_g_skill)
{
	if(current_xmachine->xmachine_Firm) (*current_xmachine->xmachine_Firm).average_g_skill = average_g_skill;
}

/** \fn double get_average_g_skill()
 * \brief Get average_g_skill memory variable from current X-machine.
 * \return Value for variable.
 */
double get_average_g_skill()
{
	if(current_xmachine->xmachine_Firm) return (*current_xmachine->xmachine_Firm).average_g_skill;

    // suppress compiler warning by returning dummy value /
    // this statement should rightfully NEVER be reached /
    return (double)0;
}

/** \fn void set_average_adaptation_speed_specific_skills(double average_adaptation_speed_specific_skills)
 * \brief Set average_adaptation_speed_specific_skills memory variable for current X-machine.
 * \param average_adaptation_speed_specific_skills New value for variable.
 */
void set_average_adaptation_speed_specific_skills(double average_adaptation_speed_specific_skills)
{
	if(current_xmachine->xmachine_Firm) (*current_xmachine->xmachine_Firm).average_adaptation_speed_specific_skills = average_adaptation_speed_specific_skills;
}

/** \fn double get_average_adaptation_speed_specific_skills()
 * \brief Get average_adaptation_speed_specific_skills memory variable from current X-machine.
 * \return Value for variable.
 */
double get_average_adaptation_speed_specific_skills()
{
	if(current_xmachine->xmachine_Firm) return (*current_xmachine->xmachine_Firm).average_adaptation_speed_specific_skills;

    // suppress compiler warning by returning dummy value /
    // this statement should rightfully NEVER be reached /
    return (double)0;
}

/** \fn adt_list_adaptation_speed_array get_list_adaptation_speed_per_skill_group()
 * \brief Get list_adaptation_speed_per_skill_group memory variable from current X-machine.
 * \return Value for variable.
 */
adt_list_adaptation_speed_array * get_list_adaptation_speed_per_skill_group()
{
	if(current_xmachine->xmachine_Firm) return &(*current_xmachine->xmachine_Firm).list_adaptation_speed_per_skill_group;

    // suppress compiler warning by returning dummy value /
    // this statement should rightfully NEVER be reached /
    return NULL;
}

/** \fn void set_average_s_skill_of_1(double average_s_skill_of_1)
 * \brief Set average_s_skill_of_1 memory variable for current X-machine.
 * \param average_s_skill_of_1 New value for variable.
 */
void set_average_s_skill_of_1(double average_s_skill_of_1)
{
	if(current_xmachine->xmachine_Firm) (*current_xmachine->xmachine_Firm).average_s_skill_of_1 = average_s_skill_of_1;
}

/** \fn double get_average_s_skill_of_1()
 * \brief Get average_s_skill_of_1 memory variable from current X-machine.
 * \return Value for variable.
 */
double get_average_s_skill_of_1()
{
	if(current_xmachine->xmachine_Firm) return (*current_xmachine->xmachine_Firm).average_s_skill_of_1;

    // suppress compiler warning by returning dummy value /
    // this statement should rightfully NEVER be reached /
    return (double)0;
}

/** \fn void set_average_s_skill_of_2(double average_s_skill_of_2)
 * \brief Set average_s_skill_of_2 memory variable for current X-machine.
 * \param average_s_skill_of_2 New value for variable.
 */
void set_average_s_skill_of_2(double average_s_skill_of_2)
{
	if(current_xmachine->xmachine_Firm) (*current_xmachine->xmachine_Firm).average_s_skill_of_2 = average_s_skill_of_2;
}

/** \fn double get_average_s_skill_of_2()
 * \brief Get average_s_skill_of_2 memory variable from current X-machine.
 * \return Value for variable.
 */
double get_average_s_skill_of_2()
{
	if(current_xmachine->xmachine_Firm) return (*current_xmachine->xmachine_Firm).average_s_skill_of_2;

    // suppress compiler warning by returning dummy value /
    // this statement should rightfully NEVER be reached /
    return (double)0;
}

/** \fn void set_average_s_skill_of_3(double average_s_skill_of_3)
 * \brief Set average_s_skill_of_3 memory variable for current X-machine.
 * \param average_s_skill_of_3 New value for variable.
 */
void set_average_s_skill_of_3(double average_s_skill_of_3)
{
	if(current_xmachine->xmachine_Firm) (*current_xmachine->xmachine_Firm).average_s_skill_of_3 = average_s_skill_of_3;
}

/** \fn double get_average_s_skill_of_3()
 * \brief Get average_s_skill_of_3 memory variable from current X-machine.
 * \return Value for variable.
 */
double get_average_s_skill_of_3()
{
	if(current_xmachine->xmachine_Firm) return (*current_xmachine->xmachine_Firm).average_s_skill_of_3;

    // suppress compiler warning by returning dummy value /
    // this statement should rightfully NEVER be reached /
    return (double)0;
}

/** \fn void set_average_s_skill_of_4(double average_s_skill_of_4)
 * \brief Set average_s_skill_of_4 memory variable for current X-machine.
 * \param average_s_skill_of_4 New value for variable.
 */
void set_average_s_skill_of_4(double average_s_skill_of_4)
{
	if(current_xmachine->xmachine_Firm) (*current_xmachine->xmachine_Firm).average_s_skill_of_4 = average_s_skill_of_4;
}

/** \fn double get_average_s_skill_of_4()
 * \brief Get average_s_skill_of_4 memory variable from current X-machine.
 * \return Value for variable.
 */
double get_average_s_skill_of_4()
{
	if(current_xmachine->xmachine_Firm) return (*current_xmachine->xmachine_Firm).average_s_skill_of_4;

    // suppress compiler warning by returning dummy value /
    // this statement should rightfully NEVER be reached /
    return (double)0;
}

/** \fn void set_average_s_skill_of_5(double average_s_skill_of_5)
 * \brief Set average_s_skill_of_5 memory variable for current X-machine.
 * \param average_s_skill_of_5 New value for variable.
 */
void set_average_s_skill_of_5(double average_s_skill_of_5)
{
	if(current_xmachine->xmachine_Firm) (*current_xmachine->xmachine_Firm).average_s_skill_of_5 = average_s_skill_of_5;
}

/** \fn double get_average_s_skill_of_5()
 * \brief Get average_s_skill_of_5 memory variable from current X-machine.
 * \return Value for variable.
 */
double get_average_s_skill_of_5()
{
	if(current_xmachine->xmachine_Firm) return (*current_xmachine->xmachine_Firm).average_s_skill_of_5;

    // suppress compiler warning by returning dummy value /
    // this statement should rightfully NEVER be reached /
    return (double)0;
}

/** \fn void set_wage_offer_for_skill_1(double wage_offer_for_skill_1)
 * \brief Set wage_offer_for_skill_1 memory variable for current X-machine.
 * \param wage_offer_for_skill_1 New value for variable.
 */
void set_wage_offer_for_skill_1(double wage_offer_for_skill_1)
{
	if(current_xmachine->xmachine_Firm) (*current_xmachine->xmachine_Firm).wage_offer_for_skill_1 = wage_offer_for_skill_1;
}

/** \fn double get_wage_offer_for_skill_1()
 * \brief Get wage_offer_for_skill_1 memory variable from current X-machine.
 * \return Value for variable.
 */
double get_wage_offer_for_skill_1()
{
	if(current_xmachine->xmachine_Firm) return (*current_xmachine->xmachine_Firm).wage_offer_for_skill_1;

    // suppress compiler warning by returning dummy value /
    // this statement should rightfully NEVER be reached /
    return (double)0;
}

/** \fn void set_wage_offer_for_skill_2(double wage_offer_for_skill_2)
 * \brief Set wage_offer_for_skill_2 memory variable for current X-machine.
 * \param wage_offer_for_skill_2 New value for variable.
 */
void set_wage_offer_for_skill_2(double wage_offer_for_skill_2)
{
	if(current_xmachine->xmachine_Firm) (*current_xmachine->xmachine_Firm).wage_offer_for_skill_2 = wage_offer_for_skill_2;
}

/** \fn double get_wage_offer_for_skill_2()
 * \brief Get wage_offer_for_skill_2 memory variable from current X-machine.
 * \return Value for variable.
 */
double get_wage_offer_for_skill_2()
{
	if(current_xmachine->xmachine_Firm) return (*current_xmachine->xmachine_Firm).wage_offer_for_skill_2;

    // suppress compiler warning by returning dummy value /
    // this statement should rightfully NEVER be reached /
    return (double)0;
}

/** \fn void set_wage_offer_for_skill_3(double wage_offer_for_skill_3)
 * \brief Set wage_offer_for_skill_3 memory variable for current X-machine.
 * \param wage_offer_for_skill_3 New value for variable.
 */
void set_wage_offer_for_skill_3(double wage_offer_for_skill_3)
{
	if(current_xmachine->xmachine_Firm) (*current_xmachine->xmachine_Firm).wage_offer_for_skill_3 = wage_offer_for_skill_3;
}

/** \fn double get_wage_offer_for_skill_3()
 * \brief Get wage_offer_for_skill_3 memory variable from current X-machine.
 * \return Value for variable.
 */
double get_wage_offer_for_skill_3()
{
	if(current_xmachine->xmachine_Firm) return (*current_xmachine->xmachine_Firm).wage_offer_for_skill_3;

    // suppress compiler warning by returning dummy value /
    // this statement should rightfully NEVER be reached /
    return (double)0;
}

/** \fn void set_wage_offer_for_skill_4(double wage_offer_for_skill_4)
 * \brief Set wage_offer_for_skill_4 memory variable for current X-machine.
 * \param wage_offer_for_skill_4 New value for variable.
 */
void set_wage_offer_for_skill_4(double wage_offer_for_skill_4)
{
	if(current_xmachine->xmachine_Firm) (*current_xmachine->xmachine_Firm).wage_offer_for_skill_4 = wage_offer_for_skill_4;
}

/** \fn double get_wage_offer_for_skill_4()
 * \brief Get wage_offer_for_skill_4 memory variable from current X-machine.
 * \return Value for variable.
 */
double get_wage_offer_for_skill_4()
{
	if(current_xmachine->xmachine_Firm) return (*current_xmachine->xmachine_Firm).wage_offer_for_skill_4;

    // suppress compiler warning by returning dummy value /
    // this statement should rightfully NEVER be reached /
    return (double)0;
}

/** \fn void set_wage_offer_for_skill_5(double wage_offer_for_skill_5)
 * \brief Set wage_offer_for_skill_5 memory variable for current X-machine.
 * \param wage_offer_for_skill_5 New value for variable.
 */
void set_wage_offer_for_skill_5(double wage_offer_for_skill_5)
{
	if(current_xmachine->xmachine_Firm) (*current_xmachine->xmachine_Firm).wage_offer_for_skill_5 = wage_offer_for_skill_5;
}

/** \fn double get_wage_offer_for_skill_5()
 * \brief Get wage_offer_for_skill_5 memory variable from current X-machine.
 * \return Value for variable.
 */
double get_wage_offer_for_skill_5()
{
	if(current_xmachine->xmachine_Firm) return (*current_xmachine->xmachine_Firm).wage_offer_for_skill_5;

    // suppress compiler warning by returning dummy value /
    // this statement should rightfully NEVER be reached /
    return (double)0;
}

/** \fn void set_wage_offer_for_r_and_d_employees(double wage_offer_for_r_and_d_employees)
 * \brief Set wage_offer_for_r_and_d_employees memory variable for current X-machine.
 * \param wage_offer_for_r_and_d_employees New value for variable.
 */
void set_wage_offer_for_r_and_d_employees(double wage_offer_for_r_and_d_employees)
{
	if(current_xmachine->xmachine_Firm) (*current_xmachine->xmachine_Firm).wage_offer_for_r_and_d_employees = wage_offer_for_r_and_d_employees;
}

/** \fn double get_wage_offer_for_r_and_d_employees()
 * \brief Get wage_offer_for_r_and_d_employees memory variable from current X-machine.
 * \return Value for variable.
 */
double get_wage_offer_for_r_and_d_employees()
{
	if(current_xmachine->xmachine_Firm) return (*current_xmachine->xmachine_Firm).wage_offer_for_r_and_d_employees;

    // suppress compiler warning by returning dummy value /
    // this statement should rightfully NEVER be reached /
    return (double)0;
}

/** \fn void set_base_wage_offer_r_and_d(double base_wage_offer_r_and_d)
 * \brief Set base_wage_offer_r_and_d memory variable for current X-machine.
 * \param base_wage_offer_r_and_d New value for variable.
 */
void set_base_wage_offer_r_and_d(double base_wage_offer_r_and_d)
{
	if(current_xmachine->xmachine_Firm) (*current_xmachine->xmachine_Firm).base_wage_offer_r_and_d = base_wage_offer_r_and_d;
}

/** \fn double get_base_wage_offer_r_and_d()
 * \brief Get base_wage_offer_r_and_d memory variable from current X-machine.
 * \return Value for variable.
 */
double get_base_wage_offer_r_and_d()
{
	if(current_xmachine->xmachine_Firm) return (*current_xmachine->xmachine_Firm).base_wage_offer_r_and_d;

    // suppress compiler warning by returning dummy value /
    // this statement should rightfully NEVER be reached /
    return (double)0;
}

/** \fn void set_employees_needed(int employees_needed)
 * \brief Set employees_needed memory variable for current X-machine.
 * \param employees_needed New value for variable.
 */
void set_employees_needed(int employees_needed)
{
	if(current_xmachine->xmachine_Firm) (*current_xmachine->xmachine_Firm).employees_needed = employees_needed;
}

/** \fn int get_employees_needed()
 * \brief Get employees_needed memory variable from current X-machine.
 * \return Value for variable.
 */
int get_employees_needed()
{
	if(current_xmachine->xmachine_Firm) return (*current_xmachine->xmachine_Firm).employees_needed;

    // suppress compiler warning by returning dummy value /
    // this statement should rightfully NEVER be reached /
    return (int)0;
}

/** \fn firm_balance_sheet_adt get_firm_balance_sheet_calendar()
 * \brief Get firm_balance_sheet_calendar memory variable from current X-machine.
 * \return Value for variable.
 */
firm_balance_sheet_adt * get_firm_balance_sheet_calendar()
{
	if(current_xmachine->xmachine_Firm) return &(*current_xmachine->xmachine_Firm).firm_balance_sheet_calendar;

    // suppress compiler warning by returning dummy value /
    // this statement should rightfully NEVER be reached /
    return NULL;
}

/** \fn firm_stocks_adt get_firm_stocks_calendar()
 * \brief Get firm_stocks_calendar memory variable from current X-machine.
 * \return Value for variable.
 */
firm_stocks_adt * get_firm_stocks_calendar()
{
	if(current_xmachine->xmachine_Firm) return &(*current_xmachine->xmachine_Firm).firm_stocks_calendar;

    // suppress compiler warning by returning dummy value /
    // this statement should rightfully NEVER be reached /
    return NULL;
}

/** \fn firm_outflows_adt get_firm_outflows_calendar()
 * \brief Get firm_outflows_calendar memory variable from current X-machine.
 * \return Value for variable.
 */
firm_outflows_adt * get_firm_outflows_calendar()
{
	if(current_xmachine->xmachine_Firm) return &(*current_xmachine->xmachine_Firm).firm_outflows_calendar;

    // suppress compiler warning by returning dummy value /
    // this statement should rightfully NEVER be reached /
    return NULL;
}

/** \fn firm_inflows_adt get_firm_inflows_calendar()
 * \brief Get firm_inflows_calendar memory variable from current X-machine.
 * \return Value for variable.
 */
firm_inflows_adt * get_firm_inflows_calendar()
{
	if(current_xmachine->xmachine_Firm) return &(*current_xmachine->xmachine_Firm).firm_inflows_calendar;

    // suppress compiler warning by returning dummy value /
    // this statement should rightfully NEVER be reached /
    return NULL;
}

/** \fn void set_age(int age)
 * \brief Set age memory variable for current X-machine.
 * \param age New value for variable.
 */
void set_age(int age)
{
	if(current_xmachine->xmachine_Firm) (*current_xmachine->xmachine_Firm).age = age;
	if(current_xmachine->xmachine_IGFirm) (*current_xmachine->xmachine_IGFirm).age = age;
}

/** \fn int get_age()
 * \brief Get age memory variable from current X-machine.
 * \return Value for variable.
 */
int get_age()
{
	if(current_xmachine->xmachine_Firm) return (*current_xmachine->xmachine_Firm).age;
	if(current_xmachine->xmachine_IGFirm) return (*current_xmachine->xmachine_IGFirm).age;

    // suppress compiler warning by returning dummy value /
    // this statement should rightfully NEVER be reached /
    return (int)0;
}

/** \fn void set_transfer_payment(double transfer_payment)
 * \brief Set transfer_payment memory variable for current X-machine.
 * \param transfer_payment New value for variable.
 */
void set_transfer_payment(double transfer_payment)
{
	if(current_xmachine->xmachine_Firm) (*current_xmachine->xmachine_Firm).transfer_payment = transfer_payment;
	if(current_xmachine->xmachine_Household) (*current_xmachine->xmachine_Household).transfer_payment = transfer_payment;
	if(current_xmachine->xmachine_IGFirm) (*current_xmachine->xmachine_IGFirm).transfer_payment = transfer_payment;
}

/** \fn double get_transfer_payment()
 * \brief Get transfer_payment memory variable from current X-machine.
 * \return Value for variable.
 */
double get_transfer_payment()
{
	if(current_xmachine->xmachine_Firm) return (*current_xmachine->xmachine_Firm).transfer_payment;
	if(current_xmachine->xmachine_Household) return (*current_xmachine->xmachine_Household).transfer_payment;
	if(current_xmachine->xmachine_IGFirm) return (*current_xmachine->xmachine_IGFirm).transfer_payment;

    // suppress compiler warning by returning dummy value /
    // this statement should rightfully NEVER be reached /
    return (double)0;
}

/** \fn void set_subsidy_pct(double subsidy_pct)
 * \brief Set subsidy_pct memory variable for current X-machine.
 * \param subsidy_pct New value for variable.
 */
void set_subsidy_pct(double subsidy_pct)
{
	if(current_xmachine->xmachine_Firm) (*current_xmachine->xmachine_Firm).subsidy_pct = subsidy_pct;
	if(current_xmachine->xmachine_Household) (*current_xmachine->xmachine_Household).subsidy_pct = subsidy_pct;
	if(current_xmachine->xmachine_IGFirm) (*current_xmachine->xmachine_IGFirm).subsidy_pct = subsidy_pct;
}

/** \fn double get_subsidy_pct()
 * \brief Get subsidy_pct memory variable from current X-machine.
 * \return Value for variable.
 */
double get_subsidy_pct()
{
	if(current_xmachine->xmachine_Firm) return (*current_xmachine->xmachine_Firm).subsidy_pct;
	if(current_xmachine->xmachine_Household) return (*current_xmachine->xmachine_Household).subsidy_pct;
	if(current_xmachine->xmachine_IGFirm) return (*current_xmachine->xmachine_IGFirm).subsidy_pct;

    // suppress compiler warning by returning dummy value /
    // this statement should rightfully NEVER be reached /
    return (double)0;
}

/** \fn void set_active(int active)
 * \brief Set active memory variable for current X-machine.
 * \param active New value for variable.
 */
void set_active(int active)
{
	if(current_xmachine->xmachine_Firm) (*current_xmachine->xmachine_Firm).active = active;
	if(current_xmachine->xmachine_IGFirm) (*current_xmachine->xmachine_IGFirm).active = active;
	if(current_xmachine->xmachine_Bank) (*current_xmachine->xmachine_Bank).active = active;
}

/** \fn int get_active()
 * \brief Get active memory variable from current X-machine.
 * \return Value for variable.
 */
int get_active()
{
	if(current_xmachine->xmachine_Firm) return (*current_xmachine->xmachine_Firm).active;
	if(current_xmachine->xmachine_IGFirm) return (*current_xmachine->xmachine_IGFirm).active;
	if(current_xmachine->xmachine_Bank) return (*current_xmachine->xmachine_Bank).active;

    // suppress compiler warning by returning dummy value /
    // this statement should rightfully NEVER be reached /
    return (int)0;
}

/** \fn void set_inactive(int inactive)
 * \brief Set inactive memory variable for current X-machine.
 * \param inactive New value for variable.
 */
void set_inactive(int inactive)
{
	if(current_xmachine->xmachine_Firm) (*current_xmachine->xmachine_Firm).inactive = inactive;
	if(current_xmachine->xmachine_Bank) (*current_xmachine->xmachine_Bank).inactive = inactive;
}

/** \fn int get_inactive()
 * \brief Get inactive memory variable from current X-machine.
 * \return Value for variable.
 */
int get_inactive()
{
	if(current_xmachine->xmachine_Firm) return (*current_xmachine->xmachine_Firm).inactive;
	if(current_xmachine->xmachine_Bank) return (*current_xmachine->xmachine_Bank).inactive;

    // suppress compiler warning by returning dummy value /
    // this statement should rightfully NEVER be reached /
    return (int)0;
}

/** \fn void set_zero_output(int zero_output)
 * \brief Set zero_output memory variable for current X-machine.
 * \param zero_output New value for variable.
 */
void set_zero_output(int zero_output)
{
	if(current_xmachine->xmachine_Firm) (*current_xmachine->xmachine_Firm).zero_output = zero_output;
}

/** \fn int get_zero_output()
 * \brief Get zero_output memory variable from current X-machine.
 * \return Value for variable.
 */
int get_zero_output()
{
	if(current_xmachine->xmachine_Firm) return (*current_xmachine->xmachine_Firm).zero_output;

    // suppress compiler warning by returning dummy value /
    // this statement should rightfully NEVER be reached /
    return (int)0;
}

/** \fn void set_bankruptcy_idle_counter(int bankruptcy_idle_counter)
 * \brief Set bankruptcy_idle_counter memory variable for current X-machine.
 * \param bankruptcy_idle_counter New value for variable.
 */
void set_bankruptcy_idle_counter(int bankruptcy_idle_counter)
{
	if(current_xmachine->xmachine_Firm) (*current_xmachine->xmachine_Firm).bankruptcy_idle_counter = bankruptcy_idle_counter;
	if(current_xmachine->xmachine_IGFirm) (*current_xmachine->xmachine_IGFirm).bankruptcy_idle_counter = bankruptcy_idle_counter;
}

/** \fn int get_bankruptcy_idle_counter()
 * \brief Get bankruptcy_idle_counter memory variable from current X-machine.
 * \return Value for variable.
 */
int get_bankruptcy_idle_counter()
{
	if(current_xmachine->xmachine_Firm) return (*current_xmachine->xmachine_Firm).bankruptcy_idle_counter;
	if(current_xmachine->xmachine_IGFirm) return (*current_xmachine->xmachine_IGFirm).bankruptcy_idle_counter;

    // suppress compiler warning by returning dummy value /
    // this statement should rightfully NEVER be reached /
    return (int)0;
}

/** \fn void set_bankruptcy_state(int bankruptcy_state)
 * \brief Set bankruptcy_state memory variable for current X-machine.
 * \param bankruptcy_state New value for variable.
 */
void set_bankruptcy_state(int bankruptcy_state)
{
	if(current_xmachine->xmachine_Firm) (*current_xmachine->xmachine_Firm).bankruptcy_state = bankruptcy_state;
	if(current_xmachine->xmachine_IGFirm) (*current_xmachine->xmachine_IGFirm).bankruptcy_state = bankruptcy_state;
}

/** \fn int get_bankruptcy_state()
 * \brief Get bankruptcy_state memory variable from current X-machine.
 * \return Value for variable.
 */
int get_bankruptcy_state()
{
	if(current_xmachine->xmachine_Firm) return (*current_xmachine->xmachine_Firm).bankruptcy_state;
	if(current_xmachine->xmachine_IGFirm) return (*current_xmachine->xmachine_IGFirm).bankruptcy_state;

    // suppress compiler warning by returning dummy value /
    // this statement should rightfully NEVER be reached /
    return (int)0;
}

/** \fn void set_bankruptcy_insolvency_state(int bankruptcy_insolvency_state)
 * \brief Set bankruptcy_insolvency_state memory variable for current X-machine.
 * \param bankruptcy_insolvency_state New value for variable.
 */
void set_bankruptcy_insolvency_state(int bankruptcy_insolvency_state)
{
	if(current_xmachine->xmachine_Firm) (*current_xmachine->xmachine_Firm).bankruptcy_insolvency_state = bankruptcy_insolvency_state;
	if(current_xmachine->xmachine_IGFirm) (*current_xmachine->xmachine_IGFirm).bankruptcy_insolvency_state = bankruptcy_insolvency_state;
}

/** \fn int get_bankruptcy_insolvency_state()
 * \brief Get bankruptcy_insolvency_state memory variable from current X-machine.
 * \return Value for variable.
 */
int get_bankruptcy_insolvency_state()
{
	if(current_xmachine->xmachine_Firm) return (*current_xmachine->xmachine_Firm).bankruptcy_insolvency_state;
	if(current_xmachine->xmachine_IGFirm) return (*current_xmachine->xmachine_IGFirm).bankruptcy_insolvency_state;

    // suppress compiler warning by returning dummy value /
    // this statement should rightfully NEVER be reached /
    return (int)0;
}

/** \fn void set_bankruptcy_illiquidity_state(int bankruptcy_illiquidity_state)
 * \brief Set bankruptcy_illiquidity_state memory variable for current X-machine.
 * \param bankruptcy_illiquidity_state New value for variable.
 */
void set_bankruptcy_illiquidity_state(int bankruptcy_illiquidity_state)
{
	if(current_xmachine->xmachine_Firm) (*current_xmachine->xmachine_Firm).bankruptcy_illiquidity_state = bankruptcy_illiquidity_state;
	if(current_xmachine->xmachine_IGFirm) (*current_xmachine->xmachine_IGFirm).bankruptcy_illiquidity_state = bankruptcy_illiquidity_state;
}

/** \fn int get_bankruptcy_illiquidity_state()
 * \brief Get bankruptcy_illiquidity_state memory variable from current X-machine.
 * \return Value for variable.
 */
int get_bankruptcy_illiquidity_state()
{
	if(current_xmachine->xmachine_Firm) return (*current_xmachine->xmachine_Firm).bankruptcy_illiquidity_state;
	if(current_xmachine->xmachine_IGFirm) return (*current_xmachine->xmachine_IGFirm).bankruptcy_illiquidity_state;

    // suppress compiler warning by returning dummy value /
    // this statement should rightfully NEVER be reached /
    return (int)0;
}

/** \fn void set_financial_crisis_state(int financial_crisis_state)
 * \brief Set financial_crisis_state memory variable for current X-machine.
 * \param financial_crisis_state New value for variable.
 */
void set_financial_crisis_state(int financial_crisis_state)
{
	if(current_xmachine->xmachine_Firm) (*current_xmachine->xmachine_Firm).financial_crisis_state = financial_crisis_state;
	if(current_xmachine->xmachine_IGFirm) (*current_xmachine->xmachine_IGFirm).financial_crisis_state = financial_crisis_state;
}

/** \fn int get_financial_crisis_state()
 * \brief Get financial_crisis_state memory variable from current X-machine.
 * \return Value for variable.
 */
int get_financial_crisis_state()
{
	if(current_xmachine->xmachine_Firm) return (*current_xmachine->xmachine_Firm).financial_crisis_state;
	if(current_xmachine->xmachine_IGFirm) return (*current_xmachine->xmachine_IGFirm).financial_crisis_state;

    // suppress compiler warning by returning dummy value /
    // this statement should rightfully NEVER be reached /
    return (int)0;
}

/** \fn void set_vacancy_filling_rate(double vacancy_filling_rate)
 * \brief Set vacancy_filling_rate memory variable for current X-machine.
 * \param vacancy_filling_rate New value for variable.
 */
void set_vacancy_filling_rate(double vacancy_filling_rate)
{
	if(current_xmachine->xmachine_Firm) (*current_xmachine->xmachine_Firm).vacancy_filling_rate = vacancy_filling_rate;
}

/** \fn double get_vacancy_filling_rate()
 * \brief Get vacancy_filling_rate memory variable from current X-machine.
 * \return Value for variable.
 */
double get_vacancy_filling_rate()
{
	if(current_xmachine->xmachine_Firm) return (*current_xmachine->xmachine_Firm).vacancy_filling_rate;

    // suppress compiler warning by returning dummy value /
    // this statement should rightfully NEVER be reached /
    return (double)0;
}

/** \fn void set_average_s_skill_from_eurostat(double average_s_skill_from_eurostat)
 * \brief Set average_s_skill_from_eurostat memory variable for current X-machine.
 * \param average_s_skill_from_eurostat New value for variable.
 */
void set_average_s_skill_from_eurostat(double average_s_skill_from_eurostat)
{
	if(current_xmachine->xmachine_Firm) (*current_xmachine->xmachine_Firm).average_s_skill_from_eurostat = average_s_skill_from_eurostat;
}

/** \fn double get_average_s_skill_from_eurostat()
 * \brief Get average_s_skill_from_eurostat memory variable from current X-machine.
 * \return Value for variable.
 */
double get_average_s_skill_from_eurostat()
{
	if(current_xmachine->xmachine_Firm) return (*current_xmachine->xmachine_Firm).average_s_skill_from_eurostat;

    // suppress compiler warning by returning dummy value /
    // this statement should rightfully NEVER be reached /
    return (double)0;
}

/** \fn void set_average_technology_from_eurostat(double average_technology_from_eurostat)
 * \brief Set average_technology_from_eurostat memory variable for current X-machine.
 * \param average_technology_from_eurostat New value for variable.
 */
void set_average_technology_from_eurostat(double average_technology_from_eurostat)
{
	if(current_xmachine->xmachine_Firm) (*current_xmachine->xmachine_Firm).average_technology_from_eurostat = average_technology_from_eurostat;
}

/** \fn double get_average_technology_from_eurostat()
 * \brief Get average_technology_from_eurostat memory variable from current X-machine.
 * \return Value for variable.
 */
double get_average_technology_from_eurostat()
{
	if(current_xmachine->xmachine_Firm) return (*current_xmachine->xmachine_Firm).average_technology_from_eurostat;

    // suppress compiler warning by returning dummy value /
    // this statement should rightfully NEVER be reached /
    return (double)0;
}

/** \fn void set_average_wage_offer_from_eurostat(double average_wage_offer_from_eurostat)
 * \brief Set average_wage_offer_from_eurostat memory variable for current X-machine.
 * \param average_wage_offer_from_eurostat New value for variable.
 */
void set_average_wage_offer_from_eurostat(double average_wage_offer_from_eurostat)
{
	if(current_xmachine->xmachine_Firm) (*current_xmachine->xmachine_Firm).average_wage_offer_from_eurostat = average_wage_offer_from_eurostat;
}

/** \fn double get_average_wage_offer_from_eurostat()
 * \brief Get average_wage_offer_from_eurostat memory variable from current X-machine.
 * \return Value for variable.
 */
double get_average_wage_offer_from_eurostat()
{
	if(current_xmachine->xmachine_Firm) return (*current_xmachine->xmachine_Firm).average_wage_offer_from_eurostat;

    // suppress compiler warning by returning dummy value /
    // this statement should rightfully NEVER be reached /
    return (double)0;
}

/** \fn void set_average_output_from_eurostat(double average_output_from_eurostat)
 * \brief Set average_output_from_eurostat memory variable for current X-machine.
 * \param average_output_from_eurostat New value for variable.
 */
void set_average_output_from_eurostat(double average_output_from_eurostat)
{
	if(current_xmachine->xmachine_Firm) (*current_xmachine->xmachine_Firm).average_output_from_eurostat = average_output_from_eurostat;
}

/** \fn double get_average_output_from_eurostat()
 * \brief Get average_output_from_eurostat memory variable from current X-machine.
 * \return Value for variable.
 */
double get_average_output_from_eurostat()
{
	if(current_xmachine->xmachine_Firm) return (*current_xmachine->xmachine_Firm).average_output_from_eurostat;

    // suppress compiler warning by returning dummy value /
    // this statement should rightfully NEVER be reached /
    return (double)0;
}

/** \fn price_quality_pair_array get_quality_price_competitors()
 * \brief Get quality_price_competitors memory variable from current X-machine.
 * \return Value for variable.
 */
price_quality_pair_array * get_quality_price_competitors()
{
	if(current_xmachine->xmachine_Firm) return &(*current_xmachine->xmachine_Firm).quality_price_competitors;

    // suppress compiler warning by returning dummy value /
    // this statement should rightfully NEVER be reached /
    return NULL;
}

/** \fn void set_subsidy_payment(double subsidy_payment)
 * \brief Set subsidy_payment memory variable for current X-machine.
 * \param subsidy_payment New value for variable.
 */
void set_subsidy_payment(double subsidy_payment)
{
	if(current_xmachine->xmachine_Firm) (*current_xmachine->xmachine_Firm).subsidy_payment = subsidy_payment;
	if(current_xmachine->xmachine_Household) (*current_xmachine->xmachine_Household).subsidy_payment = subsidy_payment;
	if(current_xmachine->xmachine_IGFirm) (*current_xmachine->xmachine_IGFirm).subsidy_payment = subsidy_payment;
}

/** \fn double get_subsidy_payment()
 * \brief Get subsidy_payment memory variable from current X-machine.
 * \return Value for variable.
 */
double get_subsidy_payment()
{
	if(current_xmachine->xmachine_Firm) return (*current_xmachine->xmachine_Firm).subsidy_payment;
	if(current_xmachine->xmachine_Household) return (*current_xmachine->xmachine_Household).subsidy_payment;
	if(current_xmachine->xmachine_IGFirm) return (*current_xmachine->xmachine_IGFirm).subsidy_payment;

    // suppress compiler warning by returning dummy value /
    // this statement should rightfully NEVER be reached /
    return (double)0;
}

/** \fn void set_current_price_index(double current_price_index)
 * \brief Set current_price_index memory variable for current X-machine.
 * \param current_price_index New value for variable.
 */
void set_current_price_index(double current_price_index)
{
	if(current_xmachine->xmachine_Firm) (*current_xmachine->xmachine_Firm).current_price_index = current_price_index;
}

/** \fn double get_current_price_index()
 * \brief Get current_price_index memory variable from current X-machine.
 * \return Value for variable.
 */
double get_current_price_index()
{
	if(current_xmachine->xmachine_Firm) return (*current_xmachine->xmachine_Firm).current_price_index;

    // suppress compiler warning by returning dummy value /
    // this statement should rightfully NEVER be reached /
    return (double)0;
}

/** \fn void set_current_quality_index(double current_quality_index)
 * \brief Set current_quality_index memory variable for current X-machine.
 * \param current_quality_index New value for variable.
 */
void set_current_quality_index(double current_quality_index)
{
	if(current_xmachine->xmachine_Firm) (*current_xmachine->xmachine_Firm).current_quality_index = current_quality_index;
}

/** \fn double get_current_quality_index()
 * \brief Get current_quality_index memory variable from current X-machine.
 * \return Value for variable.
 */
double get_current_quality_index()
{
	if(current_xmachine->xmachine_Firm) return (*current_xmachine->xmachine_Firm).current_quality_index;

    // suppress compiler warning by returning dummy value /
    // this statement should rightfully NEVER be reached /
    return (double)0;
}

/** \fn void set_minimum_wage(double minimum_wage)
 * \brief Set minimum_wage memory variable for current X-machine.
 * \param minimum_wage New value for variable.
 */
void set_minimum_wage(double minimum_wage)
{
	if(current_xmachine->xmachine_Firm) (*current_xmachine->xmachine_Firm).minimum_wage = minimum_wage;
	if(current_xmachine->xmachine_Household) (*current_xmachine->xmachine_Household).minimum_wage = minimum_wage;
	if(current_xmachine->xmachine_Government) (*current_xmachine->xmachine_Government).minimum_wage = minimum_wage;
}

/** \fn double get_minimum_wage()
 * \brief Get minimum_wage memory variable from current X-machine.
 * \return Value for variable.
 */
double get_minimum_wage()
{
	if(current_xmachine->xmachine_Firm) return (*current_xmachine->xmachine_Firm).minimum_wage;
	if(current_xmachine->xmachine_Household) return (*current_xmachine->xmachine_Household).minimum_wage;
	if(current_xmachine->xmachine_Government) return (*current_xmachine->xmachine_Government).minimum_wage;

    // suppress compiler warning by returning dummy value /
    // this statement should rightfully NEVER be reached /
    return (double)0;
}

/** \fn void set_no_competitors(int no_competitors)
 * \brief Set no_competitors memory variable for current X-machine.
 * \param no_competitors New value for variable.
 */
void set_no_competitors(int no_competitors)
{
	if(current_xmachine->xmachine_Firm) (*current_xmachine->xmachine_Firm).no_competitors = no_competitors;
}

/** \fn int get_no_competitors()
 * \brief Get no_competitors memory variable from current X-machine.
 * \return Value for variable.
 */
int get_no_competitors()
{
	if(current_xmachine->xmachine_Firm) return (*current_xmachine->xmachine_Firm).no_competitors;

    // suppress compiler warning by returning dummy value /
    // this statement should rightfully NEVER be reached /
    return (int)0;
}

/** \fn void set_indicator_earnings(int indicator_earnings)
 * \brief Set indicator_earnings memory variable for current X-machine.
 * \param indicator_earnings New value for variable.
 */
void set_indicator_earnings(int indicator_earnings)
{
	if(current_xmachine->xmachine_Firm) (*current_xmachine->xmachine_Firm).indicator_earnings = indicator_earnings;
}

/** \fn int get_indicator_earnings()
 * \brief Get indicator_earnings memory variable from current X-machine.
 * \return Value for variable.
 */
int get_indicator_earnings()
{
	if(current_xmachine->xmachine_Firm) return (*current_xmachine->xmachine_Firm).indicator_earnings;

    // suppress compiler warning by returning dummy value /
    // this statement should rightfully NEVER be reached /
    return (int)0;
}

/** \fn void set_indicator_capital_costs(int indicator_capital_costs)
 * \brief Set indicator_capital_costs memory variable for current X-machine.
 * \param indicator_capital_costs New value for variable.
 */
void set_indicator_capital_costs(int indicator_capital_costs)
{
	if(current_xmachine->xmachine_Firm) (*current_xmachine->xmachine_Firm).indicator_capital_costs = indicator_capital_costs;
}

/** \fn int get_indicator_capital_costs()
 * \brief Get indicator_capital_costs memory variable from current X-machine.
 * \return Value for variable.
 */
int get_indicator_capital_costs()
{
	if(current_xmachine->xmachine_Firm) return (*current_xmachine->xmachine_Firm).indicator_capital_costs;

    // suppress compiler warning by returning dummy value /
    // this statement should rightfully NEVER be reached /
    return (int)0;
}

/** \fn void set_agg_vacancy_filling_rate(double agg_vacancy_filling_rate)
 * \brief Set agg_vacancy_filling_rate memory variable for current X-machine.
 * \param agg_vacancy_filling_rate New value for variable.
 */
void set_agg_vacancy_filling_rate(double agg_vacancy_filling_rate)
{
	if(current_xmachine->xmachine_Firm) (*current_xmachine->xmachine_Firm).agg_vacancy_filling_rate = agg_vacancy_filling_rate;
}

/** \fn double get_agg_vacancy_filling_rate()
 * \brief Get agg_vacancy_filling_rate memory variable from current X-machine.
 * \return Value for variable.
 */
double get_agg_vacancy_filling_rate()
{
	if(current_xmachine->xmachine_Firm) return (*current_xmachine->xmachine_Firm).agg_vacancy_filling_rate;

    // suppress compiler warning by returning dummy value /
    // this statement should rightfully NEVER be reached /
    return (double)0;
}

/** \fn void set_market_research_sample_size(int market_research_sample_size)
 * \brief Set market_research_sample_size memory variable for current X-machine.
 * \param market_research_sample_size New value for variable.
 */
void set_market_research_sample_size(int market_research_sample_size)
{
	if(current_xmachine->xmachine_Firm) (*current_xmachine->xmachine_Firm).market_research_sample_size = market_research_sample_size;
}

/** \fn int get_market_research_sample_size()
 * \brief Get market_research_sample_size memory variable from current X-machine.
 * \return Value for variable.
 */
int get_market_research_sample_size()
{
	if(current_xmachine->xmachine_Firm) return (*current_xmachine->xmachine_Firm).market_research_sample_size;

    // suppress compiler warning by returning dummy value /
    // this statement should rightfully NEVER be reached /
    return (int)0;
}

/** \fn void set_product_innovation(int product_innovation)
 * \brief Set product_innovation memory variable for current X-machine.
 * \param product_innovation New value for variable.
 */
void set_product_innovation(int product_innovation)
{
	if(current_xmachine->xmachine_Firm) (*current_xmachine->xmachine_Firm).product_innovation = product_innovation;
}

/** \fn int get_product_innovation()
 * \brief Get product_innovation memory variable from current X-machine.
 * \return Value for variable.
 */
int get_product_innovation()
{
	if(current_xmachine->xmachine_Firm) return (*current_xmachine->xmachine_Firm).product_innovation;

    // suppress compiler warning by returning dummy value /
    // this statement should rightfully NEVER be reached /
    return (int)0;
}

/** \fn void set_regional_analysis(int regional_analysis)
 * \brief Set regional_analysis memory variable for current X-machine.
 * \param regional_analysis New value for variable.
 */
void set_regional_analysis(int regional_analysis)
{
	if(current_xmachine->xmachine_Firm) (*current_xmachine->xmachine_Firm).regional_analysis = regional_analysis;
}

/** \fn int get_regional_analysis()
 * \brief Get regional_analysis memory variable from current X-machine.
 * \return Value for variable.
 */
int get_regional_analysis()
{
	if(current_xmachine->xmachine_Firm) return (*current_xmachine->xmachine_Firm).regional_analysis;

    // suppress compiler warning by returning dummy value /
    // this statement should rightfully NEVER be reached /
    return (int)0;
}

/** \fn void set_day_of_year_market_research(int day_of_year_market_research)
 * \brief Set day_of_year_market_research memory variable for current X-machine.
 * \param day_of_year_market_research New value for variable.
 */
void set_day_of_year_market_research(int day_of_year_market_research)
{
	if(current_xmachine->xmachine_Firm) (*current_xmachine->xmachine_Firm).day_of_year_market_research = day_of_year_market_research;
}

/** \fn int get_day_of_year_market_research()
 * \brief Get day_of_year_market_research memory variable from current X-machine.
 * \return Value for variable.
 */
int get_day_of_year_market_research()
{
	if(current_xmachine->xmachine_Firm) return (*current_xmachine->xmachine_Firm).day_of_year_market_research;

    // suppress compiler warning by returning dummy value /
    // this statement should rightfully NEVER be reached /
    return (int)0;
}

/** \fn void set_day_of_month_price_was_set(int day_of_month_price_was_set)
 * \brief Set day_of_month_price_was_set memory variable for current X-machine.
 * \param day_of_month_price_was_set New value for variable.
 */
void set_day_of_month_price_was_set(int day_of_month_price_was_set)
{
	if(current_xmachine->xmachine_Firm) (*current_xmachine->xmachine_Firm).day_of_month_price_was_set = day_of_month_price_was_set;
}

/** \fn int get_day_of_month_price_was_set()
 * \brief Get day_of_month_price_was_set memory variable from current X-machine.
 * \return Value for variable.
 */
int get_day_of_month_price_was_set()
{
	if(current_xmachine->xmachine_Firm) return (*current_xmachine->xmachine_Firm).day_of_month_price_was_set;

    // suppress compiler warning by returning dummy value /
    // this statement should rightfully NEVER be reached /
    return (int)0;
}

/** \fn void set_actual_sample_size(int actual_sample_size)
 * \brief Set actual_sample_size memory variable for current X-machine.
 * \param actual_sample_size New value for variable.
 */
void set_actual_sample_size(int actual_sample_size)
{
	if(current_xmachine->xmachine_Firm) (*current_xmachine->xmachine_Firm).actual_sample_size = actual_sample_size;
}

/** \fn int get_actual_sample_size()
 * \brief Get actual_sample_size memory variable from current X-machine.
 * \return Value for variable.
 */
int get_actual_sample_size()
{
	if(current_xmachine->xmachine_Firm) return (*current_xmachine->xmachine_Firm).actual_sample_size;

    // suppress compiler warning by returning dummy value /
    // this statement should rightfully NEVER be reached /
    return (int)0;
}

/** \fn dt_total_and_regional_market_size_array get_last_market_sizes()
 * \brief Get last_market_sizes memory variable from current X-machine.
 * \return Value for variable.
 */
dt_total_and_regional_market_size_array * get_last_market_sizes()
{
	if(current_xmachine->xmachine_Firm) return &(*current_xmachine->xmachine_Firm).last_market_sizes;

    // suppress compiler warning by returning dummy value /
    // this statement should rightfully NEVER be reached /
    return NULL;
}

/** \fn dt_price_range get_price_range_pricing()
 * \brief Get price_range_pricing memory variable from current X-machine.
 * \return Value for variable.
 */
dt_price_range * get_price_range_pricing()
{
	if(current_xmachine->xmachine_Firm) return &(*current_xmachine->xmachine_Firm).price_range_pricing;

    // suppress compiler warning by returning dummy value /
    // this statement should rightfully NEVER be reached /
    return NULL;
}

/** \fn void set_estimated_variance_market_share(double estimated_variance_market_share)
 * \brief Set estimated_variance_market_share memory variable for current X-machine.
 * \param estimated_variance_market_share New value for variable.
 */
void set_estimated_variance_market_share(double estimated_variance_market_share)
{
	if(current_xmachine->xmachine_Firm) (*current_xmachine->xmachine_Firm).estimated_variance_market_share = estimated_variance_market_share;
}

/** \fn double get_estimated_variance_market_share()
 * \brief Get estimated_variance_market_share memory variable from current X-machine.
 * \return Value for variable.
 */
double get_estimated_variance_market_share()
{
	if(current_xmachine->xmachine_Firm) return (*current_xmachine->xmachine_Firm).estimated_variance_market_share;

    // suppress compiler warning by returning dummy value /
    // this statement should rightfully NEVER be reached /
    return (double)0;
}

/** \fn price_quality_pair get_estimated_coefficients()
 * \brief Get estimated_coefficients memory variable from current X-machine.
 * \return Value for variable.
 */
price_quality_pair * get_estimated_coefficients()
{
	if(current_xmachine->xmachine_Firm) return &(*current_xmachine->xmachine_Firm).estimated_coefficients;

    // suppress compiler warning by returning dummy value /
    // this statement should rightfully NEVER be reached /
    return NULL;
}

/** \fn dt_price_range get_price_range_innovation()
 * \brief Get price_range_innovation memory variable from current X-machine.
 * \return Value for variable.
 */
dt_price_range * get_price_range_innovation()
{
	if(current_xmachine->xmachine_Firm) return &(*current_xmachine->xmachine_Firm).price_range_innovation;

    // suppress compiler warning by returning dummy value /
    // this statement should rightfully NEVER be reached /
    return NULL;
}

/** \fn int get_price_quality_counts()
 * \brief Get price_quality_counts memory variable from current X-machine.
 * \return Value for variable.
 */
int * get_price_quality_counts()
{
	if(current_xmachine->xmachine_Firm) return (*current_xmachine->xmachine_Firm).price_quality_counts;

    // suppress compiler warning by returning dummy value /
    // this statement should rightfully NEVER be reached /
    return NULL;
}

/** \fn price_quality_pair get_price_quality_inno()
 * \brief Get price_quality_inno memory variable from current X-machine.
 * \return Value for variable.
 */
price_quality_pair * get_price_quality_inno()
{
	if(current_xmachine->xmachine_Firm) return (*current_xmachine->xmachine_Firm).price_quality_inno;

    // suppress compiler warning by returning dummy value /
    // this statement should rightfully NEVER be reached /
    return NULL;
}

/** \fn void set_new_product_released(int new_product_released)
 * \brief Set new_product_released memory variable for current X-machine.
 * \param new_product_released New value for variable.
 */
void set_new_product_released(int new_product_released)
{
	if(current_xmachine->xmachine_Firm) (*current_xmachine->xmachine_Firm).new_product_released = new_product_released;
}

/** \fn int get_new_product_released()
 * \brief Get new_product_released memory variable from current X-machine.
 * \return Value for variable.
 */
int get_new_product_released()
{
	if(current_xmachine->xmachine_Firm) return (*current_xmachine->xmachine_Firm).new_product_released;

    // suppress compiler warning by returning dummy value /
    // this statement should rightfully NEVER be reached /
    return (int)0;
}

/** \fn dt_prospective_variables_array get_prospective_variables()
 * \brief Get prospective_variables memory variable from current X-machine.
 * \return Value for variable.
 */
dt_prospective_variables_array * get_prospective_variables()
{
	if(current_xmachine->xmachine_Firm) return &(*current_xmachine->xmachine_Firm).prospective_variables;

    // suppress compiler warning by returning dummy value /
    // this statement should rightfully NEVER be reached /
    return NULL;
}

/** \fn void set_price_at_questionnaire(double price_at_questionnaire)
 * \brief Set price_at_questionnaire memory variable for current X-machine.
 * \param price_at_questionnaire New value for variable.
 */
void set_price_at_questionnaire(double price_at_questionnaire)
{
	if(current_xmachine->xmachine_Firm) (*current_xmachine->xmachine_Firm).price_at_questionnaire = price_at_questionnaire;
}

/** \fn double get_price_at_questionnaire()
 * \brief Get price_at_questionnaire memory variable from current X-machine.
 * \return Value for variable.
 */
double get_price_at_questionnaire()
{
	if(current_xmachine->xmachine_Firm) return (*current_xmachine->xmachine_Firm).price_at_questionnaire;

    // suppress compiler warning by returning dummy value /
    // this statement should rightfully NEVER be reached /
    return (double)0;
}

/** \fn void set_price_index_at_questionnaire(double price_index_at_questionnaire)
 * \brief Set price_index_at_questionnaire memory variable for current X-machine.
 * \param price_index_at_questionnaire New value for variable.
 */
void set_price_index_at_questionnaire(double price_index_at_questionnaire)
{
	if(current_xmachine->xmachine_Firm) (*current_xmachine->xmachine_Firm).price_index_at_questionnaire = price_index_at_questionnaire;
}

/** \fn double get_price_index_at_questionnaire()
 * \brief Get price_index_at_questionnaire memory variable from current X-machine.
 * \return Value for variable.
 */
double get_price_index_at_questionnaire()
{
	if(current_xmachine->xmachine_Firm) return (*current_xmachine->xmachine_Firm).price_index_at_questionnaire;

    // suppress compiler warning by returning dummy value /
    // this statement should rightfully NEVER be reached /
    return (double)0;
}

/** \fn dt_best_price_strategies_array get_best_pricing_strategies()
 * \brief Get best_pricing_strategies memory variable from current X-machine.
 * \return Value for variable.
 */
dt_best_price_strategies_array * get_best_pricing_strategies()
{
	if(current_xmachine->xmachine_Firm) return &(*current_xmachine->xmachine_Firm).best_pricing_strategies;

    // suppress compiler warning by returning dummy value /
    // this statement should rightfully NEVER be reached /
    return NULL;
}

/** \fn void set_intermediate_quality(double intermediate_quality)
 * \brief Set intermediate_quality memory variable for current X-machine.
 * \param intermediate_quality New value for variable.
 */
void set_intermediate_quality(double intermediate_quality)
{
	if(current_xmachine->xmachine_Firm) (*current_xmachine->xmachine_Firm).intermediate_quality = intermediate_quality;
}

/** \fn double get_intermediate_quality()
 * \brief Get intermediate_quality memory variable from current X-machine.
 * \return Value for variable.
 */
double get_intermediate_quality()
{
	if(current_xmachine->xmachine_Firm) return (*current_xmachine->xmachine_Firm).intermediate_quality;

    // suppress compiler warning by returning dummy value /
    // this statement should rightfully NEVER be reached /
    return (double)0;
}

/** \fn void set_no_employees_product_innovation_fundable(int no_employees_product_innovation_fundable)
 * \brief Set no_employees_product_innovation_fundable memory variable for current X-machine.
 * \param no_employees_product_innovation_fundable New value for variable.
 */
void set_no_employees_product_innovation_fundable(int no_employees_product_innovation_fundable)
{
	if(current_xmachine->xmachine_Firm) (*current_xmachine->xmachine_Firm).no_employees_product_innovation_fundable = no_employees_product_innovation_fundable;
}

/** \fn int get_no_employees_product_innovation_fundable()
 * \brief Get no_employees_product_innovation_fundable memory variable from current X-machine.
 * \return Value for variable.
 */
int get_no_employees_product_innovation_fundable()
{
	if(current_xmachine->xmachine_Firm) return (*current_xmachine->xmachine_Firm).no_employees_product_innovation_fundable;

    // suppress compiler warning by returning dummy value /
    // this statement should rightfully NEVER be reached /
    return (int)0;
}

/** \fn void set_r_and_d_probability_for_incremental_success(double r_and_d_probability_for_incremental_success)
 * \brief Set r_and_d_probability_for_incremental_success memory variable for current X-machine.
 * \param r_and_d_probability_for_incremental_success New value for variable.
 */
void set_r_and_d_probability_for_incremental_success(double r_and_d_probability_for_incremental_success)
{
	if(current_xmachine->xmachine_Firm) (*current_xmachine->xmachine_Firm).r_and_d_probability_for_incremental_success = r_and_d_probability_for_incremental_success;
}

/** \fn double get_r_and_d_probability_for_incremental_success()
 * \brief Get r_and_d_probability_for_incremental_success memory variable from current X-machine.
 * \return Value for variable.
 */
double get_r_and_d_probability_for_incremental_success()
{
	if(current_xmachine->xmachine_Firm) return (*current_xmachine->xmachine_Firm).r_and_d_probability_for_incremental_success;

    // suppress compiler warning by returning dummy value /
    // this statement should rightfully NEVER be reached /
    return (double)0;
}

/** \fn void set_day_of_year_price_setting(int day_of_year_price_setting)
 * \brief Set day_of_year_price_setting memory variable for current X-machine.
 * \param day_of_year_price_setting New value for variable.
 */
void set_day_of_year_price_setting(int day_of_year_price_setting)
{
	if(current_xmachine->xmachine_Firm) (*current_xmachine->xmachine_Firm).day_of_year_price_setting = day_of_year_price_setting;
}

/** \fn int get_day_of_year_price_setting()
 * \brief Get day_of_year_price_setting memory variable from current X-machine.
 * \return Value for variable.
 */
int get_day_of_year_price_setting()
{
	if(current_xmachine->xmachine_Firm) return (*current_xmachine->xmachine_Firm).day_of_year_price_setting;

    // suppress compiler warning by returning dummy value /
    // this statement should rightfully NEVER be reached /
    return (int)0;
}

/** \fn void set_market_research_active(int market_research_active)
 * \brief Set market_research_active memory variable for current X-machine.
 * \param market_research_active New value for variable.
 */
void set_market_research_active(int market_research_active)
{
	if(current_xmachine->xmachine_Firm) (*current_xmachine->xmachine_Firm).market_research_active = market_research_active;
}

/** \fn int get_market_research_active()
 * \brief Get market_research_active memory variable from current X-machine.
 * \return Value for variable.
 */
int get_market_research_active()
{
	if(current_xmachine->xmachine_Firm) return (*current_xmachine->xmachine_Firm).market_research_active;

    // suppress compiler warning by returning dummy value /
    // this statement should rightfully NEVER be reached /
    return (int)0;
}

/** \fn void set_innovation_successful(int innovation_successful)
 * \brief Set innovation_successful memory variable for current X-machine.
 * \param innovation_successful New value for variable.
 */
void set_innovation_successful(int innovation_successful)
{
	if(current_xmachine->xmachine_Firm) (*current_xmachine->xmachine_Firm).innovation_successful = innovation_successful;
}

/** \fn int get_innovation_successful()
 * \brief Get innovation_successful memory variable from current X-machine.
 * \return Value for variable.
 */
int get_innovation_successful()
{
	if(current_xmachine->xmachine_Firm) return (*current_xmachine->xmachine_Firm).innovation_successful;

    // suppress compiler warning by returning dummy value /
    // this statement should rightfully NEVER be reached /
    return (int)0;
}

/** \fn void set_actual_market_share(double actual_market_share)
 * \brief Set actual_market_share memory variable for current X-machine.
 * \param actual_market_share New value for variable.
 */
void set_actual_market_share(double actual_market_share)
{
	if(current_xmachine->xmachine_Firm) (*current_xmachine->xmachine_Firm).actual_market_share = actual_market_share;
}

/** \fn double get_actual_market_share()
 * \brief Get actual_market_share memory variable from current X-machine.
 * \return Value for variable.
 */
double get_actual_market_share()
{
	if(current_xmachine->xmachine_Firm) return (*current_xmachine->xmachine_Firm).actual_market_share;

    // suppress compiler warning by returning dummy value /
    // this statement should rightfully NEVER be reached /
    return (double)0;
}

/** \fn void set_market_size(double market_size)
 * \brief Set market_size memory variable for current X-machine.
 * \param market_size New value for variable.
 */
void set_market_size(double market_size)
{
	if(current_xmachine->xmachine_Firm) (*current_xmachine->xmachine_Firm).market_size = market_size;
}

/** \fn double get_market_size()
 * \brief Get market_size memory variable from current X-machine.
 * \return Value for variable.
 */
double get_market_size()
{
	if(current_xmachine->xmachine_Firm) return (*current_xmachine->xmachine_Firm).market_size;

    // suppress compiler warning by returning dummy value /
    // this statement should rightfully NEVER be reached /
    return (double)0;
}

/** \fn void set_market_size_reg1(double market_size_reg1)
 * \brief Set market_size_reg1 memory variable for current X-machine.
 * \param market_size_reg1 New value for variable.
 */
void set_market_size_reg1(double market_size_reg1)
{
	if(current_xmachine->xmachine_Firm) (*current_xmachine->xmachine_Firm).market_size_reg1 = market_size_reg1;
}

/** \fn double get_market_size_reg1()
 * \brief Get market_size_reg1 memory variable from current X-machine.
 * \return Value for variable.
 */
double get_market_size_reg1()
{
	if(current_xmachine->xmachine_Firm) return (*current_xmachine->xmachine_Firm).market_size_reg1;

    // suppress compiler warning by returning dummy value /
    // this statement should rightfully NEVER be reached /
    return (double)0;
}

/** \fn void set_market_size_reg2(double market_size_reg2)
 * \brief Set market_size_reg2 memory variable for current X-machine.
 * \param market_size_reg2 New value for variable.
 */
void set_market_size_reg2(double market_size_reg2)
{
	if(current_xmachine->xmachine_Firm) (*current_xmachine->xmachine_Firm).market_size_reg2 = market_size_reg2;
}

/** \fn double get_market_size_reg2()
 * \brief Get market_size_reg2 memory variable from current X-machine.
 * \return Value for variable.
 */
double get_market_size_reg2()
{
	if(current_xmachine->xmachine_Firm) return (*current_xmachine->xmachine_Firm).market_size_reg2;

    // suppress compiler warning by returning dummy value /
    // this statement should rightfully NEVER be reached /
    return (double)0;
}

/** \fn void set_estimated_market_size(double estimated_market_size)
 * \brief Set estimated_market_size memory variable for current X-machine.
 * \param estimated_market_size New value for variable.
 */
void set_estimated_market_size(double estimated_market_size)
{
	if(current_xmachine->xmachine_Firm) (*current_xmachine->xmachine_Firm).estimated_market_size = estimated_market_size;
}

/** \fn double get_estimated_market_size()
 * \brief Get estimated_market_size memory variable from current X-machine.
 * \return Value for variable.
 */
double get_estimated_market_size()
{
	if(current_xmachine->xmachine_Firm) return (*current_xmachine->xmachine_Firm).estimated_market_size;

    // suppress compiler warning by returning dummy value /
    // this statement should rightfully NEVER be reached /
    return (double)0;
}

/** \fn estimators_linear_regression_array get_linear_regression_market_size()
 * \brief Get linear_regression_market_size memory variable from current X-machine.
 * \return Value for variable.
 */
estimators_linear_regression_array * get_linear_regression_market_size()
{
	if(current_xmachine->xmachine_Firm) return &(*current_xmachine->xmachine_Firm).linear_regression_market_size;

    // suppress compiler warning by returning dummy value /
    // this statement should rightfully NEVER be reached /
    return NULL;
}

/** \fn void set_counter_month_since_last_price_setting(int counter_month_since_last_price_setting)
 * \brief Set counter_month_since_last_price_setting memory variable for current X-machine.
 * \param counter_month_since_last_price_setting New value for variable.
 */
void set_counter_month_since_last_price_setting(int counter_month_since_last_price_setting)
{
	if(current_xmachine->xmachine_Firm) (*current_xmachine->xmachine_Firm).counter_month_since_last_price_setting = counter_month_since_last_price_setting;
}

/** \fn int get_counter_month_since_last_price_setting()
 * \brief Get counter_month_since_last_price_setting memory variable from current X-machine.
 * \return Value for variable.
 */
int get_counter_month_since_last_price_setting()
{
	if(current_xmachine->xmachine_Firm) return (*current_xmachine->xmachine_Firm).counter_month_since_last_price_setting;

    // suppress compiler warning by returning dummy value /
    // this statement should rightfully NEVER be reached /
    return (int)0;
}

/** \fn dt_demand_function get_demand_function_pricing()
 * \brief Get demand_function_pricing memory variable from current X-machine.
 * \return Value for variable.
 */
dt_demand_function * get_demand_function_pricing()
{
	if(current_xmachine->xmachine_Firm) return &(*current_xmachine->xmachine_Firm).demand_function_pricing;

    // suppress compiler warning by returning dummy value /
    // this statement should rightfully NEVER be reached /
    return NULL;
}

/** \fn dt_demand_function_array get_demand_functions_product_innovation()
 * \brief Get demand_functions_product_innovation memory variable from current X-machine.
 * \return Value for variable.
 */
dt_demand_function_array * get_demand_functions_product_innovation()
{
	if(current_xmachine->xmachine_Firm) return &(*current_xmachine->xmachine_Firm).demand_functions_product_innovation;

    // suppress compiler warning by returning dummy value /
    // this statement should rightfully NEVER be reached /
    return NULL;
}

/** \fn void set_market_research_delayed(int market_research_delayed)
 * \brief Set market_research_delayed memory variable for current X-machine.
 * \param market_research_delayed New value for variable.
 */
void set_market_research_delayed(int market_research_delayed)
{
	if(current_xmachine->xmachine_Firm) (*current_xmachine->xmachine_Firm).market_research_delayed = market_research_delayed;
}

/** \fn int get_market_research_delayed()
 * \brief Get market_research_delayed memory variable from current X-machine.
 * \return Value for variable.
 */
int get_market_research_delayed()
{
	if(current_xmachine->xmachine_Firm) return (*current_xmachine->xmachine_Firm).market_research_delayed;

    // suppress compiler warning by returning dummy value /
    // this statement should rightfully NEVER be reached /
    return (int)0;
}

/** \fn dt_market_research_price_array get_market_research_data_pricing()
 * \brief Get market_research_data_pricing memory variable from current X-machine.
 * \return Value for variable.
 */
dt_market_research_price_array * get_market_research_data_pricing()
{
	if(current_xmachine->xmachine_Firm) return &(*current_xmachine->xmachine_Firm).market_research_data_pricing;

    // suppress compiler warning by returning dummy value /
    // this statement should rightfully NEVER be reached /
    return NULL;
}

/** \fn dt_market_research_qualities_array get_market_research_data_product_innovation()
 * \brief Get market_research_data_product_innovation memory variable from current X-machine.
 * \return Value for variable.
 */
dt_market_research_qualities_array * get_market_research_data_product_innovation()
{
	if(current_xmachine->xmachine_Firm) return &(*current_xmachine->xmachine_Firm).market_research_data_product_innovation;

    // suppress compiler warning by returning dummy value /
    // this statement should rightfully NEVER be reached /
    return NULL;
}

/** \fn void set_expected_earnings_per_month(double expected_earnings_per_month)
 * \brief Set expected_earnings_per_month memory variable for current X-machine.
 * \param expected_earnings_per_month New value for variable.
 */
void set_expected_earnings_per_month(double expected_earnings_per_month)
{
	if(current_xmachine->xmachine_Firm) (*current_xmachine->xmachine_Firm).expected_earnings_per_month = expected_earnings_per_month;
}

/** \fn double get_expected_earnings_per_month()
 * \brief Get expected_earnings_per_month memory variable from current X-machine.
 * \return Value for variable.
 */
double get_expected_earnings_per_month()
{
	if(current_xmachine->xmachine_Firm) return (*current_xmachine->xmachine_Firm).expected_earnings_per_month;

    // suppress compiler warning by returning dummy value /
    // this statement should rightfully NEVER be reached /
    return (double)0;
}

/** \fn double_array get_expected_price_choices()
 * \brief Get expected_price_choices memory variable from current X-machine.
 * \return Value for variable.
 */
double_array * get_expected_price_choices()
{
	if(current_xmachine->xmachine_Firm) return &(*current_xmachine->xmachine_Firm).expected_price_choices;

    // suppress compiler warning by returning dummy value /
    // this statement should rightfully NEVER be reached /
    return NULL;
}

/** \fn void set_no_considered_qualities(double no_considered_qualities)
 * \brief Set no_considered_qualities memory variable for current X-machine.
 * \param no_considered_qualities New value for variable.
 */
void set_no_considered_qualities(double no_considered_qualities)
{
	if(current_xmachine->xmachine_Firm) (*current_xmachine->xmachine_Firm).no_considered_qualities = no_considered_qualities;
}

/** \fn double get_no_considered_qualities()
 * \brief Get no_considered_qualities memory variable from current X-machine.
 * \return Value for variable.
 */
double get_no_considered_qualities()
{
	if(current_xmachine->xmachine_Firm) return (*current_xmachine->xmachine_Firm).no_considered_qualities;

    // suppress compiler warning by returning dummy value /
    // this statement should rightfully NEVER be reached /
    return (double)0;
}

/** \fn void set_last_interest_rate_for_loans(double last_interest_rate_for_loans)
 * \brief Set last_interest_rate_for_loans memory variable for current X-machine.
 * \param last_interest_rate_for_loans New value for variable.
 */
void set_last_interest_rate_for_loans(double last_interest_rate_for_loans)
{
	if(current_xmachine->xmachine_Firm) (*current_xmachine->xmachine_Firm).last_interest_rate_for_loans = last_interest_rate_for_loans;
}

/** \fn double get_last_interest_rate_for_loans()
 * \brief Get last_interest_rate_for_loans memory variable from current X-machine.
 * \return Value for variable.
 */
double get_last_interest_rate_for_loans()
{
	if(current_xmachine->xmachine_Firm) return (*current_xmachine->xmachine_Firm).last_interest_rate_for_loans;

    // suppress compiler warning by returning dummy value /
    // this statement should rightfully NEVER be reached /
    return (double)0;
}

/** \fn void set_cum_earnings_last_r_d_project(double cum_earnings_last_r_d_project)
 * \brief Set cum_earnings_last_r_d_project memory variable for current X-machine.
 * \param cum_earnings_last_r_d_project New value for variable.
 */
void set_cum_earnings_last_r_d_project(double cum_earnings_last_r_d_project)
{
	if(current_xmachine->xmachine_Firm) (*current_xmachine->xmachine_Firm).cum_earnings_last_r_d_project = cum_earnings_last_r_d_project;
}

/** \fn double get_cum_earnings_last_r_d_project()
 * \brief Get cum_earnings_last_r_d_project memory variable from current X-machine.
 * \return Value for variable.
 */
double get_cum_earnings_last_r_d_project()
{
	if(current_xmachine->xmachine_Firm) return (*current_xmachine->xmachine_Firm).cum_earnings_last_r_d_project;

    // suppress compiler warning by returning dummy value /
    // this statement should rightfully NEVER be reached /
    return (double)0;
}

/** \fn void set_cum_r_d_investments(double cum_r_d_investments)
 * \brief Set cum_r_d_investments memory variable for current X-machine.
 * \param cum_r_d_investments New value for variable.
 */
void set_cum_r_d_investments(double cum_r_d_investments)
{
	if(current_xmachine->xmachine_Firm) (*current_xmachine->xmachine_Firm).cum_r_d_investments = cum_r_d_investments;
}

/** \fn double get_cum_r_d_investments()
 * \brief Get cum_r_d_investments memory variable from current X-machine.
 * \return Value for variable.
 */
double get_cum_r_d_investments()
{
	if(current_xmachine->xmachine_Firm) return (*current_xmachine->xmachine_Firm).cum_r_d_investments;

    // suppress compiler warning by returning dummy value /
    // this statement should rightfully NEVER be reached /
    return (double)0;
}

/** \fn void set_r_d_investments_last_project(double r_d_investments_last_project)
 * \brief Set r_d_investments_last_project memory variable for current X-machine.
 * \param r_d_investments_last_project New value for variable.
 */
void set_r_d_investments_last_project(double r_d_investments_last_project)
{
	if(current_xmachine->xmachine_Firm) (*current_xmachine->xmachine_Firm).r_d_investments_last_project = r_d_investments_last_project;
}

/** \fn double get_r_d_investments_last_project()
 * \brief Get r_d_investments_last_project memory variable from current X-machine.
 * \return Value for variable.
 */
double get_r_d_investments_last_project()
{
	if(current_xmachine->xmachine_Firm) return (*current_xmachine->xmachine_Firm).r_d_investments_last_project;

    // suppress compiler warning by returning dummy value /
    // this statement should rightfully NEVER be reached /
    return (double)0;
}

/** \fn void set_total_person_months(int total_person_months)
 * \brief Set total_person_months memory variable for current X-machine.
 * \param total_person_months New value for variable.
 */
void set_total_person_months(int total_person_months)
{
	if(current_xmachine->xmachine_Firm) (*current_xmachine->xmachine_Firm).total_person_months = total_person_months;
}

/** \fn int get_total_person_months()
 * \brief Get total_person_months memory variable from current X-machine.
 * \return Value for variable.
 */
int get_total_person_months()
{
	if(current_xmachine->xmachine_Firm) return (*current_xmachine->xmachine_Firm).total_person_months;

    // suppress compiler warning by returning dummy value /
    // this statement should rightfully NEVER be reached /
    return (int)0;
}

/** \fn void set_cum_person_months(int cum_person_months)
 * \brief Set cum_person_months memory variable for current X-machine.
 * \param cum_person_months New value for variable.
 */
void set_cum_person_months(int cum_person_months)
{
	if(current_xmachine->xmachine_Firm) (*current_xmachine->xmachine_Firm).cum_person_months = cum_person_months;
}

/** \fn int get_cum_person_months()
 * \brief Get cum_person_months memory variable from current X-machine.
 * \return Value for variable.
 */
int get_cum_person_months()
{
	if(current_xmachine->xmachine_Firm) return (*current_xmachine->xmachine_Firm).cum_person_months;

    // suppress compiler warning by returning dummy value /
    // this statement should rightfully NEVER be reached /
    return (int)0;
}

/** \fn void set_actual_r_and_d_success_probability(double actual_r_and_d_success_probability)
 * \brief Set actual_r_and_d_success_probability memory variable for current X-machine.
 * \param actual_r_and_d_success_probability New value for variable.
 */
void set_actual_r_and_d_success_probability(double actual_r_and_d_success_probability)
{
	if(current_xmachine->xmachine_Firm) (*current_xmachine->xmachine_Firm).actual_r_and_d_success_probability = actual_r_and_d_success_probability;
}

/** \fn double get_actual_r_and_d_success_probability()
 * \brief Get actual_r_and_d_success_probability memory variable from current X-machine.
 * \return Value for variable.
 */
double get_actual_r_and_d_success_probability()
{
	if(current_xmachine->xmachine_Firm) return (*current_xmachine->xmachine_Firm).actual_r_and_d_success_probability;

    // suppress compiler warning by returning dummy value /
    // this statement should rightfully NEVER be reached /
    return (double)0;
}

/** \fn void set_last_quality(double last_quality)
 * \brief Set last_quality memory variable for current X-machine.
 * \param last_quality New value for variable.
 */
void set_last_quality(double last_quality)
{
	if(current_xmachine->xmachine_Firm) (*current_xmachine->xmachine_Firm).last_quality = last_quality;
}

/** \fn double get_last_quality()
 * \brief Get last_quality memory variable from current X-machine.
 * \return Value for variable.
 */
double get_last_quality()
{
	if(current_xmachine->xmachine_Firm) return (*current_xmachine->xmachine_Firm).last_quality;

    // suppress compiler warning by returning dummy value /
    // this statement should rightfully NEVER be reached /
    return (double)0;
}

/** \fn void set_quality_change(double quality_change)
 * \brief Set quality_change memory variable for current X-machine.
 * \param quality_change New value for variable.
 */
void set_quality_change(double quality_change)
{
	if(current_xmachine->xmachine_Firm) (*current_xmachine->xmachine_Firm).quality_change = quality_change;
}

/** \fn double get_quality_change()
 * \brief Get quality_change memory variable from current X-machine.
 * \return Value for variable.
 */
double get_quality_change()
{
	if(current_xmachine->xmachine_Firm) return (*current_xmachine->xmachine_Firm).quality_change;

    // suppress compiler warning by returning dummy value /
    // this statement should rightfully NEVER be reached /
    return (double)0;
}

/** \fn void set_expected_sold_quantity_per_month(double expected_sold_quantity_per_month)
 * \brief Set expected_sold_quantity_per_month memory variable for current X-machine.
 * \param expected_sold_quantity_per_month New value for variable.
 */
void set_expected_sold_quantity_per_month(double expected_sold_quantity_per_month)
{
	if(current_xmachine->xmachine_Firm) (*current_xmachine->xmachine_Firm).expected_sold_quantity_per_month = expected_sold_quantity_per_month;
}

/** \fn double get_expected_sold_quantity_per_month()
 * \brief Get expected_sold_quantity_per_month memory variable from current X-machine.
 * \return Value for variable.
 */
double get_expected_sold_quantity_per_month()
{
	if(current_xmachine->xmachine_Firm) return (*current_xmachine->xmachine_Firm).expected_sold_quantity_per_month;

    // suppress compiler warning by returning dummy value /
    // this statement should rightfully NEVER be reached /
    return (double)0;
}

/** \fn void set_estimated_market_share(double estimated_market_share)
 * \brief Set estimated_market_share memory variable for current X-machine.
 * \param estimated_market_share New value for variable.
 */
void set_estimated_market_share(double estimated_market_share)
{
	if(current_xmachine->xmachine_Firm) (*current_xmachine->xmachine_Firm).estimated_market_share = estimated_market_share;
}

/** \fn double get_estimated_market_share()
 * \brief Get estimated_market_share memory variable from current X-machine.
 * \return Value for variable.
 */
double get_estimated_market_share()
{
	if(current_xmachine->xmachine_Firm) return (*current_xmachine->xmachine_Firm).estimated_market_share;

    // suppress compiler warning by returning dummy value /
    // this statement should rightfully NEVER be reached /
    return (double)0;
}

/** \fn void set_estimated_yearly_earnings(double estimated_yearly_earnings)
 * \brief Set estimated_yearly_earnings memory variable for current X-machine.
 * \param estimated_yearly_earnings New value for variable.
 */
void set_estimated_yearly_earnings(double estimated_yearly_earnings)
{
	if(current_xmachine->xmachine_Firm) (*current_xmachine->xmachine_Firm).estimated_yearly_earnings = estimated_yearly_earnings;
}

/** \fn double get_estimated_yearly_earnings()
 * \brief Get estimated_yearly_earnings memory variable from current X-machine.
 * \return Value for variable.
 */
double get_estimated_yearly_earnings()
{
	if(current_xmachine->xmachine_Firm) return (*current_xmachine->xmachine_Firm).estimated_yearly_earnings;

    // suppress compiler warning by returning dummy value /
    // this statement should rightfully NEVER be reached /
    return (double)0;
}

/** \fn dt_monthly_estimations get_expected_earnings_and_costs_over_year()
 * \brief Get expected_earnings_and_costs_over_year memory variable from current X-machine.
 * \return Value for variable.
 */
dt_monthly_estimations * get_expected_earnings_and_costs_over_year()
{
	if(current_xmachine->xmachine_Firm) return (*current_xmachine->xmachine_Firm).expected_earnings_and_costs_over_year;

    // suppress compiler warning by returning dummy value /
    // this statement should rightfully NEVER be reached /
    return NULL;
}

/** \fn void set_expected_output_in_current_month(double expected_output_in_current_month)
 * \brief Set expected_output_in_current_month memory variable for current X-machine.
 * \param expected_output_in_current_month New value for variable.
 */
void set_expected_output_in_current_month(double expected_output_in_current_month)
{
	if(current_xmachine->xmachine_Firm) (*current_xmachine->xmachine_Firm).expected_output_in_current_month = expected_output_in_current_month;
}

/** \fn double get_expected_output_in_current_month()
 * \brief Get expected_output_in_current_month memory variable from current X-machine.
 * \return Value for variable.
 */
double get_expected_output_in_current_month()
{
	if(current_xmachine->xmachine_Firm) return (*current_xmachine->xmachine_Firm).expected_output_in_current_month;

    // suppress compiler warning by returning dummy value /
    // this statement should rightfully NEVER be reached /
    return (double)0;
}

/** \fn void set_expected_profit_in_current_month(double expected_profit_in_current_month)
 * \brief Set expected_profit_in_current_month memory variable for current X-machine.
 * \param expected_profit_in_current_month New value for variable.
 */
void set_expected_profit_in_current_month(double expected_profit_in_current_month)
{
	if(current_xmachine->xmachine_Firm) (*current_xmachine->xmachine_Firm).expected_profit_in_current_month = expected_profit_in_current_month;
}

/** \fn double get_expected_profit_in_current_month()
 * \brief Get expected_profit_in_current_month memory variable from current X-machine.
 * \return Value for variable.
 */
double get_expected_profit_in_current_month()
{
	if(current_xmachine->xmachine_Firm) return (*current_xmachine->xmachine_Firm).expected_profit_in_current_month;

    // suppress compiler warning by returning dummy value /
    // this statement should rightfully NEVER be reached /
    return (double)0;
}

/** \fn void set_expected_labor_costs_in_current_month(double expected_labor_costs_in_current_month)
 * \brief Set expected_labor_costs_in_current_month memory variable for current X-machine.
 * \param expected_labor_costs_in_current_month New value for variable.
 */
void set_expected_labor_costs_in_current_month(double expected_labor_costs_in_current_month)
{
	if(current_xmachine->xmachine_Firm) (*current_xmachine->xmachine_Firm).expected_labor_costs_in_current_month = expected_labor_costs_in_current_month;
}

/** \fn double get_expected_labor_costs_in_current_month()
 * \brief Get expected_labor_costs_in_current_month memory variable from current X-machine.
 * \return Value for variable.
 */
double get_expected_labor_costs_in_current_month()
{
	if(current_xmachine->xmachine_Firm) return (*current_xmachine->xmachine_Firm).expected_labor_costs_in_current_month;

    // suppress compiler warning by returning dummy value /
    // this statement should rightfully NEVER be reached /
    return (double)0;
}

/** \fn void set_expected_capital_costs_in_current_month(double expected_capital_costs_in_current_month)
 * \brief Set expected_capital_costs_in_current_month memory variable for current X-machine.
 * \param expected_capital_costs_in_current_month New value for variable.
 */
void set_expected_capital_costs_in_current_month(double expected_capital_costs_in_current_month)
{
	if(current_xmachine->xmachine_Firm) (*current_xmachine->xmachine_Firm).expected_capital_costs_in_current_month = expected_capital_costs_in_current_month;
}

/** \fn double get_expected_capital_costs_in_current_month()
 * \brief Get expected_capital_costs_in_current_month memory variable from current X-machine.
 * \return Value for variable.
 */
double get_expected_capital_costs_in_current_month()
{
	if(current_xmachine->xmachine_Firm) return (*current_xmachine->xmachine_Firm).expected_capital_costs_in_current_month;

    // suppress compiler warning by returning dummy value /
    // this statement should rightfully NEVER be reached /
    return (double)0;
}

/** \fn void set_expected_interests_in_current_month(double expected_interests_in_current_month)
 * \brief Set expected_interests_in_current_month memory variable for current X-machine.
 * \param expected_interests_in_current_month New value for variable.
 */
void set_expected_interests_in_current_month(double expected_interests_in_current_month)
{
	if(current_xmachine->xmachine_Firm) (*current_xmachine->xmachine_Firm).expected_interests_in_current_month = expected_interests_in_current_month;
}

/** \fn double get_expected_interests_in_current_month()
 * \brief Get expected_interests_in_current_month memory variable from current X-machine.
 * \return Value for variable.
 */
double get_expected_interests_in_current_month()
{
	if(current_xmachine->xmachine_Firm) return (*current_xmachine->xmachine_Firm).expected_interests_in_current_month;

    // suppress compiler warning by returning dummy value /
    // this statement should rightfully NEVER be reached /
    return (double)0;
}

/** \fn void set_expected_output_in_previous_month(double expected_output_in_previous_month)
 * \brief Set expected_output_in_previous_month memory variable for current X-machine.
 * \param expected_output_in_previous_month New value for variable.
 */
void set_expected_output_in_previous_month(double expected_output_in_previous_month)
{
	if(current_xmachine->xmachine_Firm) (*current_xmachine->xmachine_Firm).expected_output_in_previous_month = expected_output_in_previous_month;
}

/** \fn double get_expected_output_in_previous_month()
 * \brief Get expected_output_in_previous_month memory variable from current X-machine.
 * \return Value for variable.
 */
double get_expected_output_in_previous_month()
{
	if(current_xmachine->xmachine_Firm) return (*current_xmachine->xmachine_Firm).expected_output_in_previous_month;

    // suppress compiler warning by returning dummy value /
    // this statement should rightfully NEVER be reached /
    return (double)0;
}

/** \fn void set_expected_actual_sold_quantity_in_previous_month(double expected_actual_sold_quantity_in_previous_month)
 * \brief Set expected_actual_sold_quantity_in_previous_month memory variable for current X-machine.
 * \param expected_actual_sold_quantity_in_previous_month New value for variable.
 */
void set_expected_actual_sold_quantity_in_previous_month(double expected_actual_sold_quantity_in_previous_month)
{
	if(current_xmachine->xmachine_Firm) (*current_xmachine->xmachine_Firm).expected_actual_sold_quantity_in_previous_month = expected_actual_sold_quantity_in_previous_month;
}

/** \fn double get_expected_actual_sold_quantity_in_previous_month()
 * \brief Get expected_actual_sold_quantity_in_previous_month memory variable from current X-machine.
 * \return Value for variable.
 */
double get_expected_actual_sold_quantity_in_previous_month()
{
	if(current_xmachine->xmachine_Firm) return (*current_xmachine->xmachine_Firm).expected_actual_sold_quantity_in_previous_month;

    // suppress compiler warning by returning dummy value /
    // this statement should rightfully NEVER be reached /
    return (double)0;
}

/** \fn void set_expected_actual_sold_quantity_in_current_month(double expected_actual_sold_quantity_in_current_month)
 * \brief Set expected_actual_sold_quantity_in_current_month memory variable for current X-machine.
 * \param expected_actual_sold_quantity_in_current_month New value for variable.
 */
void set_expected_actual_sold_quantity_in_current_month(double expected_actual_sold_quantity_in_current_month)
{
	if(current_xmachine->xmachine_Firm) (*current_xmachine->xmachine_Firm).expected_actual_sold_quantity_in_current_month = expected_actual_sold_quantity_in_current_month;
}

/** \fn double get_expected_actual_sold_quantity_in_current_month()
 * \brief Get expected_actual_sold_quantity_in_current_month memory variable from current X-machine.
 * \return Value for variable.
 */
double get_expected_actual_sold_quantity_in_current_month()
{
	if(current_xmachine->xmachine_Firm) return (*current_xmachine->xmachine_Firm).expected_actual_sold_quantity_in_current_month;

    // suppress compiler warning by returning dummy value /
    // this statement should rightfully NEVER be reached /
    return (double)0;
}

/** \fn void set_expected_labor_costs_in_previous_month(double expected_labor_costs_in_previous_month)
 * \brief Set expected_labor_costs_in_previous_month memory variable for current X-machine.
 * \param expected_labor_costs_in_previous_month New value for variable.
 */
void set_expected_labor_costs_in_previous_month(double expected_labor_costs_in_previous_month)
{
	if(current_xmachine->xmachine_Firm) (*current_xmachine->xmachine_Firm).expected_labor_costs_in_previous_month = expected_labor_costs_in_previous_month;
}

/** \fn double get_expected_labor_costs_in_previous_month()
 * \brief Get expected_labor_costs_in_previous_month memory variable from current X-machine.
 * \return Value for variable.
 */
double get_expected_labor_costs_in_previous_month()
{
	if(current_xmachine->xmachine_Firm) return (*current_xmachine->xmachine_Firm).expected_labor_costs_in_previous_month;

    // suppress compiler warning by returning dummy value /
    // this statement should rightfully NEVER be reached /
    return (double)0;
}

/** \fn void set_expected_capital_costs_in_previous_month(double expected_capital_costs_in_previous_month)
 * \brief Set expected_capital_costs_in_previous_month memory variable for current X-machine.
 * \param expected_capital_costs_in_previous_month New value for variable.
 */
void set_expected_capital_costs_in_previous_month(double expected_capital_costs_in_previous_month)
{
	if(current_xmachine->xmachine_Firm) (*current_xmachine->xmachine_Firm).expected_capital_costs_in_previous_month = expected_capital_costs_in_previous_month;
}

/** \fn double get_expected_capital_costs_in_previous_month()
 * \brief Get expected_capital_costs_in_previous_month memory variable from current X-machine.
 * \return Value for variable.
 */
double get_expected_capital_costs_in_previous_month()
{
	if(current_xmachine->xmachine_Firm) return (*current_xmachine->xmachine_Firm).expected_capital_costs_in_previous_month;

    // suppress compiler warning by returning dummy value /
    // this statement should rightfully NEVER be reached /
    return (double)0;
}

/** \fn void set_expected_interests_in_previous_month(double expected_interests_in_previous_month)
 * \brief Set expected_interests_in_previous_month memory variable for current X-machine.
 * \param expected_interests_in_previous_month New value for variable.
 */
void set_expected_interests_in_previous_month(double expected_interests_in_previous_month)
{
	if(current_xmachine->xmachine_Firm) (*current_xmachine->xmachine_Firm).expected_interests_in_previous_month = expected_interests_in_previous_month;
}

/** \fn double get_expected_interests_in_previous_month()
 * \brief Get expected_interests_in_previous_month memory variable from current X-machine.
 * \return Value for variable.
 */
double get_expected_interests_in_previous_month()
{
	if(current_xmachine->xmachine_Firm) return (*current_xmachine->xmachine_Firm).expected_interests_in_previous_month;

    // suppress compiler warning by returning dummy value /
    // this statement should rightfully NEVER be reached /
    return (double)0;
}

/** \fn void set_expected_profit_in_previous_month(double expected_profit_in_previous_month)
 * \brief Set expected_profit_in_previous_month memory variable for current X-machine.
 * \param expected_profit_in_previous_month New value for variable.
 */
void set_expected_profit_in_previous_month(double expected_profit_in_previous_month)
{
	if(current_xmachine->xmachine_Firm) (*current_xmachine->xmachine_Firm).expected_profit_in_previous_month = expected_profit_in_previous_month;
}

/** \fn double get_expected_profit_in_previous_month()
 * \brief Get expected_profit_in_previous_month memory variable from current X-machine.
 * \return Value for variable.
 */
double get_expected_profit_in_previous_month()
{
	if(current_xmachine->xmachine_Firm) return (*current_xmachine->xmachine_Firm).expected_profit_in_previous_month;

    // suppress compiler warning by returning dummy value /
    // this statement should rightfully NEVER be reached /
    return (double)0;
}

/** \fn void set_expected_wage_in_current_month(double expected_wage_in_current_month)
 * \brief Set expected_wage_in_current_month memory variable for current X-machine.
 * \param expected_wage_in_current_month New value for variable.
 */
void set_expected_wage_in_current_month(double expected_wage_in_current_month)
{
	if(current_xmachine->xmachine_Firm) (*current_xmachine->xmachine_Firm).expected_wage_in_current_month = expected_wage_in_current_month;
}

/** \fn double get_expected_wage_in_current_month()
 * \brief Get expected_wage_in_current_month memory variable from current X-machine.
 * \return Value for variable.
 */
double get_expected_wage_in_current_month()
{
	if(current_xmachine->xmachine_Firm) return (*current_xmachine->xmachine_Firm).expected_wage_in_current_month;

    // suppress compiler warning by returning dummy value /
    // this statement should rightfully NEVER be reached /
    return (double)0;
}

/** \fn void set_expected_wage_in_previous_month(double expected_wage_in_previous_month)
 * \brief Set expected_wage_in_previous_month memory variable for current X-machine.
 * \param expected_wage_in_previous_month New value for variable.
 */
void set_expected_wage_in_previous_month(double expected_wage_in_previous_month)
{
	if(current_xmachine->xmachine_Firm) (*current_xmachine->xmachine_Firm).expected_wage_in_previous_month = expected_wage_in_previous_month;
}

/** \fn double get_expected_wage_in_previous_month()
 * \brief Get expected_wage_in_previous_month memory variable from current X-machine.
 * \return Value for variable.
 */
double get_expected_wage_in_previous_month()
{
	if(current_xmachine->xmachine_Firm) return (*current_xmachine->xmachine_Firm).expected_wage_in_previous_month;

    // suppress compiler warning by returning dummy value /
    // this statement should rightfully NEVER be reached /
    return (double)0;
}

/** \fn void set_expected_mean_specific_skills_in_current_month(double expected_mean_specific_skills_in_current_month)
 * \brief Set expected_mean_specific_skills_in_current_month memory variable for current X-machine.
 * \param expected_mean_specific_skills_in_current_month New value for variable.
 */
void set_expected_mean_specific_skills_in_current_month(double expected_mean_specific_skills_in_current_month)
{
	if(current_xmachine->xmachine_Firm) (*current_xmachine->xmachine_Firm).expected_mean_specific_skills_in_current_month = expected_mean_specific_skills_in_current_month;
}

/** \fn double get_expected_mean_specific_skills_in_current_month()
 * \brief Get expected_mean_specific_skills_in_current_month memory variable from current X-machine.
 * \return Value for variable.
 */
double get_expected_mean_specific_skills_in_current_month()
{
	if(current_xmachine->xmachine_Firm) return (*current_xmachine->xmachine_Firm).expected_mean_specific_skills_in_current_month;

    // suppress compiler warning by returning dummy value /
    // this statement should rightfully NEVER be reached /
    return (double)0;
}

/** \fn void set_expected_mean_specific_skills_in_previous_month(double expected_mean_specific_skills_in_previous_month)
 * \brief Set expected_mean_specific_skills_in_previous_month memory variable for current X-machine.
 * \param expected_mean_specific_skills_in_previous_month New value for variable.
 */
void set_expected_mean_specific_skills_in_previous_month(double expected_mean_specific_skills_in_previous_month)
{
	if(current_xmachine->xmachine_Firm) (*current_xmachine->xmachine_Firm).expected_mean_specific_skills_in_previous_month = expected_mean_specific_skills_in_previous_month;
}

/** \fn double get_expected_mean_specific_skills_in_previous_month()
 * \brief Get expected_mean_specific_skills_in_previous_month memory variable from current X-machine.
 * \return Value for variable.
 */
double get_expected_mean_specific_skills_in_previous_month()
{
	if(current_xmachine->xmachine_Firm) return (*current_xmachine->xmachine_Firm).expected_mean_specific_skills_in_previous_month;

    // suppress compiler warning by returning dummy value /
    // this statement should rightfully NEVER be reached /
    return (double)0;
}

/** \fn void set_expected_average_productivity_in_current_month(double expected_average_productivity_in_current_month)
 * \brief Set expected_average_productivity_in_current_month memory variable for current X-machine.
 * \param expected_average_productivity_in_current_month New value for variable.
 */
void set_expected_average_productivity_in_current_month(double expected_average_productivity_in_current_month)
{
	if(current_xmachine->xmachine_Firm) (*current_xmachine->xmachine_Firm).expected_average_productivity_in_current_month = expected_average_productivity_in_current_month;
}

/** \fn double get_expected_average_productivity_in_current_month()
 * \brief Get expected_average_productivity_in_current_month memory variable from current X-machine.
 * \return Value for variable.
 */
double get_expected_average_productivity_in_current_month()
{
	if(current_xmachine->xmachine_Firm) return (*current_xmachine->xmachine_Firm).expected_average_productivity_in_current_month;

    // suppress compiler warning by returning dummy value /
    // this statement should rightfully NEVER be reached /
    return (double)0;
}

/** \fn void set_expected_investment_nominal_in_current_month(double expected_investment_nominal_in_current_month)
 * \brief Set expected_investment_nominal_in_current_month memory variable for current X-machine.
 * \param expected_investment_nominal_in_current_month New value for variable.
 */
void set_expected_investment_nominal_in_current_month(double expected_investment_nominal_in_current_month)
{
	if(current_xmachine->xmachine_Firm) (*current_xmachine->xmachine_Firm).expected_investment_nominal_in_current_month = expected_investment_nominal_in_current_month;
}

/** \fn double get_expected_investment_nominal_in_current_month()
 * \brief Get expected_investment_nominal_in_current_month memory variable from current X-machine.
 * \return Value for variable.
 */
double get_expected_investment_nominal_in_current_month()
{
	if(current_xmachine->xmachine_Firm) return (*current_xmachine->xmachine_Firm).expected_investment_nominal_in_current_month;

    // suppress compiler warning by returning dummy value /
    // this statement should rightfully NEVER be reached /
    return (double)0;
}

/** \fn void set_expected_investment_nominal_in_previous_month(double expected_investment_nominal_in_previous_month)
 * \brief Set expected_investment_nominal_in_previous_month memory variable for current X-machine.
 * \param expected_investment_nominal_in_previous_month New value for variable.
 */
void set_expected_investment_nominal_in_previous_month(double expected_investment_nominal_in_previous_month)
{
	if(current_xmachine->xmachine_Firm) (*current_xmachine->xmachine_Firm).expected_investment_nominal_in_previous_month = expected_investment_nominal_in_previous_month;
}

/** \fn double get_expected_investment_nominal_in_previous_month()
 * \brief Get expected_investment_nominal_in_previous_month memory variable from current X-machine.
 * \return Value for variable.
 */
double get_expected_investment_nominal_in_previous_month()
{
	if(current_xmachine->xmachine_Firm) return (*current_xmachine->xmachine_Firm).expected_investment_nominal_in_previous_month;

    // suppress compiler warning by returning dummy value /
    // this statement should rightfully NEVER be reached /
    return (double)0;
}

/** \fn void set_expected_average_productivity_in_previous_month(double expected_average_productivity_in_previous_month)
 * \brief Set expected_average_productivity_in_previous_month memory variable for current X-machine.
 * \param expected_average_productivity_in_previous_month New value for variable.
 */
void set_expected_average_productivity_in_previous_month(double expected_average_productivity_in_previous_month)
{
	if(current_xmachine->xmachine_Firm) (*current_xmachine->xmachine_Firm).expected_average_productivity_in_previous_month = expected_average_productivity_in_previous_month;
}

/** \fn double get_expected_average_productivity_in_previous_month()
 * \brief Get expected_average_productivity_in_previous_month memory variable from current X-machine.
 * \return Value for variable.
 */
double get_expected_average_productivity_in_previous_month()
{
	if(current_xmachine->xmachine_Firm) return (*current_xmachine->xmachine_Firm).expected_average_productivity_in_previous_month;

    // suppress compiler warning by returning dummy value /
    // this statement should rightfully NEVER be reached /
    return (double)0;
}

/** \fn void set_earnings_while_last_pricing_period(double earnings_while_last_pricing_period)
 * \brief Set earnings_while_last_pricing_period memory variable for current X-machine.
 * \param earnings_while_last_pricing_period New value for variable.
 */
void set_earnings_while_last_pricing_period(double earnings_while_last_pricing_period)
{
	if(current_xmachine->xmachine_Firm) (*current_xmachine->xmachine_Firm).earnings_while_last_pricing_period = earnings_while_last_pricing_period;
}

/** \fn double get_earnings_while_last_pricing_period()
 * \brief Get earnings_while_last_pricing_period memory variable from current X-machine.
 * \return Value for variable.
 */
double get_earnings_while_last_pricing_period()
{
	if(current_xmachine->xmachine_Firm) return (*current_xmachine->xmachine_Firm).earnings_while_last_pricing_period;

    // suppress compiler warning by returning dummy value /
    // this statement should rightfully NEVER be reached /
    return (double)0;
}

/** \fn void set_sum_earnings_since_price_change(double sum_earnings_since_price_change)
 * \brief Set sum_earnings_since_price_change memory variable for current X-machine.
 * \param sum_earnings_since_price_change New value for variable.
 */
void set_sum_earnings_since_price_change(double sum_earnings_since_price_change)
{
	if(current_xmachine->xmachine_Firm) (*current_xmachine->xmachine_Firm).sum_earnings_since_price_change = sum_earnings_since_price_change;
}

/** \fn double get_sum_earnings_since_price_change()
 * \brief Get sum_earnings_since_price_change memory variable from current X-machine.
 * \return Value for variable.
 */
double get_sum_earnings_since_price_change()
{
	if(current_xmachine->xmachine_Firm) return (*current_xmachine->xmachine_Firm).sum_earnings_since_price_change;

    // suppress compiler warning by returning dummy value /
    // this statement should rightfully NEVER be reached /
    return (double)0;
}

/** \fn dt_variables_changed_array get_variables_last_year()
 * \brief Get variables_last_year memory variable from current X-machine.
 * \return Value for variable.
 */
dt_variables_changed_array * get_variables_last_year()
{
	if(current_xmachine->xmachine_Firm) return &(*current_xmachine->xmachine_Firm).variables_last_year;

    // suppress compiler warning by returning dummy value /
    // this statement should rightfully NEVER be reached /
    return NULL;
}

/** \fn void set_innovation_month_counter(int innovation_month_counter)
 * \brief Set innovation_month_counter memory variable for current X-machine.
 * \param innovation_month_counter New value for variable.
 */
void set_innovation_month_counter(int innovation_month_counter)
{
	if(current_xmachine->xmachine_Firm) (*current_xmachine->xmachine_Firm).innovation_month_counter = innovation_month_counter;
}

/** \fn int get_innovation_month_counter()
 * \brief Get innovation_month_counter memory variable from current X-machine.
 * \return Value for variable.
 */
int get_innovation_month_counter()
{
	if(current_xmachine->xmachine_Firm) return (*current_xmachine->xmachine_Firm).innovation_month_counter;

    // suppress compiler warning by returning dummy value /
    // this statement should rightfully NEVER be reached /
    return (int)0;
}

/** \fn void set_periods_output_zero_counter(int periods_output_zero_counter)
 * \brief Set periods_output_zero_counter memory variable for current X-machine.
 * \param periods_output_zero_counter New value for variable.
 */
void set_periods_output_zero_counter(int periods_output_zero_counter)
{
	if(current_xmachine->xmachine_Firm) (*current_xmachine->xmachine_Firm).periods_output_zero_counter = periods_output_zero_counter;
}

/** \fn int get_periods_output_zero_counter()
 * \brief Get periods_output_zero_counter memory variable from current X-machine.
 * \return Value for variable.
 */
int get_periods_output_zero_counter()
{
	if(current_xmachine->xmachine_Firm) return (*current_xmachine->xmachine_Firm).periods_output_zero_counter;

    // suppress compiler warning by returning dummy value /
    // this statement should rightfully NEVER be reached /
    return (int)0;
}

/** \fn dt_variables_changed get_variables_change()
 * \brief Get variables_change memory variable from current X-machine.
 * \return Value for variable.
 */
dt_variables_changed * get_variables_change()
{
	if(current_xmachine->xmachine_Firm) return &(*current_xmachine->xmachine_Firm).variables_change;

    // suppress compiler warning by returning dummy value /
    // this statement should rightfully NEVER be reached /
    return NULL;
}

/** \fn void set_r_and_d_investments_per_month(double r_and_d_investments_per_month)
 * \brief Set r_and_d_investments_per_month memory variable for current X-machine.
 * \param r_and_d_investments_per_month New value for variable.
 */
void set_r_and_d_investments_per_month(double r_and_d_investments_per_month)
{
	if(current_xmachine->xmachine_Firm) (*current_xmachine->xmachine_Firm).r_and_d_investments_per_month = r_and_d_investments_per_month;
}

/** \fn double get_r_and_d_investments_per_month()
 * \brief Get r_and_d_investments_per_month memory variable from current X-machine.
 * \return Value for variable.
 */
double get_r_and_d_investments_per_month()
{
	if(current_xmachine->xmachine_Firm) return (*current_xmachine->xmachine_Firm).r_and_d_investments_per_month;

    // suppress compiler warning by returning dummy value /
    // this statement should rightfully NEVER be reached /
    return (double)0;
}

/** \fn void set_innovation_flag(int innovation_flag)
 * \brief Set innovation_flag memory variable for current X-machine.
 * \param innovation_flag New value for variable.
 */
void set_innovation_flag(int innovation_flag)
{
	if(current_xmachine->xmachine_Firm) (*current_xmachine->xmachine_Firm).innovation_flag = innovation_flag;
}

/** \fn int get_innovation_flag()
 * \brief Get innovation_flag memory variable from current X-machine.
 * \return Value for variable.
 */
int get_innovation_flag()
{
	if(current_xmachine->xmachine_Firm) return (*current_xmachine->xmachine_Firm).innovation_flag;

    // suppress compiler warning by returning dummy value /
    // this statement should rightfully NEVER be reached /
    return (int)0;
}

/** \fn void set_innovation_employees_needed(int innovation_employees_needed)
 * \brief Set innovation_employees_needed memory variable for current X-machine.
 * \param innovation_employees_needed New value for variable.
 */
void set_innovation_employees_needed(int innovation_employees_needed)
{
	if(current_xmachine->xmachine_Firm) (*current_xmachine->xmachine_Firm).innovation_employees_needed = innovation_employees_needed;
}

/** \fn int get_innovation_employees_needed()
 * \brief Get innovation_employees_needed memory variable from current X-machine.
 * \return Value for variable.
 */
int get_innovation_employees_needed()
{
	if(current_xmachine->xmachine_Firm) return (*current_xmachine->xmachine_Firm).innovation_employees_needed;

    // suppress compiler warning by returning dummy value /
    // this statement should rightfully NEVER be reached /
    return (int)0;
}

/** \fn void set_no_employees_innovation(int no_employees_innovation)
 * \brief Set no_employees_innovation memory variable for current X-machine.
 * \param no_employees_innovation New value for variable.
 */
void set_no_employees_innovation(int no_employees_innovation)
{
	if(current_xmachine->xmachine_Firm) (*current_xmachine->xmachine_Firm).no_employees_innovation = no_employees_innovation;
}

/** \fn int get_no_employees_innovation()
 * \brief Get no_employees_innovation memory variable from current X-machine.
 * \return Value for variable.
 */
int get_no_employees_innovation()
{
	if(current_xmachine->xmachine_Firm) return (*current_xmachine->xmachine_Firm).no_employees_innovation;

    // suppress compiler warning by returning dummy value /
    // this statement should rightfully NEVER be reached /
    return (int)0;
}

/** \fn void set_employees_needed_innovation(int employees_needed_innovation)
 * \brief Set employees_needed_innovation memory variable for current X-machine.
 * \param employees_needed_innovation New value for variable.
 */
void set_employees_needed_innovation(int employees_needed_innovation)
{
	if(current_xmachine->xmachine_Firm) (*current_xmachine->xmachine_Firm).employees_needed_innovation = employees_needed_innovation;
}

/** \fn int get_employees_needed_innovation()
 * \brief Get employees_needed_innovation memory variable from current X-machine.
 * \return Value for variable.
 */
int get_employees_needed_innovation()
{
	if(current_xmachine->xmachine_Firm) return (*current_xmachine->xmachine_Firm).employees_needed_innovation;

    // suppress compiler warning by returning dummy value /
    // this statement should rightfully NEVER be reached /
    return (int)0;
}

/** \fn void set_optimal_employees_needed_innovation(int optimal_employees_needed_innovation)
 * \brief Set optimal_employees_needed_innovation memory variable for current X-machine.
 * \param optimal_employees_needed_innovation New value for variable.
 */
void set_optimal_employees_needed_innovation(int optimal_employees_needed_innovation)
{
	if(current_xmachine->xmachine_Firm) (*current_xmachine->xmachine_Firm).optimal_employees_needed_innovation = optimal_employees_needed_innovation;
}

/** \fn int get_optimal_employees_needed_innovation()
 * \brief Get optimal_employees_needed_innovation memory variable from current X-machine.
 * \return Value for variable.
 */
int get_optimal_employees_needed_innovation()
{
	if(current_xmachine->xmachine_Firm) return (*current_xmachine->xmachine_Firm).optimal_employees_needed_innovation;

    // suppress compiler warning by returning dummy value /
    // this statement should rightfully NEVER be reached /
    return (int)0;
}

/** \fn void set_total_no_periods_for_product_development(int total_no_periods_for_product_development)
 * \brief Set total_no_periods_for_product_development memory variable for current X-machine.
 * \param total_no_periods_for_product_development New value for variable.
 */
void set_total_no_periods_for_product_development(int total_no_periods_for_product_development)
{
	if(current_xmachine->xmachine_Firm) (*current_xmachine->xmachine_Firm).total_no_periods_for_product_development = total_no_periods_for_product_development;
}

/** \fn int get_total_no_periods_for_product_development()
 * \brief Get total_no_periods_for_product_development memory variable from current X-machine.
 * \return Value for variable.
 */
int get_total_no_periods_for_product_development()
{
	if(current_xmachine->xmachine_Firm) return (*current_xmachine->xmachine_Firm).total_no_periods_for_product_development;

    // suppress compiler warning by returning dummy value /
    // this statement should rightfully NEVER be reached /
    return (int)0;
}

/** \fn void set_ratio_project_value_established_product(double ratio_project_value_established_product)
 * \brief Set ratio_project_value_established_product memory variable for current X-machine.
 * \param ratio_project_value_established_product New value for variable.
 */
void set_ratio_project_value_established_product(double ratio_project_value_established_product)
{
	if(current_xmachine->xmachine_Firm) (*current_xmachine->xmachine_Firm).ratio_project_value_established_product = ratio_project_value_established_product;
}

/** \fn double get_ratio_project_value_established_product()
 * \brief Get ratio_project_value_established_product memory variable from current X-machine.
 * \return Value for variable.
 */
double get_ratio_project_value_established_product()
{
	if(current_xmachine->xmachine_Firm) return (*current_xmachine->xmachine_Firm).ratio_project_value_established_product;

    // suppress compiler warning by returning dummy value /
    // this statement should rightfully NEVER be reached /
    return (double)0;
}

/** \fn void set_vintage_choice_already_taken(int vintage_choice_already_taken)
 * \brief Set vintage_choice_already_taken memory variable for current X-machine.
 * \param vintage_choice_already_taken New value for variable.
 */
void set_vintage_choice_already_taken(int vintage_choice_already_taken)
{
	if(current_xmachine->xmachine_Firm) (*current_xmachine->xmachine_Firm).vintage_choice_already_taken = vintage_choice_already_taken;
}

/** \fn int get_vintage_choice_already_taken()
 * \brief Get vintage_choice_already_taken memory variable from current X-machine.
 * \return Value for variable.
 */
int get_vintage_choice_already_taken()
{
	if(current_xmachine->xmachine_Firm) return (*current_xmachine->xmachine_Firm).vintage_choice_already_taken;

    // suppress compiler warning by returning dummy value /
    // this statement should rightfully NEVER be reached /
    return (int)0;
}

/** \fn void set_change_due_to_last_innovation(double change_due_to_last_innovation)
 * \brief Set change_due_to_last_innovation memory variable for current X-machine.
 * \param change_due_to_last_innovation New value for variable.
 */
void set_change_due_to_last_innovation(double change_due_to_last_innovation)
{
	if(current_xmachine->xmachine_Firm) (*current_xmachine->xmachine_Firm).change_due_to_last_innovation = change_due_to_last_innovation;
}

/** \fn double get_change_due_to_last_innovation()
 * \brief Get change_due_to_last_innovation memory variable from current X-machine.
 * \return Value for variable.
 */
double get_change_due_to_last_innovation()
{
	if(current_xmachine->xmachine_Firm) return (*current_xmachine->xmachine_Firm).change_due_to_last_innovation;

    // suppress compiler warning by returning dummy value /
    // this statement should rightfully NEVER be reached /
    return (double)0;
}

/** \fn void set_remaining_periods_to_complete_product_development(int remaining_periods_to_complete_product_development)
 * \brief Set remaining_periods_to_complete_product_development memory variable for current X-machine.
 * \param remaining_periods_to_complete_product_development New value for variable.
 */
void set_remaining_periods_to_complete_product_development(int remaining_periods_to_complete_product_development)
{
	if(current_xmachine->xmachine_Firm) (*current_xmachine->xmachine_Firm).remaining_periods_to_complete_product_development = remaining_periods_to_complete_product_development;
}

/** \fn int get_remaining_periods_to_complete_product_development()
 * \brief Get remaining_periods_to_complete_product_development memory variable from current X-machine.
 * \return Value for variable.
 */
int get_remaining_periods_to_complete_product_development()
{
	if(current_xmachine->xmachine_Firm) return (*current_xmachine->xmachine_Firm).remaining_periods_to_complete_product_development;

    // suppress compiler warning by returning dummy value /
    // this statement should rightfully NEVER be reached /
    return (int)0;
}

/** \fn void set_planned_quality(double planned_quality)
 * \brief Set planned_quality memory variable for current X-machine.
 * \param planned_quality New value for variable.
 */
void set_planned_quality(double planned_quality)
{
	if(current_xmachine->xmachine_Firm) (*current_xmachine->xmachine_Firm).planned_quality = planned_quality;
}

/** \fn double get_planned_quality()
 * \brief Get planned_quality memory variable from current X-machine.
 * \return Value for variable.
 */
double get_planned_quality()
{
	if(current_xmachine->xmachine_Firm) return (*current_xmachine->xmachine_Firm).planned_quality;

    // suppress compiler warning by returning dummy value /
    // this statement should rightfully NEVER be reached /
    return (double)0;
}

/** \fn void set_product_development_completed(double product_development_completed)
 * \brief Set product_development_completed memory variable for current X-machine.
 * \param product_development_completed New value for variable.
 */
void set_product_development_completed(double product_development_completed)
{
	if(current_xmachine->xmachine_Firm) (*current_xmachine->xmachine_Firm).product_development_completed = product_development_completed;
}

/** \fn double get_product_development_completed()
 * \brief Get product_development_completed memory variable from current X-machine.
 * \return Value for variable.
 */
double get_product_development_completed()
{
	if(current_xmachine->xmachine_Firm) return (*current_xmachine->xmachine_Firm).product_development_completed;

    // suppress compiler warning by returning dummy value /
    // this statement should rightfully NEVER be reached /
    return (double)0;
}

/** \fn void set_price_just_set_flag(double price_just_set_flag)
 * \brief Set price_just_set_flag memory variable for current X-machine.
 * \param price_just_set_flag New value for variable.
 */
void set_price_just_set_flag(double price_just_set_flag)
{
	if(current_xmachine->xmachine_Firm) (*current_xmachine->xmachine_Firm).price_just_set_flag = price_just_set_flag;
}

/** \fn double get_price_just_set_flag()
 * \brief Get price_just_set_flag memory variable from current X-machine.
 * \return Value for variable.
 */
double get_price_just_set_flag()
{
	if(current_xmachine->xmachine_Firm) return (*current_xmachine->xmachine_Firm).price_just_set_flag;

    // suppress compiler warning by returning dummy value /
    // this statement should rightfully NEVER be reached /
    return (double)0;
}

/** \fn dt_value_lattice_years_array get_value_lattice()
 * \brief Get value_lattice memory variable from current X-machine.
 * \return Value for variable.
 */
dt_value_lattice_years_array * get_value_lattice()
{
	if(current_xmachine->xmachine_Firm) return &(*current_xmachine->xmachine_Firm).value_lattice;

    // suppress compiler warning by returning dummy value /
    // this statement should rightfully NEVER be reached /
    return NULL;
}

/** \fn void set_combined_variance_demand_function(double combined_variance_demand_function)
 * \brief Set combined_variance_demand_function memory variable for current X-machine.
 * \param combined_variance_demand_function New value for variable.
 */
void set_combined_variance_demand_function(double combined_variance_demand_function)
{
	if(current_xmachine->xmachine_Firm) (*current_xmachine->xmachine_Firm).combined_variance_demand_function = combined_variance_demand_function;
}

/** \fn double get_combined_variance_demand_function()
 * \brief Get combined_variance_demand_function memory variable from current X-machine.
 * \return Value for variable.
 */
double get_combined_variance_demand_function()
{
	if(current_xmachine->xmachine_Firm) return (*current_xmachine->xmachine_Firm).combined_variance_demand_function;

    // suppress compiler warning by returning dummy value /
    // this statement should rightfully NEVER be reached /
    return (double)0;
}

/** \fn int_array get_neighboring_region_ids()
 * \brief Get neighboring_region_ids memory variable from current X-machine.
 * \return Value for variable.
 */
int_array * get_neighboring_region_ids()
{
	if(current_xmachine->xmachine_Household) return &(*current_xmachine->xmachine_Household).neighboring_region_ids;

    // suppress compiler warning by returning dummy value /
    // this statement should rightfully NEVER be reached /
    return NULL;
}

/** \fn void set_new_agent(int new_agent)
 * \brief Set new_agent memory variable for current X-machine.
 * \param new_agent New value for variable.
 */
void set_new_agent(int new_agent)
{
	if(current_xmachine->xmachine_Household) (*current_xmachine->xmachine_Household).new_agent = new_agent;
}

/** \fn int get_new_agent()
 * \brief Get new_agent memory variable from current X-machine.
 * \return Value for variable.
 */
int get_new_agent()
{
	if(current_xmachine->xmachine_Household) return (*current_xmachine->xmachine_Household).new_agent;

    // suppress compiler warning by returning dummy value /
    // this statement should rightfully NEVER be reached /
    return (int)0;
}

/** \fn void set_migration_status(int migration_status)
 * \brief Set migration_status memory variable for current X-machine.
 * \param migration_status New value for variable.
 */
void set_migration_status(int migration_status)
{
	if(current_xmachine->xmachine_Household) (*current_xmachine->xmachine_Household).migration_status = migration_status;
}

/** \fn int get_migration_status()
 * \brief Get migration_status memory variable from current X-machine.
 * \return Value for variable.
 */
int get_migration_status()
{
	if(current_xmachine->xmachine_Household) return (*current_xmachine->xmachine_Household).migration_status;

    // suppress compiler warning by returning dummy value /
    // this statement should rightfully NEVER be reached /
    return (int)0;
}

/** \fn void set_consumption_budget(double consumption_budget)
 * \brief Set consumption_budget memory variable for current X-machine.
 * \param consumption_budget New value for variable.
 */
void set_consumption_budget(double consumption_budget)
{
	if(current_xmachine->xmachine_Household) (*current_xmachine->xmachine_Household).consumption_budget = consumption_budget;
}

/** \fn double get_consumption_budget()
 * \brief Get consumption_budget memory variable from current X-machine.
 * \return Value for variable.
 */
double get_consumption_budget()
{
	if(current_xmachine->xmachine_Household) return (*current_xmachine->xmachine_Household).consumption_budget;

    // suppress compiler warning by returning dummy value /
    // this statement should rightfully NEVER be reached /
    return (double)0;
}

/** \fn void set_consumption_budget_in_month(double consumption_budget_in_month)
 * \brief Set consumption_budget_in_month memory variable for current X-machine.
 * \param consumption_budget_in_month New value for variable.
 */
void set_consumption_budget_in_month(double consumption_budget_in_month)
{
	if(current_xmachine->xmachine_Household) (*current_xmachine->xmachine_Household).consumption_budget_in_month = consumption_budget_in_month;
}

/** \fn double get_consumption_budget_in_month()
 * \brief Get consumption_budget_in_month memory variable from current X-machine.
 * \return Value for variable.
 */
double get_consumption_budget_in_month()
{
	if(current_xmachine->xmachine_Household) return (*current_xmachine->xmachine_Household).consumption_budget_in_month;

    // suppress compiler warning by returning dummy value /
    // this statement should rightfully NEVER be reached /
    return (double)0;
}

/** \fn void set_week_of_month(int week_of_month)
 * \brief Set week_of_month memory variable for current X-machine.
 * \param week_of_month New value for variable.
 */
void set_week_of_month(int week_of_month)
{
	if(current_xmachine->xmachine_Household) (*current_xmachine->xmachine_Household).week_of_month = week_of_month;
}

/** \fn int get_week_of_month()
 * \brief Get week_of_month memory variable from current X-machine.
 * \return Value for variable.
 */
int get_week_of_month()
{
	if(current_xmachine->xmachine_Household) return (*current_xmachine->xmachine_Household).week_of_month;

    // suppress compiler warning by returning dummy value /
    // this statement should rightfully NEVER be reached /
    return (int)0;
}

/** \fn void set_weekly_budget(double weekly_budget)
 * \brief Set weekly_budget memory variable for current X-machine.
 * \param weekly_budget New value for variable.
 */
void set_weekly_budget(double weekly_budget)
{
	if(current_xmachine->xmachine_Household) (*current_xmachine->xmachine_Household).weekly_budget = weekly_budget;
}

/** \fn double get_weekly_budget()
 * \brief Get weekly_budget memory variable from current X-machine.
 * \return Value for variable.
 */
double get_weekly_budget()
{
	if(current_xmachine->xmachine_Household) return (*current_xmachine->xmachine_Household).weekly_budget;

    // suppress compiler warning by returning dummy value /
    // this statement should rightfully NEVER be reached /
    return (double)0;
}

/** \fn void set_rationed(int rationed)
 * \brief Set rationed memory variable for current X-machine.
 * \param rationed New value for variable.
 */
void set_rationed(int rationed)
{
	if(current_xmachine->xmachine_Household) (*current_xmachine->xmachine_Household).rationed = rationed;
}

/** \fn int get_rationed()
 * \brief Get rationed memory variable from current X-machine.
 * \return Value for variable.
 */
int get_rationed()
{
	if(current_xmachine->xmachine_Household) return (*current_xmachine->xmachine_Household).rationed;

    // suppress compiler warning by returning dummy value /
    // this statement should rightfully NEVER be reached /
    return (int)0;
}

/** \fn void set_mall_completely_sold_out(int mall_completely_sold_out)
 * \brief Set mall_completely_sold_out memory variable for current X-machine.
 * \param mall_completely_sold_out New value for variable.
 */
void set_mall_completely_sold_out(int mall_completely_sold_out)
{
	if(current_xmachine->xmachine_Household) (*current_xmachine->xmachine_Household).mall_completely_sold_out = mall_completely_sold_out;
}

/** \fn int get_mall_completely_sold_out()
 * \brief Get mall_completely_sold_out memory variable from current X-machine.
 * \return Value for variable.
 */
int get_mall_completely_sold_out()
{
	if(current_xmachine->xmachine_Household) return (*current_xmachine->xmachine_Household).mall_completely_sold_out;

    // suppress compiler warning by returning dummy value /
    // this statement should rightfully NEVER be reached /
    return (int)0;
}

/** \fn ordered_quantity get_order_quantity()
 * \brief Get order_quantity memory variable from current X-machine.
 * \return Value for variable.
 */
ordered_quantity * get_order_quantity()
{
	if(current_xmachine->xmachine_Household) return (*current_xmachine->xmachine_Household).order_quantity;

    // suppress compiler warning by returning dummy value /
    // this statement should rightfully NEVER be reached /
    return NULL;
}

/** \fn received_quantities get_received_quantity()
 * \brief Get received_quantity memory variable from current X-machine.
 * \return Value for variable.
 */
received_quantities * get_received_quantity()
{
	if(current_xmachine->xmachine_Household) return (*current_xmachine->xmachine_Household).received_quantity;

    // suppress compiler warning by returning dummy value /
    // this statement should rightfully NEVER be reached /
    return NULL;
}

/** \fn void set_day_of_week_to_act(int day_of_week_to_act)
 * \brief Set day_of_week_to_act memory variable for current X-machine.
 * \param day_of_week_to_act New value for variable.
 */
void set_day_of_week_to_act(int day_of_week_to_act)
{
	if(current_xmachine->xmachine_Household) (*current_xmachine->xmachine_Household).day_of_week_to_act = day_of_week_to_act;
}

/** \fn int get_day_of_week_to_act()
 * \brief Get day_of_week_to_act memory variable from current X-machine.
 * \return Value for variable.
 */
int get_day_of_week_to_act()
{
	if(current_xmachine->xmachine_Household) return (*current_xmachine->xmachine_Household).day_of_week_to_act;

    // suppress compiler warning by returning dummy value /
    // this statement should rightfully NEVER be reached /
    return (int)0;
}

/** \fn void set_day_of_month_receive_income(int day_of_month_receive_income)
 * \brief Set day_of_month_receive_income memory variable for current X-machine.
 * \param day_of_month_receive_income New value for variable.
 */
void set_day_of_month_receive_income(int day_of_month_receive_income)
{
	if(current_xmachine->xmachine_Household) (*current_xmachine->xmachine_Household).day_of_month_receive_income = day_of_month_receive_income;
}

/** \fn int get_day_of_month_receive_income()
 * \brief Get day_of_month_receive_income memory variable from current X-machine.
 * \return Value for variable.
 */
int get_day_of_month_receive_income()
{
	if(current_xmachine->xmachine_Household) return (*current_xmachine->xmachine_Household).day_of_month_receive_income;

    // suppress compiler warning by returning dummy value /
    // this statement should rightfully NEVER be reached /
    return (int)0;
}

/** \fn void set_current_productivity_employer(double current_productivity_employer)
 * \brief Set current_productivity_employer memory variable for current X-machine.
 * \param current_productivity_employer New value for variable.
 */
void set_current_productivity_employer(double current_productivity_employer)
{
	if(current_xmachine->xmachine_Household) (*current_xmachine->xmachine_Household).current_productivity_employer = current_productivity_employer;
}

/** \fn double get_current_productivity_employer()
 * \brief Get current_productivity_employer memory variable from current X-machine.
 * \return Value for variable.
 */
double get_current_productivity_employer()
{
	if(current_xmachine->xmachine_Household) return (*current_xmachine->xmachine_Household).current_productivity_employer;

    // suppress compiler warning by returning dummy value /
    // this statement should rightfully NEVER be reached /
    return (double)0;
}

/** \fn void set_current_mean_specific_skills_employer(double current_mean_specific_skills_employer)
 * \brief Set current_mean_specific_skills_employer memory variable for current X-machine.
 * \param current_mean_specific_skills_employer New value for variable.
 */
void set_current_mean_specific_skills_employer(double current_mean_specific_skills_employer)
{
	if(current_xmachine->xmachine_Household) (*current_xmachine->xmachine_Household).current_mean_specific_skills_employer = current_mean_specific_skills_employer;
}

/** \fn double get_current_mean_specific_skills_employer()
 * \brief Get current_mean_specific_skills_employer memory variable from current X-machine.
 * \return Value for variable.
 */
double get_current_mean_specific_skills_employer()
{
	if(current_xmachine->xmachine_Household) return (*current_xmachine->xmachine_Household).current_mean_specific_skills_employer;

    // suppress compiler warning by returning dummy value /
    // this statement should rightfully NEVER be reached /
    return (double)0;
}

/** \fn void set_cum_total_dividends(double cum_total_dividends)
 * \brief Set cum_total_dividends memory variable for current X-machine.
 * \param cum_total_dividends New value for variable.
 */
void set_cum_total_dividends(double cum_total_dividends)
{
	if(current_xmachine->xmachine_Household) (*current_xmachine->xmachine_Household).cum_total_dividends = cum_total_dividends;
}

/** \fn double get_cum_total_dividends()
 * \brief Get cum_total_dividends memory variable from current X-machine.
 * \return Value for variable.
 */
double get_cum_total_dividends()
{
	if(current_xmachine->xmachine_Household) return (*current_xmachine->xmachine_Household).cum_total_dividends;

    // suppress compiler warning by returning dummy value /
    // this statement should rightfully NEVER be reached /
    return (double)0;
}

/** \fn void set_tax_rate_hh_capital(double tax_rate_hh_capital)
 * \brief Set tax_rate_hh_capital memory variable for current X-machine.
 * \param tax_rate_hh_capital New value for variable.
 */
void set_tax_rate_hh_capital(double tax_rate_hh_capital)
{
	if(current_xmachine->xmachine_Household) (*current_xmachine->xmachine_Household).tax_rate_hh_capital = tax_rate_hh_capital;
	if(current_xmachine->xmachine_Government) (*current_xmachine->xmachine_Government).tax_rate_hh_capital = tax_rate_hh_capital;
}

/** \fn double get_tax_rate_hh_capital()
 * \brief Get tax_rate_hh_capital memory variable from current X-machine.
 * \return Value for variable.
 */
double get_tax_rate_hh_capital()
{
	if(current_xmachine->xmachine_Household) return (*current_xmachine->xmachine_Household).tax_rate_hh_capital;
	if(current_xmachine->xmachine_Government) return (*current_xmachine->xmachine_Government).tax_rate_hh_capital;

    // suppress compiler warning by returning dummy value /
    // this statement should rightfully NEVER be reached /
    return (double)0;
}

/** \fn void set_tax_rate_hh_labour(double tax_rate_hh_labour)
 * \brief Set tax_rate_hh_labour memory variable for current X-machine.
 * \param tax_rate_hh_labour New value for variable.
 */
void set_tax_rate_hh_labour(double tax_rate_hh_labour)
{
	if(current_xmachine->xmachine_Household) (*current_xmachine->xmachine_Household).tax_rate_hh_labour = tax_rate_hh_labour;
	if(current_xmachine->xmachine_Government) (*current_xmachine->xmachine_Government).tax_rate_hh_labour = tax_rate_hh_labour;
}

/** \fn double get_tax_rate_hh_labour()
 * \brief Get tax_rate_hh_labour memory variable from current X-machine.
 * \return Value for variable.
 */
double get_tax_rate_hh_labour()
{
	if(current_xmachine->xmachine_Household) return (*current_xmachine->xmachine_Household).tax_rate_hh_labour;
	if(current_xmachine->xmachine_Government) return (*current_xmachine->xmachine_Government).tax_rate_hh_labour;

    // suppress compiler warning by returning dummy value /
    // this statement should rightfully NEVER be reached /
    return (double)0;
}

/** \fn void set_price_index(double price_index)
 * \brief Set price_index memory variable for current X-machine.
 * \param price_index New value for variable.
 */
void set_price_index(double price_index)
{
	if(current_xmachine->xmachine_Household) (*current_xmachine->xmachine_Household).price_index = price_index;
	if(current_xmachine->xmachine_Eurostat) (*current_xmachine->xmachine_Eurostat).price_index = price_index;
}

/** \fn double get_price_index()
 * \brief Get price_index memory variable from current X-machine.
 * \return Value for variable.
 */
double get_price_index()
{
	if(current_xmachine->xmachine_Household) return (*current_xmachine->xmachine_Household).price_index;
	if(current_xmachine->xmachine_Eurostat) return (*current_xmachine->xmachine_Eurostat).price_index;

    // suppress compiler warning by returning dummy value /
    // this statement should rightfully NEVER be reached /
    return (double)0;
}

/** \fn void set_price_index_base_period(double price_index_base_period)
 * \brief Set price_index_base_period memory variable for current X-machine.
 * \param price_index_base_period New value for variable.
 */
void set_price_index_base_period(double price_index_base_period)
{
	if(current_xmachine->xmachine_Household) (*current_xmachine->xmachine_Household).price_index_base_period = price_index_base_period;
}

/** \fn double get_price_index_base_period()
 * \brief Get price_index_base_period memory variable from current X-machine.
 * \return Value for variable.
 */
double get_price_index_base_period()
{
	if(current_xmachine->xmachine_Household) return (*current_xmachine->xmachine_Household).price_index_base_period;

    // suppress compiler warning by returning dummy value /
    // this statement should rightfully NEVER be reached /
    return (double)0;
}

/** \fn void set_commuting_costs_price_level_weight(double commuting_costs_price_level_weight)
 * \brief Set commuting_costs_price_level_weight memory variable for current X-machine.
 * \param commuting_costs_price_level_weight New value for variable.
 */
void set_commuting_costs_price_level_weight(double commuting_costs_price_level_weight)
{
	if(current_xmachine->xmachine_Household) (*current_xmachine->xmachine_Household).commuting_costs_price_level_weight = commuting_costs_price_level_weight;
}

/** \fn double get_commuting_costs_price_level_weight()
 * \brief Get commuting_costs_price_level_weight memory variable from current X-machine.
 * \return Value for variable.
 */
double get_commuting_costs_price_level_weight()
{
	if(current_xmachine->xmachine_Household) return (*current_xmachine->xmachine_Household).commuting_costs_price_level_weight;

    // suppress compiler warning by returning dummy value /
    // this statement should rightfully NEVER be reached /
    return (double)0;
}

/** \fn void set_expenditures(double expenditures)
 * \brief Set expenditures memory variable for current X-machine.
 * \param expenditures New value for variable.
 */
void set_expenditures(double expenditures)
{
	if(current_xmachine->xmachine_Household) (*current_xmachine->xmachine_Household).expenditures = expenditures;
}

/** \fn double get_expenditures()
 * \brief Get expenditures memory variable from current X-machine.
 * \return Value for variable.
 */
double get_expenditures()
{
	if(current_xmachine->xmachine_Household) return (*current_xmachine->xmachine_Household).expenditures;

    // suppress compiler warning by returning dummy value /
    // this statement should rightfully NEVER be reached /
    return (double)0;
}

/** \fn void set_received_dividend(double received_dividend)
 * \brief Set received_dividend memory variable for current X-machine.
 * \param received_dividend New value for variable.
 */
void set_received_dividend(double received_dividend)
{
	if(current_xmachine->xmachine_Household) (*current_xmachine->xmachine_Household).received_dividend = received_dividend;
}

/** \fn double get_received_dividend()
 * \brief Get received_dividend memory variable from current X-machine.
 * \return Value for variable.
 */
double get_received_dividend()
{
	if(current_xmachine->xmachine_Household) return (*current_xmachine->xmachine_Household).received_dividend;

    // suppress compiler warning by returning dummy value /
    // this statement should rightfully NEVER be reached /
    return (double)0;
}

/** \fn void set_received_dividend_in_calendar_month(double received_dividend_in_calendar_month)
 * \brief Set received_dividend_in_calendar_month memory variable for current X-machine.
 * \param received_dividend_in_calendar_month New value for variable.
 */
void set_received_dividend_in_calendar_month(double received_dividend_in_calendar_month)
{
	if(current_xmachine->xmachine_Household) (*current_xmachine->xmachine_Household).received_dividend_in_calendar_month = received_dividend_in_calendar_month;
}

/** \fn double get_received_dividend_in_calendar_month()
 * \brief Get received_dividend_in_calendar_month memory variable from current X-machine.
 * \return Value for variable.
 */
double get_received_dividend_in_calendar_month()
{
	if(current_xmachine->xmachine_Household) return (*current_xmachine->xmachine_Household).received_dividend_in_calendar_month;

    // suppress compiler warning by returning dummy value /
    // this statement should rightfully NEVER be reached /
    return (double)0;
}

/** \fn void set_flag_consumption_shifting(int flag_consumption_shifting)
 * \brief Set flag_consumption_shifting memory variable for current X-machine.
 * \param flag_consumption_shifting New value for variable.
 */
void set_flag_consumption_shifting(int flag_consumption_shifting)
{
	if(current_xmachine->xmachine_Household) (*current_xmachine->xmachine_Household).flag_consumption_shifting = flag_consumption_shifting;
}

/** \fn int get_flag_consumption_shifting()
 * \brief Get flag_consumption_shifting memory variable from current X-machine.
 * \return Value for variable.
 */
int get_flag_consumption_shifting()
{
	if(current_xmachine->xmachine_Household) return (*current_xmachine->xmachine_Household).flag_consumption_shifting;

    // suppress compiler warning by returning dummy value /
    // this statement should rightfully NEVER be reached /
    return (int)0;
}

/** \fn void set_excess_weekly_budget(double excess_weekly_budget)
 * \brief Set excess_weekly_budget memory variable for current X-machine.
 * \param excess_weekly_budget New value for variable.
 */
void set_excess_weekly_budget(double excess_weekly_budget)
{
	if(current_xmachine->xmachine_Household) (*current_xmachine->xmachine_Household).excess_weekly_budget = excess_weekly_budget;
}

/** \fn double get_excess_weekly_budget()
 * \brief Get excess_weekly_budget memory variable from current X-machine.
 * \return Value for variable.
 */
double get_excess_weekly_budget()
{
	if(current_xmachine->xmachine_Household) return (*current_xmachine->xmachine_Household).excess_weekly_budget;

    // suppress compiler warning by returning dummy value /
    // this statement should rightfully NEVER be reached /
    return (double)0;
}

/** \fn void set_wealth_income_ratio_actual(double wealth_income_ratio_actual)
 * \brief Set wealth_income_ratio_actual memory variable for current X-machine.
 * \param wealth_income_ratio_actual New value for variable.
 */
void set_wealth_income_ratio_actual(double wealth_income_ratio_actual)
{
	if(current_xmachine->xmachine_Household) (*current_xmachine->xmachine_Household).wealth_income_ratio_actual = wealth_income_ratio_actual;
}

/** \fn double get_wealth_income_ratio_actual()
 * \brief Get wealth_income_ratio_actual memory variable from current X-machine.
 * \return Value for variable.
 */
double get_wealth_income_ratio_actual()
{
	if(current_xmachine->xmachine_Household) return (*current_xmachine->xmachine_Household).wealth_income_ratio_actual;

    // suppress compiler warning by returning dummy value /
    // this statement should rightfully NEVER be reached /
    return (double)0;
}

/** \fn void set_wealth_income_ratio_target(double wealth_income_ratio_target)
 * \brief Set wealth_income_ratio_target memory variable for current X-machine.
 * \param wealth_income_ratio_target New value for variable.
 */
void set_wealth_income_ratio_target(double wealth_income_ratio_target)
{
	if(current_xmachine->xmachine_Household) (*current_xmachine->xmachine_Household).wealth_income_ratio_target = wealth_income_ratio_target;
}

/** \fn double get_wealth_income_ratio_target()
 * \brief Get wealth_income_ratio_target memory variable from current X-machine.
 * \return Value for variable.
 */
double get_wealth_income_ratio_target()
{
	if(current_xmachine->xmachine_Household) return (*current_xmachine->xmachine_Household).wealth_income_ratio_target;

    // suppress compiler warning by returning dummy value /
    // this statement should rightfully NEVER be reached /
    return (double)0;
}

/** \fn void set_last_weekly_budget(double last_weekly_budget)
 * \brief Set last_weekly_budget memory variable for current X-machine.
 * \param last_weekly_budget New value for variable.
 */
void set_last_weekly_budget(double last_weekly_budget)
{
	if(current_xmachine->xmachine_Household) (*current_xmachine->xmachine_Household).last_weekly_budget = last_weekly_budget;
}

/** \fn double get_last_weekly_budget()
 * \brief Get last_weekly_budget memory variable from current X-machine.
 * \return Value for variable.
 */
double get_last_weekly_budget()
{
	if(current_xmachine->xmachine_Household) return (*current_xmachine->xmachine_Household).last_weekly_budget;

    // suppress compiler warning by returning dummy value /
    // this statement should rightfully NEVER be reached /
    return (double)0;
}

/** \fn void set_risk_free_rate(double risk_free_rate)
 * \brief Set risk_free_rate memory variable for current X-machine.
 * \param risk_free_rate New value for variable.
 */
void set_risk_free_rate(double risk_free_rate)
{
	if(current_xmachine->xmachine_Household) (*current_xmachine->xmachine_Household).risk_free_rate = risk_free_rate;
}

/** \fn double get_risk_free_rate()
 * \brief Get risk_free_rate memory variable from current X-machine.
 * \return Value for variable.
 */
double get_risk_free_rate()
{
	if(current_xmachine->xmachine_Household) return (*current_xmachine->xmachine_Household).risk_free_rate;

    // suppress compiler warning by returning dummy value /
    // this statement should rightfully NEVER be reached /
    return (double)0;
}

/** \fn void set_wealth(double wealth)
 * \brief Set wealth memory variable for current X-machine.
 * \param wealth New value for variable.
 */
void set_wealth(double wealth)
{
	if(current_xmachine->xmachine_Household) (*current_xmachine->xmachine_Household).wealth = wealth;
}

/** \fn double get_wealth()
 * \brief Get wealth memory variable from current X-machine.
 * \return Value for variable.
 */
double get_wealth()
{
	if(current_xmachine->xmachine_Household) return (*current_xmachine->xmachine_Household).wealth;

    // suppress compiler warning by returning dummy value /
    // this statement should rightfully NEVER be reached /
    return (double)0;
}

/** \fn Belief get_beliefs()
 * \brief Get beliefs memory variable from current X-machine.
 * \return Value for variable.
 */
Belief * get_beliefs()
{
	if(current_xmachine->xmachine_Household) return &(*current_xmachine->xmachine_Household).beliefs;

    // suppress compiler warning by returning dummy value /
    // this statement should rightfully NEVER be reached /
    return NULL;
}

/** \fn index_portfolio get_assetsowned()
 * \brief Get assetsowned memory variable from current X-machine.
 * \return Value for variable.
 */
index_portfolio * get_assetsowned()
{
	if(current_xmachine->xmachine_Household) return &(*current_xmachine->xmachine_Household).assetsowned;

    // suppress compiler warning by returning dummy value /
    // this statement should rightfully NEVER be reached /
    return NULL;
}

/** \fn void set_logit_beta(double logit_beta)
 * \brief Set logit_beta memory variable for current X-machine.
 * \param logit_beta New value for variable.
 */
void set_logit_beta(double logit_beta)
{
	if(current_xmachine->xmachine_Household) (*current_xmachine->xmachine_Household).logit_beta = logit_beta;
}

/** \fn double get_logit_beta()
 * \brief Get logit_beta memory variable from current X-machine.
 * \return Value for variable.
 */
double get_logit_beta()
{
	if(current_xmachine->xmachine_Household) return (*current_xmachine->xmachine_Household).logit_beta;

    // suppress compiler warning by returning dummy value /
    // this statement should rightfully NEVER be reached /
    return (double)0;
}

/** \fn void set_wage(double wage)
 * \brief Set wage memory variable for current X-machine.
 * \param wage New value for variable.
 */
void set_wage(double wage)
{
	if(current_xmachine->xmachine_Household) (*current_xmachine->xmachine_Household).wage = wage;
}

/** \fn double get_wage()
 * \brief Get wage memory variable from current X-machine.
 * \return Value for variable.
 */
double get_wage()
{
	if(current_xmachine->xmachine_Household) return (*current_xmachine->xmachine_Household).wage;

    // suppress compiler warning by returning dummy value /
    // this statement should rightfully NEVER be reached /
    return (double)0;
}

/** \fn void set_wage_reservation(double wage_reservation)
 * \brief Set wage_reservation memory variable for current X-machine.
 * \param wage_reservation New value for variable.
 */
void set_wage_reservation(double wage_reservation)
{
	if(current_xmachine->xmachine_Household) (*current_xmachine->xmachine_Household).wage_reservation = wage_reservation;
}

/** \fn double get_wage_reservation()
 * \brief Get wage_reservation memory variable from current X-machine.
 * \return Value for variable.
 */
double get_wage_reservation()
{
	if(current_xmachine->xmachine_Household) return (*current_xmachine->xmachine_Household).wage_reservation;

    // suppress compiler warning by returning dummy value /
    // this statement should rightfully NEVER be reached /
    return (double)0;
}

/** \fn void set_general_skill(int general_skill)
 * \brief Set general_skill memory variable for current X-machine.
 * \param general_skill New value for variable.
 */
void set_general_skill(int general_skill)
{
	if(current_xmachine->xmachine_Household) (*current_xmachine->xmachine_Household).general_skill = general_skill;
}

/** \fn int get_general_skill()
 * \brief Get general_skill memory variable from current X-machine.
 * \return Value for variable.
 */
int get_general_skill()
{
	if(current_xmachine->xmachine_Household) return (*current_xmachine->xmachine_Household).general_skill;

    // suppress compiler warning by returning dummy value /
    // this statement should rightfully NEVER be reached /
    return (int)0;
}

/** \fn adt_list_adaptation_speed_array get_list_adaptation_speed_per_general_skill_group()
 * \brief Get list_adaptation_speed_per_general_skill_group memory variable from current X-machine.
 * \return Value for variable.
 */
adt_list_adaptation_speed_array * get_list_adaptation_speed_per_general_skill_group()
{
	if(current_xmachine->xmachine_Household) return &(*current_xmachine->xmachine_Household).list_adaptation_speed_per_general_skill_group;

    // suppress compiler warning by returning dummy value /
    // this statement should rightfully NEVER be reached /
    return NULL;
}

/** \fn void set_on_the_job_search(int on_the_job_search)
 * \brief Set on_the_job_search memory variable for current X-machine.
 * \param on_the_job_search New value for variable.
 */
void set_on_the_job_search(int on_the_job_search)
{
	if(current_xmachine->xmachine_Household) (*current_xmachine->xmachine_Household).on_the_job_search = on_the_job_search;
}

/** \fn int get_on_the_job_search()
 * \brief Get on_the_job_search memory variable from current X-machine.
 * \return Value for variable.
 */
int get_on_the_job_search()
{
	if(current_xmachine->xmachine_Household) return (*current_xmachine->xmachine_Household).on_the_job_search;

    // suppress compiler warning by returning dummy value /
    // this statement should rightfully NEVER be reached /
    return (int)0;
}

/** \fn void set_search_today(int search_today)
 * \brief Set search_today memory variable for current X-machine.
 * \param search_today New value for variable.
 */
void set_search_today(int search_today)
{
	if(current_xmachine->xmachine_Household) (*current_xmachine->xmachine_Household).search_today = search_today;
}

/** \fn int get_search_today()
 * \brief Get search_today memory variable from current X-machine.
 * \return Value for variable.
 */
int get_search_today()
{
	if(current_xmachine->xmachine_Household) return (*current_xmachine->xmachine_Household).search_today;

    // suppress compiler warning by returning dummy value /
    // this statement should rightfully NEVER be reached /
    return (int)0;
}

/** \fn void set_last_labour_income(double last_labour_income)
 * \brief Set last_labour_income memory variable for current X-machine.
 * \param last_labour_income New value for variable.
 */
void set_last_labour_income(double last_labour_income)
{
	if(current_xmachine->xmachine_Household) (*current_xmachine->xmachine_Household).last_labour_income = last_labour_income;
}

/** \fn double get_last_labour_income()
 * \brief Get last_labour_income memory variable from current X-machine.
 * \return Value for variable.
 */
double get_last_labour_income()
{
	if(current_xmachine->xmachine_Household) return (*current_xmachine->xmachine_Household).last_labour_income;

    // suppress compiler warning by returning dummy value /
    // this statement should rightfully NEVER be reached /
    return (double)0;
}

/** \fn void set_specific_skill(double specific_skill)
 * \brief Set specific_skill memory variable for current X-machine.
 * \param specific_skill New value for variable.
 */
void set_specific_skill(double specific_skill)
{
	if(current_xmachine->xmachine_Household) (*current_xmachine->xmachine_Household).specific_skill = specific_skill;
}

/** \fn double get_specific_skill()
 * \brief Get specific_skill memory variable from current X-machine.
 * \return Value for variable.
 */
double get_specific_skill()
{
	if(current_xmachine->xmachine_Household) return (*current_xmachine->xmachine_Household).specific_skill;

    // suppress compiler warning by returning dummy value /
    // this statement should rightfully NEVER be reached /
    return (double)0;
}

/** \fn void set_employee_firm_id(int employee_firm_id)
 * \brief Set employee_firm_id memory variable for current X-machine.
 * \param employee_firm_id New value for variable.
 */
void set_employee_firm_id(int employee_firm_id)
{
	if(current_xmachine->xmachine_Household) (*current_xmachine->xmachine_Household).employee_firm_id = employee_firm_id;
}

/** \fn int get_employee_firm_id()
 * \brief Get employee_firm_id memory variable from current X-machine.
 * \return Value for variable.
 */
int get_employee_firm_id()
{
	if(current_xmachine->xmachine_Household) return (*current_xmachine->xmachine_Household).employee_firm_id;

    // suppress compiler warning by returning dummy value /
    // this statement should rightfully NEVER be reached /
    return (int)0;
}

/** \fn void set_hh_applications_per_day(int hh_applications_per_day)
 * \brief Set hh_applications_per_day memory variable for current X-machine.
 * \param hh_applications_per_day New value for variable.
 */
void set_hh_applications_per_day(int hh_applications_per_day)
{
	if(current_xmachine->xmachine_Household) (*current_xmachine->xmachine_Household).hh_applications_per_day = hh_applications_per_day;
}

/** \fn int get_hh_applications_per_day()
 * \brief Get hh_applications_per_day memory variable from current X-machine.
 * \return Value for variable.
 */
int get_hh_applications_per_day()
{
	if(current_xmachine->xmachine_Household) return (*current_xmachine->xmachine_Household).hh_applications_per_day;

    // suppress compiler warning by returning dummy value /
    // this statement should rightfully NEVER be reached /
    return (int)0;
}

/** \fn void set_just_employed(int just_employed)
 * \brief Set just_employed memory variable for current X-machine.
 * \param just_employed New value for variable.
 */
void set_just_employed(int just_employed)
{
	if(current_xmachine->xmachine_Household) (*current_xmachine->xmachine_Household).just_employed = just_employed;
	if(current_xmachine->xmachine_Eurostat) (*current_xmachine->xmachine_Eurostat).just_employed = just_employed;
}

/** \fn int get_just_employed()
 * \brief Get just_employed memory variable from current X-machine.
 * \return Value for variable.
 */
int get_just_employed()
{
	if(current_xmachine->xmachine_Household) return (*current_xmachine->xmachine_Household).just_employed;
	if(current_xmachine->xmachine_Eurostat) return (*current_xmachine->xmachine_Eurostat).just_employed;

    // suppress compiler warning by returning dummy value /
    // this statement should rightfully NEVER be reached /
    return (int)0;
}

/** \fn void set_just_unemployed(int just_unemployed)
 * \brief Set just_unemployed memory variable for current X-machine.
 * \param just_unemployed New value for variable.
 */
void set_just_unemployed(int just_unemployed)
{
	if(current_xmachine->xmachine_Household) (*current_xmachine->xmachine_Household).just_unemployed = just_unemployed;
	if(current_xmachine->xmachine_Eurostat) (*current_xmachine->xmachine_Eurostat).just_unemployed = just_unemployed;
}

/** \fn int get_just_unemployed()
 * \brief Get just_unemployed memory variable from current X-machine.
 * \return Value for variable.
 */
int get_just_unemployed()
{
	if(current_xmachine->xmachine_Household) return (*current_xmachine->xmachine_Household).just_unemployed;
	if(current_xmachine->xmachine_Eurostat) return (*current_xmachine->xmachine_Eurostat).just_unemployed;

    // suppress compiler warning by returning dummy value /
    // this statement should rightfully NEVER be reached /
    return (int)0;
}

/** \fn void set_start_unemployed(int start_unemployed)
 * \brief Set start_unemployed memory variable for current X-machine.
 * \param start_unemployed New value for variable.
 */
void set_start_unemployed(int start_unemployed)
{
	if(current_xmachine->xmachine_Household) (*current_xmachine->xmachine_Household).start_unemployed = start_unemployed;
	if(current_xmachine->xmachine_Eurostat) (*current_xmachine->xmachine_Eurostat).start_unemployed = start_unemployed;
}

/** \fn int get_start_unemployed()
 * \brief Get start_unemployed memory variable from current X-machine.
 * \return Value for variable.
 */
int get_start_unemployed()
{
	if(current_xmachine->xmachine_Household) return (*current_xmachine->xmachine_Household).start_unemployed;
	if(current_xmachine->xmachine_Eurostat) return (*current_xmachine->xmachine_Eurostat).start_unemployed;

    // suppress compiler warning by returning dummy value /
    // this statement should rightfully NEVER be reached /
    return (int)0;
}

/** \fn void set_start_employed(int start_employed)
 * \brief Set start_employed memory variable for current X-machine.
 * \param start_employed New value for variable.
 */
void set_start_employed(int start_employed)
{
	if(current_xmachine->xmachine_Household) (*current_xmachine->xmachine_Household).start_employed = start_employed;
	if(current_xmachine->xmachine_Eurostat) (*current_xmachine->xmachine_Eurostat).start_employed = start_employed;
}

/** \fn int get_start_employed()
 * \brief Get start_employed memory variable from current X-machine.
 * \return Value for variable.
 */
int get_start_employed()
{
	if(current_xmachine->xmachine_Household) return (*current_xmachine->xmachine_Household).start_employed;
	if(current_xmachine->xmachine_Eurostat) return (*current_xmachine->xmachine_Eurostat).start_employed;

    // suppress compiler warning by returning dummy value /
    // this statement should rightfully NEVER be reached /
    return (int)0;
}

/** \fn void set_unemployed_duration(int unemployed_duration)
 * \brief Set unemployed_duration memory variable for current X-machine.
 * \param unemployed_duration New value for variable.
 */
void set_unemployed_duration(int unemployed_duration)
{
	if(current_xmachine->xmachine_Household) (*current_xmachine->xmachine_Household).unemployed_duration = unemployed_duration;
	if(current_xmachine->xmachine_Eurostat) (*current_xmachine->xmachine_Eurostat).unemployed_duration = unemployed_duration;
}

/** \fn int get_unemployed_duration()
 * \brief Get unemployed_duration memory variable from current X-machine.
 * \return Value for variable.
 */
int get_unemployed_duration()
{
	if(current_xmachine->xmachine_Household) return (*current_xmachine->xmachine_Household).unemployed_duration;
	if(current_xmachine->xmachine_Eurostat) return (*current_xmachine->xmachine_Eurostat).unemployed_duration;

    // suppress compiler warning by returning dummy value /
    // this statement should rightfully NEVER be reached /
    return (int)0;
}

/** \fn void set_enter_matching(int enter_matching)
 * \brief Set enter_matching memory variable for current X-machine.
 * \param enter_matching New value for variable.
 */
void set_enter_matching(int enter_matching)
{
	if(current_xmachine->xmachine_Household) (*current_xmachine->xmachine_Household).enter_matching = enter_matching;
	if(current_xmachine->xmachine_Eurostat) (*current_xmachine->xmachine_Eurostat).enter_matching = enter_matching;
}

/** \fn int get_enter_matching()
 * \brief Get enter_matching memory variable from current X-machine.
 * \return Value for variable.
 */
int get_enter_matching()
{
	if(current_xmachine->xmachine_Household) return (*current_xmachine->xmachine_Household).enter_matching;
	if(current_xmachine->xmachine_Eurostat) return (*current_xmachine->xmachine_Eurostat).enter_matching;

    // suppress compiler warning by returning dummy value /
    // this statement should rightfully NEVER be reached /
    return (int)0;
}

/** \fn void set_employer_region_id(int employer_region_id)
 * \brief Set employer_region_id memory variable for current X-machine.
 * \param employer_region_id New value for variable.
 */
void set_employer_region_id(int employer_region_id)
{
	if(current_xmachine->xmachine_Household) (*current_xmachine->xmachine_Household).employer_region_id = employer_region_id;
}

/** \fn int get_employer_region_id()
 * \brief Get employer_region_id memory variable from current X-machine.
 * \return Value for variable.
 */
int get_employer_region_id()
{
	if(current_xmachine->xmachine_Household) return (*current_xmachine->xmachine_Household).employer_region_id;

    // suppress compiler warning by returning dummy value /
    // this statement should rightfully NEVER be reached /
    return (int)0;
}

/** \fn void set_employer_igfirm(int employer_igfirm)
 * \brief Set employer_igfirm memory variable for current X-machine.
 * \param employer_igfirm New value for variable.
 */
void set_employer_igfirm(int employer_igfirm)
{
	if(current_xmachine->xmachine_Household) (*current_xmachine->xmachine_Household).employer_igfirm = employer_igfirm;
}

/** \fn int get_employer_igfirm()
 * \brief Get employer_igfirm memory variable from current X-machine.
 * \return Value for variable.
 */
int get_employer_igfirm()
{
	if(current_xmachine->xmachine_Household) return (*current_xmachine->xmachine_Household).employer_igfirm;

    // suppress compiler warning by returning dummy value /
    // this statement should rightfully NEVER be reached /
    return (int)0;
}

/** \fn void set_day_of_month_receive_benefit(int day_of_month_receive_benefit)
 * \brief Set day_of_month_receive_benefit memory variable for current X-machine.
 * \param day_of_month_receive_benefit New value for variable.
 */
void set_day_of_month_receive_benefit(int day_of_month_receive_benefit)
{
	if(current_xmachine->xmachine_Household) (*current_xmachine->xmachine_Household).day_of_month_receive_benefit = day_of_month_receive_benefit;
}

/** \fn int get_day_of_month_receive_benefit()
 * \brief Get day_of_month_receive_benefit memory variable from current X-machine.
 * \return Value for variable.
 */
int get_day_of_month_receive_benefit()
{
	if(current_xmachine->xmachine_Household) return (*current_xmachine->xmachine_Household).day_of_month_receive_benefit;

    // suppress compiler warning by returning dummy value /
    // this statement should rightfully NEVER be reached /
    return (int)0;
}

/** \fn void set_unemployment_payment(double unemployment_payment)
 * \brief Set unemployment_payment memory variable for current X-machine.
 * \param unemployment_payment New value for variable.
 */
void set_unemployment_payment(double unemployment_payment)
{
	if(current_xmachine->xmachine_Household) (*current_xmachine->xmachine_Household).unemployment_payment = unemployment_payment;
}

/** \fn double get_unemployment_payment()
 * \brief Get unemployment_payment memory variable from current X-machine.
 * \return Value for variable.
 */
double get_unemployment_payment()
{
	if(current_xmachine->xmachine_Household) return (*current_xmachine->xmachine_Household).unemployment_payment;

    // suppress compiler warning by returning dummy value /
    // this statement should rightfully NEVER be reached /
    return (double)0;
}

/** \fn void set_region_wide_mean_wage(double region_wide_mean_wage)
 * \brief Set region_wide_mean_wage memory variable for current X-machine.
 * \param region_wide_mean_wage New value for variable.
 */
void set_region_wide_mean_wage(double region_wide_mean_wage)
{
	if(current_xmachine->xmachine_Household) (*current_xmachine->xmachine_Household).region_wide_mean_wage = region_wide_mean_wage;
}

/** \fn double get_region_wide_mean_wage()
 * \brief Get region_wide_mean_wage memory variable from current X-machine.
 * \return Value for variable.
 */
double get_region_wide_mean_wage()
{
	if(current_xmachine->xmachine_Household) return (*current_xmachine->xmachine_Household).region_wide_mean_wage;

    // suppress compiler warning by returning dummy value /
    // this statement should rightfully NEVER be reached /
    return (double)0;
}

/** \fn void set_basic_security_benefits(double basic_security_benefits)
 * \brief Set basic_security_benefits memory variable for current X-machine.
 * \param basic_security_benefits New value for variable.
 */
void set_basic_security_benefits(double basic_security_benefits)
{
	if(current_xmachine->xmachine_Household) (*current_xmachine->xmachine_Household).basic_security_benefits = basic_security_benefits;
	if(current_xmachine->xmachine_Government) (*current_xmachine->xmachine_Government).basic_security_benefits = basic_security_benefits;
}

/** \fn double get_basic_security_benefits()
 * \brief Get basic_security_benefits memory variable from current X-machine.
 * \return Value for variable.
 */
double get_basic_security_benefits()
{
	if(current_xmachine->xmachine_Household) return (*current_xmachine->xmachine_Household).basic_security_benefits;
	if(current_xmachine->xmachine_Government) return (*current_xmachine->xmachine_Government).basic_security_benefits;

    // suppress compiler warning by returning dummy value /
    // this statement should rightfully NEVER be reached /
    return (double)0;
}

/** \fn double_array get_last_net_income()
 * \brief Get last_net_income memory variable from current X-machine.
 * \return Value for variable.
 */
double_array * get_last_net_income()
{
	if(current_xmachine->xmachine_Household) return &(*current_xmachine->xmachine_Household).last_net_income;

    // suppress compiler warning by returning dummy value /
    // this statement should rightfully NEVER be reached /
    return NULL;
}

/** \fn void set_mean_net_income(double mean_net_income)
 * \brief Set mean_net_income memory variable for current X-machine.
 * \param mean_net_income New value for variable.
 */
void set_mean_net_income(double mean_net_income)
{
	if(current_xmachine->xmachine_Household) (*current_xmachine->xmachine_Household).mean_net_income = mean_net_income;
	if(current_xmachine->xmachine_Eurostat) (*current_xmachine->xmachine_Eurostat).mean_net_income = mean_net_income;
}

/** \fn double get_mean_net_income()
 * \brief Get mean_net_income memory variable from current X-machine.
 * \return Value for variable.
 */
double get_mean_net_income()
{
	if(current_xmachine->xmachine_Household) return (*current_xmachine->xmachine_Household).mean_net_income;
	if(current_xmachine->xmachine_Eurostat) return (*current_xmachine->xmachine_Eurostat).mean_net_income;

    // suppress compiler warning by returning dummy value /
    // this statement should rightfully NEVER be reached /
    return (double)0;
}

/** \fn household_balance_sheet_adt get_household_balance_sheet_calendar()
 * \brief Get household_balance_sheet_calendar memory variable from current X-machine.
 * \return Value for variable.
 */
household_balance_sheet_adt * get_household_balance_sheet_calendar()
{
	if(current_xmachine->xmachine_Household) return &(*current_xmachine->xmachine_Household).household_balance_sheet_calendar;

    // suppress compiler warning by returning dummy value /
    // this statement should rightfully NEVER be reached /
    return NULL;
}

/** \fn household_stocks_adt get_household_stocks_calendar()
 * \brief Get household_stocks_calendar memory variable from current X-machine.
 * \return Value for variable.
 */
household_stocks_adt * get_household_stocks_calendar()
{
	if(current_xmachine->xmachine_Household) return &(*current_xmachine->xmachine_Household).household_stocks_calendar;

    // suppress compiler warning by returning dummy value /
    // this statement should rightfully NEVER be reached /
    return NULL;
}

/** \fn household_outflows_adt get_household_outflows_calendar()
 * \brief Get household_outflows_calendar memory variable from current X-machine.
 * \return Value for variable.
 */
household_outflows_adt * get_household_outflows_calendar()
{
	if(current_xmachine->xmachine_Household) return &(*current_xmachine->xmachine_Household).household_outflows_calendar;

    // suppress compiler warning by returning dummy value /
    // this statement should rightfully NEVER be reached /
    return NULL;
}

/** \fn household_inflows_adt get_household_inflows_calendar()
 * \brief Get household_inflows_calendar memory variable from current X-machine.
 * \return Value for variable.
 */
household_inflows_adt * get_household_inflows_calendar()
{
	if(current_xmachine->xmachine_Household) return &(*current_xmachine->xmachine_Household).household_inflows_calendar;

    // suppress compiler warning by returning dummy value /
    // this statement should rightfully NEVER be reached /
    return NULL;
}

/** \fn void set_unemployment_benefit_pct(double unemployment_benefit_pct)
 * \brief Set unemployment_benefit_pct memory variable for current X-machine.
 * \param unemployment_benefit_pct New value for variable.
 */
void set_unemployment_benefit_pct(double unemployment_benefit_pct)
{
	if(current_xmachine->xmachine_Household) (*current_xmachine->xmachine_Household).unemployment_benefit_pct = unemployment_benefit_pct;
	if(current_xmachine->xmachine_Government) (*current_xmachine->xmachine_Government).unemployment_benefit_pct = unemployment_benefit_pct;
}

/** \fn double get_unemployment_benefit_pct()
 * \brief Get unemployment_benefit_pct memory variable from current X-machine.
 * \return Value for variable.
 */
double get_unemployment_benefit_pct()
{
	if(current_xmachine->xmachine_Household) return (*current_xmachine->xmachine_Household).unemployment_benefit_pct;
	if(current_xmachine->xmachine_Government) return (*current_xmachine->xmachine_Government).unemployment_benefit_pct;

    // suppress compiler warning by returning dummy value /
    // this statement should rightfully NEVER be reached /
    return (double)0;
}

/** \fn void set_monthly_interest_income(double monthly_interest_income)
 * \brief Set monthly_interest_income memory variable for current X-machine.
 * \param monthly_interest_income New value for variable.
 */
void set_monthly_interest_income(double monthly_interest_income)
{
	if(current_xmachine->xmachine_Household) (*current_xmachine->xmachine_Household).monthly_interest_income = monthly_interest_income;
}

/** \fn double get_monthly_interest_income()
 * \brief Get monthly_interest_income memory variable from current X-machine.
 * \return Value for variable.
 */
double get_monthly_interest_income()
{
	if(current_xmachine->xmachine_Household) return (*current_xmachine->xmachine_Household).monthly_interest_income;

    // suppress compiler warning by returning dummy value /
    // this statement should rightfully NEVER be reached /
    return (double)0;
}

/** \fn void set_monthly_consumption_expenditure(double monthly_consumption_expenditure)
 * \brief Set monthly_consumption_expenditure memory variable for current X-machine.
 * \param monthly_consumption_expenditure New value for variable.
 */
void set_monthly_consumption_expenditure(double monthly_consumption_expenditure)
{
	if(current_xmachine->xmachine_Household) (*current_xmachine->xmachine_Household).monthly_consumption_expenditure = monthly_consumption_expenditure;
	if(current_xmachine->xmachine_Government) (*current_xmachine->xmachine_Government).monthly_consumption_expenditure = monthly_consumption_expenditure;
}

/** \fn double get_monthly_consumption_expenditure()
 * \brief Get monthly_consumption_expenditure memory variable from current X-machine.
 * \return Value for variable.
 */
double get_monthly_consumption_expenditure()
{
	if(current_xmachine->xmachine_Household) return (*current_xmachine->xmachine_Household).monthly_consumption_expenditure;
	if(current_xmachine->xmachine_Government) return (*current_xmachine->xmachine_Government).monthly_consumption_expenditure;

    // suppress compiler warning by returning dummy value /
    // this statement should rightfully NEVER be reached /
    return (double)0;
}

/** \fn void set_monthly_bond_interest_income(double monthly_bond_interest_income)
 * \brief Set monthly_bond_interest_income memory variable for current X-machine.
 * \param monthly_bond_interest_income New value for variable.
 */
void set_monthly_bond_interest_income(double monthly_bond_interest_income)
{
	if(current_xmachine->xmachine_Household) (*current_xmachine->xmachine_Household).monthly_bond_interest_income = monthly_bond_interest_income;
}

/** \fn double get_monthly_bond_interest_income()
 * \brief Get monthly_bond_interest_income memory variable from current X-machine.
 * \return Value for variable.
 */
double get_monthly_bond_interest_income()
{
	if(current_xmachine->xmachine_Household) return (*current_xmachine->xmachine_Household).monthly_bond_interest_income;

    // suppress compiler warning by returning dummy value /
    // this statement should rightfully NEVER be reached /
    return (double)0;
}

/** \fn void set_region_mean_wage(double region_mean_wage)
 * \brief Set region_mean_wage memory variable for current X-machine.
 * \param region_mean_wage New value for variable.
 */
void set_region_mean_wage(double region_mean_wage)
{
	if(current_xmachine->xmachine_Household) (*current_xmachine->xmachine_Household).region_mean_wage = region_mean_wage;
}

/** \fn double get_region_mean_wage()
 * \brief Get region_mean_wage memory variable from current X-machine.
 * \return Value for variable.
 */
double get_region_mean_wage()
{
	if(current_xmachine->xmachine_Household) return (*current_xmachine->xmachine_Household).region_mean_wage;

    // suppress compiler warning by returning dummy value /
    // this statement should rightfully NEVER be reached /
    return (double)0;
}

/** \fn void set_human_capital_policy_flag(int human_capital_policy_flag)
 * \brief Set human_capital_policy_flag memory variable for current X-machine.
 * \param human_capital_policy_flag New value for variable.
 */
void set_human_capital_policy_flag(int human_capital_policy_flag)
{
	if(current_xmachine->xmachine_Household) (*current_xmachine->xmachine_Household).human_capital_policy_flag = human_capital_policy_flag;
	if(current_xmachine->xmachine_Government) (*current_xmachine->xmachine_Government).human_capital_policy_flag = human_capital_policy_flag;
}

/** \fn int get_human_capital_policy_flag()
 * \brief Get human_capital_policy_flag memory variable from current X-machine.
 * \return Value for variable.
 */
int get_human_capital_policy_flag()
{
	if(current_xmachine->xmachine_Household) return (*current_xmachine->xmachine_Household).human_capital_policy_flag;
	if(current_xmachine->xmachine_Government) return (*current_xmachine->xmachine_Government).human_capital_policy_flag;

    // suppress compiler warning by returning dummy value /
    // this statement should rightfully NEVER be reached /
    return (int)0;
}

/** \fn void set_questionnaire_attending_propability(double questionnaire_attending_propability)
 * \brief Set questionnaire_attending_propability memory variable for current X-machine.
 * \param questionnaire_attending_propability New value for variable.
 */
void set_questionnaire_attending_propability(double questionnaire_attending_propability)
{
	if(current_xmachine->xmachine_Household) (*current_xmachine->xmachine_Household).questionnaire_attending_propability = questionnaire_attending_propability;
}

/** \fn double get_questionnaire_attending_propability()
 * \brief Get questionnaire_attending_propability memory variable from current X-machine.
 * \return Value for variable.
 */
double get_questionnaire_attending_propability()
{
	if(current_xmachine->xmachine_Household) return (*current_xmachine->xmachine_Household).questionnaire_attending_propability;

    // suppress compiler warning by returning dummy value /
    // this statement should rightfully NEVER be reached /
    return (double)0;
}

/** \fn void set_willingness_to_attend(int willingness_to_attend)
 * \brief Set willingness_to_attend memory variable for current X-machine.
 * \param willingness_to_attend New value for variable.
 */
void set_willingness_to_attend(int willingness_to_attend)
{
	if(current_xmachine->xmachine_Household) (*current_xmachine->xmachine_Household).willingness_to_attend = willingness_to_attend;
}

/** \fn int get_willingness_to_attend()
 * \brief Get willingness_to_attend memory variable from current X-machine.
 * \return Value for variable.
 */
int get_willingness_to_attend()
{
	if(current_xmachine->xmachine_Household) return (*current_xmachine->xmachine_Household).willingness_to_attend;

    // suppress compiler warning by returning dummy value /
    // this statement should rightfully NEVER be reached /
    return (int)0;
}

/** \fn void set_interviewer_id(int interviewer_id)
 * \brief Set interviewer_id memory variable for current X-machine.
 * \param interviewer_id New value for variable.
 */
void set_interviewer_id(int interviewer_id)
{
	if(current_xmachine->xmachine_Household) (*current_xmachine->xmachine_Household).interviewer_id = interviewer_id;
}

/** \fn int get_interviewer_id()
 * \brief Get interviewer_id memory variable from current X-machine.
 * \return Value for variable.
 */
int get_interviewer_id()
{
	if(current_xmachine->xmachine_Household) return (*current_xmachine->xmachine_Household).interviewer_id;

    // suppress compiler warning by returning dummy value /
    // this statement should rightfully NEVER be reached /
    return (int)0;
}

/** \fn void set_random_no_test(int random_no_test)
 * \brief Set random_no_test memory variable for current X-machine.
 * \param random_no_test New value for variable.
 */
void set_random_no_test(int random_no_test)
{
	if(current_xmachine->xmachine_Household) (*current_xmachine->xmachine_Household).random_no_test = random_no_test;
}

/** \fn int get_random_no_test()
 * \brief Get random_no_test memory variable from current X-machine.
 * \return Value for variable.
 */
int get_random_no_test()
{
	if(current_xmachine->xmachine_Household) return (*current_xmachine->xmachine_Household).random_no_test;

    // suppress compiler warning by returning dummy value /
    // this statement should rightfully NEVER be reached /
    return (int)0;
}

/** \fn int get_questionnaire()
 * \brief Get questionnaire memory variable from current X-machine.
 * \return Value for variable.
 */
int * get_questionnaire()
{
	if(current_xmachine->xmachine_Household) return (*current_xmachine->xmachine_Household).questionnaire;

    // suppress compiler warning by returning dummy value /
    // this statement should rightfully NEVER be reached /
    return NULL;
}

/** \fn consumption_goods_offer_array get_current_price_quality_list()
 * \brief Get current_price_quality_list memory variable from current X-machine.
 * \return Value for variable.
 */
consumption_goods_offer_array * get_current_price_quality_list()
{
	if(current_xmachine->xmachine_Household) return &(*current_xmachine->xmachine_Household).current_price_quality_list;

    // suppress compiler warning by returning dummy value /
    // this statement should rightfully NEVER be reached /
    return NULL;
}

/** \fn mall_stock_array get_current_stock()
 * \brief Get current_stock memory variable from current X-machine.
 * \return Value for variable.
 */
mall_stock_array * get_current_stock()
{
	if(current_xmachine->xmachine_Mall) return &(*current_xmachine->xmachine_Mall).current_stock;

    // suppress compiler warning by returning dummy value /
    // this statement should rightfully NEVER be reached /
    return NULL;
}

/** \fn sales_in_mall_array get_firm_revenues()
 * \brief Get firm_revenues memory variable from current X-machine.
 * \return Value for variable.
 */
sales_in_mall_array * get_firm_revenues()
{
	if(current_xmachine->xmachine_Mall) return &(*current_xmachine->xmachine_Mall).firm_revenues;

    // suppress compiler warning by returning dummy value /
    // this statement should rightfully NEVER be reached /
    return NULL;
}

/** \fn void set_sales_per_month(double sales_per_month)
 * \brief Set sales_per_month memory variable for current X-machine.
 * \param sales_per_month New value for variable.
 */
void set_sales_per_month(double sales_per_month)
{
	if(current_xmachine->xmachine_Mall) (*current_xmachine->xmachine_Mall).sales_per_month = sales_per_month;
}

/** \fn double get_sales_per_month()
 * \brief Get sales_per_month memory variable from current X-machine.
 * \return Value for variable.
 */
double get_sales_per_month()
{
	if(current_xmachine->xmachine_Mall) return (*current_xmachine->xmachine_Mall).sales_per_month;

    // suppress compiler warning by returning dummy value /
    // this statement should rightfully NEVER be reached /
    return (double)0;
}

/** \fn double get_export_volume_matrix()
 * \brief Get export_volume_matrix memory variable from current X-machine.
 * \return Value for variable.
 */
double * get_export_volume_matrix()
{
	if(current_xmachine->xmachine_Mall) return (*current_xmachine->xmachine_Mall).export_volume_matrix;
	if(current_xmachine->xmachine_Eurostat) return (*current_xmachine->xmachine_Eurostat).export_volume_matrix;

    // suppress compiler warning by returning dummy value /
    // this statement should rightfully NEVER be reached /
    return NULL;
}

/** \fn double get_export_value_matrix()
 * \brief Get export_value_matrix memory variable from current X-machine.
 * \return Value for variable.
 */
double * get_export_value_matrix()
{
	if(current_xmachine->xmachine_Mall) return (*current_xmachine->xmachine_Mall).export_value_matrix;
	if(current_xmachine->xmachine_Eurostat) return (*current_xmachine->xmachine_Eurostat).export_value_matrix;

    // suppress compiler warning by returning dummy value /
    // this statement should rightfully NEVER be reached /
    return NULL;
}

/** \fn double get_export_previous_value_matrix()
 * \brief Get export_previous_value_matrix memory variable from current X-machine.
 * \return Value for variable.
 */
double * get_export_previous_value_matrix()
{
	if(current_xmachine->xmachine_Mall) return (*current_xmachine->xmachine_Mall).export_previous_value_matrix;
	if(current_xmachine->xmachine_Eurostat) return (*current_xmachine->xmachine_Eurostat).export_previous_value_matrix;

    // suppress compiler warning by returning dummy value /
    // this statement should rightfully NEVER be reached /
    return NULL;
}

/** \fn void set_productivity(double productivity)
 * \brief Set productivity memory variable for current X-machine.
 * \param productivity New value for variable.
 */
void set_productivity(double productivity)
{
	if(current_xmachine->xmachine_IGFirm) (*current_xmachine->xmachine_IGFirm).productivity = productivity;
}

/** \fn double get_productivity()
 * \brief Get productivity memory variable from current X-machine.
 * \return Value for variable.
 */
double get_productivity()
{
	if(current_xmachine->xmachine_IGFirm) return (*current_xmachine->xmachine_IGFirm).productivity;

    // suppress compiler warning by returning dummy value /
    // this statement should rightfully NEVER be reached /
    return (double)0;
}

/** \fn void set_capital_good_price(double capital_good_price)
 * \brief Set capital_good_price memory variable for current X-machine.
 * \param capital_good_price New value for variable.
 */
void set_capital_good_price(double capital_good_price)
{
	if(current_xmachine->xmachine_IGFirm) (*current_xmachine->xmachine_IGFirm).capital_good_price = capital_good_price;
}

/** \fn double get_capital_good_price()
 * \brief Get capital_good_price memory variable from current X-machine.
 * \return Value for variable.
 */
double get_capital_good_price()
{
	if(current_xmachine->xmachine_IGFirm) return (*current_xmachine->xmachine_IGFirm).capital_good_price;

    // suppress compiler warning by returning dummy value /
    // this statement should rightfully NEVER be reached /
    return (double)0;
}

/** \fn vintage_array get_vintages()
 * \brief Get vintages memory variable from current X-machine.
 * \return Value for variable.
 */
vintage_array * get_vintages()
{
	if(current_xmachine->xmachine_IGFirm) return &(*current_xmachine->xmachine_IGFirm).vintages;

    // suppress compiler warning by returning dummy value /
    // this statement should rightfully NEVER be reached /
    return NULL;
}

/** \fn adt_sales_per_vintage_array get_sales_per_vintage()
 * \brief Get sales_per_vintage memory variable from current X-machine.
 * \return Value for variable.
 */
adt_sales_per_vintage_array * get_sales_per_vintage()
{
	if(current_xmachine->xmachine_IGFirm) return &(*current_xmachine->xmachine_IGFirm).sales_per_vintage;

    // suppress compiler warning by returning dummy value /
    // this statement should rightfully NEVER be reached /
    return NULL;
}

/** \fn void set_mean_productivity_of_sales(double mean_productivity_of_sales)
 * \brief Set mean_productivity_of_sales memory variable for current X-machine.
 * \param mean_productivity_of_sales New value for variable.
 */
void set_mean_productivity_of_sales(double mean_productivity_of_sales)
{
	if(current_xmachine->xmachine_IGFirm) (*current_xmachine->xmachine_IGFirm).mean_productivity_of_sales = mean_productivity_of_sales;
}

/** \fn double get_mean_productivity_of_sales()
 * \brief Get mean_productivity_of_sales memory variable from current X-machine.
 * \return Value for variable.
 */
double get_mean_productivity_of_sales()
{
	if(current_xmachine->xmachine_IGFirm) return (*current_xmachine->xmachine_IGFirm).mean_productivity_of_sales;

    // suppress compiler warning by returning dummy value /
    // this statement should rightfully NEVER be reached /
    return (double)0;
}

/** \fn void set_ratio_sold_productivity_best_practice(double ratio_sold_productivity_best_practice)
 * \brief Set ratio_sold_productivity_best_practice memory variable for current X-machine.
 * \param ratio_sold_productivity_best_practice New value for variable.
 */
void set_ratio_sold_productivity_best_practice(double ratio_sold_productivity_best_practice)
{
	if(current_xmachine->xmachine_IGFirm) (*current_xmachine->xmachine_IGFirm).ratio_sold_productivity_best_practice = ratio_sold_productivity_best_practice;
}

/** \fn double get_ratio_sold_productivity_best_practice()
 * \brief Get ratio_sold_productivity_best_practice memory variable from current X-machine.
 * \return Value for variable.
 */
double get_ratio_sold_productivity_best_practice()
{
	if(current_xmachine->xmachine_IGFirm) return (*current_xmachine->xmachine_IGFirm).ratio_sold_productivity_best_practice;

    // suppress compiler warning by returning dummy value /
    // this statement should rightfully NEVER be reached /
    return (double)0;
}

/** \fn void set_igfirm_endogenous_innovation_probability(double igfirm_endogenous_innovation_probability)
 * \brief Set igfirm_endogenous_innovation_probability memory variable for current X-machine.
 * \param igfirm_endogenous_innovation_probability New value for variable.
 */
void set_igfirm_endogenous_innovation_probability(double igfirm_endogenous_innovation_probability)
{
	if(current_xmachine->xmachine_IGFirm) (*current_xmachine->xmachine_IGFirm).igfirm_endogenous_innovation_probability = igfirm_endogenous_innovation_probability;
}

/** \fn double get_igfirm_endogenous_innovation_probability()
 * \brief Get igfirm_endogenous_innovation_probability memory variable from current X-machine.
 * \return Value for variable.
 */
double get_igfirm_endogenous_innovation_probability()
{
	if(current_xmachine->xmachine_IGFirm) return (*current_xmachine->xmachine_IGFirm).igfirm_endogenous_innovation_probability;

    // suppress compiler warning by returning dummy value /
    // this statement should rightfully NEVER be reached /
    return (double)0;
}

/** \fn void set_net_profit(double net_profit)
 * \brief Set net_profit memory variable for current X-machine.
 * \param net_profit New value for variable.
 */
void set_net_profit(double net_profit)
{
	if(current_xmachine->xmachine_IGFirm) (*current_xmachine->xmachine_IGFirm).net_profit = net_profit;
}

/** \fn double get_net_profit()
 * \brief Get net_profit memory variable from current X-machine.
 * \return Value for variable.
 */
double get_net_profit()
{
	if(current_xmachine->xmachine_IGFirm) return (*current_xmachine->xmachine_IGFirm).net_profit;

    // suppress compiler warning by returning dummy value /
    // this statement should rightfully NEVER be reached /
    return (double)0;
}

/** \fn void set_energy_price_markup(double energy_price_markup)
 * \brief Set energy_price_markup memory variable for current X-machine.
 * \param energy_price_markup New value for variable.
 */
void set_energy_price_markup(double energy_price_markup)
{
	if(current_xmachine->xmachine_IGFirm) (*current_xmachine->xmachine_IGFirm).energy_price_markup = energy_price_markup;
}

/** \fn double get_energy_price_markup()
 * \brief Get energy_price_markup memory variable from current X-machine.
 * \return Value for variable.
 */
double get_energy_price_markup()
{
	if(current_xmachine->xmachine_IGFirm) return (*current_xmachine->xmachine_IGFirm).energy_price_markup;

    // suppress compiler warning by returning dummy value /
    // this statement should rightfully NEVER be reached /
    return (double)0;
}

/** \fn void set_energy_costs_per_day(double energy_costs_per_day)
 * \brief Set energy_costs_per_day memory variable for current X-machine.
 * \param energy_costs_per_day New value for variable.
 */
void set_energy_costs_per_day(double energy_costs_per_day)
{
	if(current_xmachine->xmachine_IGFirm) (*current_xmachine->xmachine_IGFirm).energy_costs_per_day = energy_costs_per_day;
}

/** \fn double get_energy_costs_per_day()
 * \brief Get energy_costs_per_day memory variable from current X-machine.
 * \return Value for variable.
 */
double get_energy_costs_per_day()
{
	if(current_xmachine->xmachine_IGFirm) return (*current_xmachine->xmachine_IGFirm).energy_costs_per_day;

    // suppress compiler warning by returning dummy value /
    // this statement should rightfully NEVER be reached /
    return (double)0;
}

/** \fn void set_earnings_per_day(double earnings_per_day)
 * \brief Set earnings_per_day memory variable for current X-machine.
 * \param earnings_per_day New value for variable.
 */
void set_earnings_per_day(double earnings_per_day)
{
	if(current_xmachine->xmachine_IGFirm) (*current_xmachine->xmachine_IGFirm).earnings_per_day = earnings_per_day;
}

/** \fn double get_earnings_per_day()
 * \brief Get earnings_per_day memory variable from current X-machine.
 * \return Value for variable.
 */
double get_earnings_per_day()
{
	if(current_xmachine->xmachine_IGFirm) return (*current_xmachine->xmachine_IGFirm).earnings_per_day;

    // suppress compiler warning by returning dummy value /
    // this statement should rightfully NEVER be reached /
    return (double)0;
}

/** \fn void set_cum_energy_costs(double cum_energy_costs)
 * \brief Set cum_energy_costs memory variable for current X-machine.
 * \param cum_energy_costs New value for variable.
 */
void set_cum_energy_costs(double cum_energy_costs)
{
	if(current_xmachine->xmachine_IGFirm) (*current_xmachine->xmachine_IGFirm).cum_energy_costs = cum_energy_costs;
}

/** \fn double get_cum_energy_costs()
 * \brief Get cum_energy_costs memory variable from current X-machine.
 * \return Value for variable.
 */
double get_cum_energy_costs()
{
	if(current_xmachine->xmachine_IGFirm) return (*current_xmachine->xmachine_IGFirm).cum_energy_costs;

    // suppress compiler warning by returning dummy value /
    // this statement should rightfully NEVER be reached /
    return (double)0;
}

/** \fn double_array get_last_net_profits()
 * \brief Get last_net_profits memory variable from current X-machine.
 * \return Value for variable.
 */
double_array * get_last_net_profits()
{
	if(current_xmachine->xmachine_IGFirm) return &(*current_xmachine->xmachine_IGFirm).last_net_profits;

    // suppress compiler warning by returning dummy value /
    // this statement should rightfully NEVER be reached /
    return NULL;
}

/** \fn void set_mean_sales_last_months(double mean_sales_last_months)
 * \brief Set mean_sales_last_months memory variable for current X-machine.
 * \param mean_sales_last_months New value for variable.
 */
void set_mean_sales_last_months(double mean_sales_last_months)
{
	if(current_xmachine->xmachine_IGFirm) (*current_xmachine->xmachine_IGFirm).mean_sales_last_months = mean_sales_last_months;
}

/** \fn double get_mean_sales_last_months()
 * \brief Get mean_sales_last_months memory variable from current X-machine.
 * \return Value for variable.
 */
double get_mean_sales_last_months()
{
	if(current_xmachine->xmachine_IGFirm) return (*current_xmachine->xmachine_IGFirm).mean_sales_last_months;

    // suppress compiler warning by returning dummy value /
    // this statement should rightfully NEVER be reached /
    return (double)0;
}

/** \fn double_array get_last_sales()
 * \brief Get last_sales memory variable from current X-machine.
 * \return Value for variable.
 */
double_array * get_last_sales()
{
	if(current_xmachine->xmachine_IGFirm) return &(*current_xmachine->xmachine_IGFirm).last_sales;

    // suppress compiler warning by returning dummy value /
    // this statement should rightfully NEVER be reached /
    return NULL;
}

/** \fn void set_dividend_payment(double dividend_payment)
 * \brief Set dividend_payment memory variable for current X-machine.
 * \param dividend_payment New value for variable.
 */
void set_dividend_payment(double dividend_payment)
{
	if(current_xmachine->xmachine_IGFirm) (*current_xmachine->xmachine_IGFirm).dividend_payment = dividend_payment;
	if(current_xmachine->xmachine_CentralBank) (*current_xmachine->xmachine_CentralBank).dividend_payment = dividend_payment;
}

/** \fn double get_dividend_payment()
 * \brief Get dividend_payment memory variable from current X-machine.
 * \return Value for variable.
 */
double get_dividend_payment()
{
	if(current_xmachine->xmachine_IGFirm) return (*current_xmachine->xmachine_IGFirm).dividend_payment;
	if(current_xmachine->xmachine_CentralBank) return (*current_xmachine->xmachine_CentralBank).dividend_payment;

    // suppress compiler warning by returning dummy value /
    // this statement should rightfully NEVER be reached /
    return (double)0;
}

/** \fn void set_duration_until_next_innovation(int duration_until_next_innovation)
 * \brief Set duration_until_next_innovation memory variable for current X-machine.
 * \param duration_until_next_innovation New value for variable.
 */
void set_duration_until_next_innovation(int duration_until_next_innovation)
{
	if(current_xmachine->xmachine_IGFirm) (*current_xmachine->xmachine_IGFirm).duration_until_next_innovation = duration_until_next_innovation;
}

/** \fn int get_duration_until_next_innovation()
 * \brief Get duration_until_next_innovation memory variable from current X-machine.
 * \return Value for variable.
 */
int get_duration_until_next_innovation()
{
	if(current_xmachine->xmachine_IGFirm) return (*current_xmachine->xmachine_IGFirm).duration_until_next_innovation;

    // suppress compiler warning by returning dummy value /
    // this statement should rightfully NEVER be reached /
    return (int)0;
}

/** \fn void set_sales(double sales)
 * \brief Set sales memory variable for current X-machine.
 * \param sales New value for variable.
 */
void set_sales(double sales)
{
	if(current_xmachine->xmachine_IGFirm) (*current_xmachine->xmachine_IGFirm).sales = sales;
}

/** \fn double get_sales()
 * \brief Get sales memory variable from current X-machine.
 * \return Value for variable.
 */
double get_sales()
{
	if(current_xmachine->xmachine_IGFirm) return (*current_xmachine->xmachine_IGFirm).sales;

    // suppress compiler warning by returning dummy value /
    // this statement should rightfully NEVER be reached /
    return (double)0;
}

/** \fn void set_capital_good_demand(double capital_good_demand)
 * \brief Set capital_good_demand memory variable for current X-machine.
 * \param capital_good_demand New value for variable.
 */
void set_capital_good_demand(double capital_good_demand)
{
	if(current_xmachine->xmachine_IGFirm) (*current_xmachine->xmachine_IGFirm).capital_good_demand = capital_good_demand;
}

/** \fn double get_capital_good_demand()
 * \brief Get capital_good_demand memory variable from current X-machine.
 * \return Value for variable.
 */
double get_capital_good_demand()
{
	if(current_xmachine->xmachine_IGFirm) return (*current_xmachine->xmachine_IGFirm).capital_good_demand;

    // suppress compiler warning by returning dummy value /
    // this statement should rightfully NEVER be reached /
    return (double)0;
}

/** \fn void set_capital_good_demand_last_month(double capital_good_demand_last_month)
 * \brief Set capital_good_demand_last_month memory variable for current X-machine.
 * \param capital_good_demand_last_month New value for variable.
 */
void set_capital_good_demand_last_month(double capital_good_demand_last_month)
{
	if(current_xmachine->xmachine_IGFirm) (*current_xmachine->xmachine_IGFirm).capital_good_demand_last_month = capital_good_demand_last_month;
}

/** \fn double get_capital_good_demand_last_month()
 * \brief Get capital_good_demand_last_month memory variable from current X-machine.
 * \return Value for variable.
 */
double get_capital_good_demand_last_month()
{
	if(current_xmachine->xmachine_IGFirm) return (*current_xmachine->xmachine_IGFirm).capital_good_demand_last_month;

    // suppress compiler warning by returning dummy value /
    // this statement should rightfully NEVER be reached /
    return (double)0;
}

/** \fn void set_sales_last_month(double sales_last_month)
 * \brief Set sales_last_month memory variable for current X-machine.
 * \param sales_last_month New value for variable.
 */
void set_sales_last_month(double sales_last_month)
{
	if(current_xmachine->xmachine_IGFirm) (*current_xmachine->xmachine_IGFirm).sales_last_month = sales_last_month;
}

/** \fn double get_sales_last_month()
 * \brief Get sales_last_month memory variable from current X-machine.
 * \return Value for variable.
 */
double get_sales_last_month()
{
	if(current_xmachine->xmachine_IGFirm) return (*current_xmachine->xmachine_IGFirm).sales_last_month;

    // suppress compiler warning by returning dummy value /
    // this statement should rightfully NEVER be reached /
    return (double)0;
}

/** \fn void set_cum_revenue_last_month(double cum_revenue_last_month)
 * \brief Set cum_revenue_last_month memory variable for current X-machine.
 * \param cum_revenue_last_month New value for variable.
 */
void set_cum_revenue_last_month(double cum_revenue_last_month)
{
	if(current_xmachine->xmachine_IGFirm) (*current_xmachine->xmachine_IGFirm).cum_revenue_last_month = cum_revenue_last_month;
}

/** \fn double get_cum_revenue_last_month()
 * \brief Get cum_revenue_last_month memory variable from current X-machine.
 * \return Value for variable.
 */
double get_cum_revenue_last_month()
{
	if(current_xmachine->xmachine_IGFirm) return (*current_xmachine->xmachine_IGFirm).cum_revenue_last_month;

    // suppress compiler warning by returning dummy value /
    // this statement should rightfully NEVER be reached /
    return (double)0;
}

/** \fn int_array get_innovation_sheme_low_progress()
 * \brief Get innovation_sheme_low_progress memory variable from current X-machine.
 * \return Value for variable.
 */
int_array * get_innovation_sheme_low_progress()
{
	if(current_xmachine->xmachine_IGFirm) return &(*current_xmachine->xmachine_IGFirm).innovation_sheme_low_progress;

    // suppress compiler warning by returning dummy value /
    // this statement should rightfully NEVER be reached /
    return NULL;
}

/** \fn int_array get_innovation_sheme_medium_progress()
 * \brief Get innovation_sheme_medium_progress memory variable from current X-machine.
 * \return Value for variable.
 */
int_array * get_innovation_sheme_medium_progress()
{
	if(current_xmachine->xmachine_IGFirm) return &(*current_xmachine->xmachine_IGFirm).innovation_sheme_medium_progress;

    // suppress compiler warning by returning dummy value /
    // this statement should rightfully NEVER be reached /
    return NULL;
}

/** \fn int_array get_innovation_sheme_high_progress()
 * \brief Get innovation_sheme_high_progress memory variable from current X-machine.
 * \return Value for variable.
 */
int_array * get_innovation_sheme_high_progress()
{
	if(current_xmachine->xmachine_IGFirm) return &(*current_xmachine->xmachine_IGFirm).innovation_sheme_high_progress;

    // suppress compiler warning by returning dummy value /
    // this statement should rightfully NEVER be reached /
    return NULL;
}

/** \fn void set_mean_general_skills(double mean_general_skills)
 * \brief Set mean_general_skills memory variable for current X-machine.
 * \param mean_general_skills New value for variable.
 */
void set_mean_general_skills(double mean_general_skills)
{
	if(current_xmachine->xmachine_IGFirm) (*current_xmachine->xmachine_IGFirm).mean_general_skills = mean_general_skills;
}

/** \fn double get_mean_general_skills()
 * \brief Get mean_general_skills memory variable from current X-machine.
 * \return Value for variable.
 */
double get_mean_general_skills()
{
	if(current_xmachine->xmachine_IGFirm) return (*current_xmachine->xmachine_IGFirm).mean_general_skills;

    // suppress compiler warning by returning dummy value /
    // this statement should rightfully NEVER be reached /
    return (double)0;
}

/** \fn void set_mean_adaptation_speed(double mean_adaptation_speed)
 * \brief Set mean_adaptation_speed memory variable for current X-machine.
 * \param mean_adaptation_speed New value for variable.
 */
void set_mean_adaptation_speed(double mean_adaptation_speed)
{
	if(current_xmachine->xmachine_IGFirm) (*current_xmachine->xmachine_IGFirm).mean_adaptation_speed = mean_adaptation_speed;
}

/** \fn double get_mean_adaptation_speed()
 * \brief Get mean_adaptation_speed memory variable from current X-machine.
 * \return Value for variable.
 */
double get_mean_adaptation_speed()
{
	if(current_xmachine->xmachine_IGFirm) return (*current_xmachine->xmachine_IGFirm).mean_adaptation_speed;

    // suppress compiler warning by returning dummy value /
    // this statement should rightfully NEVER be reached /
    return (double)0;
}

/** \fn adt_list_adaptation_speed_array get_list_adaptation_speed()
 * \brief Get list_adaptation_speed memory variable from current X-machine.
 * \return Value for variable.
 */
adt_list_adaptation_speed_array * get_list_adaptation_speed()
{
	if(current_xmachine->xmachine_IGFirm) return &(*current_xmachine->xmachine_IGFirm).list_adaptation_speed;

    // suppress compiler warning by returning dummy value /
    // this statement should rightfully NEVER be reached /
    return NULL;
}

/** \fn void set_productivity_progress_in_economy(double productivity_progress_in_economy)
 * \brief Set productivity_progress_in_economy memory variable for current X-machine.
 * \param productivity_progress_in_economy New value for variable.
 */
void set_productivity_progress_in_economy(double productivity_progress_in_economy)
{
	if(current_xmachine->xmachine_IGFirm) (*current_xmachine->xmachine_IGFirm).productivity_progress_in_economy = productivity_progress_in_economy;
}

/** \fn double get_productivity_progress_in_economy()
 * \brief Get productivity_progress_in_economy memory variable from current X-machine.
 * \return Value for variable.
 */
double get_productivity_progress_in_economy()
{
	if(current_xmachine->xmachine_IGFirm) return (*current_xmachine->xmachine_IGFirm).productivity_progress_in_economy;

    // suppress compiler warning by returning dummy value /
    // this statement should rightfully NEVER be reached /
    return (double)0;
}

/** \fn void set_economy_wide_capital_stock(double economy_wide_capital_stock)
 * \brief Set economy_wide_capital_stock memory variable for current X-machine.
 * \param economy_wide_capital_stock New value for variable.
 */
void set_economy_wide_capital_stock(double economy_wide_capital_stock)
{
	if(current_xmachine->xmachine_IGFirm) (*current_xmachine->xmachine_IGFirm).economy_wide_capital_stock = economy_wide_capital_stock;
}

/** \fn double get_economy_wide_capital_stock()
 * \brief Get economy_wide_capital_stock memory variable from current X-machine.
 * \return Value for variable.
 */
double get_economy_wide_capital_stock()
{
	if(current_xmachine->xmachine_IGFirm) return (*current_xmachine->xmachine_IGFirm).economy_wide_capital_stock;

    // suppress compiler warning by returning dummy value /
    // this statement should rightfully NEVER be reached /
    return (double)0;
}

/** \fn void set_dividend_buffer(double dividend_buffer)
 * \brief Set dividend_buffer memory variable for current X-machine.
 * \param dividend_buffer New value for variable.
 */
void set_dividend_buffer(double dividend_buffer)
{
	if(current_xmachine->xmachine_IGFirm) (*current_xmachine->xmachine_IGFirm).dividend_buffer = dividend_buffer;
}

/** \fn double get_dividend_buffer()
 * \brief Get dividend_buffer memory variable from current X-machine.
 * \return Value for variable.
 */
double get_dividend_buffer()
{
	if(current_xmachine->xmachine_IGFirm) return (*current_xmachine->xmachine_IGFirm).dividend_buffer;

    // suppress compiler warning by returning dummy value /
    // this statement should rightfully NEVER be reached /
    return (double)0;
}

/** \fn void set_dividend_target(double dividend_target)
 * \brief Set dividend_target memory variable for current X-machine.
 * \param dividend_target New value for variable.
 */
void set_dividend_target(double dividend_target)
{
	if(current_xmachine->xmachine_IGFirm) (*current_xmachine->xmachine_IGFirm).dividend_target = dividend_target;
}

/** \fn double get_dividend_target()
 * \brief Get dividend_target memory variable from current X-machine.
 * \return Value for variable.
 */
double get_dividend_target()
{
	if(current_xmachine->xmachine_IGFirm) return (*current_xmachine->xmachine_IGFirm).dividend_target;

    // suppress compiler warning by returning dummy value /
    // this statement should rightfully NEVER be reached /
    return (double)0;
}

/** \fn igfirm_balance_sheet_adt get_igfirm_balance_sheet_calendar()
 * \brief Get igfirm_balance_sheet_calendar memory variable from current X-machine.
 * \return Value for variable.
 */
igfirm_balance_sheet_adt * get_igfirm_balance_sheet_calendar()
{
	if(current_xmachine->xmachine_IGFirm) return &(*current_xmachine->xmachine_IGFirm).igfirm_balance_sheet_calendar;

    // suppress compiler warning by returning dummy value /
    // this statement should rightfully NEVER be reached /
    return NULL;
}

/** \fn igfirm_stocks_adt get_igfirm_stocks_calendar()
 * \brief Get igfirm_stocks_calendar memory variable from current X-machine.
 * \return Value for variable.
 */
igfirm_stocks_adt * get_igfirm_stocks_calendar()
{
	if(current_xmachine->xmachine_IGFirm) return &(*current_xmachine->xmachine_IGFirm).igfirm_stocks_calendar;

    // suppress compiler warning by returning dummy value /
    // this statement should rightfully NEVER be reached /
    return NULL;
}

/** \fn igfirm_outflows_adt get_igfirm_outflows_calendar()
 * \brief Get igfirm_outflows_calendar memory variable from current X-machine.
 * \return Value for variable.
 */
igfirm_outflows_adt * get_igfirm_outflows_calendar()
{
	if(current_xmachine->xmachine_IGFirm) return &(*current_xmachine->xmachine_IGFirm).igfirm_outflows_calendar;

    // suppress compiler warning by returning dummy value /
    // this statement should rightfully NEVER be reached /
    return NULL;
}

/** \fn igfirm_inflows_adt get_igfirm_inflows_calendar()
 * \brief Get igfirm_inflows_calendar memory variable from current X-machine.
 * \return Value for variable.
 */
igfirm_inflows_adt * get_igfirm_inflows_calendar()
{
	if(current_xmachine->xmachine_IGFirm) return &(*current_xmachine->xmachine_IGFirm).igfirm_inflows_calendar;

    // suppress compiler warning by returning dummy value /
    // this statement should rightfully NEVER be reached /
    return NULL;
}

/** \fn void set_economy_wide_general_skills_in_firms(double economy_wide_general_skills_in_firms)
 * \brief Set economy_wide_general_skills_in_firms memory variable for current X-machine.
 * \param economy_wide_general_skills_in_firms New value for variable.
 */
void set_economy_wide_general_skills_in_firms(double economy_wide_general_skills_in_firms)
{
	if(current_xmachine->xmachine_IGFirm) (*current_xmachine->xmachine_IGFirm).economy_wide_general_skills_in_firms = economy_wide_general_skills_in_firms;
}

/** \fn double get_economy_wide_general_skills_in_firms()
 * \brief Get economy_wide_general_skills_in_firms memory variable from current X-machine.
 * \return Value for variable.
 */
double get_economy_wide_general_skills_in_firms()
{
	if(current_xmachine->xmachine_IGFirm) return (*current_xmachine->xmachine_IGFirm).economy_wide_general_skills_in_firms;

    // suppress compiler warning by returning dummy value /
    // this statement should rightfully NEVER be reached /
    return (double)0;
}

/** \fn void set_economy_wide_specific_skills_in_firms(double economy_wide_specific_skills_in_firms)
 * \brief Set economy_wide_specific_skills_in_firms memory variable for current X-machine.
 * \param economy_wide_specific_skills_in_firms New value for variable.
 */
void set_economy_wide_specific_skills_in_firms(double economy_wide_specific_skills_in_firms)
{
	if(current_xmachine->xmachine_IGFirm) (*current_xmachine->xmachine_IGFirm).economy_wide_specific_skills_in_firms = economy_wide_specific_skills_in_firms;
}

/** \fn double get_economy_wide_specific_skills_in_firms()
 * \brief Get economy_wide_specific_skills_in_firms memory variable from current X-machine.
 * \return Value for variable.
 */
double get_economy_wide_specific_skills_in_firms()
{
	if(current_xmachine->xmachine_IGFirm) return (*current_xmachine->xmachine_IGFirm).economy_wide_specific_skills_in_firms;

    // suppress compiler warning by returning dummy value /
    // this statement should rightfully NEVER be reached /
    return (double)0;
}

/** \fn void set_switch_datastorage(int switch_datastorage)
 * \brief Set switch_datastorage memory variable for current X-machine.
 * \param switch_datastorage New value for variable.
 */
void set_switch_datastorage(int switch_datastorage)
{
	if(current_xmachine->xmachine_Eurostat) (*current_xmachine->xmachine_Eurostat).switch_datastorage = switch_datastorage;
}

/** \fn int get_switch_datastorage()
 * \brief Get switch_datastorage memory variable from current X-machine.
 * \return Value for variable.
 */
int get_switch_datastorage()
{
	if(current_xmachine->xmachine_Eurostat) return (*current_xmachine->xmachine_Eurostat).switch_datastorage;

    // suppress compiler warning by returning dummy value /
    // this statement should rightfully NEVER be reached /
    return (int)0;
}

/** \fn void set_num_households(int num_households)
 * \brief Set num_households memory variable for current X-machine.
 * \param num_households New value for variable.
 */
void set_num_households(int num_households)
{
	if(current_xmachine->xmachine_Eurostat) (*current_xmachine->xmachine_Eurostat).num_households = num_households;
}

/** \fn int get_num_households()
 * \brief Get num_households memory variable from current X-machine.
 * \return Value for variable.
 */
int get_num_households()
{
	if(current_xmachine->xmachine_Eurostat) return (*current_xmachine->xmachine_Eurostat).num_households;

    // suppress compiler warning by returning dummy value /
    // this statement should rightfully NEVER be reached /
    return (int)0;
}

/** \fn void set_no_households_skill_1(int no_households_skill_1)
 * \brief Set no_households_skill_1 memory variable for current X-machine.
 * \param no_households_skill_1 New value for variable.
 */
void set_no_households_skill_1(int no_households_skill_1)
{
	if(current_xmachine->xmachine_Eurostat) (*current_xmachine->xmachine_Eurostat).no_households_skill_1 = no_households_skill_1;
}

/** \fn int get_no_households_skill_1()
 * \brief Get no_households_skill_1 memory variable from current X-machine.
 * \return Value for variable.
 */
int get_no_households_skill_1()
{
	if(current_xmachine->xmachine_Eurostat) return (*current_xmachine->xmachine_Eurostat).no_households_skill_1;

    // suppress compiler warning by returning dummy value /
    // this statement should rightfully NEVER be reached /
    return (int)0;
}

/** \fn void set_no_households_skill_2(int no_households_skill_2)
 * \brief Set no_households_skill_2 memory variable for current X-machine.
 * \param no_households_skill_2 New value for variable.
 */
void set_no_households_skill_2(int no_households_skill_2)
{
	if(current_xmachine->xmachine_Eurostat) (*current_xmachine->xmachine_Eurostat).no_households_skill_2 = no_households_skill_2;
}

/** \fn int get_no_households_skill_2()
 * \brief Get no_households_skill_2 memory variable from current X-machine.
 * \return Value for variable.
 */
int get_no_households_skill_2()
{
	if(current_xmachine->xmachine_Eurostat) return (*current_xmachine->xmachine_Eurostat).no_households_skill_2;

    // suppress compiler warning by returning dummy value /
    // this statement should rightfully NEVER be reached /
    return (int)0;
}

/** \fn void set_no_households_skill_3(int no_households_skill_3)
 * \brief Set no_households_skill_3 memory variable for current X-machine.
 * \param no_households_skill_3 New value for variable.
 */
void set_no_households_skill_3(int no_households_skill_3)
{
	if(current_xmachine->xmachine_Eurostat) (*current_xmachine->xmachine_Eurostat).no_households_skill_3 = no_households_skill_3;
}

/** \fn int get_no_households_skill_3()
 * \brief Get no_households_skill_3 memory variable from current X-machine.
 * \return Value for variable.
 */
int get_no_households_skill_3()
{
	if(current_xmachine->xmachine_Eurostat) return (*current_xmachine->xmachine_Eurostat).no_households_skill_3;

    // suppress compiler warning by returning dummy value /
    // this statement should rightfully NEVER be reached /
    return (int)0;
}

/** \fn void set_no_households_skill_4(int no_households_skill_4)
 * \brief Set no_households_skill_4 memory variable for current X-machine.
 * \param no_households_skill_4 New value for variable.
 */
void set_no_households_skill_4(int no_households_skill_4)
{
	if(current_xmachine->xmachine_Eurostat) (*current_xmachine->xmachine_Eurostat).no_households_skill_4 = no_households_skill_4;
}

/** \fn int get_no_households_skill_4()
 * \brief Get no_households_skill_4 memory variable from current X-machine.
 * \return Value for variable.
 */
int get_no_households_skill_4()
{
	if(current_xmachine->xmachine_Eurostat) return (*current_xmachine->xmachine_Eurostat).no_households_skill_4;

    // suppress compiler warning by returning dummy value /
    // this statement should rightfully NEVER be reached /
    return (int)0;
}

/** \fn void set_no_households_skill_5(int no_households_skill_5)
 * \brief Set no_households_skill_5 memory variable for current X-machine.
 * \param no_households_skill_5 New value for variable.
 */
void set_no_households_skill_5(int no_households_skill_5)
{
	if(current_xmachine->xmachine_Eurostat) (*current_xmachine->xmachine_Eurostat).no_households_skill_5 = no_households_skill_5;
}

/** \fn int get_no_households_skill_5()
 * \brief Get no_households_skill_5 memory variable from current X-machine.
 * \return Value for variable.
 */
int get_no_households_skill_5()
{
	if(current_xmachine->xmachine_Eurostat) return (*current_xmachine->xmachine_Eurostat).no_households_skill_5;

    // suppress compiler warning by returning dummy value /
    // this statement should rightfully NEVER be reached /
    return (int)0;
}

/** \fn void set_employed(int employed)
 * \brief Set employed memory variable for current X-machine.
 * \param employed New value for variable.
 */
void set_employed(int employed)
{
	if(current_xmachine->xmachine_Eurostat) (*current_xmachine->xmachine_Eurostat).employed = employed;
}

/** \fn int get_employed()
 * \brief Get employed memory variable from current X-machine.
 * \return Value for variable.
 */
int get_employed()
{
	if(current_xmachine->xmachine_Eurostat) return (*current_xmachine->xmachine_Eurostat).employed;

    // suppress compiler warning by returning dummy value /
    // this statement should rightfully NEVER be reached /
    return (int)0;
}

/** \fn void set_employed_skill_1(int employed_skill_1)
 * \brief Set employed_skill_1 memory variable for current X-machine.
 * \param employed_skill_1 New value for variable.
 */
void set_employed_skill_1(int employed_skill_1)
{
	if(current_xmachine->xmachine_Eurostat) (*current_xmachine->xmachine_Eurostat).employed_skill_1 = employed_skill_1;
}

/** \fn int get_employed_skill_1()
 * \brief Get employed_skill_1 memory variable from current X-machine.
 * \return Value for variable.
 */
int get_employed_skill_1()
{
	if(current_xmachine->xmachine_Eurostat) return (*current_xmachine->xmachine_Eurostat).employed_skill_1;

    // suppress compiler warning by returning dummy value /
    // this statement should rightfully NEVER be reached /
    return (int)0;
}

/** \fn void set_employed_skill_2(int employed_skill_2)
 * \brief Set employed_skill_2 memory variable for current X-machine.
 * \param employed_skill_2 New value for variable.
 */
void set_employed_skill_2(int employed_skill_2)
{
	if(current_xmachine->xmachine_Eurostat) (*current_xmachine->xmachine_Eurostat).employed_skill_2 = employed_skill_2;
}

/** \fn int get_employed_skill_2()
 * \brief Get employed_skill_2 memory variable from current X-machine.
 * \return Value for variable.
 */
int get_employed_skill_2()
{
	if(current_xmachine->xmachine_Eurostat) return (*current_xmachine->xmachine_Eurostat).employed_skill_2;

    // suppress compiler warning by returning dummy value /
    // this statement should rightfully NEVER be reached /
    return (int)0;
}

/** \fn void set_employed_skill_3(int employed_skill_3)
 * \brief Set employed_skill_3 memory variable for current X-machine.
 * \param employed_skill_3 New value for variable.
 */
void set_employed_skill_3(int employed_skill_3)
{
	if(current_xmachine->xmachine_Eurostat) (*current_xmachine->xmachine_Eurostat).employed_skill_3 = employed_skill_3;
}

/** \fn int get_employed_skill_3()
 * \brief Get employed_skill_3 memory variable from current X-machine.
 * \return Value for variable.
 */
int get_employed_skill_3()
{
	if(current_xmachine->xmachine_Eurostat) return (*current_xmachine->xmachine_Eurostat).employed_skill_3;

    // suppress compiler warning by returning dummy value /
    // this statement should rightfully NEVER be reached /
    return (int)0;
}

/** \fn void set_employed_skill_4(int employed_skill_4)
 * \brief Set employed_skill_4 memory variable for current X-machine.
 * \param employed_skill_4 New value for variable.
 */
void set_employed_skill_4(int employed_skill_4)
{
	if(current_xmachine->xmachine_Eurostat) (*current_xmachine->xmachine_Eurostat).employed_skill_4 = employed_skill_4;
}

/** \fn int get_employed_skill_4()
 * \brief Get employed_skill_4 memory variable from current X-machine.
 * \return Value for variable.
 */
int get_employed_skill_4()
{
	if(current_xmachine->xmachine_Eurostat) return (*current_xmachine->xmachine_Eurostat).employed_skill_4;

    // suppress compiler warning by returning dummy value /
    // this statement should rightfully NEVER be reached /
    return (int)0;
}

/** \fn void set_employed_skill_5(int employed_skill_5)
 * \brief Set employed_skill_5 memory variable for current X-machine.
 * \param employed_skill_5 New value for variable.
 */
void set_employed_skill_5(int employed_skill_5)
{
	if(current_xmachine->xmachine_Eurostat) (*current_xmachine->xmachine_Eurostat).employed_skill_5 = employed_skill_5;
}

/** \fn int get_employed_skill_5()
 * \brief Get employed_skill_5 memory variable from current X-machine.
 * \return Value for variable.
 */
int get_employed_skill_5()
{
	if(current_xmachine->xmachine_Eurostat) return (*current_xmachine->xmachine_Eurostat).employed_skill_5;

    // suppress compiler warning by returning dummy value /
    // this statement should rightfully NEVER be reached /
    return (int)0;
}

/** \fn void set_average_unit_labor_costs_reg_1(double average_unit_labor_costs_reg_1)
 * \brief Set average_unit_labor_costs_reg_1 memory variable for current X-machine.
 * \param average_unit_labor_costs_reg_1 New value for variable.
 */
void set_average_unit_labor_costs_reg_1(double average_unit_labor_costs_reg_1)
{
	if(current_xmachine->xmachine_Eurostat) (*current_xmachine->xmachine_Eurostat).average_unit_labor_costs_reg_1 = average_unit_labor_costs_reg_1;
}

/** \fn double get_average_unit_labor_costs_reg_1()
 * \brief Get average_unit_labor_costs_reg_1 memory variable from current X-machine.
 * \return Value for variable.
 */
double get_average_unit_labor_costs_reg_1()
{
	if(current_xmachine->xmachine_Eurostat) return (*current_xmachine->xmachine_Eurostat).average_unit_labor_costs_reg_1;

    // suppress compiler warning by returning dummy value /
    // this statement should rightfully NEVER be reached /
    return (double)0;
}

/** \fn void set_average_unit_labor_costs_reg_2(double average_unit_labor_costs_reg_2)
 * \brief Set average_unit_labor_costs_reg_2 memory variable for current X-machine.
 * \param average_unit_labor_costs_reg_2 New value for variable.
 */
void set_average_unit_labor_costs_reg_2(double average_unit_labor_costs_reg_2)
{
	if(current_xmachine->xmachine_Eurostat) (*current_xmachine->xmachine_Eurostat).average_unit_labor_costs_reg_2 = average_unit_labor_costs_reg_2;
}

/** \fn double get_average_unit_labor_costs_reg_2()
 * \brief Get average_unit_labor_costs_reg_2 memory variable from current X-machine.
 * \return Value for variable.
 */
double get_average_unit_labor_costs_reg_2()
{
	if(current_xmachine->xmachine_Eurostat) return (*current_xmachine->xmachine_Eurostat).average_unit_labor_costs_reg_2;

    // suppress compiler warning by returning dummy value /
    // this statement should rightfully NEVER be reached /
    return (double)0;
}

/** \fn void set_unemployed(int unemployed)
 * \brief Set unemployed memory variable for current X-machine.
 * \param unemployed New value for variable.
 */
void set_unemployed(int unemployed)
{
	if(current_xmachine->xmachine_Eurostat) (*current_xmachine->xmachine_Eurostat).unemployed = unemployed;
}

/** \fn int get_unemployed()
 * \brief Get unemployed memory variable from current X-machine.
 * \return Value for variable.
 */
int get_unemployed()
{
	if(current_xmachine->xmachine_Eurostat) return (*current_xmachine->xmachine_Eurostat).unemployed;

    // suppress compiler warning by returning dummy value /
    // this statement should rightfully NEVER be reached /
    return (int)0;
}

/** \fn void set_unemployment_rate(double unemployment_rate)
 * \brief Set unemployment_rate memory variable for current X-machine.
 * \param unemployment_rate New value for variable.
 */
void set_unemployment_rate(double unemployment_rate)
{
	if(current_xmachine->xmachine_Eurostat) (*current_xmachine->xmachine_Eurostat).unemployment_rate = unemployment_rate;
	if(current_xmachine->xmachine_Government) (*current_xmachine->xmachine_Government).unemployment_rate = unemployment_rate;
}

/** \fn double get_unemployment_rate()
 * \brief Get unemployment_rate memory variable from current X-machine.
 * \return Value for variable.
 */
double get_unemployment_rate()
{
	if(current_xmachine->xmachine_Eurostat) return (*current_xmachine->xmachine_Eurostat).unemployment_rate;
	if(current_xmachine->xmachine_Government) return (*current_xmachine->xmachine_Government).unemployment_rate;

    // suppress compiler warning by returning dummy value /
    // this statement should rightfully NEVER be reached /
    return (double)0;
}

/** \fn void set_employment_rate(double employment_rate)
 * \brief Set employment_rate memory variable for current X-machine.
 * \param employment_rate New value for variable.
 */
void set_employment_rate(double employment_rate)
{
	if(current_xmachine->xmachine_Eurostat) (*current_xmachine->xmachine_Eurostat).employment_rate = employment_rate;
}

/** \fn double get_employment_rate()
 * \brief Get employment_rate memory variable from current X-machine.
 * \return Value for variable.
 */
double get_employment_rate()
{
	if(current_xmachine->xmachine_Eurostat) return (*current_xmachine->xmachine_Eurostat).employment_rate;

    // suppress compiler warning by returning dummy value /
    // this statement should rightfully NEVER be reached /
    return (double)0;
}

/** \fn void set_unemployment_rate_skill_1(double unemployment_rate_skill_1)
 * \brief Set unemployment_rate_skill_1 memory variable for current X-machine.
 * \param unemployment_rate_skill_1 New value for variable.
 */
void set_unemployment_rate_skill_1(double unemployment_rate_skill_1)
{
	if(current_xmachine->xmachine_Eurostat) (*current_xmachine->xmachine_Eurostat).unemployment_rate_skill_1 = unemployment_rate_skill_1;
}

/** \fn double get_unemployment_rate_skill_1()
 * \brief Get unemployment_rate_skill_1 memory variable from current X-machine.
 * \return Value for variable.
 */
double get_unemployment_rate_skill_1()
{
	if(current_xmachine->xmachine_Eurostat) return (*current_xmachine->xmachine_Eurostat).unemployment_rate_skill_1;

    // suppress compiler warning by returning dummy value /
    // this statement should rightfully NEVER be reached /
    return (double)0;
}

/** \fn void set_unemployment_rate_skill_2(double unemployment_rate_skill_2)
 * \brief Set unemployment_rate_skill_2 memory variable for current X-machine.
 * \param unemployment_rate_skill_2 New value for variable.
 */
void set_unemployment_rate_skill_2(double unemployment_rate_skill_2)
{
	if(current_xmachine->xmachine_Eurostat) (*current_xmachine->xmachine_Eurostat).unemployment_rate_skill_2 = unemployment_rate_skill_2;
}

/** \fn double get_unemployment_rate_skill_2()
 * \brief Get unemployment_rate_skill_2 memory variable from current X-machine.
 * \return Value for variable.
 */
double get_unemployment_rate_skill_2()
{
	if(current_xmachine->xmachine_Eurostat) return (*current_xmachine->xmachine_Eurostat).unemployment_rate_skill_2;

    // suppress compiler warning by returning dummy value /
    // this statement should rightfully NEVER be reached /
    return (double)0;
}

/** \fn void set_unemployment_rate_skill_3(double unemployment_rate_skill_3)
 * \brief Set unemployment_rate_skill_3 memory variable for current X-machine.
 * \param unemployment_rate_skill_3 New value for variable.
 */
void set_unemployment_rate_skill_3(double unemployment_rate_skill_3)
{
	if(current_xmachine->xmachine_Eurostat) (*current_xmachine->xmachine_Eurostat).unemployment_rate_skill_3 = unemployment_rate_skill_3;
}

/** \fn double get_unemployment_rate_skill_3()
 * \brief Get unemployment_rate_skill_3 memory variable from current X-machine.
 * \return Value for variable.
 */
double get_unemployment_rate_skill_3()
{
	if(current_xmachine->xmachine_Eurostat) return (*current_xmachine->xmachine_Eurostat).unemployment_rate_skill_3;

    // suppress compiler warning by returning dummy value /
    // this statement should rightfully NEVER be reached /
    return (double)0;
}

/** \fn void set_unemployment_rate_skill_4(double unemployment_rate_skill_4)
 * \brief Set unemployment_rate_skill_4 memory variable for current X-machine.
 * \param unemployment_rate_skill_4 New value for variable.
 */
void set_unemployment_rate_skill_4(double unemployment_rate_skill_4)
{
	if(current_xmachine->xmachine_Eurostat) (*current_xmachine->xmachine_Eurostat).unemployment_rate_skill_4 = unemployment_rate_skill_4;
}

/** \fn double get_unemployment_rate_skill_4()
 * \brief Get unemployment_rate_skill_4 memory variable from current X-machine.
 * \return Value for variable.
 */
double get_unemployment_rate_skill_4()
{
	if(current_xmachine->xmachine_Eurostat) return (*current_xmachine->xmachine_Eurostat).unemployment_rate_skill_4;

    // suppress compiler warning by returning dummy value /
    // this statement should rightfully NEVER be reached /
    return (double)0;
}

/** \fn void set_unemployment_rate_skill_5(double unemployment_rate_skill_5)
 * \brief Set unemployment_rate_skill_5 memory variable for current X-machine.
 * \param unemployment_rate_skill_5 New value for variable.
 */
void set_unemployment_rate_skill_5(double unemployment_rate_skill_5)
{
	if(current_xmachine->xmachine_Eurostat) (*current_xmachine->xmachine_Eurostat).unemployment_rate_skill_5 = unemployment_rate_skill_5;
}

/** \fn double get_unemployment_rate_skill_5()
 * \brief Get unemployment_rate_skill_5 memory variable from current X-machine.
 * \return Value for variable.
 */
double get_unemployment_rate_skill_5()
{
	if(current_xmachine->xmachine_Eurostat) return (*current_xmachine->xmachine_Eurostat).unemployment_rate_skill_5;

    // suppress compiler warning by returning dummy value /
    // this statement should rightfully NEVER be reached /
    return (double)0;
}

/** \fn void set_unemployed_reg1(int unemployed_reg1)
 * \brief Set unemployed_reg1 memory variable for current X-machine.
 * \param unemployed_reg1 New value for variable.
 */
void set_unemployed_reg1(int unemployed_reg1)
{
	if(current_xmachine->xmachine_Eurostat) (*current_xmachine->xmachine_Eurostat).unemployed_reg1 = unemployed_reg1;
}

/** \fn int get_unemployed_reg1()
 * \brief Get unemployed_reg1 memory variable from current X-machine.
 * \return Value for variable.
 */
int get_unemployed_reg1()
{
	if(current_xmachine->xmachine_Eurostat) return (*current_xmachine->xmachine_Eurostat).unemployed_reg1;

    // suppress compiler warning by returning dummy value /
    // this statement should rightfully NEVER be reached /
    return (int)0;
}

/** \fn void set_unemployed_reg2(int unemployed_reg2)
 * \brief Set unemployed_reg2 memory variable for current X-machine.
 * \param unemployed_reg2 New value for variable.
 */
void set_unemployed_reg2(int unemployed_reg2)
{
	if(current_xmachine->xmachine_Eurostat) (*current_xmachine->xmachine_Eurostat).unemployed_reg2 = unemployed_reg2;
}

/** \fn int get_unemployed_reg2()
 * \brief Get unemployed_reg2 memory variable from current X-machine.
 * \return Value for variable.
 */
int get_unemployed_reg2()
{
	if(current_xmachine->xmachine_Eurostat) return (*current_xmachine->xmachine_Eurostat).unemployed_reg2;

    // suppress compiler warning by returning dummy value /
    // this statement should rightfully NEVER be reached /
    return (int)0;
}

/** \fn void set_unemployment_rate_reg1(double unemployment_rate_reg1)
 * \brief Set unemployment_rate_reg1 memory variable for current X-machine.
 * \param unemployment_rate_reg1 New value for variable.
 */
void set_unemployment_rate_reg1(double unemployment_rate_reg1)
{
	if(current_xmachine->xmachine_Eurostat) (*current_xmachine->xmachine_Eurostat).unemployment_rate_reg1 = unemployment_rate_reg1;
}

/** \fn double get_unemployment_rate_reg1()
 * \brief Get unemployment_rate_reg1 memory variable from current X-machine.
 * \return Value for variable.
 */
double get_unemployment_rate_reg1()
{
	if(current_xmachine->xmachine_Eurostat) return (*current_xmachine->xmachine_Eurostat).unemployment_rate_reg1;

    // suppress compiler warning by returning dummy value /
    // this statement should rightfully NEVER be reached /
    return (double)0;
}

/** \fn void set_unemployment_rate_reg2(double unemployment_rate_reg2)
 * \brief Set unemployment_rate_reg2 memory variable for current X-machine.
 * \param unemployment_rate_reg2 New value for variable.
 */
void set_unemployment_rate_reg2(double unemployment_rate_reg2)
{
	if(current_xmachine->xmachine_Eurostat) (*current_xmachine->xmachine_Eurostat).unemployment_rate_reg2 = unemployment_rate_reg2;
}

/** \fn double get_unemployment_rate_reg2()
 * \brief Get unemployment_rate_reg2 memory variable from current X-machine.
 * \return Value for variable.
 */
double get_unemployment_rate_reg2()
{
	if(current_xmachine->xmachine_Eurostat) return (*current_xmachine->xmachine_Eurostat).unemployment_rate_reg2;

    // suppress compiler warning by returning dummy value /
    // this statement should rightfully NEVER be reached /
    return (double)0;
}

/** \fn void set_v_u_ratio_reg1(double v_u_ratio_reg1)
 * \brief Set v_u_ratio_reg1 memory variable for current X-machine.
 * \param v_u_ratio_reg1 New value for variable.
 */
void set_v_u_ratio_reg1(double v_u_ratio_reg1)
{
	if(current_xmachine->xmachine_Eurostat) (*current_xmachine->xmachine_Eurostat).v_u_ratio_reg1 = v_u_ratio_reg1;
}

/** \fn double get_v_u_ratio_reg1()
 * \brief Get v_u_ratio_reg1 memory variable from current X-machine.
 * \return Value for variable.
 */
double get_v_u_ratio_reg1()
{
	if(current_xmachine->xmachine_Eurostat) return (*current_xmachine->xmachine_Eurostat).v_u_ratio_reg1;

    // suppress compiler warning by returning dummy value /
    // this statement should rightfully NEVER be reached /
    return (double)0;
}

/** \fn void set_v_u_ratio_reg2(double v_u_ratio_reg2)
 * \brief Set v_u_ratio_reg2 memory variable for current X-machine.
 * \param v_u_ratio_reg2 New value for variable.
 */
void set_v_u_ratio_reg2(double v_u_ratio_reg2)
{
	if(current_xmachine->xmachine_Eurostat) (*current_xmachine->xmachine_Eurostat).v_u_ratio_reg2 = v_u_ratio_reg2;
}

/** \fn double get_v_u_ratio_reg2()
 * \brief Get v_u_ratio_reg2 memory variable from current X-machine.
 * \return Value for variable.
 */
double get_v_u_ratio_reg2()
{
	if(current_xmachine->xmachine_Eurostat) return (*current_xmachine->xmachine_Eurostat).v_u_ratio_reg2;

    // suppress compiler warning by returning dummy value /
    // this statement should rightfully NEVER be reached /
    return (double)0;
}

/** \fn void set_average_wage(double average_wage)
 * \brief Set average_wage memory variable for current X-machine.
 * \param average_wage New value for variable.
 */
void set_average_wage(double average_wage)
{
	if(current_xmachine->xmachine_Eurostat) (*current_xmachine->xmachine_Eurostat).average_wage = average_wage;
}

/** \fn double get_average_wage()
 * \brief Get average_wage memory variable from current X-machine.
 * \return Value for variable.
 */
double get_average_wage()
{
	if(current_xmachine->xmachine_Eurostat) return (*current_xmachine->xmachine_Eurostat).average_wage;

    // suppress compiler warning by returning dummy value /
    // this statement should rightfully NEVER be reached /
    return (double)0;
}

/** \fn void set_average_wage_reservation(double average_wage_reservation)
 * \brief Set average_wage_reservation memory variable for current X-machine.
 * \param average_wage_reservation New value for variable.
 */
void set_average_wage_reservation(double average_wage_reservation)
{
	if(current_xmachine->xmachine_Eurostat) (*current_xmachine->xmachine_Eurostat).average_wage_reservation = average_wage_reservation;
}

/** \fn double get_average_wage_reservation()
 * \brief Get average_wage_reservation memory variable from current X-machine.
 * \return Value for variable.
 */
double get_average_wage_reservation()
{
	if(current_xmachine->xmachine_Eurostat) return (*current_xmachine->xmachine_Eurostat).average_wage_reservation;

    // suppress compiler warning by returning dummy value /
    // this statement should rightfully NEVER be reached /
    return (double)0;
}

/** \fn void set_average_wage_reservation_region_1(double average_wage_reservation_region_1)
 * \brief Set average_wage_reservation_region_1 memory variable for current X-machine.
 * \param average_wage_reservation_region_1 New value for variable.
 */
void set_average_wage_reservation_region_1(double average_wage_reservation_region_1)
{
	if(current_xmachine->xmachine_Eurostat) (*current_xmachine->xmachine_Eurostat).average_wage_reservation_region_1 = average_wage_reservation_region_1;
}

/** \fn double get_average_wage_reservation_region_1()
 * \brief Get average_wage_reservation_region_1 memory variable from current X-machine.
 * \return Value for variable.
 */
double get_average_wage_reservation_region_1()
{
	if(current_xmachine->xmachine_Eurostat) return (*current_xmachine->xmachine_Eurostat).average_wage_reservation_region_1;

    // suppress compiler warning by returning dummy value /
    // this statement should rightfully NEVER be reached /
    return (double)0;
}

/** \fn void set_average_wage_reservation_region_2(double average_wage_reservation_region_2)
 * \brief Set average_wage_reservation_region_2 memory variable for current X-machine.
 * \param average_wage_reservation_region_2 New value for variable.
 */
void set_average_wage_reservation_region_2(double average_wage_reservation_region_2)
{
	if(current_xmachine->xmachine_Eurostat) (*current_xmachine->xmachine_Eurostat).average_wage_reservation_region_2 = average_wage_reservation_region_2;
}

/** \fn double get_average_wage_reservation_region_2()
 * \brief Get average_wage_reservation_region_2 memory variable from current X-machine.
 * \return Value for variable.
 */
double get_average_wage_reservation_region_2()
{
	if(current_xmachine->xmachine_Eurostat) return (*current_xmachine->xmachine_Eurostat).average_wage_reservation_region_2;

    // suppress compiler warning by returning dummy value /
    // this statement should rightfully NEVER be reached /
    return (double)0;
}

/** \fn void set_average_wage_skill_1(double average_wage_skill_1)
 * \brief Set average_wage_skill_1 memory variable for current X-machine.
 * \param average_wage_skill_1 New value for variable.
 */
void set_average_wage_skill_1(double average_wage_skill_1)
{
	if(current_xmachine->xmachine_Eurostat) (*current_xmachine->xmachine_Eurostat).average_wage_skill_1 = average_wage_skill_1;
}

/** \fn double get_average_wage_skill_1()
 * \brief Get average_wage_skill_1 memory variable from current X-machine.
 * \return Value for variable.
 */
double get_average_wage_skill_1()
{
	if(current_xmachine->xmachine_Eurostat) return (*current_xmachine->xmachine_Eurostat).average_wage_skill_1;

    // suppress compiler warning by returning dummy value /
    // this statement should rightfully NEVER be reached /
    return (double)0;
}

/** \fn void set_average_wage_skill_2(double average_wage_skill_2)
 * \brief Set average_wage_skill_2 memory variable for current X-machine.
 * \param average_wage_skill_2 New value for variable.
 */
void set_average_wage_skill_2(double average_wage_skill_2)
{
	if(current_xmachine->xmachine_Eurostat) (*current_xmachine->xmachine_Eurostat).average_wage_skill_2 = average_wage_skill_2;
}

/** \fn double get_average_wage_skill_2()
 * \brief Get average_wage_skill_2 memory variable from current X-machine.
 * \return Value for variable.
 */
double get_average_wage_skill_2()
{
	if(current_xmachine->xmachine_Eurostat) return (*current_xmachine->xmachine_Eurostat).average_wage_skill_2;

    // suppress compiler warning by returning dummy value /
    // this statement should rightfully NEVER be reached /
    return (double)0;
}

/** \fn void set_average_wage_skill_3(double average_wage_skill_3)
 * \brief Set average_wage_skill_3 memory variable for current X-machine.
 * \param average_wage_skill_3 New value for variable.
 */
void set_average_wage_skill_3(double average_wage_skill_3)
{
	if(current_xmachine->xmachine_Eurostat) (*current_xmachine->xmachine_Eurostat).average_wage_skill_3 = average_wage_skill_3;
}

/** \fn double get_average_wage_skill_3()
 * \brief Get average_wage_skill_3 memory variable from current X-machine.
 * \return Value for variable.
 */
double get_average_wage_skill_3()
{
	if(current_xmachine->xmachine_Eurostat) return (*current_xmachine->xmachine_Eurostat).average_wage_skill_3;

    // suppress compiler warning by returning dummy value /
    // this statement should rightfully NEVER be reached /
    return (double)0;
}

/** \fn void set_average_wage_skill_4(double average_wage_skill_4)
 * \brief Set average_wage_skill_4 memory variable for current X-machine.
 * \param average_wage_skill_4 New value for variable.
 */
void set_average_wage_skill_4(double average_wage_skill_4)
{
	if(current_xmachine->xmachine_Eurostat) (*current_xmachine->xmachine_Eurostat).average_wage_skill_4 = average_wage_skill_4;
}

/** \fn double get_average_wage_skill_4()
 * \brief Get average_wage_skill_4 memory variable from current X-machine.
 * \return Value for variable.
 */
double get_average_wage_skill_4()
{
	if(current_xmachine->xmachine_Eurostat) return (*current_xmachine->xmachine_Eurostat).average_wage_skill_4;

    // suppress compiler warning by returning dummy value /
    // this statement should rightfully NEVER be reached /
    return (double)0;
}

/** \fn void set_average_wage_skill_5(double average_wage_skill_5)
 * \brief Set average_wage_skill_5 memory variable for current X-machine.
 * \param average_wage_skill_5 New value for variable.
 */
void set_average_wage_skill_5(double average_wage_skill_5)
{
	if(current_xmachine->xmachine_Eurostat) (*current_xmachine->xmachine_Eurostat).average_wage_skill_5 = average_wage_skill_5;
}

/** \fn double get_average_wage_skill_5()
 * \brief Get average_wage_skill_5 memory variable from current X-machine.
 * \return Value for variable.
 */
double get_average_wage_skill_5()
{
	if(current_xmachine->xmachine_Eurostat) return (*current_xmachine->xmachine_Eurostat).average_wage_skill_5;

    // suppress compiler warning by returning dummy value /
    // this statement should rightfully NEVER be reached /
    return (double)0;
}

/** \fn void set_sd_wage(double sd_wage)
 * \brief Set sd_wage memory variable for current X-machine.
 * \param sd_wage New value for variable.
 */
void set_sd_wage(double sd_wage)
{
	if(current_xmachine->xmachine_Eurostat) (*current_xmachine->xmachine_Eurostat).sd_wage = sd_wage;
}

/** \fn double get_sd_wage()
 * \brief Get sd_wage memory variable from current X-machine.
 * \return Value for variable.
 */
double get_sd_wage()
{
	if(current_xmachine->xmachine_Eurostat) return (*current_xmachine->xmachine_Eurostat).sd_wage;

    // suppress compiler warning by returning dummy value /
    // this statement should rightfully NEVER be reached /
    return (double)0;
}

/** \fn void set_sd_income(double sd_income)
 * \brief Set sd_income memory variable for current X-machine.
 * \param sd_income New value for variable.
 */
void set_sd_income(double sd_income)
{
	if(current_xmachine->xmachine_Eurostat) (*current_xmachine->xmachine_Eurostat).sd_income = sd_income;
}

/** \fn double get_sd_income()
 * \brief Get sd_income memory variable from current X-machine.
 * \return Value for variable.
 */
double get_sd_income()
{
	if(current_xmachine->xmachine_Eurostat) return (*current_xmachine->xmachine_Eurostat).sd_income;

    // suppress compiler warning by returning dummy value /
    // this statement should rightfully NEVER be reached /
    return (double)0;
}

/** \fn void set_sd_wealth(double sd_wealth)
 * \brief Set sd_wealth memory variable for current X-machine.
 * \param sd_wealth New value for variable.
 */
void set_sd_wealth(double sd_wealth)
{
	if(current_xmachine->xmachine_Eurostat) (*current_xmachine->xmachine_Eurostat).sd_wealth = sd_wealth;
}

/** \fn double get_sd_wealth()
 * \brief Get sd_wealth memory variable from current X-machine.
 * \return Value for variable.
 */
double get_sd_wealth()
{
	if(current_xmachine->xmachine_Eurostat) return (*current_xmachine->xmachine_Eurostat).sd_wealth;

    // suppress compiler warning by returning dummy value /
    // this statement should rightfully NEVER be reached /
    return (double)0;
}

/** \fn void set_sd_specific_skills(double sd_specific_skills)
 * \brief Set sd_specific_skills memory variable for current X-machine.
 * \param sd_specific_skills New value for variable.
 */
void set_sd_specific_skills(double sd_specific_skills)
{
	if(current_xmachine->xmachine_Eurostat) (*current_xmachine->xmachine_Eurostat).sd_specific_skills = sd_specific_skills;
}

/** \fn double get_sd_specific_skills()
 * \brief Get sd_specific_skills memory variable from current X-machine.
 * \return Value for variable.
 */
double get_sd_specific_skills()
{
	if(current_xmachine->xmachine_Eurostat) return (*current_xmachine->xmachine_Eurostat).sd_specific_skills;

    // suppress compiler warning by returning dummy value /
    // this statement should rightfully NEVER be reached /
    return (double)0;
}

/** \fn void set_sd_wage_reg_1(double sd_wage_reg_1)
 * \brief Set sd_wage_reg_1 memory variable for current X-machine.
 * \param sd_wage_reg_1 New value for variable.
 */
void set_sd_wage_reg_1(double sd_wage_reg_1)
{
	if(current_xmachine->xmachine_Eurostat) (*current_xmachine->xmachine_Eurostat).sd_wage_reg_1 = sd_wage_reg_1;
}

/** \fn double get_sd_wage_reg_1()
 * \brief Get sd_wage_reg_1 memory variable from current X-machine.
 * \return Value for variable.
 */
double get_sd_wage_reg_1()
{
	if(current_xmachine->xmachine_Eurostat) return (*current_xmachine->xmachine_Eurostat).sd_wage_reg_1;

    // suppress compiler warning by returning dummy value /
    // this statement should rightfully NEVER be reached /
    return (double)0;
}

/** \fn void set_sd_income_reg_1(double sd_income_reg_1)
 * \brief Set sd_income_reg_1 memory variable for current X-machine.
 * \param sd_income_reg_1 New value for variable.
 */
void set_sd_income_reg_1(double sd_income_reg_1)
{
	if(current_xmachine->xmachine_Eurostat) (*current_xmachine->xmachine_Eurostat).sd_income_reg_1 = sd_income_reg_1;
}

/** \fn double get_sd_income_reg_1()
 * \brief Get sd_income_reg_1 memory variable from current X-machine.
 * \return Value for variable.
 */
double get_sd_income_reg_1()
{
	if(current_xmachine->xmachine_Eurostat) return (*current_xmachine->xmachine_Eurostat).sd_income_reg_1;

    // suppress compiler warning by returning dummy value /
    // this statement should rightfully NEVER be reached /
    return (double)0;
}

/** \fn void set_sd_wealth_reg_1(double sd_wealth_reg_1)
 * \brief Set sd_wealth_reg_1 memory variable for current X-machine.
 * \param sd_wealth_reg_1 New value for variable.
 */
void set_sd_wealth_reg_1(double sd_wealth_reg_1)
{
	if(current_xmachine->xmachine_Eurostat) (*current_xmachine->xmachine_Eurostat).sd_wealth_reg_1 = sd_wealth_reg_1;
}

/** \fn double get_sd_wealth_reg_1()
 * \brief Get sd_wealth_reg_1 memory variable from current X-machine.
 * \return Value for variable.
 */
double get_sd_wealth_reg_1()
{
	if(current_xmachine->xmachine_Eurostat) return (*current_xmachine->xmachine_Eurostat).sd_wealth_reg_1;

    // suppress compiler warning by returning dummy value /
    // this statement should rightfully NEVER be reached /
    return (double)0;
}

/** \fn void set_sd_specific_skills_reg_1(double sd_specific_skills_reg_1)
 * \brief Set sd_specific_skills_reg_1 memory variable for current X-machine.
 * \param sd_specific_skills_reg_1 New value for variable.
 */
void set_sd_specific_skills_reg_1(double sd_specific_skills_reg_1)
{
	if(current_xmachine->xmachine_Eurostat) (*current_xmachine->xmachine_Eurostat).sd_specific_skills_reg_1 = sd_specific_skills_reg_1;
}

/** \fn double get_sd_specific_skills_reg_1()
 * \brief Get sd_specific_skills_reg_1 memory variable from current X-machine.
 * \return Value for variable.
 */
double get_sd_specific_skills_reg_1()
{
	if(current_xmachine->xmachine_Eurostat) return (*current_xmachine->xmachine_Eurostat).sd_specific_skills_reg_1;

    // suppress compiler warning by returning dummy value /
    // this statement should rightfully NEVER be reached /
    return (double)0;
}

/** \fn void set_sd_wage_reg_2(double sd_wage_reg_2)
 * \brief Set sd_wage_reg_2 memory variable for current X-machine.
 * \param sd_wage_reg_2 New value for variable.
 */
void set_sd_wage_reg_2(double sd_wage_reg_2)
{
	if(current_xmachine->xmachine_Eurostat) (*current_xmachine->xmachine_Eurostat).sd_wage_reg_2 = sd_wage_reg_2;
}

/** \fn double get_sd_wage_reg_2()
 * \brief Get sd_wage_reg_2 memory variable from current X-machine.
 * \return Value for variable.
 */
double get_sd_wage_reg_2()
{
	if(current_xmachine->xmachine_Eurostat) return (*current_xmachine->xmachine_Eurostat).sd_wage_reg_2;

    // suppress compiler warning by returning dummy value /
    // this statement should rightfully NEVER be reached /
    return (double)0;
}

/** \fn void set_sd_income_reg_2(double sd_income_reg_2)
 * \brief Set sd_income_reg_2 memory variable for current X-machine.
 * \param sd_income_reg_2 New value for variable.
 */
void set_sd_income_reg_2(double sd_income_reg_2)
{
	if(current_xmachine->xmachine_Eurostat) (*current_xmachine->xmachine_Eurostat).sd_income_reg_2 = sd_income_reg_2;
}

/** \fn double get_sd_income_reg_2()
 * \brief Get sd_income_reg_2 memory variable from current X-machine.
 * \return Value for variable.
 */
double get_sd_income_reg_2()
{
	if(current_xmachine->xmachine_Eurostat) return (*current_xmachine->xmachine_Eurostat).sd_income_reg_2;

    // suppress compiler warning by returning dummy value /
    // this statement should rightfully NEVER be reached /
    return (double)0;
}

/** \fn void set_sd_wealth_reg_2(double sd_wealth_reg_2)
 * \brief Set sd_wealth_reg_2 memory variable for current X-machine.
 * \param sd_wealth_reg_2 New value for variable.
 */
void set_sd_wealth_reg_2(double sd_wealth_reg_2)
{
	if(current_xmachine->xmachine_Eurostat) (*current_xmachine->xmachine_Eurostat).sd_wealth_reg_2 = sd_wealth_reg_2;
}

/** \fn double get_sd_wealth_reg_2()
 * \brief Get sd_wealth_reg_2 memory variable from current X-machine.
 * \return Value for variable.
 */
double get_sd_wealth_reg_2()
{
	if(current_xmachine->xmachine_Eurostat) return (*current_xmachine->xmachine_Eurostat).sd_wealth_reg_2;

    // suppress compiler warning by returning dummy value /
    // this statement should rightfully NEVER be reached /
    return (double)0;
}

/** \fn void set_sd_specific_skills_reg_2(double sd_specific_skills_reg_2)
 * \brief Set sd_specific_skills_reg_2 memory variable for current X-machine.
 * \param sd_specific_skills_reg_2 New value for variable.
 */
void set_sd_specific_skills_reg_2(double sd_specific_skills_reg_2)
{
	if(current_xmachine->xmachine_Eurostat) (*current_xmachine->xmachine_Eurostat).sd_specific_skills_reg_2 = sd_specific_skills_reg_2;
}

/** \fn double get_sd_specific_skills_reg_2()
 * \brief Get sd_specific_skills_reg_2 memory variable from current X-machine.
 * \return Value for variable.
 */
double get_sd_specific_skills_reg_2()
{
	if(current_xmachine->xmachine_Eurostat) return (*current_xmachine->xmachine_Eurostat).sd_specific_skills_reg_2;

    // suppress compiler warning by returning dummy value /
    // this statement should rightfully NEVER be reached /
    return (double)0;
}

/** \fn void set_total_output_reg_2(double total_output_reg_2)
 * \brief Set total_output_reg_2 memory variable for current X-machine.
 * \param total_output_reg_2 New value for variable.
 */
void set_total_output_reg_2(double total_output_reg_2)
{
	if(current_xmachine->xmachine_Eurostat) (*current_xmachine->xmachine_Eurostat).total_output_reg_2 = total_output_reg_2;
}

/** \fn double get_total_output_reg_2()
 * \brief Get total_output_reg_2 memory variable from current X-machine.
 * \return Value for variable.
 */
double get_total_output_reg_2()
{
	if(current_xmachine->xmachine_Eurostat) return (*current_xmachine->xmachine_Eurostat).total_output_reg_2;

    // suppress compiler warning by returning dummy value /
    // this statement should rightfully NEVER be reached /
    return (double)0;
}

/** \fn void set_total_output_reg_1(double total_output_reg_1)
 * \brief Set total_output_reg_1 memory variable for current X-machine.
 * \param total_output_reg_1 New value for variable.
 */
void set_total_output_reg_1(double total_output_reg_1)
{
	if(current_xmachine->xmachine_Eurostat) (*current_xmachine->xmachine_Eurostat).total_output_reg_1 = total_output_reg_1;
}

/** \fn double get_total_output_reg_1()
 * \brief Get total_output_reg_1 memory variable from current X-machine.
 * \return Value for variable.
 */
double get_total_output_reg_1()
{
	if(current_xmachine->xmachine_Eurostat) return (*current_xmachine->xmachine_Eurostat).total_output_reg_1;

    // suppress compiler warning by returning dummy value /
    // this statement should rightfully NEVER be reached /
    return (double)0;
}

/** \fn void set_per_capita_output_reg_2(double per_capita_output_reg_2)
 * \brief Set per_capita_output_reg_2 memory variable for current X-machine.
 * \param per_capita_output_reg_2 New value for variable.
 */
void set_per_capita_output_reg_2(double per_capita_output_reg_2)
{
	if(current_xmachine->xmachine_Eurostat) (*current_xmachine->xmachine_Eurostat).per_capita_output_reg_2 = per_capita_output_reg_2;
}

/** \fn double get_per_capita_output_reg_2()
 * \brief Get per_capita_output_reg_2 memory variable from current X-machine.
 * \return Value for variable.
 */
double get_per_capita_output_reg_2()
{
	if(current_xmachine->xmachine_Eurostat) return (*current_xmachine->xmachine_Eurostat).per_capita_output_reg_2;

    // suppress compiler warning by returning dummy value /
    // this statement should rightfully NEVER be reached /
    return (double)0;
}

/** \fn void set_per_capita_output_reg_1(double per_capita_output_reg_1)
 * \brief Set per_capita_output_reg_1 memory variable for current X-machine.
 * \param per_capita_output_reg_1 New value for variable.
 */
void set_per_capita_output_reg_1(double per_capita_output_reg_1)
{
	if(current_xmachine->xmachine_Eurostat) (*current_xmachine->xmachine_Eurostat).per_capita_output_reg_1 = per_capita_output_reg_1;
}

/** \fn double get_per_capita_output_reg_1()
 * \brief Get per_capita_output_reg_1 memory variable from current X-machine.
 * \return Value for variable.
 */
double get_per_capita_output_reg_1()
{
	if(current_xmachine->xmachine_Eurostat) return (*current_xmachine->xmachine_Eurostat).per_capita_output_reg_1;

    // suppress compiler warning by returning dummy value /
    // this statement should rightfully NEVER be reached /
    return (double)0;
}

/** \fn void set_mean_price_reg_1(double mean_price_reg_1)
 * \brief Set mean_price_reg_1 memory variable for current X-machine.
 * \param mean_price_reg_1 New value for variable.
 */
void set_mean_price_reg_1(double mean_price_reg_1)
{
	if(current_xmachine->xmachine_Eurostat) (*current_xmachine->xmachine_Eurostat).mean_price_reg_1 = mean_price_reg_1;
}

/** \fn double get_mean_price_reg_1()
 * \brief Get mean_price_reg_1 memory variable from current X-machine.
 * \return Value for variable.
 */
double get_mean_price_reg_1()
{
	if(current_xmachine->xmachine_Eurostat) return (*current_xmachine->xmachine_Eurostat).mean_price_reg_1;

    // suppress compiler warning by returning dummy value /
    // this statement should rightfully NEVER be reached /
    return (double)0;
}

/** \fn void set_mean_price_reg_2(double mean_price_reg_2)
 * \brief Set mean_price_reg_2 memory variable for current X-machine.
 * \param mean_price_reg_2 New value for variable.
 */
void set_mean_price_reg_2(double mean_price_reg_2)
{
	if(current_xmachine->xmachine_Eurostat) (*current_xmachine->xmachine_Eurostat).mean_price_reg_2 = mean_price_reg_2;
}

/** \fn double get_mean_price_reg_2()
 * \brief Get mean_price_reg_2 memory variable from current X-machine.
 * \return Value for variable.
 */
double get_mean_price_reg_2()
{
	if(current_xmachine->xmachine_Eurostat) return (*current_xmachine->xmachine_Eurostat).mean_price_reg_2;

    // suppress compiler warning by returning dummy value /
    // this statement should rightfully NEVER be reached /
    return (double)0;
}

/** \fn void set_mean_technology_reg_1(double mean_technology_reg_1)
 * \brief Set mean_technology_reg_1 memory variable for current X-machine.
 * \param mean_technology_reg_1 New value for variable.
 */
void set_mean_technology_reg_1(double mean_technology_reg_1)
{
	if(current_xmachine->xmachine_Eurostat) (*current_xmachine->xmachine_Eurostat).mean_technology_reg_1 = mean_technology_reg_1;
}

/** \fn double get_mean_technology_reg_1()
 * \brief Get mean_technology_reg_1 memory variable from current X-machine.
 * \return Value for variable.
 */
double get_mean_technology_reg_1()
{
	if(current_xmachine->xmachine_Eurostat) return (*current_xmachine->xmachine_Eurostat).mean_technology_reg_1;

    // suppress compiler warning by returning dummy value /
    // this statement should rightfully NEVER be reached /
    return (double)0;
}

/** \fn void set_mean_technology_reg_2(double mean_technology_reg_2)
 * \brief Set mean_technology_reg_2 memory variable for current X-machine.
 * \param mean_technology_reg_2 New value for variable.
 */
void set_mean_technology_reg_2(double mean_technology_reg_2)
{
	if(current_xmachine->xmachine_Eurostat) (*current_xmachine->xmachine_Eurostat).mean_technology_reg_2 = mean_technology_reg_2;
}

/** \fn double get_mean_technology_reg_2()
 * \brief Get mean_technology_reg_2 memory variable from current X-machine.
 * \return Value for variable.
 */
double get_mean_technology_reg_2()
{
	if(current_xmachine->xmachine_Eurostat) return (*current_xmachine->xmachine_Eurostat).mean_technology_reg_2;

    // suppress compiler warning by returning dummy value /
    // this statement should rightfully NEVER be reached /
    return (double)0;
}

/** \fn void set_exports_reg1(double exports_reg1)
 * \brief Set exports_reg1 memory variable for current X-machine.
 * \param exports_reg1 New value for variable.
 */
void set_exports_reg1(double exports_reg1)
{
	if(current_xmachine->xmachine_Eurostat) (*current_xmachine->xmachine_Eurostat).exports_reg1 = exports_reg1;
}

/** \fn double get_exports_reg1()
 * \brief Get exports_reg1 memory variable from current X-machine.
 * \return Value for variable.
 */
double get_exports_reg1()
{
	if(current_xmachine->xmachine_Eurostat) return (*current_xmachine->xmachine_Eurostat).exports_reg1;

    // suppress compiler warning by returning dummy value /
    // this statement should rightfully NEVER be reached /
    return (double)0;
}

/** \fn void set_exports_reg2(double exports_reg2)
 * \brief Set exports_reg2 memory variable for current X-machine.
 * \param exports_reg2 New value for variable.
 */
void set_exports_reg2(double exports_reg2)
{
	if(current_xmachine->xmachine_Eurostat) (*current_xmachine->xmachine_Eurostat).exports_reg2 = exports_reg2;
}

/** \fn double get_exports_reg2()
 * \brief Get exports_reg2 memory variable from current X-machine.
 * \return Value for variable.
 */
double get_exports_reg2()
{
	if(current_xmachine->xmachine_Eurostat) return (*current_xmachine->xmachine_Eurostat).exports_reg2;

    // suppress compiler warning by returning dummy value /
    // this statement should rightfully NEVER be reached /
    return (double)0;
}

/** \fn void set_imports_reg1(double imports_reg1)
 * \brief Set imports_reg1 memory variable for current X-machine.
 * \param imports_reg1 New value for variable.
 */
void set_imports_reg1(double imports_reg1)
{
	if(current_xmachine->xmachine_Eurostat) (*current_xmachine->xmachine_Eurostat).imports_reg1 = imports_reg1;
}

/** \fn double get_imports_reg1()
 * \brief Get imports_reg1 memory variable from current X-machine.
 * \return Value for variable.
 */
double get_imports_reg1()
{
	if(current_xmachine->xmachine_Eurostat) return (*current_xmachine->xmachine_Eurostat).imports_reg1;

    // suppress compiler warning by returning dummy value /
    // this statement should rightfully NEVER be reached /
    return (double)0;
}

/** \fn void set_trade_balance_reg1(double trade_balance_reg1)
 * \brief Set trade_balance_reg1 memory variable for current X-machine.
 * \param trade_balance_reg1 New value for variable.
 */
void set_trade_balance_reg1(double trade_balance_reg1)
{
	if(current_xmachine->xmachine_Eurostat) (*current_xmachine->xmachine_Eurostat).trade_balance_reg1 = trade_balance_reg1;
}

/** \fn double get_trade_balance_reg1()
 * \brief Get trade_balance_reg1 memory variable from current X-machine.
 * \return Value for variable.
 */
double get_trade_balance_reg1()
{
	if(current_xmachine->xmachine_Eurostat) return (*current_xmachine->xmachine_Eurostat).trade_balance_reg1;

    // suppress compiler warning by returning dummy value /
    // this statement should rightfully NEVER be reached /
    return (double)0;
}

/** \fn void set_trade_balance_reg2(double trade_balance_reg2)
 * \brief Set trade_balance_reg2 memory variable for current X-machine.
 * \param trade_balance_reg2 New value for variable.
 */
void set_trade_balance_reg2(double trade_balance_reg2)
{
	if(current_xmachine->xmachine_Eurostat) (*current_xmachine->xmachine_Eurostat).trade_balance_reg2 = trade_balance_reg2;
}

/** \fn double get_trade_balance_reg2()
 * \brief Get trade_balance_reg2 memory variable from current X-machine.
 * \return Value for variable.
 */
double get_trade_balance_reg2()
{
	if(current_xmachine->xmachine_Eurostat) return (*current_xmachine->xmachine_Eurostat).trade_balance_reg2;

    // suppress compiler warning by returning dummy value /
    // this statement should rightfully NEVER be reached /
    return (double)0;
}

/** \fn void set_imports_reg2(double imports_reg2)
 * \brief Set imports_reg2 memory variable for current X-machine.
 * \param imports_reg2 New value for variable.
 */
void set_imports_reg2(double imports_reg2)
{
	if(current_xmachine->xmachine_Eurostat) (*current_xmachine->xmachine_Eurostat).imports_reg2 = imports_reg2;
}

/** \fn double get_imports_reg2()
 * \brief Get imports_reg2 memory variable from current X-machine.
 * \return Value for variable.
 */
double get_imports_reg2()
{
	if(current_xmachine->xmachine_Eurostat) return (*current_xmachine->xmachine_Eurostat).imports_reg2;

    // suppress compiler warning by returning dummy value /
    // this statement should rightfully NEVER be reached /
    return (double)0;
}

/** \fn void set_export_quota_reg1(double export_quota_reg1)
 * \brief Set export_quota_reg1 memory variable for current X-machine.
 * \param export_quota_reg1 New value for variable.
 */
void set_export_quota_reg1(double export_quota_reg1)
{
	if(current_xmachine->xmachine_Eurostat) (*current_xmachine->xmachine_Eurostat).export_quota_reg1 = export_quota_reg1;
}

/** \fn double get_export_quota_reg1()
 * \brief Get export_quota_reg1 memory variable from current X-machine.
 * \return Value for variable.
 */
double get_export_quota_reg1()
{
	if(current_xmachine->xmachine_Eurostat) return (*current_xmachine->xmachine_Eurostat).export_quota_reg1;

    // suppress compiler warning by returning dummy value /
    // this statement should rightfully NEVER be reached /
    return (double)0;
}

/** \fn void set_export_quota_reg2(double export_quota_reg2)
 * \brief Set export_quota_reg2 memory variable for current X-machine.
 * \param export_quota_reg2 New value for variable.
 */
void set_export_quota_reg2(double export_quota_reg2)
{
	if(current_xmachine->xmachine_Eurostat) (*current_xmachine->xmachine_Eurostat).export_quota_reg2 = export_quota_reg2;
}

/** \fn double get_export_quota_reg2()
 * \brief Get export_quota_reg2 memory variable from current X-machine.
 * \return Value for variable.
 */
double get_export_quota_reg2()
{
	if(current_xmachine->xmachine_Eurostat) return (*current_xmachine->xmachine_Eurostat).export_quota_reg2;

    // suppress compiler warning by returning dummy value /
    // this statement should rightfully NEVER be reached /
    return (double)0;
}

/** \fn void set_import_quota_reg1(double import_quota_reg1)
 * \brief Set import_quota_reg1 memory variable for current X-machine.
 * \param import_quota_reg1 New value for variable.
 */
void set_import_quota_reg1(double import_quota_reg1)
{
	if(current_xmachine->xmachine_Eurostat) (*current_xmachine->xmachine_Eurostat).import_quota_reg1 = import_quota_reg1;
}

/** \fn double get_import_quota_reg1()
 * \brief Get import_quota_reg1 memory variable from current X-machine.
 * \return Value for variable.
 */
double get_import_quota_reg1()
{
	if(current_xmachine->xmachine_Eurostat) return (*current_xmachine->xmachine_Eurostat).import_quota_reg1;

    // suppress compiler warning by returning dummy value /
    // this statement should rightfully NEVER be reached /
    return (double)0;
}

/** \fn void set_import_quota_reg2(double import_quota_reg2)
 * \brief Set import_quota_reg2 memory variable for current X-machine.
 * \param import_quota_reg2 New value for variable.
 */
void set_import_quota_reg2(double import_quota_reg2)
{
	if(current_xmachine->xmachine_Eurostat) (*current_xmachine->xmachine_Eurostat).import_quota_reg2 = import_quota_reg2;
}

/** \fn double get_import_quota_reg2()
 * \brief Get import_quota_reg2 memory variable from current X-machine.
 * \return Value for variable.
 */
double get_import_quota_reg2()
{
	if(current_xmachine->xmachine_Eurostat) return (*current_xmachine->xmachine_Eurostat).import_quota_reg2;

    // suppress compiler warning by returning dummy value /
    // this statement should rightfully NEVER be reached /
    return (double)0;
}

/** \fn void set_trade_balance_quota_reg1(double trade_balance_quota_reg1)
 * \brief Set trade_balance_quota_reg1 memory variable for current X-machine.
 * \param trade_balance_quota_reg1 New value for variable.
 */
void set_trade_balance_quota_reg1(double trade_balance_quota_reg1)
{
	if(current_xmachine->xmachine_Eurostat) (*current_xmachine->xmachine_Eurostat).trade_balance_quota_reg1 = trade_balance_quota_reg1;
}

/** \fn double get_trade_balance_quota_reg1()
 * \brief Get trade_balance_quota_reg1 memory variable from current X-machine.
 * \return Value for variable.
 */
double get_trade_balance_quota_reg1()
{
	if(current_xmachine->xmachine_Eurostat) return (*current_xmachine->xmachine_Eurostat).trade_balance_quota_reg1;

    // suppress compiler warning by returning dummy value /
    // this statement should rightfully NEVER be reached /
    return (double)0;
}

/** \fn void set_trade_balance_quota_reg2(double trade_balance_quota_reg2)
 * \brief Set trade_balance_quota_reg2 memory variable for current X-machine.
 * \param trade_balance_quota_reg2 New value for variable.
 */
void set_trade_balance_quota_reg2(double trade_balance_quota_reg2)
{
	if(current_xmachine->xmachine_Eurostat) (*current_xmachine->xmachine_Eurostat).trade_balance_quota_reg2 = trade_balance_quota_reg2;
}

/** \fn double get_trade_balance_quota_reg2()
 * \brief Get trade_balance_quota_reg2 memory variable from current X-machine.
 * \return Value for variable.
 */
double get_trade_balance_quota_reg2()
{
	if(current_xmachine->xmachine_Eurostat) return (*current_xmachine->xmachine_Eurostat).trade_balance_quota_reg2;

    // suppress compiler warning by returning dummy value /
    // this statement should rightfully NEVER be reached /
    return (double)0;
}

/** \fn void set_mean_wage_reg_1(double mean_wage_reg_1)
 * \brief Set mean_wage_reg_1 memory variable for current X-machine.
 * \param mean_wage_reg_1 New value for variable.
 */
void set_mean_wage_reg_1(double mean_wage_reg_1)
{
	if(current_xmachine->xmachine_Eurostat) (*current_xmachine->xmachine_Eurostat).mean_wage_reg_1 = mean_wage_reg_1;
}

/** \fn double get_mean_wage_reg_1()
 * \brief Get mean_wage_reg_1 memory variable from current X-machine.
 * \return Value for variable.
 */
double get_mean_wage_reg_1()
{
	if(current_xmachine->xmachine_Eurostat) return (*current_xmachine->xmachine_Eurostat).mean_wage_reg_1;

    // suppress compiler warning by returning dummy value /
    // this statement should rightfully NEVER be reached /
    return (double)0;
}

/** \fn void set_mean_wage_reg_2(double mean_wage_reg_2)
 * \brief Set mean_wage_reg_2 memory variable for current X-machine.
 * \param mean_wage_reg_2 New value for variable.
 */
void set_mean_wage_reg_2(double mean_wage_reg_2)
{
	if(current_xmachine->xmachine_Eurostat) (*current_xmachine->xmachine_Eurostat).mean_wage_reg_2 = mean_wage_reg_2;
}

/** \fn double get_mean_wage_reg_2()
 * \brief Get mean_wage_reg_2 memory variable from current X-machine.
 * \return Value for variable.
 */
double get_mean_wage_reg_2()
{
	if(current_xmachine->xmachine_Eurostat) return (*current_xmachine->xmachine_Eurostat).mean_wage_reg_2;

    // suppress compiler warning by returning dummy value /
    // this statement should rightfully NEVER be reached /
    return (double)0;
}

/** \fn void set_mean_wage_offer_reg_1(double mean_wage_offer_reg_1)
 * \brief Set mean_wage_offer_reg_1 memory variable for current X-machine.
 * \param mean_wage_offer_reg_1 New value for variable.
 */
void set_mean_wage_offer_reg_1(double mean_wage_offer_reg_1)
{
	if(current_xmachine->xmachine_Eurostat) (*current_xmachine->xmachine_Eurostat).mean_wage_offer_reg_1 = mean_wage_offer_reg_1;
}

/** \fn double get_mean_wage_offer_reg_1()
 * \brief Get mean_wage_offer_reg_1 memory variable from current X-machine.
 * \return Value for variable.
 */
double get_mean_wage_offer_reg_1()
{
	if(current_xmachine->xmachine_Eurostat) return (*current_xmachine->xmachine_Eurostat).mean_wage_offer_reg_1;

    // suppress compiler warning by returning dummy value /
    // this statement should rightfully NEVER be reached /
    return (double)0;
}

/** \fn void set_mean_wage_offer_reg_2(double mean_wage_offer_reg_2)
 * \brief Set mean_wage_offer_reg_2 memory variable for current X-machine.
 * \param mean_wage_offer_reg_2 New value for variable.
 */
void set_mean_wage_offer_reg_2(double mean_wage_offer_reg_2)
{
	if(current_xmachine->xmachine_Eurostat) (*current_xmachine->xmachine_Eurostat).mean_wage_offer_reg_2 = mean_wage_offer_reg_2;
}

/** \fn double get_mean_wage_offer_reg_2()
 * \brief Get mean_wage_offer_reg_2 memory variable from current X-machine.
 * \return Value for variable.
 */
double get_mean_wage_offer_reg_2()
{
	if(current_xmachine->xmachine_Eurostat) return (*current_xmachine->xmachine_Eurostat).mean_wage_offer_reg_2;

    // suppress compiler warning by returning dummy value /
    // this statement should rightfully NEVER be reached /
    return (double)0;
}

/** \fn void set_mean_s_skills_reg_1(double mean_s_skills_reg_1)
 * \brief Set mean_s_skills_reg_1 memory variable for current X-machine.
 * \param mean_s_skills_reg_1 New value for variable.
 */
void set_mean_s_skills_reg_1(double mean_s_skills_reg_1)
{
	if(current_xmachine->xmachine_Eurostat) (*current_xmachine->xmachine_Eurostat).mean_s_skills_reg_1 = mean_s_skills_reg_1;
}

/** \fn double get_mean_s_skills_reg_1()
 * \brief Get mean_s_skills_reg_1 memory variable from current X-machine.
 * \return Value for variable.
 */
double get_mean_s_skills_reg_1()
{
	if(current_xmachine->xmachine_Eurostat) return (*current_xmachine->xmachine_Eurostat).mean_s_skills_reg_1;

    // suppress compiler warning by returning dummy value /
    // this statement should rightfully NEVER be reached /
    return (double)0;
}

/** \fn void set_mean_s_skills_reg_2(double mean_s_skills_reg_2)
 * \brief Set mean_s_skills_reg_2 memory variable for current X-machine.
 * \param mean_s_skills_reg_2 New value for variable.
 */
void set_mean_s_skills_reg_2(double mean_s_skills_reg_2)
{
	if(current_xmachine->xmachine_Eurostat) (*current_xmachine->xmachine_Eurostat).mean_s_skills_reg_2 = mean_s_skills_reg_2;
}

/** \fn double get_mean_s_skills_reg_2()
 * \brief Get mean_s_skills_reg_2 memory variable from current X-machine.
 * \return Value for variable.
 */
double get_mean_s_skills_reg_2()
{
	if(current_xmachine->xmachine_Eurostat) return (*current_xmachine->xmachine_Eurostat).mean_s_skills_reg_2;

    // suppress compiler warning by returning dummy value /
    // this statement should rightfully NEVER be reached /
    return (double)0;
}

/** \fn void set_mean_mark_up_reg_1(double mean_mark_up_reg_1)
 * \brief Set mean_mark_up_reg_1 memory variable for current X-machine.
 * \param mean_mark_up_reg_1 New value for variable.
 */
void set_mean_mark_up_reg_1(double mean_mark_up_reg_1)
{
	if(current_xmachine->xmachine_Eurostat) (*current_xmachine->xmachine_Eurostat).mean_mark_up_reg_1 = mean_mark_up_reg_1;
}

/** \fn double get_mean_mark_up_reg_1()
 * \brief Get mean_mark_up_reg_1 memory variable from current X-machine.
 * \return Value for variable.
 */
double get_mean_mark_up_reg_1()
{
	if(current_xmachine->xmachine_Eurostat) return (*current_xmachine->xmachine_Eurostat).mean_mark_up_reg_1;

    // suppress compiler warning by returning dummy value /
    // this statement should rightfully NEVER be reached /
    return (double)0;
}

/** \fn void set_mean_mark_up_reg_2(double mean_mark_up_reg_2)
 * \brief Set mean_mark_up_reg_2 memory variable for current X-machine.
 * \param mean_mark_up_reg_2 New value for variable.
 */
void set_mean_mark_up_reg_2(double mean_mark_up_reg_2)
{
	if(current_xmachine->xmachine_Eurostat) (*current_xmachine->xmachine_Eurostat).mean_mark_up_reg_2 = mean_mark_up_reg_2;
}

/** \fn double get_mean_mark_up_reg_2()
 * \brief Get mean_mark_up_reg_2 memory variable from current X-machine.
 * \return Value for variable.
 */
double get_mean_mark_up_reg_2()
{
	if(current_xmachine->xmachine_Eurostat) return (*current_xmachine->xmachine_Eurostat).mean_mark_up_reg_2;

    // suppress compiler warning by returning dummy value /
    // this statement should rightfully NEVER be reached /
    return (double)0;
}

/** \fn void set_relative_price(double relative_price)
 * \brief Set relative_price memory variable for current X-machine.
 * \param relative_price New value for variable.
 */
void set_relative_price(double relative_price)
{
	if(current_xmachine->xmachine_Eurostat) (*current_xmachine->xmachine_Eurostat).relative_price = relative_price;
}

/** \fn double get_relative_price()
 * \brief Get relative_price memory variable from current X-machine.
 * \return Value for variable.
 */
double get_relative_price()
{
	if(current_xmachine->xmachine_Eurostat) return (*current_xmachine->xmachine_Eurostat).relative_price;

    // suppress compiler warning by returning dummy value /
    // this statement should rightfully NEVER be reached /
    return (double)0;
}

/** \fn void set_relative_reservation_wage(double relative_reservation_wage)
 * \brief Set relative_reservation_wage memory variable for current X-machine.
 * \param relative_reservation_wage New value for variable.
 */
void set_relative_reservation_wage(double relative_reservation_wage)
{
	if(current_xmachine->xmachine_Eurostat) (*current_xmachine->xmachine_Eurostat).relative_reservation_wage = relative_reservation_wage;
}

/** \fn double get_relative_reservation_wage()
 * \brief Get relative_reservation_wage memory variable from current X-machine.
 * \return Value for variable.
 */
double get_relative_reservation_wage()
{
	if(current_xmachine->xmachine_Eurostat) return (*current_xmachine->xmachine_Eurostat).relative_reservation_wage;

    // suppress compiler warning by returning dummy value /
    // this statement should rightfully NEVER be reached /
    return (double)0;
}

/** \fn void set_relative_mark_up(double relative_mark_up)
 * \brief Set relative_mark_up memory variable for current X-machine.
 * \param relative_mark_up New value for variable.
 */
void set_relative_mark_up(double relative_mark_up)
{
	if(current_xmachine->xmachine_Eurostat) (*current_xmachine->xmachine_Eurostat).relative_mark_up = relative_mark_up;
}

/** \fn double get_relative_mark_up()
 * \brief Get relative_mark_up memory variable from current X-machine.
 * \return Value for variable.
 */
double get_relative_mark_up()
{
	if(current_xmachine->xmachine_Eurostat) return (*current_xmachine->xmachine_Eurostat).relative_mark_up;

    // suppress compiler warning by returning dummy value /
    // this statement should rightfully NEVER be reached /
    return (double)0;
}

/** \fn void set_relative_wage(double relative_wage)
 * \brief Set relative_wage memory variable for current X-machine.
 * \param relative_wage New value for variable.
 */
void set_relative_wage(double relative_wage)
{
	if(current_xmachine->xmachine_Eurostat) (*current_xmachine->xmachine_Eurostat).relative_wage = relative_wage;
}

/** \fn double get_relative_wage()
 * \brief Get relative_wage memory variable from current X-machine.
 * \return Value for variable.
 */
double get_relative_wage()
{
	if(current_xmachine->xmachine_Eurostat) return (*current_xmachine->xmachine_Eurostat).relative_wage;

    // suppress compiler warning by returning dummy value /
    // this statement should rightfully NEVER be reached /
    return (double)0;
}

/** \fn void set_relative_wage_offer(double relative_wage_offer)
 * \brief Set relative_wage_offer memory variable for current X-machine.
 * \param relative_wage_offer New value for variable.
 */
void set_relative_wage_offer(double relative_wage_offer)
{
	if(current_xmachine->xmachine_Eurostat) (*current_xmachine->xmachine_Eurostat).relative_wage_offer = relative_wage_offer;
}

/** \fn double get_relative_wage_offer()
 * \brief Get relative_wage_offer memory variable from current X-machine.
 * \return Value for variable.
 */
double get_relative_wage_offer()
{
	if(current_xmachine->xmachine_Eurostat) return (*current_xmachine->xmachine_Eurostat).relative_wage_offer;

    // suppress compiler warning by returning dummy value /
    // this statement should rightfully NEVER be reached /
    return (double)0;
}

/** \fn void set_relative_technology(double relative_technology)
 * \brief Set relative_technology memory variable for current X-machine.
 * \param relative_technology New value for variable.
 */
void set_relative_technology(double relative_technology)
{
	if(current_xmachine->xmachine_Eurostat) (*current_xmachine->xmachine_Eurostat).relative_technology = relative_technology;
}

/** \fn double get_relative_technology()
 * \brief Get relative_technology memory variable from current X-machine.
 * \return Value for variable.
 */
double get_relative_technology()
{
	if(current_xmachine->xmachine_Eurostat) return (*current_xmachine->xmachine_Eurostat).relative_technology;

    // suppress compiler warning by returning dummy value /
    // this statement should rightfully NEVER be reached /
    return (double)0;
}

/** \fn void set_relative_s_skills(double relative_s_skills)
 * \brief Set relative_s_skills memory variable for current X-machine.
 * \param relative_s_skills New value for variable.
 */
void set_relative_s_skills(double relative_s_skills)
{
	if(current_xmachine->xmachine_Eurostat) (*current_xmachine->xmachine_Eurostat).relative_s_skills = relative_s_skills;
}

/** \fn double get_relative_s_skills()
 * \brief Get relative_s_skills memory variable from current X-machine.
 * \return Value for variable.
 */
double get_relative_s_skills()
{
	if(current_xmachine->xmachine_Eurostat) return (*current_xmachine->xmachine_Eurostat).relative_s_skills;

    // suppress compiler warning by returning dummy value /
    // this statement should rightfully NEVER be reached /
    return (double)0;
}

/** \fn void set_relative_output(double relative_output)
 * \brief Set relative_output memory variable for current X-machine.
 * \param relative_output New value for variable.
 */
void set_relative_output(double relative_output)
{
	if(current_xmachine->xmachine_Eurostat) (*current_xmachine->xmachine_Eurostat).relative_output = relative_output;
}

/** \fn double get_relative_output()
 * \brief Get relative_output memory variable from current X-machine.
 * \return Value for variable.
 */
double get_relative_output()
{
	if(current_xmachine->xmachine_Eurostat) return (*current_xmachine->xmachine_Eurostat).relative_output;

    // suppress compiler warning by returning dummy value /
    // this statement should rightfully NEVER be reached /
    return (double)0;
}

/** \fn void set_government_consumption(double government_consumption)
 * \brief Set government_consumption memory variable for current X-machine.
 * \param government_consumption New value for variable.
 */
void set_government_consumption(double government_consumption)
{
	if(current_xmachine->xmachine_Eurostat) (*current_xmachine->xmachine_Eurostat).government_consumption = government_consumption;
}

/** \fn double get_government_consumption()
 * \brief Get government_consumption memory variable from current X-machine.
 * \return Value for variable.
 */
double get_government_consumption()
{
	if(current_xmachine->xmachine_Eurostat) return (*current_xmachine->xmachine_Eurostat).government_consumption;

    // suppress compiler warning by returning dummy value /
    // this statement should rightfully NEVER be reached /
    return (double)0;
}

/** \fn void set_gini_wage(double gini_wage)
 * \brief Set gini_wage memory variable for current X-machine.
 * \param gini_wage New value for variable.
 */
void set_gini_wage(double gini_wage)
{
	if(current_xmachine->xmachine_Eurostat) (*current_xmachine->xmachine_Eurostat).gini_wage = gini_wage;
}

/** \fn double get_gini_wage()
 * \brief Get gini_wage memory variable from current X-machine.
 * \return Value for variable.
 */
double get_gini_wage()
{
	if(current_xmachine->xmachine_Eurostat) return (*current_xmachine->xmachine_Eurostat).gini_wage;

    // suppress compiler warning by returning dummy value /
    // this statement should rightfully NEVER be reached /
    return (double)0;
}

/** \fn void set_gini_income(double gini_income)
 * \brief Set gini_income memory variable for current X-machine.
 * \param gini_income New value for variable.
 */
void set_gini_income(double gini_income)
{
	if(current_xmachine->xmachine_Eurostat) (*current_xmachine->xmachine_Eurostat).gini_income = gini_income;
}

/** \fn double get_gini_income()
 * \brief Get gini_income memory variable from current X-machine.
 * \return Value for variable.
 */
double get_gini_income()
{
	if(current_xmachine->xmachine_Eurostat) return (*current_xmachine->xmachine_Eurostat).gini_income;

    // suppress compiler warning by returning dummy value /
    // this statement should rightfully NEVER be reached /
    return (double)0;
}

/** \fn void set_gini_wealth(double gini_wealth)
 * \brief Set gini_wealth memory variable for current X-machine.
 * \param gini_wealth New value for variable.
 */
void set_gini_wealth(double gini_wealth)
{
	if(current_xmachine->xmachine_Eurostat) (*current_xmachine->xmachine_Eurostat).gini_wealth = gini_wealth;
}

/** \fn double get_gini_wealth()
 * \brief Get gini_wealth memory variable from current X-machine.
 * \return Value for variable.
 */
double get_gini_wealth()
{
	if(current_xmachine->xmachine_Eurostat) return (*current_xmachine->xmachine_Eurostat).gini_wealth;

    // suppress compiler warning by returning dummy value /
    // this statement should rightfully NEVER be reached /
    return (double)0;
}

/** \fn void set_gini_specific_skills(double gini_specific_skills)
 * \brief Set gini_specific_skills memory variable for current X-machine.
 * \param gini_specific_skills New value for variable.
 */
void set_gini_specific_skills(double gini_specific_skills)
{
	if(current_xmachine->xmachine_Eurostat) (*current_xmachine->xmachine_Eurostat).gini_specific_skills = gini_specific_skills;
}

/** \fn double get_gini_specific_skills()
 * \brief Get gini_specific_skills memory variable from current X-machine.
 * \return Value for variable.
 */
double get_gini_specific_skills()
{
	if(current_xmachine->xmachine_Eurostat) return (*current_xmachine->xmachine_Eurostat).gini_specific_skills;

    // suppress compiler warning by returning dummy value /
    // this statement should rightfully NEVER be reached /
    return (double)0;
}

/** \fn void set_gini_wage_reg_1(double gini_wage_reg_1)
 * \brief Set gini_wage_reg_1 memory variable for current X-machine.
 * \param gini_wage_reg_1 New value for variable.
 */
void set_gini_wage_reg_1(double gini_wage_reg_1)
{
	if(current_xmachine->xmachine_Eurostat) (*current_xmachine->xmachine_Eurostat).gini_wage_reg_1 = gini_wage_reg_1;
}

/** \fn double get_gini_wage_reg_1()
 * \brief Get gini_wage_reg_1 memory variable from current X-machine.
 * \return Value for variable.
 */
double get_gini_wage_reg_1()
{
	if(current_xmachine->xmachine_Eurostat) return (*current_xmachine->xmachine_Eurostat).gini_wage_reg_1;

    // suppress compiler warning by returning dummy value /
    // this statement should rightfully NEVER be reached /
    return (double)0;
}

/** \fn void set_gini_income_reg_1(double gini_income_reg_1)
 * \brief Set gini_income_reg_1 memory variable for current X-machine.
 * \param gini_income_reg_1 New value for variable.
 */
void set_gini_income_reg_1(double gini_income_reg_1)
{
	if(current_xmachine->xmachine_Eurostat) (*current_xmachine->xmachine_Eurostat).gini_income_reg_1 = gini_income_reg_1;
}

/** \fn double get_gini_income_reg_1()
 * \brief Get gini_income_reg_1 memory variable from current X-machine.
 * \return Value for variable.
 */
double get_gini_income_reg_1()
{
	if(current_xmachine->xmachine_Eurostat) return (*current_xmachine->xmachine_Eurostat).gini_income_reg_1;

    // suppress compiler warning by returning dummy value /
    // this statement should rightfully NEVER be reached /
    return (double)0;
}

/** \fn void set_gini_wealth_reg_1(double gini_wealth_reg_1)
 * \brief Set gini_wealth_reg_1 memory variable for current X-machine.
 * \param gini_wealth_reg_1 New value for variable.
 */
void set_gini_wealth_reg_1(double gini_wealth_reg_1)
{
	if(current_xmachine->xmachine_Eurostat) (*current_xmachine->xmachine_Eurostat).gini_wealth_reg_1 = gini_wealth_reg_1;
}

/** \fn double get_gini_wealth_reg_1()
 * \brief Get gini_wealth_reg_1 memory variable from current X-machine.
 * \return Value for variable.
 */
double get_gini_wealth_reg_1()
{
	if(current_xmachine->xmachine_Eurostat) return (*current_xmachine->xmachine_Eurostat).gini_wealth_reg_1;

    // suppress compiler warning by returning dummy value /
    // this statement should rightfully NEVER be reached /
    return (double)0;
}

/** \fn void set_gini_specific_skills_reg_1(double gini_specific_skills_reg_1)
 * \brief Set gini_specific_skills_reg_1 memory variable for current X-machine.
 * \param gini_specific_skills_reg_1 New value for variable.
 */
void set_gini_specific_skills_reg_1(double gini_specific_skills_reg_1)
{
	if(current_xmachine->xmachine_Eurostat) (*current_xmachine->xmachine_Eurostat).gini_specific_skills_reg_1 = gini_specific_skills_reg_1;
}

/** \fn double get_gini_specific_skills_reg_1()
 * \brief Get gini_specific_skills_reg_1 memory variable from current X-machine.
 * \return Value for variable.
 */
double get_gini_specific_skills_reg_1()
{
	if(current_xmachine->xmachine_Eurostat) return (*current_xmachine->xmachine_Eurostat).gini_specific_skills_reg_1;

    // suppress compiler warning by returning dummy value /
    // this statement should rightfully NEVER be reached /
    return (double)0;
}

/** \fn void set_gini_wage_reg_2(double gini_wage_reg_2)
 * \brief Set gini_wage_reg_2 memory variable for current X-machine.
 * \param gini_wage_reg_2 New value for variable.
 */
void set_gini_wage_reg_2(double gini_wage_reg_2)
{
	if(current_xmachine->xmachine_Eurostat) (*current_xmachine->xmachine_Eurostat).gini_wage_reg_2 = gini_wage_reg_2;
}

/** \fn double get_gini_wage_reg_2()
 * \brief Get gini_wage_reg_2 memory variable from current X-machine.
 * \return Value for variable.
 */
double get_gini_wage_reg_2()
{
	if(current_xmachine->xmachine_Eurostat) return (*current_xmachine->xmachine_Eurostat).gini_wage_reg_2;

    // suppress compiler warning by returning dummy value /
    // this statement should rightfully NEVER be reached /
    return (double)0;
}

/** \fn void set_gini_income_reg_2(double gini_income_reg_2)
 * \brief Set gini_income_reg_2 memory variable for current X-machine.
 * \param gini_income_reg_2 New value for variable.
 */
void set_gini_income_reg_2(double gini_income_reg_2)
{
	if(current_xmachine->xmachine_Eurostat) (*current_xmachine->xmachine_Eurostat).gini_income_reg_2 = gini_income_reg_2;
}

/** \fn double get_gini_income_reg_2()
 * \brief Get gini_income_reg_2 memory variable from current X-machine.
 * \return Value for variable.
 */
double get_gini_income_reg_2()
{
	if(current_xmachine->xmachine_Eurostat) return (*current_xmachine->xmachine_Eurostat).gini_income_reg_2;

    // suppress compiler warning by returning dummy value /
    // this statement should rightfully NEVER be reached /
    return (double)0;
}

/** \fn void set_gini_wealth_reg_2(double gini_wealth_reg_2)
 * \brief Set gini_wealth_reg_2 memory variable for current X-machine.
 * \param gini_wealth_reg_2 New value for variable.
 */
void set_gini_wealth_reg_2(double gini_wealth_reg_2)
{
	if(current_xmachine->xmachine_Eurostat) (*current_xmachine->xmachine_Eurostat).gini_wealth_reg_2 = gini_wealth_reg_2;
}

/** \fn double get_gini_wealth_reg_2()
 * \brief Get gini_wealth_reg_2 memory variable from current X-machine.
 * \return Value for variable.
 */
double get_gini_wealth_reg_2()
{
	if(current_xmachine->xmachine_Eurostat) return (*current_xmachine->xmachine_Eurostat).gini_wealth_reg_2;

    // suppress compiler warning by returning dummy value /
    // this statement should rightfully NEVER be reached /
    return (double)0;
}

/** \fn void set_gini_specific_skills_reg_2(double gini_specific_skills_reg_2)
 * \brief Set gini_specific_skills_reg_2 memory variable for current X-machine.
 * \param gini_specific_skills_reg_2 New value for variable.
 */
void set_gini_specific_skills_reg_2(double gini_specific_skills_reg_2)
{
	if(current_xmachine->xmachine_Eurostat) (*current_xmachine->xmachine_Eurostat).gini_specific_skills_reg_2 = gini_specific_skills_reg_2;
}

/** \fn double get_gini_specific_skills_reg_2()
 * \brief Get gini_specific_skills_reg_2 memory variable from current X-machine.
 * \return Value for variable.
 */
double get_gini_specific_skills_reg_2()
{
	if(current_xmachine->xmachine_Eurostat) return (*current_xmachine->xmachine_Eurostat).gini_specific_skills_reg_2;

    // suppress compiler warning by returning dummy value /
    // this statement should rightfully NEVER be reached /
    return (double)0;
}

/** \fn void set_labor_income_reg_1(double labor_income_reg_1)
 * \brief Set labor_income_reg_1 memory variable for current X-machine.
 * \param labor_income_reg_1 New value for variable.
 */
void set_labor_income_reg_1(double labor_income_reg_1)
{
	if(current_xmachine->xmachine_Eurostat) (*current_xmachine->xmachine_Eurostat).labor_income_reg_1 = labor_income_reg_1;
}

/** \fn double get_labor_income_reg_1()
 * \brief Get labor_income_reg_1 memory variable from current X-machine.
 * \return Value for variable.
 */
double get_labor_income_reg_1()
{
	if(current_xmachine->xmachine_Eurostat) return (*current_xmachine->xmachine_Eurostat).labor_income_reg_1;

    // suppress compiler warning by returning dummy value /
    // this statement should rightfully NEVER be reached /
    return (double)0;
}

/** \fn void set_labor_income_reg_2(double labor_income_reg_2)
 * \brief Set labor_income_reg_2 memory variable for current X-machine.
 * \param labor_income_reg_2 New value for variable.
 */
void set_labor_income_reg_2(double labor_income_reg_2)
{
	if(current_xmachine->xmachine_Eurostat) (*current_xmachine->xmachine_Eurostat).labor_income_reg_2 = labor_income_reg_2;
}

/** \fn double get_labor_income_reg_2()
 * \brief Get labor_income_reg_2 memory variable from current X-machine.
 * \return Value for variable.
 */
double get_labor_income_reg_2()
{
	if(current_xmachine->xmachine_Eurostat) return (*current_xmachine->xmachine_Eurostat).labor_income_reg_2;

    // suppress compiler warning by returning dummy value /
    // this statement should rightfully NEVER be reached /
    return (double)0;
}

/** \fn void set_dividend_income_reg_1(double dividend_income_reg_1)
 * \brief Set dividend_income_reg_1 memory variable for current X-machine.
 * \param dividend_income_reg_1 New value for variable.
 */
void set_dividend_income_reg_1(double dividend_income_reg_1)
{
	if(current_xmachine->xmachine_Eurostat) (*current_xmachine->xmachine_Eurostat).dividend_income_reg_1 = dividend_income_reg_1;
}

/** \fn double get_dividend_income_reg_1()
 * \brief Get dividend_income_reg_1 memory variable from current X-machine.
 * \return Value for variable.
 */
double get_dividend_income_reg_1()
{
	if(current_xmachine->xmachine_Eurostat) return (*current_xmachine->xmachine_Eurostat).dividend_income_reg_1;

    // suppress compiler warning by returning dummy value /
    // this statement should rightfully NEVER be reached /
    return (double)0;
}

/** \fn void set_dividend_income_reg_2(double dividend_income_reg_2)
 * \brief Set dividend_income_reg_2 memory variable for current X-machine.
 * \param dividend_income_reg_2 New value for variable.
 */
void set_dividend_income_reg_2(double dividend_income_reg_2)
{
	if(current_xmachine->xmachine_Eurostat) (*current_xmachine->xmachine_Eurostat).dividend_income_reg_2 = dividend_income_reg_2;
}

/** \fn double get_dividend_income_reg_2()
 * \brief Get dividend_income_reg_2 memory variable from current X-machine.
 * \return Value for variable.
 */
double get_dividend_income_reg_2()
{
	if(current_xmachine->xmachine_Eurostat) return (*current_xmachine->xmachine_Eurostat).dividend_income_reg_2;

    // suppress compiler warning by returning dummy value /
    // this statement should rightfully NEVER be reached /
    return (double)0;
}

/** \fn void set_interest_income_reg_1(double interest_income_reg_1)
 * \brief Set interest_income_reg_1 memory variable for current X-machine.
 * \param interest_income_reg_1 New value for variable.
 */
void set_interest_income_reg_1(double interest_income_reg_1)
{
	if(current_xmachine->xmachine_Eurostat) (*current_xmachine->xmachine_Eurostat).interest_income_reg_1 = interest_income_reg_1;
}

/** \fn double get_interest_income_reg_1()
 * \brief Get interest_income_reg_1 memory variable from current X-machine.
 * \return Value for variable.
 */
double get_interest_income_reg_1()
{
	if(current_xmachine->xmachine_Eurostat) return (*current_xmachine->xmachine_Eurostat).interest_income_reg_1;

    // suppress compiler warning by returning dummy value /
    // this statement should rightfully NEVER be reached /
    return (double)0;
}

/** \fn void set_interest_income_reg_2(double interest_income_reg_2)
 * \brief Set interest_income_reg_2 memory variable for current X-machine.
 * \param interest_income_reg_2 New value for variable.
 */
void set_interest_income_reg_2(double interest_income_reg_2)
{
	if(current_xmachine->xmachine_Eurostat) (*current_xmachine->xmachine_Eurostat).interest_income_reg_2 = interest_income_reg_2;
}

/** \fn double get_interest_income_reg_2()
 * \brief Get interest_income_reg_2 memory variable from current X-machine.
 * \return Value for variable.
 */
double get_interest_income_reg_2()
{
	if(current_xmachine->xmachine_Eurostat) return (*current_xmachine->xmachine_Eurostat).interest_income_reg_2;

    // suppress compiler warning by returning dummy value /
    // this statement should rightfully NEVER be reached /
    return (double)0;
}

/** \fn void set_financial_market_net_revenue_reg_1(double financial_market_net_revenue_reg_1)
 * \brief Set financial_market_net_revenue_reg_1 memory variable for current X-machine.
 * \param financial_market_net_revenue_reg_1 New value for variable.
 */
void set_financial_market_net_revenue_reg_1(double financial_market_net_revenue_reg_1)
{
	if(current_xmachine->xmachine_Eurostat) (*current_xmachine->xmachine_Eurostat).financial_market_net_revenue_reg_1 = financial_market_net_revenue_reg_1;
}

/** \fn double get_financial_market_net_revenue_reg_1()
 * \brief Get financial_market_net_revenue_reg_1 memory variable from current X-machine.
 * \return Value for variable.
 */
double get_financial_market_net_revenue_reg_1()
{
	if(current_xmachine->xmachine_Eurostat) return (*current_xmachine->xmachine_Eurostat).financial_market_net_revenue_reg_1;

    // suppress compiler warning by returning dummy value /
    // this statement should rightfully NEVER be reached /
    return (double)0;
}

/** \fn void set_financial_market_net_revenue_reg_2(double financial_market_net_revenue_reg_2)
 * \brief Set financial_market_net_revenue_reg_2 memory variable for current X-machine.
 * \param financial_market_net_revenue_reg_2 New value for variable.
 */
void set_financial_market_net_revenue_reg_2(double financial_market_net_revenue_reg_2)
{
	if(current_xmachine->xmachine_Eurostat) (*current_xmachine->xmachine_Eurostat).financial_market_net_revenue_reg_2 = financial_market_net_revenue_reg_2;
}

/** \fn double get_financial_market_net_revenue_reg_2()
 * \brief Get financial_market_net_revenue_reg_2 memory variable from current X-machine.
 * \return Value for variable.
 */
double get_financial_market_net_revenue_reg_2()
{
	if(current_xmachine->xmachine_Eurostat) return (*current_xmachine->xmachine_Eurostat).financial_market_net_revenue_reg_2;

    // suppress compiler warning by returning dummy value /
    // this statement should rightfully NEVER be reached /
    return (double)0;
}

/** \fn void set_average_s_skill(double average_s_skill)
 * \brief Set average_s_skill memory variable for current X-machine.
 * \param average_s_skill New value for variable.
 */
void set_average_s_skill(double average_s_skill)
{
	if(current_xmachine->xmachine_Eurostat) (*current_xmachine->xmachine_Eurostat).average_s_skill = average_s_skill;
}

/** \fn double get_average_s_skill()
 * \brief Get average_s_skill memory variable from current X-machine.
 * \return Value for variable.
 */
double get_average_s_skill()
{
	if(current_xmachine->xmachine_Eurostat) return (*current_xmachine->xmachine_Eurostat).average_s_skill;

    // suppress compiler warning by returning dummy value /
    // this statement should rightfully NEVER be reached /
    return (double)0;
}

/** \fn void set_average_s_skill_1(double average_s_skill_1)
 * \brief Set average_s_skill_1 memory variable for current X-machine.
 * \param average_s_skill_1 New value for variable.
 */
void set_average_s_skill_1(double average_s_skill_1)
{
	if(current_xmachine->xmachine_Eurostat) (*current_xmachine->xmachine_Eurostat).average_s_skill_1 = average_s_skill_1;
}

/** \fn double get_average_s_skill_1()
 * \brief Get average_s_skill_1 memory variable from current X-machine.
 * \return Value for variable.
 */
double get_average_s_skill_1()
{
	if(current_xmachine->xmachine_Eurostat) return (*current_xmachine->xmachine_Eurostat).average_s_skill_1;

    // suppress compiler warning by returning dummy value /
    // this statement should rightfully NEVER be reached /
    return (double)0;
}

/** \fn void set_average_s_skill_2(double average_s_skill_2)
 * \brief Set average_s_skill_2 memory variable for current X-machine.
 * \param average_s_skill_2 New value for variable.
 */
void set_average_s_skill_2(double average_s_skill_2)
{
	if(current_xmachine->xmachine_Eurostat) (*current_xmachine->xmachine_Eurostat).average_s_skill_2 = average_s_skill_2;
}

/** \fn double get_average_s_skill_2()
 * \brief Get average_s_skill_2 memory variable from current X-machine.
 * \return Value for variable.
 */
double get_average_s_skill_2()
{
	if(current_xmachine->xmachine_Eurostat) return (*current_xmachine->xmachine_Eurostat).average_s_skill_2;

    // suppress compiler warning by returning dummy value /
    // this statement should rightfully NEVER be reached /
    return (double)0;
}

/** \fn void set_average_s_skill_3(double average_s_skill_3)
 * \brief Set average_s_skill_3 memory variable for current X-machine.
 * \param average_s_skill_3 New value for variable.
 */
void set_average_s_skill_3(double average_s_skill_3)
{
	if(current_xmachine->xmachine_Eurostat) (*current_xmachine->xmachine_Eurostat).average_s_skill_3 = average_s_skill_3;
}

/** \fn double get_average_s_skill_3()
 * \brief Get average_s_skill_3 memory variable from current X-machine.
 * \return Value for variable.
 */
double get_average_s_skill_3()
{
	if(current_xmachine->xmachine_Eurostat) return (*current_xmachine->xmachine_Eurostat).average_s_skill_3;

    // suppress compiler warning by returning dummy value /
    // this statement should rightfully NEVER be reached /
    return (double)0;
}

/** \fn void set_average_s_skill_4(double average_s_skill_4)
 * \brief Set average_s_skill_4 memory variable for current X-machine.
 * \param average_s_skill_4 New value for variable.
 */
void set_average_s_skill_4(double average_s_skill_4)
{
	if(current_xmachine->xmachine_Eurostat) (*current_xmachine->xmachine_Eurostat).average_s_skill_4 = average_s_skill_4;
}

/** \fn double get_average_s_skill_4()
 * \brief Get average_s_skill_4 memory variable from current X-machine.
 * \return Value for variable.
 */
double get_average_s_skill_4()
{
	if(current_xmachine->xmachine_Eurostat) return (*current_xmachine->xmachine_Eurostat).average_s_skill_4;

    // suppress compiler warning by returning dummy value /
    // this statement should rightfully NEVER be reached /
    return (double)0;
}

/** \fn void set_average_s_skill_5(double average_s_skill_5)
 * \brief Set average_s_skill_5 memory variable for current X-machine.
 * \param average_s_skill_5 New value for variable.
 */
void set_average_s_skill_5(double average_s_skill_5)
{
	if(current_xmachine->xmachine_Eurostat) (*current_xmachine->xmachine_Eurostat).average_s_skill_5 = average_s_skill_5;
}

/** \fn double get_average_s_skill_5()
 * \brief Get average_s_skill_5 memory variable from current X-machine.
 * \return Value for variable.
 */
double get_average_s_skill_5()
{
	if(current_xmachine->xmachine_Eurostat) return (*current_xmachine->xmachine_Eurostat).average_s_skill_5;

    // suppress compiler warning by returning dummy value /
    // this statement should rightfully NEVER be reached /
    return (double)0;
}

/** \fn void set_total_consumption_budget(double total_consumption_budget)
 * \brief Set total_consumption_budget memory variable for current X-machine.
 * \param total_consumption_budget New value for variable.
 */
void set_total_consumption_budget(double total_consumption_budget)
{
	if(current_xmachine->xmachine_Eurostat) (*current_xmachine->xmachine_Eurostat).total_consumption_budget = total_consumption_budget;
}

/** \fn double get_total_consumption_budget()
 * \brief Get total_consumption_budget memory variable from current X-machine.
 * \return Value for variable.
 */
double get_total_consumption_budget()
{
	if(current_xmachine->xmachine_Eurostat) return (*current_xmachine->xmachine_Eurostat).total_consumption_budget;

    // suppress compiler warning by returning dummy value /
    // this statement should rightfully NEVER be reached /
    return (double)0;
}

/** \fn void set_no_firms(int no_firms)
 * \brief Set no_firms memory variable for current X-machine.
 * \param no_firms New value for variable.
 */
void set_no_firms(int no_firms)
{
	if(current_xmachine->xmachine_Eurostat) (*current_xmachine->xmachine_Eurostat).no_firms = no_firms;
}

/** \fn int get_no_firms()
 * \brief Get no_firms memory variable from current X-machine.
 * \return Value for variable.
 */
int get_no_firms()
{
	if(current_xmachine->xmachine_Eurostat) return (*current_xmachine->xmachine_Eurostat).no_firms;

    // suppress compiler warning by returning dummy value /
    // this statement should rightfully NEVER be reached /
    return (int)0;
}

/** \fn void set_no_active_firms(int no_active_firms)
 * \brief Set no_active_firms memory variable for current X-machine.
 * \param no_active_firms New value for variable.
 */
void set_no_active_firms(int no_active_firms)
{
	if(current_xmachine->xmachine_Eurostat) (*current_xmachine->xmachine_Eurostat).no_active_firms = no_active_firms;
}

/** \fn int get_no_active_firms()
 * \brief Get no_active_firms memory variable from current X-machine.
 * \return Value for variable.
 */
int get_no_active_firms()
{
	if(current_xmachine->xmachine_Eurostat) return (*current_xmachine->xmachine_Eurostat).no_active_firms;

    // suppress compiler warning by returning dummy value /
    // this statement should rightfully NEVER be reached /
    return (int)0;
}

/** \fn void set_no_vacancies(int no_vacancies)
 * \brief Set no_vacancies memory variable for current X-machine.
 * \param no_vacancies New value for variable.
 */
void set_no_vacancies(int no_vacancies)
{
	if(current_xmachine->xmachine_Eurostat) (*current_xmachine->xmachine_Eurostat).no_vacancies = no_vacancies;
}

/** \fn int get_no_vacancies()
 * \brief Get no_vacancies memory variable from current X-machine.
 * \return Value for variable.
 */
int get_no_vacancies()
{
	if(current_xmachine->xmachine_Eurostat) return (*current_xmachine->xmachine_Eurostat).no_vacancies;

    // suppress compiler warning by returning dummy value /
    // this statement should rightfully NEVER be reached /
    return (int)0;
}

/** \fn void set_no_posted_vacancies(int no_posted_vacancies)
 * \brief Set no_posted_vacancies memory variable for current X-machine.
 * \param no_posted_vacancies New value for variable.
 */
void set_no_posted_vacancies(int no_posted_vacancies)
{
	if(current_xmachine->xmachine_Eurostat) (*current_xmachine->xmachine_Eurostat).no_posted_vacancies = no_posted_vacancies;
}

/** \fn int get_no_posted_vacancies()
 * \brief Get no_posted_vacancies memory variable from current X-machine.
 * \return Value for variable.
 */
int get_no_posted_vacancies()
{
	if(current_xmachine->xmachine_Eurostat) return (*current_xmachine->xmachine_Eurostat).no_posted_vacancies;

    // suppress compiler warning by returning dummy value /
    // this statement should rightfully NEVER be reached /
    return (int)0;
}

/** \fn void set_no_employees_r_and_d(int no_employees_r_and_d)
 * \brief Set no_employees_r_and_d memory variable for current X-machine.
 * \param no_employees_r_and_d New value for variable.
 */
void set_no_employees_r_and_d(int no_employees_r_and_d)
{
	if(current_xmachine->xmachine_Eurostat) (*current_xmachine->xmachine_Eurostat).no_employees_r_and_d = no_employees_r_and_d;
}

/** \fn int get_no_employees_r_and_d()
 * \brief Get no_employees_r_and_d memory variable from current X-machine.
 * \return Value for variable.
 */
int get_no_employees_r_and_d()
{
	if(current_xmachine->xmachine_Eurostat) return (*current_xmachine->xmachine_Eurostat).no_employees_r_and_d;

    // suppress compiler warning by returning dummy value /
    // this statement should rightfully NEVER be reached /
    return (int)0;
}

/** \fn price_quality_pair_array get_price_quality_combination()
 * \brief Get price_quality_combination memory variable from current X-machine.
 * \return Value for variable.
 */
price_quality_pair_array * get_price_quality_combination()
{
	if(current_xmachine->xmachine_Eurostat) return &(*current_xmachine->xmachine_Eurostat).price_quality_combination;

    // suppress compiler warning by returning dummy value /
    // this statement should rightfully NEVER be reached /
    return NULL;
}

/** \fn void set_firm_average_wage(double firm_average_wage)
 * \brief Set firm_average_wage memory variable for current X-machine.
 * \param firm_average_wage New value for variable.
 */
void set_firm_average_wage(double firm_average_wage)
{
	if(current_xmachine->xmachine_Eurostat) (*current_xmachine->xmachine_Eurostat).firm_average_wage = firm_average_wage;
}

/** \fn double get_firm_average_wage()
 * \brief Get firm_average_wage memory variable from current X-machine.
 * \return Value for variable.
 */
double get_firm_average_wage()
{
	if(current_xmachine->xmachine_Eurostat) return (*current_xmachine->xmachine_Eurostat).firm_average_wage;

    // suppress compiler warning by returning dummy value /
    // this statement should rightfully NEVER be reached /
    return (double)0;
}

/** \fn void set_firm_average_production_wage(double firm_average_production_wage)
 * \brief Set firm_average_production_wage memory variable for current X-machine.
 * \param firm_average_production_wage New value for variable.
 */
void set_firm_average_production_wage(double firm_average_production_wage)
{
	if(current_xmachine->xmachine_Eurostat) (*current_xmachine->xmachine_Eurostat).firm_average_production_wage = firm_average_production_wage;
}

/** \fn double get_firm_average_production_wage()
 * \brief Get firm_average_production_wage memory variable from current X-machine.
 * \return Value for variable.
 */
double get_firm_average_production_wage()
{
	if(current_xmachine->xmachine_Eurostat) return (*current_xmachine->xmachine_Eurostat).firm_average_production_wage;

    // suppress compiler warning by returning dummy value /
    // this statement should rightfully NEVER be reached /
    return (double)0;
}

/** \fn void set_firm_average_r_and_d_wage(double firm_average_r_and_d_wage)
 * \brief Set firm_average_r_and_d_wage memory variable for current X-machine.
 * \param firm_average_r_and_d_wage New value for variable.
 */
void set_firm_average_r_and_d_wage(double firm_average_r_and_d_wage)
{
	if(current_xmachine->xmachine_Eurostat) (*current_xmachine->xmachine_Eurostat).firm_average_r_and_d_wage = firm_average_r_and_d_wage;
}

/** \fn double get_firm_average_r_and_d_wage()
 * \brief Get firm_average_r_and_d_wage memory variable from current X-machine.
 * \return Value for variable.
 */
double get_firm_average_r_and_d_wage()
{
	if(current_xmachine->xmachine_Eurostat) return (*current_xmachine->xmachine_Eurostat).firm_average_r_and_d_wage;

    // suppress compiler warning by returning dummy value /
    // this statement should rightfully NEVER be reached /
    return (double)0;
}

/** \fn void set_firm_average_wage_skill_1(double firm_average_wage_skill_1)
 * \brief Set firm_average_wage_skill_1 memory variable for current X-machine.
 * \param firm_average_wage_skill_1 New value for variable.
 */
void set_firm_average_wage_skill_1(double firm_average_wage_skill_1)
{
	if(current_xmachine->xmachine_Eurostat) (*current_xmachine->xmachine_Eurostat).firm_average_wage_skill_1 = firm_average_wage_skill_1;
}

/** \fn double get_firm_average_wage_skill_1()
 * \brief Get firm_average_wage_skill_1 memory variable from current X-machine.
 * \return Value for variable.
 */
double get_firm_average_wage_skill_1()
{
	if(current_xmachine->xmachine_Eurostat) return (*current_xmachine->xmachine_Eurostat).firm_average_wage_skill_1;

    // suppress compiler warning by returning dummy value /
    // this statement should rightfully NEVER be reached /
    return (double)0;
}

/** \fn void set_firm_average_wage_skill_2(double firm_average_wage_skill_2)
 * \brief Set firm_average_wage_skill_2 memory variable for current X-machine.
 * \param firm_average_wage_skill_2 New value for variable.
 */
void set_firm_average_wage_skill_2(double firm_average_wage_skill_2)
{
	if(current_xmachine->xmachine_Eurostat) (*current_xmachine->xmachine_Eurostat).firm_average_wage_skill_2 = firm_average_wage_skill_2;
}

/** \fn double get_firm_average_wage_skill_2()
 * \brief Get firm_average_wage_skill_2 memory variable from current X-machine.
 * \return Value for variable.
 */
double get_firm_average_wage_skill_2()
{
	if(current_xmachine->xmachine_Eurostat) return (*current_xmachine->xmachine_Eurostat).firm_average_wage_skill_2;

    // suppress compiler warning by returning dummy value /
    // this statement should rightfully NEVER be reached /
    return (double)0;
}

/** \fn void set_firm_average_wage_skill_3(double firm_average_wage_skill_3)
 * \brief Set firm_average_wage_skill_3 memory variable for current X-machine.
 * \param firm_average_wage_skill_3 New value for variable.
 */
void set_firm_average_wage_skill_3(double firm_average_wage_skill_3)
{
	if(current_xmachine->xmachine_Eurostat) (*current_xmachine->xmachine_Eurostat).firm_average_wage_skill_3 = firm_average_wage_skill_3;
}

/** \fn double get_firm_average_wage_skill_3()
 * \brief Get firm_average_wage_skill_3 memory variable from current X-machine.
 * \return Value for variable.
 */
double get_firm_average_wage_skill_3()
{
	if(current_xmachine->xmachine_Eurostat) return (*current_xmachine->xmachine_Eurostat).firm_average_wage_skill_3;

    // suppress compiler warning by returning dummy value /
    // this statement should rightfully NEVER be reached /
    return (double)0;
}

/** \fn void set_firm_average_wage_skill_4(double firm_average_wage_skill_4)
 * \brief Set firm_average_wage_skill_4 memory variable for current X-machine.
 * \param firm_average_wage_skill_4 New value for variable.
 */
void set_firm_average_wage_skill_4(double firm_average_wage_skill_4)
{
	if(current_xmachine->xmachine_Eurostat) (*current_xmachine->xmachine_Eurostat).firm_average_wage_skill_4 = firm_average_wage_skill_4;
}

/** \fn double get_firm_average_wage_skill_4()
 * \brief Get firm_average_wage_skill_4 memory variable from current X-machine.
 * \return Value for variable.
 */
double get_firm_average_wage_skill_4()
{
	if(current_xmachine->xmachine_Eurostat) return (*current_xmachine->xmachine_Eurostat).firm_average_wage_skill_4;

    // suppress compiler warning by returning dummy value /
    // this statement should rightfully NEVER be reached /
    return (double)0;
}

/** \fn void set_firm_average_wage_skill_5(double firm_average_wage_skill_5)
 * \brief Set firm_average_wage_skill_5 memory variable for current X-machine.
 * \param firm_average_wage_skill_5 New value for variable.
 */
void set_firm_average_wage_skill_5(double firm_average_wage_skill_5)
{
	if(current_xmachine->xmachine_Eurostat) (*current_xmachine->xmachine_Eurostat).firm_average_wage_skill_5 = firm_average_wage_skill_5;
}

/** \fn double get_firm_average_wage_skill_5()
 * \brief Get firm_average_wage_skill_5 memory variable from current X-machine.
 * \return Value for variable.
 */
double get_firm_average_wage_skill_5()
{
	if(current_xmachine->xmachine_Eurostat) return (*current_xmachine->xmachine_Eurostat).firm_average_wage_skill_5;

    // suppress compiler warning by returning dummy value /
    // this statement should rightfully NEVER be reached /
    return (double)0;
}

/** \fn void set_firm_average_g_skill(double firm_average_g_skill)
 * \brief Set firm_average_g_skill memory variable for current X-machine.
 * \param firm_average_g_skill New value for variable.
 */
void set_firm_average_g_skill(double firm_average_g_skill)
{
	if(current_xmachine->xmachine_Eurostat) (*current_xmachine->xmachine_Eurostat).firm_average_g_skill = firm_average_g_skill;
}

/** \fn double get_firm_average_g_skill()
 * \brief Get firm_average_g_skill memory variable from current X-machine.
 * \return Value for variable.
 */
double get_firm_average_g_skill()
{
	if(current_xmachine->xmachine_Eurostat) return (*current_xmachine->xmachine_Eurostat).firm_average_g_skill;

    // suppress compiler warning by returning dummy value /
    // this statement should rightfully NEVER be reached /
    return (double)0;
}

/** \fn void set_firm_average_s_skill(double firm_average_s_skill)
 * \brief Set firm_average_s_skill memory variable for current X-machine.
 * \param firm_average_s_skill New value for variable.
 */
void set_firm_average_s_skill(double firm_average_s_skill)
{
	if(current_xmachine->xmachine_Eurostat) (*current_xmachine->xmachine_Eurostat).firm_average_s_skill = firm_average_s_skill;
}

/** \fn double get_firm_average_s_skill()
 * \brief Get firm_average_s_skill memory variable from current X-machine.
 * \return Value for variable.
 */
double get_firm_average_s_skill()
{
	if(current_xmachine->xmachine_Eurostat) return (*current_xmachine->xmachine_Eurostat).firm_average_s_skill;

    // suppress compiler warning by returning dummy value /
    // this statement should rightfully NEVER be reached /
    return (double)0;
}

/** \fn void set_firm_average_s_skill_1(double firm_average_s_skill_1)
 * \brief Set firm_average_s_skill_1 memory variable for current X-machine.
 * \param firm_average_s_skill_1 New value for variable.
 */
void set_firm_average_s_skill_1(double firm_average_s_skill_1)
{
	if(current_xmachine->xmachine_Eurostat) (*current_xmachine->xmachine_Eurostat).firm_average_s_skill_1 = firm_average_s_skill_1;
}

/** \fn double get_firm_average_s_skill_1()
 * \brief Get firm_average_s_skill_1 memory variable from current X-machine.
 * \return Value for variable.
 */
double get_firm_average_s_skill_1()
{
	if(current_xmachine->xmachine_Eurostat) return (*current_xmachine->xmachine_Eurostat).firm_average_s_skill_1;

    // suppress compiler warning by returning dummy value /
    // this statement should rightfully NEVER be reached /
    return (double)0;
}

/** \fn void set_firm_average_s_skill_2(double firm_average_s_skill_2)
 * \brief Set firm_average_s_skill_2 memory variable for current X-machine.
 * \param firm_average_s_skill_2 New value for variable.
 */
void set_firm_average_s_skill_2(double firm_average_s_skill_2)
{
	if(current_xmachine->xmachine_Eurostat) (*current_xmachine->xmachine_Eurostat).firm_average_s_skill_2 = firm_average_s_skill_2;
}

/** \fn double get_firm_average_s_skill_2()
 * \brief Get firm_average_s_skill_2 memory variable from current X-machine.
 * \return Value for variable.
 */
double get_firm_average_s_skill_2()
{
	if(current_xmachine->xmachine_Eurostat) return (*current_xmachine->xmachine_Eurostat).firm_average_s_skill_2;

    // suppress compiler warning by returning dummy value /
    // this statement should rightfully NEVER be reached /
    return (double)0;
}

/** \fn void set_firm_average_s_skill_3(double firm_average_s_skill_3)
 * \brief Set firm_average_s_skill_3 memory variable for current X-machine.
 * \param firm_average_s_skill_3 New value for variable.
 */
void set_firm_average_s_skill_3(double firm_average_s_skill_3)
{
	if(current_xmachine->xmachine_Eurostat) (*current_xmachine->xmachine_Eurostat).firm_average_s_skill_3 = firm_average_s_skill_3;
}

/** \fn double get_firm_average_s_skill_3()
 * \brief Get firm_average_s_skill_3 memory variable from current X-machine.
 * \return Value for variable.
 */
double get_firm_average_s_skill_3()
{
	if(current_xmachine->xmachine_Eurostat) return (*current_xmachine->xmachine_Eurostat).firm_average_s_skill_3;

    // suppress compiler warning by returning dummy value /
    // this statement should rightfully NEVER be reached /
    return (double)0;
}

/** \fn void set_firm_average_s_skill_4(double firm_average_s_skill_4)
 * \brief Set firm_average_s_skill_4 memory variable for current X-machine.
 * \param firm_average_s_skill_4 New value for variable.
 */
void set_firm_average_s_skill_4(double firm_average_s_skill_4)
{
	if(current_xmachine->xmachine_Eurostat) (*current_xmachine->xmachine_Eurostat).firm_average_s_skill_4 = firm_average_s_skill_4;
}

/** \fn double get_firm_average_s_skill_4()
 * \brief Get firm_average_s_skill_4 memory variable from current X-machine.
 * \return Value for variable.
 */
double get_firm_average_s_skill_4()
{
	if(current_xmachine->xmachine_Eurostat) return (*current_xmachine->xmachine_Eurostat).firm_average_s_skill_4;

    // suppress compiler warning by returning dummy value /
    // this statement should rightfully NEVER be reached /
    return (double)0;
}

/** \fn void set_firm_average_s_skill_5(double firm_average_s_skill_5)
 * \brief Set firm_average_s_skill_5 memory variable for current X-machine.
 * \param firm_average_s_skill_5 New value for variable.
 */
void set_firm_average_s_skill_5(double firm_average_s_skill_5)
{
	if(current_xmachine->xmachine_Eurostat) (*current_xmachine->xmachine_Eurostat).firm_average_s_skill_5 = firm_average_s_skill_5;
}

/** \fn double get_firm_average_s_skill_5()
 * \brief Get firm_average_s_skill_5 memory variable from current X-machine.
 * \return Value for variable.
 */
double get_firm_average_s_skill_5()
{
	if(current_xmachine->xmachine_Eurostat) return (*current_xmachine->xmachine_Eurostat).firm_average_s_skill_5;

    // suppress compiler warning by returning dummy value /
    // this statement should rightfully NEVER be reached /
    return (double)0;
}

/** \fn void set_firm_average_quality(double firm_average_quality)
 * \brief Set firm_average_quality memory variable for current X-machine.
 * \param firm_average_quality New value for variable.
 */
void set_firm_average_quality(double firm_average_quality)
{
	if(current_xmachine->xmachine_Eurostat) (*current_xmachine->xmachine_Eurostat).firm_average_quality = firm_average_quality;
}

/** \fn double get_firm_average_quality()
 * \brief Get firm_average_quality memory variable from current X-machine.
 * \return Value for variable.
 */
double get_firm_average_quality()
{
	if(current_xmachine->xmachine_Eurostat) return (*current_xmachine->xmachine_Eurostat).firm_average_quality;

    // suppress compiler warning by returning dummy value /
    // this statement should rightfully NEVER be reached /
    return (double)0;
}

/** \fn void set_firm_average_price(double firm_average_price)
 * \brief Set firm_average_price memory variable for current X-machine.
 * \param firm_average_price New value for variable.
 */
void set_firm_average_price(double firm_average_price)
{
	if(current_xmachine->xmachine_Eurostat) (*current_xmachine->xmachine_Eurostat).firm_average_price = firm_average_price;
}

/** \fn double get_firm_average_price()
 * \brief Get firm_average_price memory variable from current X-machine.
 * \return Value for variable.
 */
double get_firm_average_price()
{
	if(current_xmachine->xmachine_Eurostat) return (*current_xmachine->xmachine_Eurostat).firm_average_price;

    // suppress compiler warning by returning dummy value /
    // this statement should rightfully NEVER be reached /
    return (double)0;
}

/** \fn firm_data_array get_region_firm_data()
 * \brief Get region_firm_data memory variable from current X-machine.
 * \return Value for variable.
 */
firm_data_array * get_region_firm_data()
{
	if(current_xmachine->xmachine_Eurostat) return &(*current_xmachine->xmachine_Eurostat).region_firm_data;

    // suppress compiler warning by returning dummy value /
    // this statement should rightfully NEVER be reached /
    return NULL;
}

/** \fn household_data_array get_region_household_data()
 * \brief Get region_household_data memory variable from current X-machine.
 * \return Value for variable.
 */
household_data_array * get_region_household_data()
{
	if(current_xmachine->xmachine_Eurostat) return &(*current_xmachine->xmachine_Eurostat).region_household_data;

    // suppress compiler warning by returning dummy value /
    // this statement should rightfully NEVER be reached /
    return NULL;
}

/** \fn government_data_array get_region_government_data()
 * \brief Get region_government_data memory variable from current X-machine.
 * \return Value for variable.
 */
government_data_array * get_region_government_data()
{
	if(current_xmachine->xmachine_Eurostat) return &(*current_xmachine->xmachine_Eurostat).region_government_data;

    // suppress compiler warning by returning dummy value /
    // this statement should rightfully NEVER be reached /
    return NULL;
}

/** \fn void set_total_earnings(double total_earnings)
 * \brief Set total_earnings memory variable for current X-machine.
 * \param total_earnings New value for variable.
 */
void set_total_earnings(double total_earnings)
{
	if(current_xmachine->xmachine_Eurostat) (*current_xmachine->xmachine_Eurostat).total_earnings = total_earnings;
}

/** \fn double get_total_earnings()
 * \brief Get total_earnings memory variable from current X-machine.
 * \return Value for variable.
 */
double get_total_earnings()
{
	if(current_xmachine->xmachine_Eurostat) return (*current_xmachine->xmachine_Eurostat).total_earnings;

    // suppress compiler warning by returning dummy value /
    // this statement should rightfully NEVER be reached /
    return (double)0;
}

/** \fn void set_total_equity(double total_equity)
 * \brief Set total_equity memory variable for current X-machine.
 * \param total_equity New value for variable.
 */
void set_total_equity(double total_equity)
{
	if(current_xmachine->xmachine_Eurostat) (*current_xmachine->xmachine_Eurostat).total_equity = total_equity;
}

/** \fn double get_total_equity()
 * \brief Get total_equity memory variable from current X-machine.
 * \return Value for variable.
 */
double get_total_equity()
{
	if(current_xmachine->xmachine_Eurostat) return (*current_xmachine->xmachine_Eurostat).total_equity;

    // suppress compiler warning by returning dummy value /
    // this statement should rightfully NEVER be reached /
    return (double)0;
}

/** \fn void set_average_debt_earnings_ratio(double average_debt_earnings_ratio)
 * \brief Set average_debt_earnings_ratio memory variable for current X-machine.
 * \param average_debt_earnings_ratio New value for variable.
 */
void set_average_debt_earnings_ratio(double average_debt_earnings_ratio)
{
	if(current_xmachine->xmachine_Eurostat) (*current_xmachine->xmachine_Eurostat).average_debt_earnings_ratio = average_debt_earnings_ratio;
}

/** \fn double get_average_debt_earnings_ratio()
 * \brief Get average_debt_earnings_ratio memory variable from current X-machine.
 * \return Value for variable.
 */
double get_average_debt_earnings_ratio()
{
	if(current_xmachine->xmachine_Eurostat) return (*current_xmachine->xmachine_Eurostat).average_debt_earnings_ratio;

    // suppress compiler warning by returning dummy value /
    // this statement should rightfully NEVER be reached /
    return (double)0;
}

/** \fn void set_average_debt_equity_ratio(double average_debt_equity_ratio)
 * \brief Set average_debt_equity_ratio memory variable for current X-machine.
 * \param average_debt_equity_ratio New value for variable.
 */
void set_average_debt_equity_ratio(double average_debt_equity_ratio)
{
	if(current_xmachine->xmachine_Eurostat) (*current_xmachine->xmachine_Eurostat).average_debt_equity_ratio = average_debt_equity_ratio;
}

/** \fn double get_average_debt_equity_ratio()
 * \brief Get average_debt_equity_ratio memory variable from current X-machine.
 * \return Value for variable.
 */
double get_average_debt_equity_ratio()
{
	if(current_xmachine->xmachine_Eurostat) return (*current_xmachine->xmachine_Eurostat).average_debt_equity_ratio;

    // suppress compiler warning by returning dummy value /
    // this statement should rightfully NEVER be reached /
    return (double)0;
}

/** \fn void set_labour_share_ratio(double labour_share_ratio)
 * \brief Set labour_share_ratio memory variable for current X-machine.
 * \param labour_share_ratio New value for variable.
 */
void set_labour_share_ratio(double labour_share_ratio)
{
	if(current_xmachine->xmachine_Eurostat) (*current_xmachine->xmachine_Eurostat).labour_share_ratio = labour_share_ratio;
}

/** \fn double get_labour_share_ratio()
 * \brief Get labour_share_ratio memory variable from current X-machine.
 * \return Value for variable.
 */
double get_labour_share_ratio()
{
	if(current_xmachine->xmachine_Eurostat) return (*current_xmachine->xmachine_Eurostat).labour_share_ratio;

    // suppress compiler warning by returning dummy value /
    // this statement should rightfully NEVER be reached /
    return (double)0;
}

/** \fn void set_hpi(double hpi)
 * \brief Set hpi memory variable for current X-machine.
 * \param hpi New value for variable.
 */
void set_hpi(double hpi)
{
	if(current_xmachine->xmachine_Eurostat) (*current_xmachine->xmachine_Eurostat).hpi = hpi;
}

/** \fn double get_hpi()
 * \brief Get hpi memory variable from current X-machine.
 * \return Value for variable.
 */
double get_hpi()
{
	if(current_xmachine->xmachine_Eurostat) return (*current_xmachine->xmachine_Eurostat).hpi;

    // suppress compiler warning by returning dummy value /
    // this statement should rightfully NEVER be reached /
    return (double)0;
}

/** \fn adt_subsidies_per_government_array get_subsidies_per_government()
 * \brief Get subsidies_per_government memory variable from current X-machine.
 * \return Value for variable.
 */
adt_subsidies_per_government_array * get_subsidies_per_government()
{
	if(current_xmachine->xmachine_Eurostat) return &(*current_xmachine->xmachine_Eurostat).subsidies_per_government;

    // suppress compiler warning by returning dummy value /
    // this statement should rightfully NEVER be reached /
    return NULL;
}

/** \fn adt_subsidies_per_government_array get_subsidies_balanced()
 * \brief Get subsidies_balanced memory variable from current X-machine.
 * \return Value for variable.
 */
adt_subsidies_per_government_array * get_subsidies_balanced()
{
	if(current_xmachine->xmachine_Eurostat) return &(*current_xmachine->xmachine_Eurostat).subsidies_balanced;

    // suppress compiler warning by returning dummy value /
    // this statement should rightfully NEVER be reached /
    return NULL;
}

/** \fn void set_gdp(double gdp)
 * \brief Set gdp memory variable for current X-machine.
 * \param gdp New value for variable.
 */
void set_gdp(double gdp)
{
	if(current_xmachine->xmachine_Eurostat) (*current_xmachine->xmachine_Eurostat).gdp = gdp;
}

/** \fn double get_gdp()
 * \brief Get gdp memory variable from current X-machine.
 * \return Value for variable.
 */
double get_gdp()
{
	if(current_xmachine->xmachine_Eurostat) return (*current_xmachine->xmachine_Eurostat).gdp;

    // suppress compiler warning by returning dummy value /
    // this statement should rightfully NEVER be reached /
    return (double)0;
}

/** \fn void set_monthly_investment_value(double monthly_investment_value)
 * \brief Set monthly_investment_value memory variable for current X-machine.
 * \param monthly_investment_value New value for variable.
 */
void set_monthly_investment_value(double monthly_investment_value)
{
	if(current_xmachine->xmachine_Eurostat) (*current_xmachine->xmachine_Eurostat).monthly_investment_value = monthly_investment_value;
}

/** \fn double get_monthly_investment_value()
 * \brief Get monthly_investment_value memory variable from current X-machine.
 * \return Value for variable.
 */
double get_monthly_investment_value()
{
	if(current_xmachine->xmachine_Eurostat) return (*current_xmachine->xmachine_Eurostat).monthly_investment_value;

    // suppress compiler warning by returning dummy value /
    // this statement should rightfully NEVER be reached /
    return (double)0;
}

/** \fn void set_monthly_sold_quantity(double monthly_sold_quantity)
 * \brief Set monthly_sold_quantity memory variable for current X-machine.
 * \param monthly_sold_quantity New value for variable.
 */
void set_monthly_sold_quantity(double monthly_sold_quantity)
{
	if(current_xmachine->xmachine_Eurostat) (*current_xmachine->xmachine_Eurostat).monthly_sold_quantity = monthly_sold_quantity;
}

/** \fn double get_monthly_sold_quantity()
 * \brief Get monthly_sold_quantity memory variable from current X-machine.
 * \return Value for variable.
 */
double get_monthly_sold_quantity()
{
	if(current_xmachine->xmachine_Eurostat) return (*current_xmachine->xmachine_Eurostat).monthly_sold_quantity;

    // suppress compiler warning by returning dummy value /
    // this statement should rightfully NEVER be reached /
    return (double)0;
}

/** \fn void set_herfindahl_index(double herfindahl_index)
 * \brief Set herfindahl_index memory variable for current X-machine.
 * \param herfindahl_index New value for variable.
 */
void set_herfindahl_index(double herfindahl_index)
{
	if(current_xmachine->xmachine_Eurostat) (*current_xmachine->xmachine_Eurostat).herfindahl_index = herfindahl_index;
}

/** \fn double get_herfindahl_index()
 * \brief Get herfindahl_index memory variable from current X-machine.
 * \return Value for variable.
 */
double get_herfindahl_index()
{
	if(current_xmachine->xmachine_Eurostat) return (*current_xmachine->xmachine_Eurostat).herfindahl_index;

    // suppress compiler warning by returning dummy value /
    // this statement should rightfully NEVER be reached /
    return (double)0;
}

/** \fn void set_monthly_output(double monthly_output)
 * \brief Set monthly_output memory variable for current X-machine.
 * \param monthly_output New value for variable.
 */
void set_monthly_output(double monthly_output)
{
	if(current_xmachine->xmachine_Eurostat) (*current_xmachine->xmachine_Eurostat).monthly_output = monthly_output;
}

/** \fn double get_monthly_output()
 * \brief Get monthly_output memory variable from current X-machine.
 * \return Value for variable.
 */
double get_monthly_output()
{
	if(current_xmachine->xmachine_Eurostat) return (*current_xmachine->xmachine_Eurostat).monthly_output;

    // suppress compiler warning by returning dummy value /
    // this statement should rightfully NEVER be reached /
    return (double)0;
}

/** \fn void set_monthly_revenue(double monthly_revenue)
 * \brief Set monthly_revenue memory variable for current X-machine.
 * \param monthly_revenue New value for variable.
 */
void set_monthly_revenue(double monthly_revenue)
{
	if(current_xmachine->xmachine_Eurostat) (*current_xmachine->xmachine_Eurostat).monthly_revenue = monthly_revenue;
}

/** \fn double get_monthly_revenue()
 * \brief Get monthly_revenue memory variable from current X-machine.
 * \return Value for variable.
 */
double get_monthly_revenue()
{
	if(current_xmachine->xmachine_Eurostat) return (*current_xmachine->xmachine_Eurostat).monthly_revenue;

    // suppress compiler warning by returning dummy value /
    // this statement should rightfully NEVER be reached /
    return (double)0;
}

/** \fn void set_monthly_planned_output(double monthly_planned_output)
 * \brief Set monthly_planned_output memory variable for current X-machine.
 * \param monthly_planned_output New value for variable.
 */
void set_monthly_planned_output(double monthly_planned_output)
{
	if(current_xmachine->xmachine_Eurostat) (*current_xmachine->xmachine_Eurostat).monthly_planned_output = monthly_planned_output;
}

/** \fn double get_monthly_planned_output()
 * \brief Get monthly_planned_output memory variable from current X-machine.
 * \return Value for variable.
 */
double get_monthly_planned_output()
{
	if(current_xmachine->xmachine_Eurostat) return (*current_xmachine->xmachine_Eurostat).monthly_planned_output;

    // suppress compiler warning by returning dummy value /
    // this statement should rightfully NEVER be reached /
    return (double)0;
}

/** \fn history_item get_history_monthly()
 * \brief Get history_monthly memory variable from current X-machine.
 * \return Value for variable.
 */
history_item * get_history_monthly()
{
	if(current_xmachine->xmachine_Eurostat) return (*current_xmachine->xmachine_Eurostat).history_monthly;

    // suppress compiler warning by returning dummy value /
    // this statement should rightfully NEVER be reached /
    return NULL;
}

/** \fn history_item get_history_quarterly()
 * \brief Get history_quarterly memory variable from current X-machine.
 * \return Value for variable.
 */
history_item * get_history_quarterly()
{
	if(current_xmachine->xmachine_Eurostat) return (*current_xmachine->xmachine_Eurostat).history_quarterly;

    // suppress compiler warning by returning dummy value /
    // this statement should rightfully NEVER be reached /
    return NULL;
}

/** \fn history_item get_monthly_growth_rates()
 * \brief Get monthly_growth_rates memory variable from current X-machine.
 * \return Value for variable.
 */
history_item * get_monthly_growth_rates()
{
	if(current_xmachine->xmachine_Eurostat) return &(*current_xmachine->xmachine_Eurostat).monthly_growth_rates;

    // suppress compiler warning by returning dummy value /
    // this statement should rightfully NEVER be reached /
    return NULL;
}

/** \fn history_item get_quarterly_growth_rates()
 * \brief Get quarterly_growth_rates memory variable from current X-machine.
 * \return Value for variable.
 */
history_item * get_quarterly_growth_rates()
{
	if(current_xmachine->xmachine_Eurostat) return &(*current_xmachine->xmachine_Eurostat).quarterly_growth_rates;

    // suppress compiler warning by returning dummy value /
    // this statement should rightfully NEVER be reached /
    return NULL;
}

/** \fn history_item get_annual_growth_rates_monthly()
 * \brief Get annual_growth_rates_monthly memory variable from current X-machine.
 * \return Value for variable.
 */
history_item * get_annual_growth_rates_monthly()
{
	if(current_xmachine->xmachine_Eurostat) return &(*current_xmachine->xmachine_Eurostat).annual_growth_rates_monthly;

    // suppress compiler warning by returning dummy value /
    // this statement should rightfully NEVER be reached /
    return NULL;
}

/** \fn history_item get_annual_growth_rates_quarterly()
 * \brief Get annual_growth_rates_quarterly memory variable from current X-machine.
 * \return Value for variable.
 */
history_item * get_annual_growth_rates_quarterly()
{
	if(current_xmachine->xmachine_Eurostat) return &(*current_xmachine->xmachine_Eurostat).annual_growth_rates_quarterly;

    // suppress compiler warning by returning dummy value /
    // this statement should rightfully NEVER be reached /
    return NULL;
}

/** \fn void set_no_firm_births(int no_firm_births)
 * \brief Set no_firm_births memory variable for current X-machine.
 * \param no_firm_births New value for variable.
 */
void set_no_firm_births(int no_firm_births)
{
	if(current_xmachine->xmachine_Eurostat) (*current_xmachine->xmachine_Eurostat).no_firm_births = no_firm_births;
}

/** \fn int get_no_firm_births()
 * \brief Get no_firm_births memory variable from current X-machine.
 * \return Value for variable.
 */
int get_no_firm_births()
{
	if(current_xmachine->xmachine_Eurostat) return (*current_xmachine->xmachine_Eurostat).no_firm_births;

    // suppress compiler warning by returning dummy value /
    // this statement should rightfully NEVER be reached /
    return (int)0;
}

/** \fn void set_no_firm_deaths(int no_firm_deaths)
 * \brief Set no_firm_deaths memory variable for current X-machine.
 * \param no_firm_deaths New value for variable.
 */
void set_no_firm_deaths(int no_firm_deaths)
{
	if(current_xmachine->xmachine_Eurostat) (*current_xmachine->xmachine_Eurostat).no_firm_deaths = no_firm_deaths;
}

/** \fn int get_no_firm_deaths()
 * \brief Get no_firm_deaths memory variable from current X-machine.
 * \return Value for variable.
 */
int get_no_firm_deaths()
{
	if(current_xmachine->xmachine_Eurostat) return (*current_xmachine->xmachine_Eurostat).no_firm_deaths;

    // suppress compiler warning by returning dummy value /
    // this statement should rightfully NEVER be reached /
    return (int)0;
}

/** \fn int get_firm_age_distribution()
 * \brief Get firm_age_distribution memory variable from current X-machine.
 * \return Value for variable.
 */
int * get_firm_age_distribution()
{
	if(current_xmachine->xmachine_Eurostat) return (*current_xmachine->xmachine_Eurostat).firm_age_distribution;

    // suppress compiler warning by returning dummy value /
    // this statement should rightfully NEVER be reached /
    return NULL;
}

/** \fn int get_firm_age_distribution_multiperiod()
 * \brief Get firm_age_distribution_multiperiod memory variable from current X-machine.
 * \return Value for variable.
 */
int * get_firm_age_distribution_multiperiod()
{
	if(current_xmachine->xmachine_Eurostat) return (*current_xmachine->xmachine_Eurostat).firm_age_distribution_multiperiod;

    // suppress compiler warning by returning dummy value /
    // this statement should rightfully NEVER be reached /
    return NULL;
}

/** \fn int get_firm_age_distribution_1_period_lag()
 * \brief Get firm_age_distribution_1_period_lag memory variable from current X-machine.
 * \return Value for variable.
 */
int * get_firm_age_distribution_1_period_lag()
{
	if(current_xmachine->xmachine_Eurostat) return (*current_xmachine->xmachine_Eurostat).firm_age_distribution_1_period_lag;

    // suppress compiler warning by returning dummy value /
    // this statement should rightfully NEVER be reached /
    return NULL;
}

/** \fn int get_firm_age_distribution_2_period_lag()
 * \brief Get firm_age_distribution_2_period_lag memory variable from current X-machine.
 * \return Value for variable.
 */
int * get_firm_age_distribution_2_period_lag()
{
	if(current_xmachine->xmachine_Eurostat) return (*current_xmachine->xmachine_Eurostat).firm_age_distribution_2_period_lag;

    // suppress compiler warning by returning dummy value /
    // this statement should rightfully NEVER be reached /
    return NULL;
}

/** \fn void set_firm_birth_rate(double firm_birth_rate)
 * \brief Set firm_birth_rate memory variable for current X-machine.
 * \param firm_birth_rate New value for variable.
 */
void set_firm_birth_rate(double firm_birth_rate)
{
	if(current_xmachine->xmachine_Eurostat) (*current_xmachine->xmachine_Eurostat).firm_birth_rate = firm_birth_rate;
}

/** \fn double get_firm_birth_rate()
 * \brief Get firm_birth_rate memory variable from current X-machine.
 * \return Value for variable.
 */
double get_firm_birth_rate()
{
	if(current_xmachine->xmachine_Eurostat) return (*current_xmachine->xmachine_Eurostat).firm_birth_rate;

    // suppress compiler warning by returning dummy value /
    // this statement should rightfully NEVER be reached /
    return (double)0;
}

/** \fn void set_firm_death_rate(double firm_death_rate)
 * \brief Set firm_death_rate memory variable for current X-machine.
 * \param firm_death_rate New value for variable.
 */
void set_firm_death_rate(double firm_death_rate)
{
	if(current_xmachine->xmachine_Eurostat) (*current_xmachine->xmachine_Eurostat).firm_death_rate = firm_death_rate;
}

/** \fn double get_firm_death_rate()
 * \brief Get firm_death_rate memory variable from current X-machine.
 * \return Value for variable.
 */
double get_firm_death_rate()
{
	if(current_xmachine->xmachine_Eurostat) return (*current_xmachine->xmachine_Eurostat).firm_death_rate;

    // suppress compiler warning by returning dummy value /
    // this statement should rightfully NEVER be reached /
    return (double)0;
}

/** \fn double get_survival_rate()
 * \brief Get survival_rate memory variable from current X-machine.
 * \return Value for variable.
 */
double * get_survival_rate()
{
	if(current_xmachine->xmachine_Eurostat) return (*current_xmachine->xmachine_Eurostat).survival_rate;

    // suppress compiler warning by returning dummy value /
    // this statement should rightfully NEVER be reached /
    return NULL;
}

/** \fn double get_survival_rate_multiperiod_1()
 * \brief Get survival_rate_multiperiod_1 memory variable from current X-machine.
 * \return Value for variable.
 */
double * get_survival_rate_multiperiod_1()
{
	if(current_xmachine->xmachine_Eurostat) return (*current_xmachine->xmachine_Eurostat).survival_rate_multiperiod_1;

    // suppress compiler warning by returning dummy value /
    // this statement should rightfully NEVER be reached /
    return NULL;
}

/** \fn double get_survival_rate_multiperiod_2()
 * \brief Get survival_rate_multiperiod_2 memory variable from current X-machine.
 * \return Value for variable.
 */
double * get_survival_rate_multiperiod_2()
{
	if(current_xmachine->xmachine_Eurostat) return (*current_xmachine->xmachine_Eurostat).survival_rate_multiperiod_2;

    // suppress compiler warning by returning dummy value /
    // this statement should rightfully NEVER be reached /
    return NULL;
}

/** \fn double get_survival_rate_multiperiod()
 * \brief Get survival_rate_multiperiod memory variable from current X-machine.
 * \return Value for variable.
 */
double * get_survival_rate_multiperiod()
{
	if(current_xmachine->xmachine_Eurostat) return (*current_xmachine->xmachine_Eurostat).survival_rate_multiperiod;

    // suppress compiler warning by returning dummy value /
    // this statement should rightfully NEVER be reached /
    return NULL;
}

/** \fn void set_max_firm_creation(int max_firm_creation)
 * \brief Set max_firm_creation memory variable for current X-machine.
 * \param max_firm_creation New value for variable.
 */
void set_max_firm_creation(int max_firm_creation)
{
	if(current_xmachine->xmachine_Eurostat) (*current_xmachine->xmachine_Eurostat).max_firm_creation = max_firm_creation;
}

/** \fn int get_max_firm_creation()
 * \brief Get max_firm_creation memory variable from current X-machine.
 * \return Value for variable.
 */
int get_max_firm_creation()
{
	if(current_xmachine->xmachine_Eurostat) return (*current_xmachine->xmachine_Eurostat).max_firm_creation;

    // suppress compiler warning by returning dummy value /
    // this statement should rightfully NEVER be reached /
    return (int)0;
}

/** \fn void set_recession_started(int recession_started)
 * \brief Set recession_started memory variable for current X-machine.
 * \param recession_started New value for variable.
 */
void set_recession_started(int recession_started)
{
	if(current_xmachine->xmachine_Eurostat) (*current_xmachine->xmachine_Eurostat).recession_started = recession_started;
}

/** \fn int get_recession_started()
 * \brief Get recession_started memory variable from current X-machine.
 * \return Value for variable.
 */
int get_recession_started()
{
	if(current_xmachine->xmachine_Eurostat) return (*current_xmachine->xmachine_Eurostat).recession_started;

    // suppress compiler warning by returning dummy value /
    // this statement should rightfully NEVER be reached /
    return (int)0;
}

/** \fn void set_recession_duration(int recession_duration)
 * \brief Set recession_duration memory variable for current X-machine.
 * \param recession_duration New value for variable.
 */
void set_recession_duration(int recession_duration)
{
	if(current_xmachine->xmachine_Eurostat) (*current_xmachine->xmachine_Eurostat).recession_duration = recession_duration;
}

/** \fn int get_recession_duration()
 * \brief Get recession_duration memory variable from current X-machine.
 * \return Value for variable.
 */
int get_recession_duration()
{
	if(current_xmachine->xmachine_Eurostat) return (*current_xmachine->xmachine_Eurostat).recession_duration;

    // suppress compiler warning by returning dummy value /
    // this statement should rightfully NEVER be reached /
    return (int)0;
}

/** \fn double get_region_export_volume()
 * \brief Get region_export_volume memory variable from current X-machine.
 * \return Value for variable.
 */
double * get_region_export_volume()
{
	if(current_xmachine->xmachine_Eurostat) return (*current_xmachine->xmachine_Eurostat).region_export_volume;

    // suppress compiler warning by returning dummy value /
    // this statement should rightfully NEVER be reached /
    return NULL;
}

/** \fn double get_region_import_volume()
 * \brief Get region_import_volume memory variable from current X-machine.
 * \return Value for variable.
 */
double * get_region_import_volume()
{
	if(current_xmachine->xmachine_Eurostat) return (*current_xmachine->xmachine_Eurostat).region_import_volume;

    // suppress compiler warning by returning dummy value /
    // this statement should rightfully NEVER be reached /
    return NULL;
}

/** \fn double get_region_export_value()
 * \brief Get region_export_value memory variable from current X-machine.
 * \return Value for variable.
 */
double * get_region_export_value()
{
	if(current_xmachine->xmachine_Eurostat) return (*current_xmachine->xmachine_Eurostat).region_export_value;

    // suppress compiler warning by returning dummy value /
    // this statement should rightfully NEVER be reached /
    return NULL;
}

/** \fn double get_region_import_value()
 * \brief Get region_import_value memory variable from current X-machine.
 * \return Value for variable.
 */
double * get_region_import_value()
{
	if(current_xmachine->xmachine_Eurostat) return (*current_xmachine->xmachine_Eurostat).region_import_value;

    // suppress compiler warning by returning dummy value /
    // this statement should rightfully NEVER be reached /
    return NULL;
}

/** \fn double get_region_import_previous_value()
 * \brief Get region_import_previous_value memory variable from current X-machine.
 * \return Value for variable.
 */
double * get_region_import_previous_value()
{
	if(current_xmachine->xmachine_Eurostat) return (*current_xmachine->xmachine_Eurostat).region_import_previous_value;

    // suppress compiler warning by returning dummy value /
    // this statement should rightfully NEVER be reached /
    return NULL;
}

/** \fn void set_firm_average_productivity_progress(double firm_average_productivity_progress)
 * \brief Set firm_average_productivity_progress memory variable for current X-machine.
 * \param firm_average_productivity_progress New value for variable.
 */
void set_firm_average_productivity_progress(double firm_average_productivity_progress)
{
	if(current_xmachine->xmachine_Eurostat) (*current_xmachine->xmachine_Eurostat).firm_average_productivity_progress = firm_average_productivity_progress;
}

/** \fn double get_firm_average_productivity_progress()
 * \brief Get firm_average_productivity_progress memory variable from current X-machine.
 * \return Value for variable.
 */
double get_firm_average_productivity_progress()
{
	if(current_xmachine->xmachine_Eurostat) return (*current_xmachine->xmachine_Eurostat).firm_average_productivity_progress;

    // suppress compiler warning by returning dummy value /
    // this statement should rightfully NEVER be reached /
    return (double)0;
}

/** \fn void set_firm_average_productivity(double firm_average_productivity)
 * \brief Set firm_average_productivity memory variable for current X-machine.
 * \param firm_average_productivity New value for variable.
 */
void set_firm_average_productivity(double firm_average_productivity)
{
	if(current_xmachine->xmachine_Eurostat) (*current_xmachine->xmachine_Eurostat).firm_average_productivity = firm_average_productivity;
}

/** \fn double get_firm_average_productivity()
 * \brief Get firm_average_productivity memory variable from current X-machine.
 * \return Value for variable.
 */
double get_firm_average_productivity()
{
	if(current_xmachine->xmachine_Eurostat) return (*current_xmachine->xmachine_Eurostat).firm_average_productivity;

    // suppress compiler warning by returning dummy value /
    // this statement should rightfully NEVER be reached /
    return (double)0;
}

/** \fn void set_investment_gdp_ratio(double investment_gdp_ratio)
 * \brief Set investment_gdp_ratio memory variable for current X-machine.
 * \param investment_gdp_ratio New value for variable.
 */
void set_investment_gdp_ratio(double investment_gdp_ratio)
{
	if(current_xmachine->xmachine_Eurostat) (*current_xmachine->xmachine_Eurostat).investment_gdp_ratio = investment_gdp_ratio;
}

/** \fn double get_investment_gdp_ratio()
 * \brief Get investment_gdp_ratio memory variable from current X-machine.
 * \return Value for variable.
 */
double get_investment_gdp_ratio()
{
	if(current_xmachine->xmachine_Eurostat) return (*current_xmachine->xmachine_Eurostat).investment_gdp_ratio;

    // suppress compiler warning by returning dummy value /
    // this statement should rightfully NEVER be reached /
    return (double)0;
}

/** \fn void set_total_capital_stock_units(double total_capital_stock_units)
 * \brief Set total_capital_stock_units memory variable for current X-machine.
 * \param total_capital_stock_units New value for variable.
 */
void set_total_capital_stock_units(double total_capital_stock_units)
{
	if(current_xmachine->xmachine_Eurostat) (*current_xmachine->xmachine_Eurostat).total_capital_stock_units = total_capital_stock_units;
}

/** \fn double get_total_capital_stock_units()
 * \brief Get total_capital_stock_units memory variable from current X-machine.
 * \return Value for variable.
 */
double get_total_capital_stock_units()
{
	if(current_xmachine->xmachine_Eurostat) return (*current_xmachine->xmachine_Eurostat).total_capital_stock_units;

    // suppress compiler warning by returning dummy value /
    // this statement should rightfully NEVER be reached /
    return (double)0;
}

/** \fn void set_total_value_mall_inventories(double total_value_mall_inventories)
 * \brief Set total_value_mall_inventories memory variable for current X-machine.
 * \param total_value_mall_inventories New value for variable.
 */
void set_total_value_mall_inventories(double total_value_mall_inventories)
{
	if(current_xmachine->xmachine_Eurostat) (*current_xmachine->xmachine_Eurostat).total_value_mall_inventories = total_value_mall_inventories;
}

/** \fn double get_total_value_mall_inventories()
 * \brief Get total_value_mall_inventories memory variable from current X-machine.
 * \return Value for variable.
 */
double get_total_value_mall_inventories()
{
	if(current_xmachine->xmachine_Eurostat) return (*current_xmachine->xmachine_Eurostat).total_value_mall_inventories;

    // suppress compiler warning by returning dummy value /
    // this statement should rightfully NEVER be reached /
    return (double)0;
}

/** \fn void set_total_dividends(double total_dividends)
 * \brief Set total_dividends memory variable for current X-machine.
 * \param total_dividends New value for variable.
 */
void set_total_dividends(double total_dividends)
{
	if(current_xmachine->xmachine_Eurostat) (*current_xmachine->xmachine_Eurostat).total_dividends = total_dividends;
}

/** \fn double get_total_dividends()
 * \brief Get total_dividends memory variable from current X-machine.
 * \return Value for variable.
 */
double get_total_dividends()
{
	if(current_xmachine->xmachine_Eurostat) return (*current_xmachine->xmachine_Eurostat).total_dividends;

    // suppress compiler warning by returning dummy value /
    // this statement should rightfully NEVER be reached /
    return (double)0;
}

/** \fn void set_base_wage_offer(double base_wage_offer)
 * \brief Set base_wage_offer memory variable for current X-machine.
 * \param base_wage_offer New value for variable.
 */
void set_base_wage_offer(double base_wage_offer)
{
	if(current_xmachine->xmachine_Eurostat) (*current_xmachine->xmachine_Eurostat).base_wage_offer = base_wage_offer;
}

/** \fn double get_base_wage_offer()
 * \brief Get base_wage_offer memory variable from current X-machine.
 * \return Value for variable.
 */
double get_base_wage_offer()
{
	if(current_xmachine->xmachine_Eurostat) return (*current_xmachine->xmachine_Eurostat).base_wage_offer;

    // suppress compiler warning by returning dummy value /
    // this statement should rightfully NEVER be reached /
    return (double)0;
}

/** \fn int_array get_all_region_ids()
 * \brief Get all_region_ids memory variable from current X-machine.
 * \return Value for variable.
 */
int_array * get_all_region_ids()
{
	if(current_xmachine->xmachine_Eurostat) return &(*current_xmachine->xmachine_Eurostat).all_region_ids;
	if(current_xmachine->xmachine_Government) return &(*current_xmachine->xmachine_Government).all_region_ids;

    // suppress compiler warning by returning dummy value /
    // this statement should rightfully NEVER be reached /
    return NULL;
}

/** \fn int_array get_all_gov_ids()
 * \brief Get all_gov_ids memory variable from current X-machine.
 * \return Value for variable.
 */
int_array * get_all_gov_ids()
{
	if(current_xmachine->xmachine_Eurostat) return &(*current_xmachine->xmachine_Eurostat).all_gov_ids;
	if(current_xmachine->xmachine_Government) return &(*current_xmachine->xmachine_Government).all_gov_ids;

    // suppress compiler warning by returning dummy value /
    // this statement should rightfully NEVER be reached /
    return NULL;
}

/** \fn void set_job_seperation_rate(double job_seperation_rate)
 * \brief Set job_seperation_rate memory variable for current X-machine.
 * \param job_seperation_rate New value for variable.
 */
void set_job_seperation_rate(double job_seperation_rate)
{
	if(current_xmachine->xmachine_Eurostat) (*current_xmachine->xmachine_Eurostat).job_seperation_rate = job_seperation_rate;
}

/** \fn double get_job_seperation_rate()
 * \brief Get job_seperation_rate memory variable from current X-machine.
 * \return Value for variable.
 */
double get_job_seperation_rate()
{
	if(current_xmachine->xmachine_Eurostat) return (*current_xmachine->xmachine_Eurostat).job_seperation_rate;

    // suppress compiler warning by returning dummy value /
    // this statement should rightfully NEVER be reached /
    return (double)0;
}

/** \fn void set_job_finding_rate(double job_finding_rate)
 * \brief Set job_finding_rate memory variable for current X-machine.
 * \param job_finding_rate New value for variable.
 */
void set_job_finding_rate(double job_finding_rate)
{
	if(current_xmachine->xmachine_Eurostat) (*current_xmachine->xmachine_Eurostat).job_finding_rate = job_finding_rate;
}

/** \fn double get_job_finding_rate()
 * \brief Get job_finding_rate memory variable from current X-machine.
 * \return Value for variable.
 */
double get_job_finding_rate()
{
	if(current_xmachine->xmachine_Eurostat) return (*current_xmachine->xmachine_Eurostat).job_finding_rate;

    // suppress compiler warning by returning dummy value /
    // this statement should rightfully NEVER be reached /
    return (double)0;
}

/** \fn void set_v_u_ratio(double v_u_ratio)
 * \brief Set v_u_ratio memory variable for current X-machine.
 * \param v_u_ratio New value for variable.
 */
void set_v_u_ratio(double v_u_ratio)
{
	if(current_xmachine->xmachine_Eurostat) (*current_xmachine->xmachine_Eurostat).v_u_ratio = v_u_ratio;
}

/** \fn double get_v_u_ratio()
 * \brief Get v_u_ratio memory variable from current X-machine.
 * \return Value for variable.
 */
double get_v_u_ratio()
{
	if(current_xmachine->xmachine_Eurostat) return (*current_xmachine->xmachine_Eurostat).v_u_ratio;

    // suppress compiler warning by returning dummy value /
    // this statement should rightfully NEVER be reached /
    return (double)0;
}

/** \fn void set_matching_rate(double matching_rate)
 * \brief Set matching_rate memory variable for current X-machine.
 * \param matching_rate New value for variable.
 */
void set_matching_rate(double matching_rate)
{
	if(current_xmachine->xmachine_Eurostat) (*current_xmachine->xmachine_Eurostat).matching_rate = matching_rate;
}

/** \fn double get_matching_rate()
 * \brief Get matching_rate memory variable from current X-machine.
 * \return Value for variable.
 */
double get_matching_rate()
{
	if(current_xmachine->xmachine_Eurostat) return (*current_xmachine->xmachine_Eurostat).matching_rate;

    // suppress compiler warning by returning dummy value /
    // this statement should rightfully NEVER be reached /
    return (double)0;
}

/** \fn void set_hh_payment_account(double hh_payment_account)
 * \brief Set hh_payment_account memory variable for current X-machine.
 * \param hh_payment_account New value for variable.
 */
void set_hh_payment_account(double hh_payment_account)
{
	if(current_xmachine->xmachine_Eurostat) (*current_xmachine->xmachine_Eurostat).hh_payment_account = hh_payment_account;
}

/** \fn double get_hh_payment_account()
 * \brief Get hh_payment_account memory variable from current X-machine.
 * \return Value for variable.
 */
double get_hh_payment_account()
{
	if(current_xmachine->xmachine_Eurostat) return (*current_xmachine->xmachine_Eurostat).hh_payment_account;

    // suppress compiler warning by returning dummy value /
    // this statement should rightfully NEVER be reached /
    return (double)0;
}

/** \fn void set_cash(double cash)
 * \brief Set cash memory variable for current X-machine.
 * \param cash New value for variable.
 */
void set_cash(double cash)
{
	if(current_xmachine->xmachine_Bank) (*current_xmachine->xmachine_Bank).cash = cash;
	if(current_xmachine->xmachine_CentralBank) (*current_xmachine->xmachine_CentralBank).cash = cash;
}

/** \fn double get_cash()
 * \brief Get cash memory variable from current X-machine.
 * \return Value for variable.
 */
double get_cash()
{
	if(current_xmachine->xmachine_Bank) return (*current_xmachine->xmachine_Bank).cash;
	if(current_xmachine->xmachine_CentralBank) return (*current_xmachine->xmachine_CentralBank).cash;

    // suppress compiler warning by returning dummy value /
    // this statement should rightfully NEVER be reached /
    return (double)0;
}

/** \fn void set_total_credit(double total_credit)
 * \brief Set total_credit memory variable for current X-machine.
 * \param total_credit New value for variable.
 */
void set_total_credit(double total_credit)
{
	if(current_xmachine->xmachine_Bank) (*current_xmachine->xmachine_Bank).total_credit = total_credit;
}

/** \fn double get_total_credit()
 * \brief Get total_credit memory variable from current X-machine.
 * \return Value for variable.
 */
double get_total_credit()
{
	if(current_xmachine->xmachine_Bank) return (*current_xmachine->xmachine_Bank).total_credit;

    // suppress compiler warning by returning dummy value /
    // this statement should rightfully NEVER be reached /
    return (double)0;
}

/** \fn void set_ecb_debt(double ecb_debt)
 * \brief Set ecb_debt memory variable for current X-machine.
 * \param ecb_debt New value for variable.
 */
void set_ecb_debt(double ecb_debt)
{
	if(current_xmachine->xmachine_Bank) (*current_xmachine->xmachine_Bank).ecb_debt = ecb_debt;
}

/** \fn double get_ecb_debt()
 * \brief Get ecb_debt memory variable from current X-machine.
 * \return Value for variable.
 */
double get_ecb_debt()
{
	if(current_xmachine->xmachine_Bank) return (*current_xmachine->xmachine_Bank).ecb_debt;

    // suppress compiler warning by returning dummy value /
    // this statement should rightfully NEVER be reached /
    return (double)0;
}

/** \fn void set_value_at_risk(double value_at_risk)
 * \brief Set value_at_risk memory variable for current X-machine.
 * \param value_at_risk New value for variable.
 */
void set_value_at_risk(double value_at_risk)
{
	if(current_xmachine->xmachine_Bank) (*current_xmachine->xmachine_Bank).value_at_risk = value_at_risk;
}

/** \fn double get_value_at_risk()
 * \brief Get value_at_risk memory variable from current X-machine.
 * \return Value for variable.
 */
double get_value_at_risk()
{
	if(current_xmachine->xmachine_Bank) return (*current_xmachine->xmachine_Bank).value_at_risk;

    // suppress compiler warning by returning dummy value /
    // this statement should rightfully NEVER be reached /
    return (double)0;
}

/** \fn void set_deposit_interest_rate(double deposit_interest_rate)
 * \brief Set deposit_interest_rate memory variable for current X-machine.
 * \param deposit_interest_rate New value for variable.
 */
void set_deposit_interest_rate(double deposit_interest_rate)
{
	if(current_xmachine->xmachine_Bank) (*current_xmachine->xmachine_Bank).deposit_interest_rate = deposit_interest_rate;
}

/** \fn double get_deposit_interest_rate()
 * \brief Get deposit_interest_rate memory variable from current X-machine.
 * \return Value for variable.
 */
double get_deposit_interest_rate()
{
	if(current_xmachine->xmachine_Bank) return (*current_xmachine->xmachine_Bank).deposit_interest_rate;

    // suppress compiler warning by returning dummy value /
    // this statement should rightfully NEVER be reached /
    return (double)0;
}

/** \fn double get_bank_gamma()
 * \brief Get bank_gamma memory variable from current X-machine.
 * \return Value for variable.
 */
double * get_bank_gamma()
{
	if(current_xmachine->xmachine_Bank) return (*current_xmachine->xmachine_Bank).bank_gamma;

    // suppress compiler warning by returning dummy value /
    // this statement should rightfully NEVER be reached /
    return NULL;
}

/** \fn double get_profits()
 * \brief Get profits memory variable from current X-machine.
 * \return Value for variable.
 */
double * get_profits()
{
	if(current_xmachine->xmachine_Bank) return (*current_xmachine->xmachine_Bank).profits;

    // suppress compiler warning by returning dummy value /
    // this statement should rightfully NEVER be reached /
    return NULL;
}

/** \fn void set_bank_dividend_rate(double bank_dividend_rate)
 * \brief Set bank_dividend_rate memory variable for current X-machine.
 * \param bank_dividend_rate New value for variable.
 */
void set_bank_dividend_rate(double bank_dividend_rate)
{
	if(current_xmachine->xmachine_Bank) (*current_xmachine->xmachine_Bank).bank_dividend_rate = bank_dividend_rate;
}

/** \fn double get_bank_dividend_rate()
 * \brief Get bank_dividend_rate memory variable from current X-machine.
 * \return Value for variable.
 */
double get_bank_dividend_rate()
{
	if(current_xmachine->xmachine_Bank) return (*current_xmachine->xmachine_Bank).bank_dividend_rate;

    // suppress compiler warning by returning dummy value /
    // this statement should rightfully NEVER be reached /
    return (double)0;
}

/** \fn void set_debt_period(double debt_period)
 * \brief Set debt_period memory variable for current X-machine.
 * \param debt_period New value for variable.
 */
void set_debt_period(double debt_period)
{
	if(current_xmachine->xmachine_Bank) (*current_xmachine->xmachine_Bank).debt_period = debt_period;
}

/** \fn double get_debt_period()
 * \brief Get debt_period memory variable from current X-machine.
 * \return Value for variable.
 */
double get_debt_period()
{
	if(current_xmachine->xmachine_Bank) return (*current_xmachine->xmachine_Bank).debt_period;

    // suppress compiler warning by returning dummy value /
    // this statement should rightfully NEVER be reached /
    return (double)0;
}

/** \fn void set_loan_request_message_found(int loan_request_message_found)
 * \brief Set loan_request_message_found memory variable for current X-machine.
 * \param loan_request_message_found New value for variable.
 */
void set_loan_request_message_found(int loan_request_message_found)
{
	if(current_xmachine->xmachine_Bank) (*current_xmachine->xmachine_Bank).loan_request_message_found = loan_request_message_found;
}

/** \fn int get_loan_request_message_found()
 * \brief Get loan_request_message_found memory variable from current X-machine.
 * \return Value for variable.
 */
int get_loan_request_message_found()
{
	if(current_xmachine->xmachine_Bank) return (*current_xmachine->xmachine_Bank).loan_request_message_found;

    // suppress compiler warning by returning dummy value /
    // this statement should rightfully NEVER be reached /
    return (int)0;
}

/** \fn void set_deposits(double deposits)
 * \brief Set deposits memory variable for current X-machine.
 * \param deposits New value for variable.
 */
void set_deposits(double deposits)
{
	if(current_xmachine->xmachine_Bank) (*current_xmachine->xmachine_Bank).deposits = deposits;
}

/** \fn double get_deposits()
 * \brief Get deposits memory variable from current X-machine.
 * \return Value for variable.
 */
double get_deposits()
{
	if(current_xmachine->xmachine_Bank) return (*current_xmachine->xmachine_Bank).deposits;

    // suppress compiler warning by returning dummy value /
    // this statement should rightfully NEVER be reached /
    return (double)0;
}

/** \fn void set_firm_loan_installments(double firm_loan_installments)
 * \brief Set firm_loan_installments memory variable for current X-machine.
 * \param firm_loan_installments New value for variable.
 */
void set_firm_loan_installments(double firm_loan_installments)
{
	if(current_xmachine->xmachine_Bank) (*current_xmachine->xmachine_Bank).firm_loan_installments = firm_loan_installments;
}

/** \fn double get_firm_loan_installments()
 * \brief Get firm_loan_installments memory variable from current X-machine.
 * \return Value for variable.
 */
double get_firm_loan_installments()
{
	if(current_xmachine->xmachine_Bank) return (*current_xmachine->xmachine_Bank).firm_loan_installments;

    // suppress compiler warning by returning dummy value /
    // this statement should rightfully NEVER be reached /
    return (double)0;
}

/** \fn void set_firm_loan_installments_in_calendar_month(double firm_loan_installments_in_calendar_month)
 * \brief Set firm_loan_installments_in_calendar_month memory variable for current X-machine.
 * \param firm_loan_installments_in_calendar_month New value for variable.
 */
void set_firm_loan_installments_in_calendar_month(double firm_loan_installments_in_calendar_month)
{
	if(current_xmachine->xmachine_Bank) (*current_xmachine->xmachine_Bank).firm_loan_installments_in_calendar_month = firm_loan_installments_in_calendar_month;
}

/** \fn double get_firm_loan_installments_in_calendar_month()
 * \brief Get firm_loan_installments_in_calendar_month memory variable from current X-machine.
 * \return Value for variable.
 */
double get_firm_loan_installments_in_calendar_month()
{
	if(current_xmachine->xmachine_Bank) return (*current_xmachine->xmachine_Bank).firm_loan_installments_in_calendar_month;

    // suppress compiler warning by returning dummy value /
    // this statement should rightfully NEVER be reached /
    return (double)0;
}

/** \fn void set_firm_interest_payments(double firm_interest_payments)
 * \brief Set firm_interest_payments memory variable for current X-machine.
 * \param firm_interest_payments New value for variable.
 */
void set_firm_interest_payments(double firm_interest_payments)
{
	if(current_xmachine->xmachine_Bank) (*current_xmachine->xmachine_Bank).firm_interest_payments = firm_interest_payments;
}

/** \fn double get_firm_interest_payments()
 * \brief Get firm_interest_payments memory variable from current X-machine.
 * \return Value for variable.
 */
double get_firm_interest_payments()
{
	if(current_xmachine->xmachine_Bank) return (*current_xmachine->xmachine_Bank).firm_interest_payments;

    // suppress compiler warning by returning dummy value /
    // this statement should rightfully NEVER be reached /
    return (double)0;
}

/** \fn void set_firm_interest_payments_in_calendar_month(double firm_interest_payments_in_calendar_month)
 * \brief Set firm_interest_payments_in_calendar_month memory variable for current X-machine.
 * \param firm_interest_payments_in_calendar_month New value for variable.
 */
void set_firm_interest_payments_in_calendar_month(double firm_interest_payments_in_calendar_month)
{
	if(current_xmachine->xmachine_Bank) (*current_xmachine->xmachine_Bank).firm_interest_payments_in_calendar_month = firm_interest_payments_in_calendar_month;
}

/** \fn double get_firm_interest_payments_in_calendar_month()
 * \brief Get firm_interest_payments_in_calendar_month memory variable from current X-machine.
 * \return Value for variable.
 */
double get_firm_interest_payments_in_calendar_month()
{
	if(current_xmachine->xmachine_Bank) return (*current_xmachine->xmachine_Bank).firm_interest_payments_in_calendar_month;

    // suppress compiler warning by returning dummy value /
    // this statement should rightfully NEVER be reached /
    return (double)0;
}

/** \fn void set_firm_loan_issues(double firm_loan_issues)
 * \brief Set firm_loan_issues memory variable for current X-machine.
 * \param firm_loan_issues New value for variable.
 */
void set_firm_loan_issues(double firm_loan_issues)
{
	if(current_xmachine->xmachine_Bank) (*current_xmachine->xmachine_Bank).firm_loan_issues = firm_loan_issues;
}

/** \fn double get_firm_loan_issues()
 * \brief Get firm_loan_issues memory variable from current X-machine.
 * \return Value for variable.
 */
double get_firm_loan_issues()
{
	if(current_xmachine->xmachine_Bank) return (*current_xmachine->xmachine_Bank).firm_loan_issues;

    // suppress compiler warning by returning dummy value /
    // this statement should rightfully NEVER be reached /
    return (double)0;
}

/** \fn void set_ecb_interest_payment(double ecb_interest_payment)
 * \brief Set ecb_interest_payment memory variable for current X-machine.
 * \param ecb_interest_payment New value for variable.
 */
void set_ecb_interest_payment(double ecb_interest_payment)
{
	if(current_xmachine->xmachine_Bank) (*current_xmachine->xmachine_Bank).ecb_interest_payment = ecb_interest_payment;
}

/** \fn double get_ecb_interest_payment()
 * \brief Get ecb_interest_payment memory variable from current X-machine.
 * \return Value for variable.
 */
double get_ecb_interest_payment()
{
	if(current_xmachine->xmachine_Bank) return (*current_xmachine->xmachine_Bank).ecb_interest_payment;

    // suppress compiler warning by returning dummy value /
    // this statement should rightfully NEVER be reached /
    return (double)0;
}

/** \fn void set_total_dividends_in_calendar_month(double total_dividends_in_calendar_month)
 * \brief Set total_dividends_in_calendar_month memory variable for current X-machine.
 * \param total_dividends_in_calendar_month New value for variable.
 */
void set_total_dividends_in_calendar_month(double total_dividends_in_calendar_month)
{
	if(current_xmachine->xmachine_Bank) (*current_xmachine->xmachine_Bank).total_dividends_in_calendar_month = total_dividends_in_calendar_month;
}

/** \fn double get_total_dividends_in_calendar_month()
 * \brief Get total_dividends_in_calendar_month memory variable from current X-machine.
 * \return Value for variable.
 */
double get_total_dividends_in_calendar_month()
{
	if(current_xmachine->xmachine_Bank) return (*current_xmachine->xmachine_Bank).total_dividends_in_calendar_month;

    // suppress compiler warning by returning dummy value /
    // this statement should rightfully NEVER be reached /
    return (double)0;
}

/** \fn void set_taxes(double taxes)
 * \brief Set taxes memory variable for current X-machine.
 * \param taxes New value for variable.
 */
void set_taxes(double taxes)
{
	if(current_xmachine->xmachine_Bank) (*current_xmachine->xmachine_Bank).taxes = taxes;
}

/** \fn double get_taxes()
 * \brief Get taxes memory variable from current X-machine.
 * \return Value for variable.
 */
double get_taxes()
{
	if(current_xmachine->xmachine_Bank) return (*current_xmachine->xmachine_Bank).taxes;

    // suppress compiler warning by returning dummy value /
    // this statement should rightfully NEVER be reached /
    return (double)0;
}

/** \fn void set_dividend_per_share(double dividend_per_share)
 * \brief Set dividend_per_share memory variable for current X-machine.
 * \param dividend_per_share New value for variable.
 */
void set_dividend_per_share(double dividend_per_share)
{
	if(current_xmachine->xmachine_Bank) (*current_xmachine->xmachine_Bank).dividend_per_share = dividend_per_share;
}

/** \fn double get_dividend_per_share()
 * \brief Get dividend_per_share memory variable from current X-machine.
 * \return Value for variable.
 */
double get_dividend_per_share()
{
	if(current_xmachine->xmachine_Bank) return (*current_xmachine->xmachine_Bank).dividend_per_share;

    // suppress compiler warning by returning dummy value /
    // this statement should rightfully NEVER be reached /
    return (double)0;
}

/** \fn void set_leverage_ratio(double leverage_ratio)
 * \brief Set leverage_ratio memory variable for current X-machine.
 * \param leverage_ratio New value for variable.
 */
void set_leverage_ratio(double leverage_ratio)
{
	if(current_xmachine->xmachine_Bank) (*current_xmachine->xmachine_Bank).leverage_ratio = leverage_ratio;
}

/** \fn double get_leverage_ratio()
 * \brief Get leverage_ratio memory variable from current X-machine.
 * \return Value for variable.
 */
double get_leverage_ratio()
{
	if(current_xmachine->xmachine_Bank) return (*current_xmachine->xmachine_Bank).leverage_ratio;

    // suppress compiler warning by returning dummy value /
    // this statement should rightfully NEVER be reached /
    return (double)0;
}

/** \fn void set_cash_deposit_ratio(double cash_deposit_ratio)
 * \brief Set cash_deposit_ratio memory variable for current X-machine.
 * \param cash_deposit_ratio New value for variable.
 */
void set_cash_deposit_ratio(double cash_deposit_ratio)
{
	if(current_xmachine->xmachine_Bank) (*current_xmachine->xmachine_Bank).cash_deposit_ratio = cash_deposit_ratio;
}

/** \fn double get_cash_deposit_ratio()
 * \brief Get cash_deposit_ratio memory variable from current X-machine.
 * \return Value for variable.
 */
double get_cash_deposit_ratio()
{
	if(current_xmachine->xmachine_Bank) return (*current_xmachine->xmachine_Bank).cash_deposit_ratio;

    // suppress compiler warning by returning dummy value /
    // this statement should rightfully NEVER be reached /
    return (double)0;
}

/** \fn void set_mean_interest_rate(double mean_interest_rate)
 * \brief Set mean_interest_rate memory variable for current X-machine.
 * \param mean_interest_rate New value for variable.
 */
void set_mean_interest_rate(double mean_interest_rate)
{
	if(current_xmachine->xmachine_Bank) (*current_xmachine->xmachine_Bank).mean_interest_rate = mean_interest_rate;
}

/** \fn double get_mean_interest_rate()
 * \brief Get mean_interest_rate memory variable from current X-machine.
 * \return Value for variable.
 */
double get_mean_interest_rate()
{
	if(current_xmachine->xmachine_Bank) return (*current_xmachine->xmachine_Bank).mean_interest_rate;

    // suppress compiler warning by returning dummy value /
    // this statement should rightfully NEVER be reached /
    return (double)0;
}

/** \fn void set_sum_new_interest_rates_in_calendar_month(double sum_new_interest_rates_in_calendar_month)
 * \brief Set sum_new_interest_rates_in_calendar_month memory variable for current X-machine.
 * \param sum_new_interest_rates_in_calendar_month New value for variable.
 */
void set_sum_new_interest_rates_in_calendar_month(double sum_new_interest_rates_in_calendar_month)
{
	if(current_xmachine->xmachine_Bank) (*current_xmachine->xmachine_Bank).sum_new_interest_rates_in_calendar_month = sum_new_interest_rates_in_calendar_month;
}

/** \fn double get_sum_new_interest_rates_in_calendar_month()
 * \brief Get sum_new_interest_rates_in_calendar_month memory variable from current X-machine.
 * \return Value for variable.
 */
double get_sum_new_interest_rates_in_calendar_month()
{
	if(current_xmachine->xmachine_Bank) return (*current_xmachine->xmachine_Bank).sum_new_interest_rates_in_calendar_month;

    // suppress compiler warning by returning dummy value /
    // this statement should rightfully NEVER be reached /
    return (double)0;
}

/** \fn void set_no_new_loans_in_calendar_month(int no_new_loans_in_calendar_month)
 * \brief Set no_new_loans_in_calendar_month memory variable for current X-machine.
 * \param no_new_loans_in_calendar_month New value for variable.
 */
void set_no_new_loans_in_calendar_month(int no_new_loans_in_calendar_month)
{
	if(current_xmachine->xmachine_Bank) (*current_xmachine->xmachine_Bank).no_new_loans_in_calendar_month = no_new_loans_in_calendar_month;
}

/** \fn int get_no_new_loans_in_calendar_month()
 * \brief Get no_new_loans_in_calendar_month memory variable from current X-machine.
 * \return Value for variable.
 */
int get_no_new_loans_in_calendar_month()
{
	if(current_xmachine->xmachine_Bank) return (*current_xmachine->xmachine_Bank).no_new_loans_in_calendar_month;

    // suppress compiler warning by returning dummy value /
    // this statement should rightfully NEVER be reached /
    return (int)0;
}

/** \fn void set_paid_interest_daily(double paid_interest_daily)
 * \brief Set paid_interest_daily memory variable for current X-machine.
 * \param paid_interest_daily New value for variable.
 */
void set_paid_interest_daily(double paid_interest_daily)
{
	if(current_xmachine->xmachine_Bank) (*current_xmachine->xmachine_Bank).paid_interest_daily = paid_interest_daily;
}

/** \fn double get_paid_interest_daily()
 * \brief Get paid_interest_daily memory variable from current X-machine.
 * \return Value for variable.
 */
double get_paid_interest_daily()
{
	if(current_xmachine->xmachine_Bank) return (*current_xmachine->xmachine_Bank).paid_interest_daily;

    // suppress compiler warning by returning dummy value /
    // this statement should rightfully NEVER be reached /
    return (double)0;
}

/** \fn void set_paid_interest_in_calendar_month(double paid_interest_in_calendar_month)
 * \brief Set paid_interest_in_calendar_month memory variable for current X-machine.
 * \param paid_interest_in_calendar_month New value for variable.
 */
void set_paid_interest_in_calendar_month(double paid_interest_in_calendar_month)
{
	if(current_xmachine->xmachine_Bank) (*current_xmachine->xmachine_Bank).paid_interest_in_calendar_month = paid_interest_in_calendar_month;
}

/** \fn double get_paid_interest_in_calendar_month()
 * \brief Get paid_interest_in_calendar_month memory variable from current X-machine.
 * \return Value for variable.
 */
double get_paid_interest_in_calendar_month()
{
	if(current_xmachine->xmachine_Bank) return (*current_xmachine->xmachine_Bank).paid_interest_in_calendar_month;

    // suppress compiler warning by returning dummy value /
    // this statement should rightfully NEVER be reached /
    return (double)0;
}

/** \fn void set_excess_var(double excess_var)
 * \brief Set excess_var memory variable for current X-machine.
 * \param excess_var New value for variable.
 */
void set_excess_var(double excess_var)
{
	if(current_xmachine->xmachine_Bank) (*current_xmachine->xmachine_Bank).excess_var = excess_var;
}

/** \fn double get_excess_var()
 * \brief Get excess_var memory variable from current X-machine.
 * \return Value for variable.
 */
double get_excess_var()
{
	if(current_xmachine->xmachine_Bank) return (*current_xmachine->xmachine_Bank).excess_var;

    // suppress compiler warning by returning dummy value /
    // this statement should rightfully NEVER be reached /
    return (double)0;
}

/** \fn void set_excess_liquidity(double excess_liquidity)
 * \brief Set excess_liquidity memory variable for current X-machine.
 * \param excess_liquidity New value for variable.
 */
void set_excess_liquidity(double excess_liquidity)
{
	if(current_xmachine->xmachine_Bank) (*current_xmachine->xmachine_Bank).excess_liquidity = excess_liquidity;
}

/** \fn double get_excess_liquidity()
 * \brief Get excess_liquidity memory variable from current X-machine.
 * \return Value for variable.
 */
double get_excess_liquidity()
{
	if(current_xmachine->xmachine_Bank) return (*current_xmachine->xmachine_Bank).excess_liquidity;

    // suppress compiler warning by returning dummy value /
    // this statement should rightfully NEVER be reached /
    return (double)0;
}

/** \fn void set_total_bad_debt_calendar_month(double total_bad_debt_calendar_month)
 * \brief Set total_bad_debt_calendar_month memory variable for current X-machine.
 * \param total_bad_debt_calendar_month New value for variable.
 */
void set_total_bad_debt_calendar_month(double total_bad_debt_calendar_month)
{
	if(current_xmachine->xmachine_Bank) (*current_xmachine->xmachine_Bank).total_bad_debt_calendar_month = total_bad_debt_calendar_month;
}

/** \fn double get_total_bad_debt_calendar_month()
 * \brief Get total_bad_debt_calendar_month memory variable from current X-machine.
 * \return Value for variable.
 */
double get_total_bad_debt_calendar_month()
{
	if(current_xmachine->xmachine_Bank) return (*current_xmachine->xmachine_Bank).total_bad_debt_calendar_month;

    // suppress compiler warning by returning dummy value /
    // this statement should rightfully NEVER be reached /
    return (double)0;
}

/** \fn bank_balance_sheet_adt get_bank_balance_sheet_calendar()
 * \brief Get bank_balance_sheet_calendar memory variable from current X-machine.
 * \return Value for variable.
 */
bank_balance_sheet_adt * get_bank_balance_sheet_calendar()
{
	if(current_xmachine->xmachine_Bank) return &(*current_xmachine->xmachine_Bank).bank_balance_sheet_calendar;

    // suppress compiler warning by returning dummy value /
    // this statement should rightfully NEVER be reached /
    return NULL;
}

/** \fn bank_stocks_adt get_bank_stocks_calendar()
 * \brief Get bank_stocks_calendar memory variable from current X-machine.
 * \return Value for variable.
 */
bank_stocks_adt * get_bank_stocks_calendar()
{
	if(current_xmachine->xmachine_Bank) return &(*current_xmachine->xmachine_Bank).bank_stocks_calendar;

    // suppress compiler warning by returning dummy value /
    // this statement should rightfully NEVER be reached /
    return NULL;
}

/** \fn bank_outflows_adt get_bank_outflows_calendar()
 * \brief Get bank_outflows_calendar memory variable from current X-machine.
 * \return Value for variable.
 */
bank_outflows_adt * get_bank_outflows_calendar()
{
	if(current_xmachine->xmachine_Bank) return &(*current_xmachine->xmachine_Bank).bank_outflows_calendar;

    // suppress compiler warning by returning dummy value /
    // this statement should rightfully NEVER be reached /
    return NULL;
}

/** \fn bank_inflows_adt get_bank_inflows_calendar()
 * \brief Get bank_inflows_calendar memory variable from current X-machine.
 * \return Value for variable.
 */
bank_inflows_adt * get_bank_inflows_calendar()
{
	if(current_xmachine->xmachine_Bank) return &(*current_xmachine->xmachine_Bank).bank_inflows_calendar;

    // suppress compiler warning by returning dummy value /
    // this statement should rightfully NEVER be reached /
    return NULL;
}

/** \fn int_array get_list_of_regions()
 * \brief Get list_of_regions memory variable from current X-machine.
 * \return Value for variable.
 */
int_array * get_list_of_regions()
{
	if(current_xmachine->xmachine_Government) return &(*current_xmachine->xmachine_Government).list_of_regions;

    // suppress compiler warning by returning dummy value /
    // this statement should rightfully NEVER be reached /
    return NULL;
}

/** \fn void set_gdp_fraction_consumption(double gdp_fraction_consumption)
 * \brief Set gdp_fraction_consumption memory variable for current X-machine.
 * \param gdp_fraction_consumption New value for variable.
 */
void set_gdp_fraction_consumption(double gdp_fraction_consumption)
{
	if(current_xmachine->xmachine_Government) (*current_xmachine->xmachine_Government).gdp_fraction_consumption = gdp_fraction_consumption;
}

/** \fn double get_gdp_fraction_consumption()
 * \brief Get gdp_fraction_consumption memory variable from current X-machine.
 * \return Value for variable.
 */
double get_gdp_fraction_consumption()
{
	if(current_xmachine->xmachine_Government) return (*current_xmachine->xmachine_Government).gdp_fraction_consumption;

    // suppress compiler warning by returning dummy value /
    // this statement should rightfully NEVER be reached /
    return (double)0;
}

/** \fn void set_gdp_fraction_investment(double gdp_fraction_investment)
 * \brief Set gdp_fraction_investment memory variable for current X-machine.
 * \param gdp_fraction_investment New value for variable.
 */
void set_gdp_fraction_investment(double gdp_fraction_investment)
{
	if(current_xmachine->xmachine_Government) (*current_xmachine->xmachine_Government).gdp_fraction_investment = gdp_fraction_investment;
}

/** \fn double get_gdp_fraction_investment()
 * \brief Get gdp_fraction_investment memory variable from current X-machine.
 * \return Value for variable.
 */
double get_gdp_fraction_investment()
{
	if(current_xmachine->xmachine_Government) return (*current_xmachine->xmachine_Government).gdp_fraction_investment;

    // suppress compiler warning by returning dummy value /
    // this statement should rightfully NEVER be reached /
    return (double)0;
}

/** \fn void set_monthly_tax_revenues(double monthly_tax_revenues)
 * \brief Set monthly_tax_revenues memory variable for current X-machine.
 * \param monthly_tax_revenues New value for variable.
 */
void set_monthly_tax_revenues(double monthly_tax_revenues)
{
	if(current_xmachine->xmachine_Government) (*current_xmachine->xmachine_Government).monthly_tax_revenues = monthly_tax_revenues;
}

/** \fn double get_monthly_tax_revenues()
 * \brief Get monthly_tax_revenues memory variable from current X-machine.
 * \return Value for variable.
 */
double get_monthly_tax_revenues()
{
	if(current_xmachine->xmachine_Government) return (*current_xmachine->xmachine_Government).monthly_tax_revenues;

    // suppress compiler warning by returning dummy value /
    // this statement should rightfully NEVER be reached /
    return (double)0;
}

/** \fn void set_yearly_tax_revenues(double yearly_tax_revenues)
 * \brief Set yearly_tax_revenues memory variable for current X-machine.
 * \param yearly_tax_revenues New value for variable.
 */
void set_yearly_tax_revenues(double yearly_tax_revenues)
{
	if(current_xmachine->xmachine_Government) (*current_xmachine->xmachine_Government).yearly_tax_revenues = yearly_tax_revenues;
}

/** \fn double get_yearly_tax_revenues()
 * \brief Get yearly_tax_revenues memory variable from current X-machine.
 * \return Value for variable.
 */
double get_yearly_tax_revenues()
{
	if(current_xmachine->xmachine_Government) return (*current_xmachine->xmachine_Government).yearly_tax_revenues;

    // suppress compiler warning by returning dummy value /
    // this statement should rightfully NEVER be reached /
    return (double)0;
}

/** \fn void set_debt_gdp_ratio(double debt_gdp_ratio)
 * \brief Set debt_gdp_ratio memory variable for current X-machine.
 * \param debt_gdp_ratio New value for variable.
 */
void set_debt_gdp_ratio(double debt_gdp_ratio)
{
	if(current_xmachine->xmachine_Government) (*current_xmachine->xmachine_Government).debt_gdp_ratio = debt_gdp_ratio;
}

/** \fn double get_debt_gdp_ratio()
 * \brief Get debt_gdp_ratio memory variable from current X-machine.
 * \return Value for variable.
 */
double get_debt_gdp_ratio()
{
	if(current_xmachine->xmachine_Government) return (*current_xmachine->xmachine_Government).debt_gdp_ratio;

    // suppress compiler warning by returning dummy value /
    // this statement should rightfully NEVER be reached /
    return (double)0;
}

/** \fn adt_gov_inflows_outflows_array get_gov_inflows_outflows()
 * \brief Get gov_inflows_outflows memory variable from current X-machine.
 * \return Value for variable.
 */
adt_gov_inflows_outflows_array * get_gov_inflows_outflows()
{
	if(current_xmachine->xmachine_Government) return &(*current_xmachine->xmachine_Government).gov_inflows_outflows;

    // suppress compiler warning by returning dummy value /
    // this statement should rightfully NEVER be reached /
    return NULL;
}

/** \fn void set_monthly_benefit_payment(double monthly_benefit_payment)
 * \brief Set monthly_benefit_payment memory variable for current X-machine.
 * \param monthly_benefit_payment New value for variable.
 */
void set_monthly_benefit_payment(double monthly_benefit_payment)
{
	if(current_xmachine->xmachine_Government) (*current_xmachine->xmachine_Government).monthly_benefit_payment = monthly_benefit_payment;
}

/** \fn double get_monthly_benefit_payment()
 * \brief Get monthly_benefit_payment memory variable from current X-machine.
 * \return Value for variable.
 */
double get_monthly_benefit_payment()
{
	if(current_xmachine->xmachine_Government) return (*current_xmachine->xmachine_Government).monthly_benefit_payment;

    // suppress compiler warning by returning dummy value /
    // this statement should rightfully NEVER be reached /
    return (double)0;
}

/** \fn void set_minimum_wage_pct(double minimum_wage_pct)
 * \brief Set minimum_wage_pct memory variable for current X-machine.
 * \param minimum_wage_pct New value for variable.
 */
void set_minimum_wage_pct(double minimum_wage_pct)
{
	if(current_xmachine->xmachine_Government) (*current_xmachine->xmachine_Government).minimum_wage_pct = minimum_wage_pct;
}

/** \fn double get_minimum_wage_pct()
 * \brief Get minimum_wage_pct memory variable from current X-machine.
 * \return Value for variable.
 */
double get_minimum_wage_pct()
{
	if(current_xmachine->xmachine_Government) return (*current_xmachine->xmachine_Government).minimum_wage_pct;

    // suppress compiler warning by returning dummy value /
    // this statement should rightfully NEVER be reached /
    return (double)0;
}

/** \fn void set_gov_monthly_consumption_budget(double gov_monthly_consumption_budget)
 * \brief Set gov_monthly_consumption_budget memory variable for current X-machine.
 * \param gov_monthly_consumption_budget New value for variable.
 */
void set_gov_monthly_consumption_budget(double gov_monthly_consumption_budget)
{
	if(current_xmachine->xmachine_Government) (*current_xmachine->xmachine_Government).gov_monthly_consumption_budget = gov_monthly_consumption_budget;
}

/** \fn double get_gov_monthly_consumption_budget()
 * \brief Get gov_monthly_consumption_budget memory variable from current X-machine.
 * \return Value for variable.
 */
double get_gov_monthly_consumption_budget()
{
	if(current_xmachine->xmachine_Government) return (*current_xmachine->xmachine_Government).gov_monthly_consumption_budget;

    // suppress compiler warning by returning dummy value /
    // this statement should rightfully NEVER be reached /
    return (double)0;
}

/** \fn void set_yearly_benefit_payment(double yearly_benefit_payment)
 * \brief Set yearly_benefit_payment memory variable for current X-machine.
 * \param yearly_benefit_payment New value for variable.
 */
void set_yearly_benefit_payment(double yearly_benefit_payment)
{
	if(current_xmachine->xmachine_Government) (*current_xmachine->xmachine_Government).yearly_benefit_payment = yearly_benefit_payment;
}

/** \fn double get_yearly_benefit_payment()
 * \brief Get yearly_benefit_payment memory variable from current X-machine.
 * \return Value for variable.
 */
double get_yearly_benefit_payment()
{
	if(current_xmachine->xmachine_Government) return (*current_xmachine->xmachine_Government).yearly_benefit_payment;

    // suppress compiler warning by returning dummy value /
    // this statement should rightfully NEVER be reached /
    return (double)0;
}

/** \fn void set_hh_transfer_payment(double hh_transfer_payment)
 * \brief Set hh_transfer_payment memory variable for current X-machine.
 * \param hh_transfer_payment New value for variable.
 */
void set_hh_transfer_payment(double hh_transfer_payment)
{
	if(current_xmachine->xmachine_Government) (*current_xmachine->xmachine_Government).hh_transfer_payment = hh_transfer_payment;
}

/** \fn double get_hh_transfer_payment()
 * \brief Get hh_transfer_payment memory variable from current X-machine.
 * \return Value for variable.
 */
double get_hh_transfer_payment()
{
	if(current_xmachine->xmachine_Government) return (*current_xmachine->xmachine_Government).hh_transfer_payment;

    // suppress compiler warning by returning dummy value /
    // this statement should rightfully NEVER be reached /
    return (double)0;
}

/** \fn void set_firm_transfer_payment(double firm_transfer_payment)
 * \brief Set firm_transfer_payment memory variable for current X-machine.
 * \param firm_transfer_payment New value for variable.
 */
void set_firm_transfer_payment(double firm_transfer_payment)
{
	if(current_xmachine->xmachine_Government) (*current_xmachine->xmachine_Government).firm_transfer_payment = firm_transfer_payment;
}

/** \fn double get_firm_transfer_payment()
 * \brief Get firm_transfer_payment memory variable from current X-machine.
 * \return Value for variable.
 */
double get_firm_transfer_payment()
{
	if(current_xmachine->xmachine_Government) return (*current_xmachine->xmachine_Government).firm_transfer_payment;

    // suppress compiler warning by returning dummy value /
    // this statement should rightfully NEVER be reached /
    return (double)0;
}

/** \fn void set_monthly_transfer_payment(double monthly_transfer_payment)
 * \brief Set monthly_transfer_payment memory variable for current X-machine.
 * \param monthly_transfer_payment New value for variable.
 */
void set_monthly_transfer_payment(double monthly_transfer_payment)
{
	if(current_xmachine->xmachine_Government) (*current_xmachine->xmachine_Government).monthly_transfer_payment = monthly_transfer_payment;
}

/** \fn double get_monthly_transfer_payment()
 * \brief Get monthly_transfer_payment memory variable from current X-machine.
 * \return Value for variable.
 */
double get_monthly_transfer_payment()
{
	if(current_xmachine->xmachine_Government) return (*current_xmachine->xmachine_Government).monthly_transfer_payment;

    // suppress compiler warning by returning dummy value /
    // this statement should rightfully NEVER be reached /
    return (double)0;
}

/** \fn void set_yearly_transfer_payment(double yearly_transfer_payment)
 * \brief Set yearly_transfer_payment memory variable for current X-machine.
 * \param yearly_transfer_payment New value for variable.
 */
void set_yearly_transfer_payment(double yearly_transfer_payment)
{
	if(current_xmachine->xmachine_Government) (*current_xmachine->xmachine_Government).yearly_transfer_payment = yearly_transfer_payment;
}

/** \fn double get_yearly_transfer_payment()
 * \brief Get yearly_transfer_payment memory variable from current X-machine.
 * \return Value for variable.
 */
double get_yearly_transfer_payment()
{
	if(current_xmachine->xmachine_Government) return (*current_xmachine->xmachine_Government).yearly_transfer_payment;

    // suppress compiler warning by returning dummy value /
    // this statement should rightfully NEVER be reached /
    return (double)0;
}

/** \fn void set_hh_subsidy_pct(double hh_subsidy_pct)
 * \brief Set hh_subsidy_pct memory variable for current X-machine.
 * \param hh_subsidy_pct New value for variable.
 */
void set_hh_subsidy_pct(double hh_subsidy_pct)
{
	if(current_xmachine->xmachine_Government) (*current_xmachine->xmachine_Government).hh_subsidy_pct = hh_subsidy_pct;
}

/** \fn double get_hh_subsidy_pct()
 * \brief Get hh_subsidy_pct memory variable from current X-machine.
 * \return Value for variable.
 */
double get_hh_subsidy_pct()
{
	if(current_xmachine->xmachine_Government) return (*current_xmachine->xmachine_Government).hh_subsidy_pct;

    // suppress compiler warning by returning dummy value /
    // this statement should rightfully NEVER be reached /
    return (double)0;
}

/** \fn void set_firm_subsidy_pct(double firm_subsidy_pct)
 * \brief Set firm_subsidy_pct memory variable for current X-machine.
 * \param firm_subsidy_pct New value for variable.
 */
void set_firm_subsidy_pct(double firm_subsidy_pct)
{
	if(current_xmachine->xmachine_Government) (*current_xmachine->xmachine_Government).firm_subsidy_pct = firm_subsidy_pct;
}

/** \fn double get_firm_subsidy_pct()
 * \brief Get firm_subsidy_pct memory variable from current X-machine.
 * \return Value for variable.
 */
double get_firm_subsidy_pct()
{
	if(current_xmachine->xmachine_Government) return (*current_xmachine->xmachine_Government).firm_subsidy_pct;

    // suppress compiler warning by returning dummy value /
    // this statement should rightfully NEVER be reached /
    return (double)0;
}

/** \fn void set_regional_firm_subsidy(int regional_firm_subsidy)
 * \brief Set regional_firm_subsidy memory variable for current X-machine.
 * \param regional_firm_subsidy New value for variable.
 */
void set_regional_firm_subsidy(int regional_firm_subsidy)
{
	if(current_xmachine->xmachine_Government) (*current_xmachine->xmachine_Government).regional_firm_subsidy = regional_firm_subsidy;
}

/** \fn int get_regional_firm_subsidy()
 * \brief Get regional_firm_subsidy memory variable from current X-machine.
 * \return Value for variable.
 */
int get_regional_firm_subsidy()
{
	if(current_xmachine->xmachine_Government) return (*current_xmachine->xmachine_Government).regional_firm_subsidy;

    // suppress compiler warning by returning dummy value /
    // this statement should rightfully NEVER be reached /
    return (int)0;
}

/** \fn void set_subsidy_flag(int subsidy_flag)
 * \brief Set subsidy_flag memory variable for current X-machine.
 * \param subsidy_flag New value for variable.
 */
void set_subsidy_flag(int subsidy_flag)
{
	if(current_xmachine->xmachine_Government) (*current_xmachine->xmachine_Government).subsidy_flag = subsidy_flag;
}

/** \fn int get_subsidy_flag()
 * \brief Get subsidy_flag memory variable from current X-machine.
 * \return Value for variable.
 */
int get_subsidy_flag()
{
	if(current_xmachine->xmachine_Government) return (*current_xmachine->xmachine_Government).subsidy_flag;

    // suppress compiler warning by returning dummy value /
    // this statement should rightfully NEVER be reached /
    return (int)0;
}

/** \fn void set_gov_interest_rate(double gov_interest_rate)
 * \brief Set gov_interest_rate memory variable for current X-machine.
 * \param gov_interest_rate New value for variable.
 */
void set_gov_interest_rate(double gov_interest_rate)
{
	if(current_xmachine->xmachine_Government) (*current_xmachine->xmachine_Government).gov_interest_rate = gov_interest_rate;
}

/** \fn double get_gov_interest_rate()
 * \brief Get gov_interest_rate memory variable from current X-machine.
 * \return Value for variable.
 */
double get_gov_interest_rate()
{
	if(current_xmachine->xmachine_Government) return (*current_xmachine->xmachine_Government).gov_interest_rate;

    // suppress compiler warning by returning dummy value /
    // this statement should rightfully NEVER be reached /
    return (double)0;
}

/** \fn void set_monthly_bond_interest_payment(double monthly_bond_interest_payment)
 * \brief Set monthly_bond_interest_payment memory variable for current X-machine.
 * \param monthly_bond_interest_payment New value for variable.
 */
void set_monthly_bond_interest_payment(double monthly_bond_interest_payment)
{
	if(current_xmachine->xmachine_Government) (*current_xmachine->xmachine_Government).monthly_bond_interest_payment = monthly_bond_interest_payment;
}

/** \fn double get_monthly_bond_interest_payment()
 * \brief Get monthly_bond_interest_payment memory variable from current X-machine.
 * \return Value for variable.
 */
double get_monthly_bond_interest_payment()
{
	if(current_xmachine->xmachine_Government) return (*current_xmachine->xmachine_Government).monthly_bond_interest_payment;

    // suppress compiler warning by returning dummy value /
    // this statement should rightfully NEVER be reached /
    return (double)0;
}

/** \fn void set_monthly_subsidy_payment(double monthly_subsidy_payment)
 * \brief Set monthly_subsidy_payment memory variable for current X-machine.
 * \param monthly_subsidy_payment New value for variable.
 */
void set_monthly_subsidy_payment(double monthly_subsidy_payment)
{
	if(current_xmachine->xmachine_Government) (*current_xmachine->xmachine_Government).monthly_subsidy_payment = monthly_subsidy_payment;
}

/** \fn double get_monthly_subsidy_payment()
 * \brief Get monthly_subsidy_payment memory variable from current X-machine.
 * \return Value for variable.
 */
double get_monthly_subsidy_payment()
{
	if(current_xmachine->xmachine_Government) return (*current_xmachine->xmachine_Government).monthly_subsidy_payment;

    // suppress compiler warning by returning dummy value /
    // this statement should rightfully NEVER be reached /
    return (double)0;
}

/** \fn void set_monthly_subsidy_payment_to_households(double monthly_subsidy_payment_to_households)
 * \brief Set monthly_subsidy_payment_to_households memory variable for current X-machine.
 * \param monthly_subsidy_payment_to_households New value for variable.
 */
void set_monthly_subsidy_payment_to_households(double monthly_subsidy_payment_to_households)
{
	if(current_xmachine->xmachine_Government) (*current_xmachine->xmachine_Government).monthly_subsidy_payment_to_households = monthly_subsidy_payment_to_households;
}

/** \fn double get_monthly_subsidy_payment_to_households()
 * \brief Get monthly_subsidy_payment_to_households memory variable from current X-machine.
 * \return Value for variable.
 */
double get_monthly_subsidy_payment_to_households()
{
	if(current_xmachine->xmachine_Government) return (*current_xmachine->xmachine_Government).monthly_subsidy_payment_to_households;

    // suppress compiler warning by returning dummy value /
    // this statement should rightfully NEVER be reached /
    return (double)0;
}

/** \fn void set_monthly_subsidy_payment_to_firms(double monthly_subsidy_payment_to_firms)
 * \brief Set monthly_subsidy_payment_to_firms memory variable for current X-machine.
 * \param monthly_subsidy_payment_to_firms New value for variable.
 */
void set_monthly_subsidy_payment_to_firms(double monthly_subsidy_payment_to_firms)
{
	if(current_xmachine->xmachine_Government) (*current_xmachine->xmachine_Government).monthly_subsidy_payment_to_firms = monthly_subsidy_payment_to_firms;
}

/** \fn double get_monthly_subsidy_payment_to_firms()
 * \brief Get monthly_subsidy_payment_to_firms memory variable from current X-machine.
 * \return Value for variable.
 */
double get_monthly_subsidy_payment_to_firms()
{
	if(current_xmachine->xmachine_Government) return (*current_xmachine->xmachine_Government).monthly_subsidy_payment_to_firms;

    // suppress compiler warning by returning dummy value /
    // this statement should rightfully NEVER be reached /
    return (double)0;
}

/** \fn void set_austerity_phase(int austerity_phase)
 * \brief Set austerity_phase memory variable for current X-machine.
 * \param austerity_phase New value for variable.
 */
void set_austerity_phase(int austerity_phase)
{
	if(current_xmachine->xmachine_Government) (*current_xmachine->xmachine_Government).austerity_phase = austerity_phase;
}

/** \fn int get_austerity_phase()
 * \brief Get austerity_phase memory variable from current X-machine.
 * \return Value for variable.
 */
int get_austerity_phase()
{
	if(current_xmachine->xmachine_Government) return (*current_xmachine->xmachine_Government).austerity_phase;

    // suppress compiler warning by returning dummy value /
    // this statement should rightfully NEVER be reached /
    return (int)0;
}

/** \fn void set_foreign_debt(double foreign_debt)
 * \brief Set foreign_debt memory variable for current X-machine.
 * \param foreign_debt New value for variable.
 */
void set_foreign_debt(double foreign_debt)
{
	if(current_xmachine->xmachine_Government) (*current_xmachine->xmachine_Government).foreign_debt = foreign_debt;
}

/** \fn double get_foreign_debt()
 * \brief Get foreign_debt memory variable from current X-machine.
 * \return Value for variable.
 */
double get_foreign_debt()
{
	if(current_xmachine->xmachine_Government) return (*current_xmachine->xmachine_Government).foreign_debt;

    // suppress compiler warning by returning dummy value /
    // this statement should rightfully NEVER be reached /
    return (double)0;
}

/** \fn void set_add_foreign_debt(double add_foreign_debt)
 * \brief Set add_foreign_debt memory variable for current X-machine.
 * \param add_foreign_debt New value for variable.
 */
void set_add_foreign_debt(double add_foreign_debt)
{
	if(current_xmachine->xmachine_Government) (*current_xmachine->xmachine_Government).add_foreign_debt = add_foreign_debt;
}

/** \fn double get_add_foreign_debt()
 * \brief Get add_foreign_debt memory variable from current X-machine.
 * \return Value for variable.
 */
double get_add_foreign_debt()
{
	if(current_xmachine->xmachine_Government) return (*current_xmachine->xmachine_Government).add_foreign_debt;

    // suppress compiler warning by returning dummy value /
    // this statement should rightfully NEVER be reached /
    return (double)0;
}

/** \fn void set_foreign_debt_installment(double foreign_debt_installment)
 * \brief Set foreign_debt_installment memory variable for current X-machine.
 * \param foreign_debt_installment New value for variable.
 */
void set_foreign_debt_installment(double foreign_debt_installment)
{
	if(current_xmachine->xmachine_Government) (*current_xmachine->xmachine_Government).foreign_debt_installment = foreign_debt_installment;
}

/** \fn double get_foreign_debt_installment()
 * \brief Get foreign_debt_installment memory variable from current X-machine.
 * \return Value for variable.
 */
double get_foreign_debt_installment()
{
	if(current_xmachine->xmachine_Government) return (*current_xmachine->xmachine_Government).foreign_debt_installment;

    // suppress compiler warning by returning dummy value /
    // this statement should rightfully NEVER be reached /
    return (double)0;
}

/** \fn void set_monthly_investment_expenditure(double monthly_investment_expenditure)
 * \brief Set monthly_investment_expenditure memory variable for current X-machine.
 * \param monthly_investment_expenditure New value for variable.
 */
void set_monthly_investment_expenditure(double monthly_investment_expenditure)
{
	if(current_xmachine->xmachine_Government) (*current_xmachine->xmachine_Government).monthly_investment_expenditure = monthly_investment_expenditure;
}

/** \fn double get_monthly_investment_expenditure()
 * \brief Get monthly_investment_expenditure memory variable from current X-machine.
 * \return Value for variable.
 */
double get_monthly_investment_expenditure()
{
	if(current_xmachine->xmachine_Government) return (*current_xmachine->xmachine_Government).monthly_investment_expenditure;

    // suppress compiler warning by returning dummy value /
    // this statement should rightfully NEVER be reached /
    return (double)0;
}

/** \fn void set_monthly_budget_balance(double monthly_budget_balance)
 * \brief Set monthly_budget_balance memory variable for current X-machine.
 * \param monthly_budget_balance New value for variable.
 */
void set_monthly_budget_balance(double monthly_budget_balance)
{
	if(current_xmachine->xmachine_Government) (*current_xmachine->xmachine_Government).monthly_budget_balance = monthly_budget_balance;
}

/** \fn double get_monthly_budget_balance()
 * \brief Get monthly_budget_balance memory variable from current X-machine.
 * \return Value for variable.
 */
double get_monthly_budget_balance()
{
	if(current_xmachine->xmachine_Government) return (*current_xmachine->xmachine_Government).monthly_budget_balance;

    // suppress compiler warning by returning dummy value /
    // this statement should rightfully NEVER be reached /
    return (double)0;
}

/** \fn void set_monthly_gdp(double monthly_gdp)
 * \brief Set monthly_gdp memory variable for current X-machine.
 * \param monthly_gdp New value for variable.
 */
void set_monthly_gdp(double monthly_gdp)
{
	if(current_xmachine->xmachine_Government) (*current_xmachine->xmachine_Government).monthly_gdp = monthly_gdp;
}

/** \fn double get_monthly_gdp()
 * \brief Get monthly_gdp memory variable from current X-machine.
 * \return Value for variable.
 */
double get_monthly_gdp()
{
	if(current_xmachine->xmachine_Government) return (*current_xmachine->xmachine_Government).monthly_gdp;

    // suppress compiler warning by returning dummy value /
    // this statement should rightfully NEVER be reached /
    return (double)0;
}

/** \fn double_array get_last_monthly_gdps()
 * \brief Get last_monthly_gdps memory variable from current X-machine.
 * \return Value for variable.
 */
double_array * get_last_monthly_gdps()
{
	if(current_xmachine->xmachine_Government) return &(*current_xmachine->xmachine_Government).last_monthly_gdps;

    // suppress compiler warning by returning dummy value /
    // this statement should rightfully NEVER be reached /
    return NULL;
}

/** \fn void set_monthly_budget_balance_gdp_fraction(double monthly_budget_balance_gdp_fraction)
 * \brief Set monthly_budget_balance_gdp_fraction memory variable for current X-machine.
 * \param monthly_budget_balance_gdp_fraction New value for variable.
 */
void set_monthly_budget_balance_gdp_fraction(double monthly_budget_balance_gdp_fraction)
{
	if(current_xmachine->xmachine_Government) (*current_xmachine->xmachine_Government).monthly_budget_balance_gdp_fraction = monthly_budget_balance_gdp_fraction;
}

/** \fn double get_monthly_budget_balance_gdp_fraction()
 * \brief Get monthly_budget_balance_gdp_fraction memory variable from current X-machine.
 * \return Value for variable.
 */
double get_monthly_budget_balance_gdp_fraction()
{
	if(current_xmachine->xmachine_Government) return (*current_xmachine->xmachine_Government).monthly_budget_balance_gdp_fraction;

    // suppress compiler warning by returning dummy value /
    // this statement should rightfully NEVER be reached /
    return (double)0;
}

/** \fn void set_monthly_consumption_budget(double monthly_consumption_budget)
 * \brief Set monthly_consumption_budget memory variable for current X-machine.
 * \param monthly_consumption_budget New value for variable.
 */
void set_monthly_consumption_budget(double monthly_consumption_budget)
{
	if(current_xmachine->xmachine_Government) (*current_xmachine->xmachine_Government).monthly_consumption_budget = monthly_consumption_budget;
}

/** \fn double get_monthly_consumption_budget()
 * \brief Get monthly_consumption_budget memory variable from current X-machine.
 * \return Value for variable.
 */
double get_monthly_consumption_budget()
{
	if(current_xmachine->xmachine_Government) return (*current_xmachine->xmachine_Government).monthly_consumption_budget;

    // suppress compiler warning by returning dummy value /
    // this statement should rightfully NEVER be reached /
    return (double)0;
}

/** \fn void set_monthly_investment_budget(double monthly_investment_budget)
 * \brief Set monthly_investment_budget memory variable for current X-machine.
 * \param monthly_investment_budget New value for variable.
 */
void set_monthly_investment_budget(double monthly_investment_budget)
{
	if(current_xmachine->xmachine_Government) (*current_xmachine->xmachine_Government).monthly_investment_budget = monthly_investment_budget;
}

/** \fn double get_monthly_investment_budget()
 * \brief Get monthly_investment_budget memory variable from current X-machine.
 * \return Value for variable.
 */
double get_monthly_investment_budget()
{
	if(current_xmachine->xmachine_Government) return (*current_xmachine->xmachine_Government).monthly_investment_budget;

    // suppress compiler warning by returning dummy value /
    // this statement should rightfully NEVER be reached /
    return (double)0;
}

/** \fn void set_monthly_income(double monthly_income)
 * \brief Set monthly_income memory variable for current X-machine.
 * \param monthly_income New value for variable.
 */
void set_monthly_income(double monthly_income)
{
	if(current_xmachine->xmachine_Government) (*current_xmachine->xmachine_Government).monthly_income = monthly_income;
}

/** \fn double get_monthly_income()
 * \brief Get monthly_income memory variable from current X-machine.
 * \return Value for variable.
 */
double get_monthly_income()
{
	if(current_xmachine->xmachine_Government) return (*current_xmachine->xmachine_Government).monthly_income;

    // suppress compiler warning by returning dummy value /
    // this statement should rightfully NEVER be reached /
    return (double)0;
}

/** \fn void set_monthly_expenditure(double monthly_expenditure)
 * \brief Set monthly_expenditure memory variable for current X-machine.
 * \param monthly_expenditure New value for variable.
 */
void set_monthly_expenditure(double monthly_expenditure)
{
	if(current_xmachine->xmachine_Government) (*current_xmachine->xmachine_Government).monthly_expenditure = monthly_expenditure;
}

/** \fn double get_monthly_expenditure()
 * \brief Get monthly_expenditure memory variable from current X-machine.
 * \return Value for variable.
 */
double get_monthly_expenditure()
{
	if(current_xmachine->xmachine_Government) return (*current_xmachine->xmachine_Government).monthly_expenditure;

    // suppress compiler warning by returning dummy value /
    // this statement should rightfully NEVER be reached /
    return (double)0;
}

/** \fn void set_yearly_subsidy_payment(double yearly_subsidy_payment)
 * \brief Set yearly_subsidy_payment memory variable for current X-machine.
 * \param yearly_subsidy_payment New value for variable.
 */
void set_yearly_subsidy_payment(double yearly_subsidy_payment)
{
	if(current_xmachine->xmachine_Government) (*current_xmachine->xmachine_Government).yearly_subsidy_payment = yearly_subsidy_payment;
}

/** \fn double get_yearly_subsidy_payment()
 * \brief Get yearly_subsidy_payment memory variable from current X-machine.
 * \return Value for variable.
 */
double get_yearly_subsidy_payment()
{
	if(current_xmachine->xmachine_Government) return (*current_xmachine->xmachine_Government).yearly_subsidy_payment;

    // suppress compiler warning by returning dummy value /
    // this statement should rightfully NEVER be reached /
    return (double)0;
}

/** \fn void set_yearly_bond_interest_payment(double yearly_bond_interest_payment)
 * \brief Set yearly_bond_interest_payment memory variable for current X-machine.
 * \param yearly_bond_interest_payment New value for variable.
 */
void set_yearly_bond_interest_payment(double yearly_bond_interest_payment)
{
	if(current_xmachine->xmachine_Government) (*current_xmachine->xmachine_Government).yearly_bond_interest_payment = yearly_bond_interest_payment;
}

/** \fn double get_yearly_bond_interest_payment()
 * \brief Get yearly_bond_interest_payment memory variable from current X-machine.
 * \return Value for variable.
 */
double get_yearly_bond_interest_payment()
{
	if(current_xmachine->xmachine_Government) return (*current_xmachine->xmachine_Government).yearly_bond_interest_payment;

    // suppress compiler warning by returning dummy value /
    // this statement should rightfully NEVER be reached /
    return (double)0;
}

/** \fn void set_yearly_investment_expenditure(double yearly_investment_expenditure)
 * \brief Set yearly_investment_expenditure memory variable for current X-machine.
 * \param yearly_investment_expenditure New value for variable.
 */
void set_yearly_investment_expenditure(double yearly_investment_expenditure)
{
	if(current_xmachine->xmachine_Government) (*current_xmachine->xmachine_Government).yearly_investment_expenditure = yearly_investment_expenditure;
}

/** \fn double get_yearly_investment_expenditure()
 * \brief Get yearly_investment_expenditure memory variable from current X-machine.
 * \return Value for variable.
 */
double get_yearly_investment_expenditure()
{
	if(current_xmachine->xmachine_Government) return (*current_xmachine->xmachine_Government).yearly_investment_expenditure;

    // suppress compiler warning by returning dummy value /
    // this statement should rightfully NEVER be reached /
    return (double)0;
}

/** \fn void set_yearly_consumption_expenditure(double yearly_consumption_expenditure)
 * \brief Set yearly_consumption_expenditure memory variable for current X-machine.
 * \param yearly_consumption_expenditure New value for variable.
 */
void set_yearly_consumption_expenditure(double yearly_consumption_expenditure)
{
	if(current_xmachine->xmachine_Government) (*current_xmachine->xmachine_Government).yearly_consumption_expenditure = yearly_consumption_expenditure;
}

/** \fn double get_yearly_consumption_expenditure()
 * \brief Get yearly_consumption_expenditure memory variable from current X-machine.
 * \return Value for variable.
 */
double get_yearly_consumption_expenditure()
{
	if(current_xmachine->xmachine_Government) return (*current_xmachine->xmachine_Government).yearly_consumption_expenditure;

    // suppress compiler warning by returning dummy value /
    // this statement should rightfully NEVER be reached /
    return (double)0;
}

/** \fn void set_yearly_income(double yearly_income)
 * \brief Set yearly_income memory variable for current X-machine.
 * \param yearly_income New value for variable.
 */
void set_yearly_income(double yearly_income)
{
	if(current_xmachine->xmachine_Government) (*current_xmachine->xmachine_Government).yearly_income = yearly_income;
}

/** \fn double get_yearly_income()
 * \brief Get yearly_income memory variable from current X-machine.
 * \return Value for variable.
 */
double get_yearly_income()
{
	if(current_xmachine->xmachine_Government) return (*current_xmachine->xmachine_Government).yearly_income;

    // suppress compiler warning by returning dummy value /
    // this statement should rightfully NEVER be reached /
    return (double)0;
}

/** \fn void set_yearly_expenditure(double yearly_expenditure)
 * \brief Set yearly_expenditure memory variable for current X-machine.
 * \param yearly_expenditure New value for variable.
 */
void set_yearly_expenditure(double yearly_expenditure)
{
	if(current_xmachine->xmachine_Government) (*current_xmachine->xmachine_Government).yearly_expenditure = yearly_expenditure;
}

/** \fn double get_yearly_expenditure()
 * \brief Get yearly_expenditure memory variable from current X-machine.
 * \return Value for variable.
 */
double get_yearly_expenditure()
{
	if(current_xmachine->xmachine_Government) return (*current_xmachine->xmachine_Government).yearly_expenditure;

    // suppress compiler warning by returning dummy value /
    // this statement should rightfully NEVER be reached /
    return (double)0;
}

/** \fn void set_subsidy_transfer_received(double subsidy_transfer_received)
 * \brief Set subsidy_transfer_received memory variable for current X-machine.
 * \param subsidy_transfer_received New value for variable.
 */
void set_subsidy_transfer_received(double subsidy_transfer_received)
{
	if(current_xmachine->xmachine_Government) (*current_xmachine->xmachine_Government).subsidy_transfer_received = subsidy_transfer_received;
}

/** \fn double get_subsidy_transfer_received()
 * \brief Get subsidy_transfer_received memory variable from current X-machine.
 * \return Value for variable.
 */
double get_subsidy_transfer_received()
{
	if(current_xmachine->xmachine_Government) return (*current_xmachine->xmachine_Government).subsidy_transfer_received;

    // suppress compiler warning by returning dummy value /
    // this statement should rightfully NEVER be reached /
    return (double)0;
}

/** \fn void set_yearly_budget_balance(double yearly_budget_balance)
 * \brief Set yearly_budget_balance memory variable for current X-machine.
 * \param yearly_budget_balance New value for variable.
 */
void set_yearly_budget_balance(double yearly_budget_balance)
{
	if(current_xmachine->xmachine_Government) (*current_xmachine->xmachine_Government).yearly_budget_balance = yearly_budget_balance;
}

/** \fn double get_yearly_budget_balance()
 * \brief Get yearly_budget_balance memory variable from current X-machine.
 * \return Value for variable.
 */
double get_yearly_budget_balance()
{
	if(current_xmachine->xmachine_Government) return (*current_xmachine->xmachine_Government).yearly_budget_balance;

    // suppress compiler warning by returning dummy value /
    // this statement should rightfully NEVER be reached /
    return (double)0;
}

/** \fn void set_total_money_financing(double total_money_financing)
 * \brief Set total_money_financing memory variable for current X-machine.
 * \param total_money_financing New value for variable.
 */
void set_total_money_financing(double total_money_financing)
{
	if(current_xmachine->xmachine_Government) (*current_xmachine->xmachine_Government).total_money_financing = total_money_financing;
}

/** \fn double get_total_money_financing()
 * \brief Get total_money_financing memory variable from current X-machine.
 * \return Value for variable.
 */
double get_total_money_financing()
{
	if(current_xmachine->xmachine_Government) return (*current_xmachine->xmachine_Government).total_money_financing;

    // suppress compiler warning by returning dummy value /
    // this statement should rightfully NEVER be reached /
    return (double)0;
}

/** \fn void set_total_bond_financing(double total_bond_financing)
 * \brief Set total_bond_financing memory variable for current X-machine.
 * \param total_bond_financing New value for variable.
 */
void set_total_bond_financing(double total_bond_financing)
{
	if(current_xmachine->xmachine_Government) (*current_xmachine->xmachine_Government).total_bond_financing = total_bond_financing;
}

/** \fn double get_total_bond_financing()
 * \brief Get total_bond_financing memory variable from current X-machine.
 * \return Value for variable.
 */
double get_total_bond_financing()
{
	if(current_xmachine->xmachine_Government) return (*current_xmachine->xmachine_Government).total_bond_financing;

    // suppress compiler warning by returning dummy value /
    // this statement should rightfully NEVER be reached /
    return (double)0;
}

/** \fn void set_country_wide_mean_wage(double country_wide_mean_wage)
 * \brief Set country_wide_mean_wage memory variable for current X-machine.
 * \param country_wide_mean_wage New value for variable.
 */
void set_country_wide_mean_wage(double country_wide_mean_wage)
{
	if(current_xmachine->xmachine_Government) (*current_xmachine->xmachine_Government).country_wide_mean_wage = country_wide_mean_wage;
}

/** \fn double get_country_wide_mean_wage()
 * \brief Get country_wide_mean_wage memory variable from current X-machine.
 * \return Value for variable.
 */
double get_country_wide_mean_wage()
{
	if(current_xmachine->xmachine_Government) return (*current_xmachine->xmachine_Government).country_wide_mean_wage;

    // suppress compiler warning by returning dummy value /
    // this statement should rightfully NEVER be reached /
    return (double)0;
}

/** \fn void set_num_unemployed(int num_unemployed)
 * \brief Set num_unemployed memory variable for current X-machine.
 * \param num_unemployed New value for variable.
 */
void set_num_unemployed(int num_unemployed)
{
	if(current_xmachine->xmachine_Government) (*current_xmachine->xmachine_Government).num_unemployed = num_unemployed;
}

/** \fn int get_num_unemployed()
 * \brief Get num_unemployed memory variable from current X-machine.
 * \return Value for variable.
 */
int get_num_unemployed()
{
	if(current_xmachine->xmachine_Government) return (*current_xmachine->xmachine_Government).num_unemployed;

    // suppress compiler warning by returning dummy value /
    // this statement should rightfully NEVER be reached /
    return (int)0;
}

/** \fn void set_yearly_gdp(double yearly_gdp)
 * \brief Set yearly_gdp memory variable for current X-machine.
 * \param yearly_gdp New value for variable.
 */
void set_yearly_gdp(double yearly_gdp)
{
	if(current_xmachine->xmachine_Government) (*current_xmachine->xmachine_Government).yearly_gdp = yearly_gdp;
}

/** \fn double get_yearly_gdp()
 * \brief Get yearly_gdp memory variable from current X-machine.
 * \return Value for variable.
 */
double get_yearly_gdp()
{
	if(current_xmachine->xmachine_Government) return (*current_xmachine->xmachine_Government).yearly_gdp;

    // suppress compiler warning by returning dummy value /
    // this statement should rightfully NEVER be reached /
    return (double)0;
}

/** \fn void set_previous_year_gdp(double previous_year_gdp)
 * \brief Set previous_year_gdp memory variable for current X-machine.
 * \param previous_year_gdp New value for variable.
 */
void set_previous_year_gdp(double previous_year_gdp)
{
	if(current_xmachine->xmachine_Government) (*current_xmachine->xmachine_Government).previous_year_gdp = previous_year_gdp;
}

/** \fn double get_previous_year_gdp()
 * \brief Get previous_year_gdp memory variable from current X-machine.
 * \return Value for variable.
 */
double get_previous_year_gdp()
{
	if(current_xmachine->xmachine_Government) return (*current_xmachine->xmachine_Government).previous_year_gdp;

    // suppress compiler warning by returning dummy value /
    // this statement should rightfully NEVER be reached /
    return (double)0;
}

/** \fn void set_subsidy_reported_to_eurostat(double subsidy_reported_to_eurostat)
 * \brief Set subsidy_reported_to_eurostat memory variable for current X-machine.
 * \param subsidy_reported_to_eurostat New value for variable.
 */
void set_subsidy_reported_to_eurostat(double subsidy_reported_to_eurostat)
{
	if(current_xmachine->xmachine_Government) (*current_xmachine->xmachine_Government).subsidy_reported_to_eurostat = subsidy_reported_to_eurostat;
}

/** \fn double get_subsidy_reported_to_eurostat()
 * \brief Get subsidy_reported_to_eurostat memory variable from current X-machine.
 * \return Value for variable.
 */
double get_subsidy_reported_to_eurostat()
{
	if(current_xmachine->xmachine_Government) return (*current_xmachine->xmachine_Government).subsidy_reported_to_eurostat;

    // suppress compiler warning by returning dummy value /
    // this statement should rightfully NEVER be reached /
    return (double)0;
}

/** \fn void set_gdp_growth(double gdp_growth)
 * \brief Set gdp_growth memory variable for current X-machine.
 * \param gdp_growth New value for variable.
 */
void set_gdp_growth(double gdp_growth)
{
	if(current_xmachine->xmachine_Government) (*current_xmachine->xmachine_Government).gdp_growth = gdp_growth;
}

/** \fn double get_gdp_growth()
 * \brief Get gdp_growth memory variable from current X-machine.
 * \return Value for variable.
 */
double get_gdp_growth()
{
	if(current_xmachine->xmachine_Government) return (*current_xmachine->xmachine_Government).gdp_growth;

    // suppress compiler warning by returning dummy value /
    // this statement should rightfully NEVER be reached /
    return (double)0;
}

/** \fn void set_gdp_forecast(double gdp_forecast)
 * \brief Set gdp_forecast memory variable for current X-machine.
 * \param gdp_forecast New value for variable.
 */
void set_gdp_forecast(double gdp_forecast)
{
	if(current_xmachine->xmachine_Government) (*current_xmachine->xmachine_Government).gdp_forecast = gdp_forecast;
}

/** \fn double get_gdp_forecast()
 * \brief Get gdp_forecast memory variable from current X-machine.
 * \return Value for variable.
 */
double get_gdp_forecast()
{
	if(current_xmachine->xmachine_Government) return (*current_xmachine->xmachine_Government).gdp_forecast;

    // suppress compiler warning by returning dummy value /
    // this statement should rightfully NEVER be reached /
    return (double)0;
}

/** \fn void set_yearly_income_forecast(double yearly_income_forecast)
 * \brief Set yearly_income_forecast memory variable for current X-machine.
 * \param yearly_income_forecast New value for variable.
 */
void set_yearly_income_forecast(double yearly_income_forecast)
{
	if(current_xmachine->xmachine_Government) (*current_xmachine->xmachine_Government).yearly_income_forecast = yearly_income_forecast;
}

/** \fn double get_yearly_income_forecast()
 * \brief Get yearly_income_forecast memory variable from current X-machine.
 * \return Value for variable.
 */
double get_yearly_income_forecast()
{
	if(current_xmachine->xmachine_Government) return (*current_xmachine->xmachine_Government).yearly_income_forecast;

    // suppress compiler warning by returning dummy value /
    // this statement should rightfully NEVER be reached /
    return (double)0;
}

/** \fn void set_yearly_expenditure_budget(double yearly_expenditure_budget)
 * \brief Set yearly_expenditure_budget memory variable for current X-machine.
 * \param yearly_expenditure_budget New value for variable.
 */
void set_yearly_expenditure_budget(double yearly_expenditure_budget)
{
	if(current_xmachine->xmachine_Government) (*current_xmachine->xmachine_Government).yearly_expenditure_budget = yearly_expenditure_budget;
}

/** \fn double get_yearly_expenditure_budget()
 * \brief Get yearly_expenditure_budget memory variable from current X-machine.
 * \return Value for variable.
 */
double get_yearly_expenditure_budget()
{
	if(current_xmachine->xmachine_Government) return (*current_xmachine->xmachine_Government).yearly_expenditure_budget;

    // suppress compiler warning by returning dummy value /
    // this statement should rightfully NEVER be reached /
    return (double)0;
}

/** \fn void set_budget_balance_forecast(double budget_balance_forecast)
 * \brief Set budget_balance_forecast memory variable for current X-machine.
 * \param budget_balance_forecast New value for variable.
 */
void set_budget_balance_forecast(double budget_balance_forecast)
{
	if(current_xmachine->xmachine_Government) (*current_xmachine->xmachine_Government).budget_balance_forecast = budget_balance_forecast;
}

/** \fn double get_budget_balance_forecast()
 * \brief Get budget_balance_forecast memory variable from current X-machine.
 * \return Value for variable.
 */
double get_budget_balance_forecast()
{
	if(current_xmachine->xmachine_Government) return (*current_xmachine->xmachine_Government).budget_balance_forecast;

    // suppress compiler warning by returning dummy value /
    // this statement should rightfully NEVER be reached /
    return (double)0;
}

/** \fn ordered_quantity_array get_ordered_quantities()
 * \brief Get ordered_quantities memory variable from current X-machine.
 * \return Value for variable.
 */
ordered_quantity_array * get_ordered_quantities()
{
	if(current_xmachine->xmachine_Government) return &(*current_xmachine->xmachine_Government).ordered_quantities;

    // suppress compiler warning by returning dummy value /
    // this statement should rightfully NEVER be reached /
    return NULL;
}

/** \fn received_quantities_array get_gov_received_quantities()
 * \brief Get gov_received_quantities memory variable from current X-machine.
 * \return Value for variable.
 */
received_quantities_array * get_gov_received_quantities()
{
	if(current_xmachine->xmachine_Government) return &(*current_xmachine->xmachine_Government).gov_received_quantities;

    // suppress compiler warning by returning dummy value /
    // this statement should rightfully NEVER be reached /
    return NULL;
}

/** \fn double_array get_consumption_budgets_per_capita()
 * \brief Get consumption_budgets_per_capita memory variable from current X-machine.
 * \return Value for variable.
 */
double_array * get_consumption_budgets_per_capita()
{
	if(current_xmachine->xmachine_Government) return &(*current_xmachine->xmachine_Government).consumption_budgets_per_capita;

    // suppress compiler warning by returning dummy value /
    // this statement should rightfully NEVER be reached /
    return NULL;
}

/** \fn void set_av_consumption_budget_per_capita(double av_consumption_budget_per_capita)
 * \brief Set av_consumption_budget_per_capita memory variable for current X-machine.
 * \param av_consumption_budget_per_capita New value for variable.
 */
void set_av_consumption_budget_per_capita(double av_consumption_budget_per_capita)
{
	if(current_xmachine->xmachine_Government) (*current_xmachine->xmachine_Government).av_consumption_budget_per_capita = av_consumption_budget_per_capita;
}

/** \fn double get_av_consumption_budget_per_capita()
 * \brief Get av_consumption_budget_per_capita memory variable from current X-machine.
 * \return Value for variable.
 */
double get_av_consumption_budget_per_capita()
{
	if(current_xmachine->xmachine_Government) return (*current_xmachine->xmachine_Government).av_consumption_budget_per_capita;

    // suppress compiler warning by returning dummy value /
    // this statement should rightfully NEVER be reached /
    return (double)0;
}

/** \fn double_array get_consumption_quotas_rel_to_reg1()
 * \brief Get consumption_quotas_rel_to_reg1 memory variable from current X-machine.
 * \return Value for variable.
 */
double_array * get_consumption_quotas_rel_to_reg1()
{
	if(current_xmachine->xmachine_Government) return &(*current_xmachine->xmachine_Government).consumption_quotas_rel_to_reg1;

    // suppress compiler warning by returning dummy value /
    // this statement should rightfully NEVER be reached /
    return NULL;
}

/** \fn void set_av_consumption_quota_rel_to_reg1(double av_consumption_quota_rel_to_reg1)
 * \brief Set av_consumption_quota_rel_to_reg1 memory variable for current X-machine.
 * \param av_consumption_quota_rel_to_reg1 New value for variable.
 */
void set_av_consumption_quota_rel_to_reg1(double av_consumption_quota_rel_to_reg1)
{
	if(current_xmachine->xmachine_Government) (*current_xmachine->xmachine_Government).av_consumption_quota_rel_to_reg1 = av_consumption_quota_rel_to_reg1;
}

/** \fn double get_av_consumption_quota_rel_to_reg1()
 * \brief Get av_consumption_quota_rel_to_reg1 memory variable from current X-machine.
 * \return Value for variable.
 */
double get_av_consumption_quota_rel_to_reg1()
{
	if(current_xmachine->xmachine_Government) return (*current_xmachine->xmachine_Government).av_consumption_quota_rel_to_reg1;

    // suppress compiler warning by returning dummy value /
    // this statement should rightfully NEVER be reached /
    return (double)0;
}

/** \fn void set_yearly_consumption_budget(double yearly_consumption_budget)
 * \brief Set yearly_consumption_budget memory variable for current X-machine.
 * \param yearly_consumption_budget New value for variable.
 */
void set_yearly_consumption_budget(double yearly_consumption_budget)
{
	if(current_xmachine->xmachine_Government) (*current_xmachine->xmachine_Government).yearly_consumption_budget = yearly_consumption_budget;
}

/** \fn double get_yearly_consumption_budget()
 * \brief Get yearly_consumption_budget memory variable from current X-machine.
 * \return Value for variable.
 */
double get_yearly_consumption_budget()
{
	if(current_xmachine->xmachine_Government) return (*current_xmachine->xmachine_Government).yearly_consumption_budget;

    // suppress compiler warning by returning dummy value /
    // this statement should rightfully NEVER be reached /
    return (double)0;
}

/** \fn void set_yearly_investment_budget(double yearly_investment_budget)
 * \brief Set yearly_investment_budget memory variable for current X-machine.
 * \param yearly_investment_budget New value for variable.
 */
void set_yearly_investment_budget(double yearly_investment_budget)
{
	if(current_xmachine->xmachine_Government) (*current_xmachine->xmachine_Government).yearly_investment_budget = yearly_investment_budget;
}

/** \fn double get_yearly_investment_budget()
 * \brief Get yearly_investment_budget memory variable from current X-machine.
 * \return Value for variable.
 */
double get_yearly_investment_budget()
{
	if(current_xmachine->xmachine_Government) return (*current_xmachine->xmachine_Government).yearly_investment_budget;

    // suppress compiler warning by returning dummy value /
    // this statement should rightfully NEVER be reached /
    return (double)0;
}

/** \fn void set_yearly_budget_balance_gdp_fraction(double yearly_budget_balance_gdp_fraction)
 * \brief Set yearly_budget_balance_gdp_fraction memory variable for current X-machine.
 * \param yearly_budget_balance_gdp_fraction New value for variable.
 */
void set_yearly_budget_balance_gdp_fraction(double yearly_budget_balance_gdp_fraction)
{
	if(current_xmachine->xmachine_Government) (*current_xmachine->xmachine_Government).yearly_budget_balance_gdp_fraction = yearly_budget_balance_gdp_fraction;
}

/** \fn double get_yearly_budget_balance_gdp_fraction()
 * \brief Get yearly_budget_balance_gdp_fraction memory variable from current X-machine.
 * \return Value for variable.
 */
double get_yearly_budget_balance_gdp_fraction()
{
	if(current_xmachine->xmachine_Government) return (*current_xmachine->xmachine_Government).yearly_budget_balance_gdp_fraction;

    // suppress compiler warning by returning dummy value /
    // this statement should rightfully NEVER be reached /
    return (double)0;
}

/** \fn void set_cumulated_deficit(double cumulated_deficit)
 * \brief Set cumulated_deficit memory variable for current X-machine.
 * \param cumulated_deficit New value for variable.
 */
void set_cumulated_deficit(double cumulated_deficit)
{
	if(current_xmachine->xmachine_Government) (*current_xmachine->xmachine_Government).cumulated_deficit = cumulated_deficit;
}

/** \fn double get_cumulated_deficit()
 * \brief Get cumulated_deficit memory variable from current X-machine.
 * \return Value for variable.
 */
double get_cumulated_deficit()
{
	if(current_xmachine->xmachine_Government) return (*current_xmachine->xmachine_Government).cumulated_deficit;

    // suppress compiler warning by returning dummy value /
    // this statement should rightfully NEVER be reached /
    return (double)0;
}

/** \fn void set_inflation_rate(double inflation_rate)
 * \brief Set inflation_rate memory variable for current X-machine.
 * \param inflation_rate New value for variable.
 */
void set_inflation_rate(double inflation_rate)
{
	if(current_xmachine->xmachine_Government) (*current_xmachine->xmachine_Government).inflation_rate = inflation_rate;
}

/** \fn double get_inflation_rate()
 * \brief Get inflation_rate memory variable from current X-machine.
 * \return Value for variable.
 */
double get_inflation_rate()
{
	if(current_xmachine->xmachine_Government) return (*current_xmachine->xmachine_Government).inflation_rate;

    // suppress compiler warning by returning dummy value /
    // this statement should rightfully NEVER be reached /
    return (double)0;
}

/** \fn void set_human_capital_policy_installation_date_in_years(int human_capital_policy_installation_date_in_years)
 * \brief Set human_capital_policy_installation_date_in_years memory variable for current X-machine.
 * \param human_capital_policy_installation_date_in_years New value for variable.
 */
void set_human_capital_policy_installation_date_in_years(int human_capital_policy_installation_date_in_years)
{
	if(current_xmachine->xmachine_Government) (*current_xmachine->xmachine_Government).human_capital_policy_installation_date_in_years = human_capital_policy_installation_date_in_years;
}

/** \fn int get_human_capital_policy_installation_date_in_years()
 * \brief Get human_capital_policy_installation_date_in_years memory variable from current X-machine.
 * \return Value for variable.
 */
int get_human_capital_policy_installation_date_in_years()
{
	if(current_xmachine->xmachine_Government) return (*current_xmachine->xmachine_Government).human_capital_policy_installation_date_in_years;

    // suppress compiler warning by returning dummy value /
    // this statement should rightfully NEVER be reached /
    return (int)0;
}

/** \fn void set_basic_security_benefits_pct(double basic_security_benefits_pct)
 * \brief Set basic_security_benefits_pct memory variable for current X-machine.
 * \param basic_security_benefits_pct New value for variable.
 */
void set_basic_security_benefits_pct(double basic_security_benefits_pct)
{
	if(current_xmachine->xmachine_Government) (*current_xmachine->xmachine_Government).basic_security_benefits_pct = basic_security_benefits_pct;
}

/** \fn double get_basic_security_benefits_pct()
 * \brief Get basic_security_benefits_pct memory variable from current X-machine.
 * \return Value for variable.
 */
double get_basic_security_benefits_pct()
{
	if(current_xmachine->xmachine_Government) return (*current_xmachine->xmachine_Government).basic_security_benefits_pct;

    // suppress compiler warning by returning dummy value /
    // this statement should rightfully NEVER be reached /
    return (double)0;
}

/** \fn adt_skill_distribution_array get_new_skill_distribution()
 * \brief Get new_skill_distribution memory variable from current X-machine.
 * \return Value for variable.
 */
adt_skill_distribution_array * get_new_skill_distribution()
{
	if(current_xmachine->xmachine_Government) return &(*current_xmachine->xmachine_Government).new_skill_distribution;

    // suppress compiler warning by returning dummy value /
    // this statement should rightfully NEVER be reached /
    return NULL;
}

/** \fn gov_balance_sheet_adt get_gov_balance_sheet_calendar()
 * \brief Get gov_balance_sheet_calendar memory variable from current X-machine.
 * \return Value for variable.
 */
gov_balance_sheet_adt * get_gov_balance_sheet_calendar()
{
	if(current_xmachine->xmachine_Government) return &(*current_xmachine->xmachine_Government).gov_balance_sheet_calendar;

    // suppress compiler warning by returning dummy value /
    // this statement should rightfully NEVER be reached /
    return NULL;
}

/** \fn gov_stocks_adt get_gov_stocks_calendar()
 * \brief Get gov_stocks_calendar memory variable from current X-machine.
 * \return Value for variable.
 */
gov_stocks_adt * get_gov_stocks_calendar()
{
	if(current_xmachine->xmachine_Government) return &(*current_xmachine->xmachine_Government).gov_stocks_calendar;

    // suppress compiler warning by returning dummy value /
    // this statement should rightfully NEVER be reached /
    return NULL;
}

/** \fn gov_outflows_adt get_gov_outflows_calendar()
 * \brief Get gov_outflows_calendar memory variable from current X-machine.
 * \return Value for variable.
 */
gov_outflows_adt * get_gov_outflows_calendar()
{
	if(current_xmachine->xmachine_Government) return &(*current_xmachine->xmachine_Government).gov_outflows_calendar;

    // suppress compiler warning by returning dummy value /
    // this statement should rightfully NEVER be reached /
    return NULL;
}

/** \fn gov_inflows_adt get_gov_inflows_calendar()
 * \brief Get gov_inflows_calendar memory variable from current X-machine.
 * \return Value for variable.
 */
gov_inflows_adt * get_gov_inflows_calendar()
{
	if(current_xmachine->xmachine_Government) return &(*current_xmachine->xmachine_Government).gov_inflows_calendar;

    // suppress compiler warning by returning dummy value /
    // this statement should rightfully NEVER be reached /
    return NULL;
}

/** \fn void set_fiat_money(double fiat_money)
 * \brief Set fiat_money memory variable for current X-machine.
 * \param fiat_money New value for variable.
 */
void set_fiat_money(double fiat_money)
{
	if(current_xmachine->xmachine_CentralBank) (*current_xmachine->xmachine_CentralBank).fiat_money = fiat_money;
}

/** \fn double get_fiat_money()
 * \brief Get fiat_money memory variable from current X-machine.
 * \return Value for variable.
 */
double get_fiat_money()
{
	if(current_xmachine->xmachine_CentralBank) return (*current_xmachine->xmachine_CentralBank).fiat_money;

    // suppress compiler warning by returning dummy value /
    // this statement should rightfully NEVER be reached /
    return (double)0;
}

/** \fn void set_fiat_money_banks(double fiat_money_banks)
 * \brief Set fiat_money_banks memory variable for current X-machine.
 * \param fiat_money_banks New value for variable.
 */
void set_fiat_money_banks(double fiat_money_banks)
{
	if(current_xmachine->xmachine_CentralBank) (*current_xmachine->xmachine_CentralBank).fiat_money_banks = fiat_money_banks;
}

/** \fn double get_fiat_money_banks()
 * \brief Get fiat_money_banks memory variable from current X-machine.
 * \return Value for variable.
 */
double get_fiat_money_banks()
{
	if(current_xmachine->xmachine_CentralBank) return (*current_xmachine->xmachine_CentralBank).fiat_money_banks;

    // suppress compiler warning by returning dummy value /
    // this statement should rightfully NEVER be reached /
    return (double)0;
}

/** \fn void set_ecb_deposits(double ecb_deposits)
 * \brief Set ecb_deposits memory variable for current X-machine.
 * \param ecb_deposits New value for variable.
 */
void set_ecb_deposits(double ecb_deposits)
{
	if(current_xmachine->xmachine_CentralBank) (*current_xmachine->xmachine_CentralBank).ecb_deposits = ecb_deposits;
}

/** \fn double get_ecb_deposits()
 * \brief Get ecb_deposits memory variable from current X-machine.
 * \return Value for variable.
 */
double get_ecb_deposits()
{
	if(current_xmachine->xmachine_CentralBank) return (*current_xmachine->xmachine_CentralBank).ecb_deposits;

    // suppress compiler warning by returning dummy value /
    // this statement should rightfully NEVER be reached /
    return (double)0;
}

/** \fn account_item_array get_accounts_banks()
 * \brief Get accounts_banks memory variable from current X-machine.
 * \return Value for variable.
 */
account_item_array * get_accounts_banks()
{
	if(current_xmachine->xmachine_CentralBank) return &(*current_xmachine->xmachine_CentralBank).accounts_banks;

    // suppress compiler warning by returning dummy value /
    // this statement should rightfully NEVER be reached /
    return NULL;
}

/** \fn account_item_array get_accounts_govs()
 * \brief Get accounts_govs memory variable from current X-machine.
 * \return Value for variable.
 */
account_item_array * get_accounts_govs()
{
	if(current_xmachine->xmachine_CentralBank) return &(*current_xmachine->xmachine_CentralBank).accounts_govs;

    // suppress compiler warning by returning dummy value /
    // this statement should rightfully NEVER be reached /
    return NULL;
}

/** \fn account_item_array get_government_national_accounts()
 * \brief Get government_national_accounts memory variable from current X-machine.
 * \return Value for variable.
 */
account_item_array * get_government_national_accounts()
{
	if(current_xmachine->xmachine_CentralBank) return &(*current_xmachine->xmachine_CentralBank).government_national_accounts;

    // suppress compiler warning by returning dummy value /
    // this statement should rightfully NEVER be reached /
    return NULL;
}

/** \fn ecb_balance_sheet_adt get_ecb_balance_sheet_calendar()
 * \brief Get ecb_balance_sheet_calendar memory variable from current X-machine.
 * \return Value for variable.
 */
ecb_balance_sheet_adt * get_ecb_balance_sheet_calendar()
{
	if(current_xmachine->xmachine_CentralBank) return &(*current_xmachine->xmachine_CentralBank).ecb_balance_sheet_calendar;

    // suppress compiler warning by returning dummy value /
    // this statement should rightfully NEVER be reached /
    return NULL;
}

/** \fn ecb_stocks_adt get_ecb_stocks_calendar()
 * \brief Get ecb_stocks_calendar memory variable from current X-machine.
 * \return Value for variable.
 */
ecb_stocks_adt * get_ecb_stocks_calendar()
{
	if(current_xmachine->xmachine_CentralBank) return &(*current_xmachine->xmachine_CentralBank).ecb_stocks_calendar;

    // suppress compiler warning by returning dummy value /
    // this statement should rightfully NEVER be reached /
    return NULL;
}

/** \fn ecb_outflows_adt get_ecb_outflows_calendar()
 * \brief Get ecb_outflows_calendar memory variable from current X-machine.
 * \return Value for variable.
 */
ecb_outflows_adt * get_ecb_outflows_calendar()
{
	if(current_xmachine->xmachine_CentralBank) return &(*current_xmachine->xmachine_CentralBank).ecb_outflows_calendar;

    // suppress compiler warning by returning dummy value /
    // this statement should rightfully NEVER be reached /
    return NULL;
}

/** \fn ecb_inflows_adt get_ecb_inflows_calendar()
 * \brief Get ecb_inflows_calendar memory variable from current X-machine.
 * \return Value for variable.
 */
ecb_inflows_adt * get_ecb_inflows_calendar()
{
	if(current_xmachine->xmachine_CentralBank) return &(*current_xmachine->xmachine_CentralBank).ecb_inflows_calendar;

    // suppress compiler warning by returning dummy value /
    // this statement should rightfully NEVER be reached /
    return NULL;
}

/** \fn void set_bond_holdings_value(double bond_holdings_value)
 * \brief Set bond_holdings_value memory variable for current X-machine.
 * \param bond_holdings_value New value for variable.
 */
void set_bond_holdings_value(double bond_holdings_value)
{
	if(current_xmachine->xmachine_CentralBank) (*current_xmachine->xmachine_CentralBank).bond_holdings_value = bond_holdings_value;
}

/** \fn double get_bond_holdings_value()
 * \brief Get bond_holdings_value memory variable from current X-machine.
 * \return Value for variable.
 */
double get_bond_holdings_value()
{
	if(current_xmachine->xmachine_CentralBank) return (*current_xmachine->xmachine_CentralBank).bond_holdings_value;

    // suppress compiler warning by returning dummy value /
    // this statement should rightfully NEVER be reached /
    return (double)0;
}

/** \fn void set_nr_gov_bonds(int nr_gov_bonds)
 * \brief Set nr_gov_bonds memory variable for current X-machine.
 * \param nr_gov_bonds New value for variable.
 */
void set_nr_gov_bonds(int nr_gov_bonds)
{
	if(current_xmachine->xmachine_CentralBank) (*current_xmachine->xmachine_CentralBank).nr_gov_bonds = nr_gov_bonds;
}

/** \fn int get_nr_gov_bonds()
 * \brief Get nr_gov_bonds memory variable from current X-machine.
 * \return Value for variable.
 */
int get_nr_gov_bonds()
{
	if(current_xmachine->xmachine_CentralBank) return (*current_xmachine->xmachine_CentralBank).nr_gov_bonds;

    // suppress compiler warning by returning dummy value /
    // this statement should rightfully NEVER be reached /
    return (int)0;
}

/** \fn void set_fiat_money_govs(double fiat_money_govs)
 * \brief Set fiat_money_govs memory variable for current X-machine.
 * \param fiat_money_govs New value for variable.
 */
void set_fiat_money_govs(double fiat_money_govs)
{
	if(current_xmachine->xmachine_CentralBank) (*current_xmachine->xmachine_CentralBank).fiat_money_govs = fiat_money_govs;
}

/** \fn double get_fiat_money_govs()
 * \brief Get fiat_money_govs memory variable from current X-machine.
 * \return Value for variable.
 */
double get_fiat_money_govs()
{
	if(current_xmachine->xmachine_CentralBank) return (*current_xmachine->xmachine_CentralBank).fiat_money_govs;

    // suppress compiler warning by returning dummy value /
    // this statement should rightfully NEVER be reached /
    return (double)0;
}

/** \fn void set_fiat_money_bond_govs(double fiat_money_bond_govs)
 * \brief Set fiat_money_bond_govs memory variable for current X-machine.
 * \param fiat_money_bond_govs New value for variable.
 */
void set_fiat_money_bond_govs(double fiat_money_bond_govs)
{
	if(current_xmachine->xmachine_CentralBank) (*current_xmachine->xmachine_CentralBank).fiat_money_bond_govs = fiat_money_bond_govs;
}

/** \fn double get_fiat_money_bond_govs()
 * \brief Get fiat_money_bond_govs memory variable from current X-machine.
 * \return Value for variable.
 */
double get_fiat_money_bond_govs()
{
	if(current_xmachine->xmachine_CentralBank) return (*current_xmachine->xmachine_CentralBank).fiat_money_bond_govs;

    // suppress compiler warning by returning dummy value /
    // this statement should rightfully NEVER be reached /
    return (double)0;
}

/** \fn void set_bank_interest(double bank_interest)
 * \brief Set bank_interest memory variable for current X-machine.
 * \param bank_interest New value for variable.
 */
void set_bank_interest(double bank_interest)
{
	if(current_xmachine->xmachine_CentralBank) (*current_xmachine->xmachine_CentralBank).bank_interest = bank_interest;
}

/** \fn double get_bank_interest()
 * \brief Get bank_interest memory variable from current X-machine.
 * \return Value for variable.
 */
double get_bank_interest()
{
	if(current_xmachine->xmachine_CentralBank) return (*current_xmachine->xmachine_CentralBank).bank_interest;

    // suppress compiler warning by returning dummy value /
    // this statement should rightfully NEVER be reached /
    return (double)0;
}

/** \fn void set_gov_interest(double gov_interest)
 * \brief Set gov_interest memory variable for current X-machine.
 * \param gov_interest New value for variable.
 */
void set_gov_interest(double gov_interest)
{
	if(current_xmachine->xmachine_CentralBank) (*current_xmachine->xmachine_CentralBank).gov_interest = gov_interest;
}

/** \fn double get_gov_interest()
 * \brief Get gov_interest memory variable from current X-machine.
 * \return Value for variable.
 */
double get_gov_interest()
{
	if(current_xmachine->xmachine_CentralBank) return (*current_xmachine->xmachine_CentralBank).gov_interest;

    // suppress compiler warning by returning dummy value /
    // this statement should rightfully NEVER be reached /
    return (double)0;
}

/** \fn void set_gov_bond_purchase(double gov_bond_purchase)
 * \brief Set gov_bond_purchase memory variable for current X-machine.
 * \param gov_bond_purchase New value for variable.
 */
void set_gov_bond_purchase(double gov_bond_purchase)
{
	if(current_xmachine->xmachine_CentralBank) (*current_xmachine->xmachine_CentralBank).gov_bond_purchase = gov_bond_purchase;
}

/** \fn double get_gov_bond_purchase()
 * \brief Get gov_bond_purchase memory variable from current X-machine.
 * \return Value for variable.
 */
double get_gov_bond_purchase()
{
	if(current_xmachine->xmachine_CentralBank) return (*current_xmachine->xmachine_CentralBank).gov_bond_purchase;

    // suppress compiler warning by returning dummy value /
    // this statement should rightfully NEVER be reached /
    return (double)0;
}

/** \fn order_array get_pending_orders()
 * \brief Get pending_orders memory variable from current X-machine.
 * \return Value for variable.
 */
order_array * get_pending_orders()
{
	if(current_xmachine->xmachine_ClearingHouse) return &(*current_xmachine->xmachine_ClearingHouse).pending_orders;

    // suppress compiler warning by returning dummy value /
    // this statement should rightfully NEVER be reached /
    return NULL;
}

/** \fn order_array get_processed_orders()
 * \brief Get processed_orders memory variable from current X-machine.
 * \return Value for variable.
 */
order_array * get_processed_orders()
{
	if(current_xmachine->xmachine_ClearingHouse) return &(*current_xmachine->xmachine_ClearingHouse).processed_orders;

    // suppress compiler warning by returning dummy value /
    // this statement should rightfully NEVER be reached /
    return NULL;
}

/** \fn index_adt get_stock_index()
 * \brief Get stock_index memory variable from current X-machine.
 * \return Value for variable.
 */
index_adt * get_stock_index()
{
	if(current_xmachine->xmachine_ClearingHouse) return &(*current_xmachine->xmachine_ClearingHouse).stock_index;

    // suppress compiler warning by returning dummy value /
    // this statement should rightfully NEVER be reached /
    return NULL;
}

/** \fn void set_dsratio(double dsratio)
 * \brief Set dsratio memory variable for current X-machine.
 * \param dsratio New value for variable.
 */
void set_dsratio(double dsratio)
{
	if(current_xmachine->xmachine_ClearingHouse) (*current_xmachine->xmachine_ClearingHouse).dsratio = dsratio;
}

/** \fn double get_dsratio()
 * \brief Get dsratio memory variable from current X-machine.
 * \return Value for variable.
 */
double get_dsratio()
{
	if(current_xmachine->xmachine_ClearingHouse) return (*current_xmachine->xmachine_ClearingHouse).dsratio;

    // suppress compiler warning by returning dummy value /
    // this statement should rightfully NEVER be reached /
    return (double)0;
}

/** \fn double_array get_random_numbers_normal()
 * \brief Get random_numbers_normal memory variable from current X-machine.
 * \return Value for variable.
 */
double_array * get_random_numbers_normal()
{
	if(current_xmachine->xmachine_ClearingHouse) return &(*current_xmachine->xmachine_ClearingHouse).random_numbers_normal;

    // suppress compiler warning by returning dummy value /
    // this statement should rightfully NEVER be reached /
    return NULL;
}

/** \fn void set_monthly_counter_total_dividend(double monthly_counter_total_dividend)
 * \brief Set monthly_counter_total_dividend memory variable for current X-machine.
 * \param monthly_counter_total_dividend New value for variable.
 */
void set_monthly_counter_total_dividend(double monthly_counter_total_dividend)
{
	if(current_xmachine->xmachine_ClearingHouse) (*current_xmachine->xmachine_ClearingHouse).monthly_counter_total_dividend = monthly_counter_total_dividend;
}

/** \fn double get_monthly_counter_total_dividend()
 * \brief Get monthly_counter_total_dividend memory variable from current X-machine.
 * \return Value for variable.
 */
double get_monthly_counter_total_dividend()
{
	if(current_xmachine->xmachine_ClearingHouse) return (*current_xmachine->xmachine_ClearingHouse).monthly_counter_total_dividend;

    // suppress compiler warning by returning dummy value /
    // this statement should rightfully NEVER be reached /
    return (double)0;
}

/** \fn void set_stock_index_price(double stock_index_price)
 * \brief Set stock_index_price memory variable for current X-machine.
 * \param stock_index_price New value for variable.
 */
void set_stock_index_price(double stock_index_price)
{
	if(current_xmachine->xmachine_ClearingHouse) (*current_xmachine->xmachine_ClearingHouse).stock_index_price = stock_index_price;
}

/** \fn double get_stock_index_price()
 * \brief Get stock_index_price memory variable from current X-machine.
 * \return Value for variable.
 */
double get_stock_index_price()
{
	if(current_xmachine->xmachine_ClearingHouse) return (*current_xmachine->xmachine_ClearingHouse).stock_index_price;

    // suppress compiler warning by returning dummy value /
    // this statement should rightfully NEVER be reached /
    return (double)0;
}


/** \fn double agent_get_range()
 * \brief Fixed routine to get the range from current X-machine
  * \return Value of range
  */
double agent_get_range()
{
    double value = 0.0;
    /*if (current_xmachine->xmachine_Firm) value = current_xmachine->xmachine_Firm->;*/
    /*if (current_xmachine->xmachine_Household) value = current_xmachine->xmachine_Household->;*/
    /*if (current_xmachine->xmachine_Mall) value = current_xmachine->xmachine_Mall->;*/
    /*if (current_xmachine->xmachine_IGFirm) value = current_xmachine->xmachine_IGFirm->;*/
    /*if (current_xmachine->xmachine_Eurostat) value = current_xmachine->xmachine_Eurostat->;*/
    /*if (current_xmachine->xmachine_Bank) value = current_xmachine->xmachine_Bank->;*/
    /*if (current_xmachine->xmachine_Government) value = current_xmachine->xmachine_Government->;*/
    /*if (current_xmachine->xmachine_CentralBank) value = current_xmachine->xmachine_CentralBank->;*/
    /*if (current_xmachine->xmachine_ClearingHouse) value = current_xmachine->xmachine_ClearingHouse->;*/

    return value;
}

/** \fn int agent_get_id()
 * \brief Fixed routine to get the id for the current X-machine
  * \return Value of agent id
  */
int agent_get_id()
{
    int value = 0;
    /*if (current_xmachine->xmachine_Firm) value = current_xmachine->xmachine_Firm->id;*/
    /*if (current_xmachine->xmachine_Household) value = current_xmachine->xmachine_Household->id;*/
    /*if (current_xmachine->xmachine_Mall) value = current_xmachine->xmachine_Mall->id;*/
    /*if (current_xmachine->xmachine_IGFirm) value = current_xmachine->xmachine_IGFirm->id;*/
    /*if (current_xmachine->xmachine_Eurostat) value = current_xmachine->xmachine_Eurostat->id;*/
    /*if (current_xmachine->xmachine_Bank) value = current_xmachine->xmachine_Bank->id;*/
    /*if (current_xmachine->xmachine_Government) value = current_xmachine->xmachine_Government->id;*/
    /*if (current_xmachine->xmachine_CentralBank) value = current_xmachine->xmachine_CentralBank->id;*/
    /*if (current_xmachine->xmachine_ClearingHouse) value = current_xmachine->xmachine_ClearingHouse->id;*/

    return value;
}

/** \fn double agent_get_x()
 * \brief Fixed routine to get the x coordinate from current X-machine
  * \return Value of x coordinate
  */
double agent_get_x()
{
    double value = 0.0;
    /*if (current_xmachine->xmachine_Firm) value = current_xmachine->xmachine_Firm->0.0;*/
    /*if (current_xmachine->xmachine_Household) value = current_xmachine->xmachine_Household->0.0;*/
    /*if (current_xmachine->xmachine_Mall) value = current_xmachine->xmachine_Mall->0.0;*/
    /*if (current_xmachine->xmachine_IGFirm) value = current_xmachine->xmachine_IGFirm->0.0;*/
    /*if (current_xmachine->xmachine_Eurostat) value = current_xmachine->xmachine_Eurostat->0.0;*/
    /*if (current_xmachine->xmachine_Bank) value = current_xmachine->xmachine_Bank->0.0;*/
    /*if (current_xmachine->xmachine_Government) value = current_xmachine->xmachine_Government->0.0;*/
    /*if (current_xmachine->xmachine_CentralBank) value = current_xmachine->xmachine_CentralBank->0.0;*/
    /*if (current_xmachine->xmachine_ClearingHouse) value = current_xmachine->xmachine_ClearingHouse->0.0;*/

    return value;
}
/** \fn double agent_get_y()
 * \brief Fixed routine to get the y coordinate from current X-machine
  * \return Value of y coordinate
  */
double agent_get_y()
{
    double value = 0.0;
    /*if (current_xmachine->xmachine_Firm) value = current_xmachine->xmachine_Firm->0.0;*/
    /*if (current_xmachine->xmachine_Household) value = current_xmachine->xmachine_Household->0.0;*/
    /*if (current_xmachine->xmachine_Mall) value = current_xmachine->xmachine_Mall->0.0;*/
    /*if (current_xmachine->xmachine_IGFirm) value = current_xmachine->xmachine_IGFirm->0.0;*/
    /*if (current_xmachine->xmachine_Eurostat) value = current_xmachine->xmachine_Eurostat->0.0;*/
    /*if (current_xmachine->xmachine_Bank) value = current_xmachine->xmachine_Bank->0.0;*/
    /*if (current_xmachine->xmachine_Government) value = current_xmachine->xmachine_Government->0.0;*/
    /*if (current_xmachine->xmachine_CentralBank) value = current_xmachine->xmachine_CentralBank->0.0;*/
    /*if (current_xmachine->xmachine_ClearingHouse) value = current_xmachine->xmachine_ClearingHouse->0.0;*/

    return value;
}
/** \fn double agent_get_z()
 * \brief Fixed routine to get the z coordinate from current X-machine
  * \return Value of z coordinate
  */
double agent_get_z()
{
    double value = 0.0;

    return value;
}

/** \fn void add_node(int node_id, double minx, double maxx, double miny, double maxy, double minz, double maxz)
 * \brief Add a node to the node list.
 * \param node_id The node ID.
 * \param minx The minumum value on the x-axis of the bounding volume.
 * \param maxx The maximum value on the x-axis of the bounding volume.
 * \param miny The minumum value on the y-axis of the bounding volume.
 * \param maxy The maximum value on the y-axis of the bounding volume.
 * \param minz The minumum value on the z-axis of the bounding volume.
 * \param maxz The maximum value on the z-axis of the bounding volume.
 */
void add_node(int node_id, double minx, double maxx, double miny, double maxy, double minz, double maxz)
{
	node_information * current = *p_node_info;
	node_information * tmp = NULL;

	while(current)
	{
		tmp = current;
		current = current->next;
	}

	current = (node_information *)malloc(sizeof(node_information));
		CHECK_POINTER(current);

	if(tmp)
	{
		tmp->next = current;
	}
	else
	{
		*p_node_info = current;
	}

	current->next = NULL;
	current->node_id = node_id;
	current->agents_in_halo = 0;
	current->agent_total = 0;
	current->agents = NULL;
	current->bank_account_update_messages = NULL;
	current->bank_to_central_bank_account_update_messages = NULL;
	current->gov_to_central_bank_account_update_messages = NULL;
	current->wage_payment_messages = NULL;
	current->quality_price_info_1_messages = NULL;
	current->quality_price_info_2_messages = NULL;
	current->update_mall_stock_messages = NULL;
	current->consumption_request_1_messages = NULL;
	current->consumption_request_2_messages = NULL;
	current->accepted_consumption_1_messages = NULL;
	current->accepted_consumption_2_messages = NULL;
	current->sales_messages = NULL;
	current->specific_skill_update_messages = NULL;
	current->policy_rate_messages = NULL;
	current->bank_identity_messages = NULL;
	current->loan_request_messages = NULL;
	current->loan_request_ranked_messages = NULL;
	current->loan_conditions_messages = NULL;
	current->loan_acceptance_messages = NULL;
	current->installment_messages = NULL;
	current->bankruptcy_messages = NULL;
	current->bank_interest_payment_messages = NULL;
	current->account_interest_messages = NULL;
	current->ecb_dividend_messages = NULL;
	current->credit_var_update_messages = NULL;
	current->bankruptcy_illiquidity_messages = NULL;
	current->bankruptcy_insolvency_messages = NULL;
	current->index_info_messages = NULL;
	current->index_price_messages = NULL;
	current->order_messages = NULL;
	current->order_status_messages = NULL;
	current->dividend_info_messages = NULL;
	current->productivity_messages = NULL;
	current->capital_good_request_messages = NULL;
	current->capital_good_delivery_messages = NULL;
	current->pay_capital_goods_messages = NULL;
	current->vacancies_messages = NULL;
	current->vacancies2_messages = NULL;
	current->vacancies_r_and_d_employees_messages = NULL;
	current->vacancies_r_and_d_employees2_messages = NULL;
	current->firing_messages = NULL;
	current->job_application_messages = NULL;
	current->job_application2_messages = NULL;
	current->job_offer_messages = NULL;
	current->job_offer2_messages = NULL;
	current->job_acceptance_messages = NULL;
	current->job_acceptance2_messages = NULL;
	current->quitting_messages = NULL;
	current->quitting2_messages = NULL;
	current->unemployment_notification_messages = NULL;
	current->policy_announcement_messages = NULL;
	current->tax_payment_messages = NULL;
	current->unemployment_benefit_restitution_messages = NULL;
	current->hh_transfer_notification_messages = NULL;
	current->hh_subsidy_notification_messages = NULL;
	current->human_capital_policy_announcement_messages = NULL;
	current->firm_transfer_notification_messages = NULL;
	current->firm_subsidy_notification_messages = NULL;
	current->request_fiat_money_messages = NULL;
	current->human_capital_policy_general_skill_information_messages = NULL;
	current->human_capital_policy_new_general_skill_notification_messages = NULL;
	current->firm_send_data_messages = NULL;
	current->government_send_data_messages = NULL;
	current->household_send_data_messages = NULL;
	current->mall_data_messages = NULL;
	current->eurostat_send_specific_skills_messages = NULL;
	current->data_for_government_messages = NULL;
	current->eurostat_send_macrodata_messages = NULL;
	current->msg_firm_id_to_malls_messages = NULL;
	current->msg_mall_id_to_firms_messages = NULL;
	current->msg_skills_eurostat_to_igfirm_messages = NULL;
	current->msg_market_sizes_messages = NULL;
	current->total_subsidies_messages = NULL;
	current->redistributed_subsidies_messages = NULL;
	current->quality_price_messages = NULL;
	current->interview_request_messages = NULL;
	current->interview_positive_response_messages = NULL;
	current->questionnaire_innovation_messages = NULL;
	current->filled_out_questionnaire_product_innovation_messages = NULL;


	current->partition_data[0] = minx;
	current->partition_data[1] = maxx;
	current->partition_data[2] = miny;
	current->partition_data[3] = maxy;
	current->partition_data[4] = minz;
	current->partition_data[5] = maxz;
}

/**\fn void free_node_info()
 * \brief Free the node list.
 */
void free_node_info()
{
	node_information * tmp, * head;
	head = *p_node_info;

	while(head)
	{
		tmp = head->next;
		free(head);
		head = tmp;
	}

	*p_node_info = NULL;
}

/** \fn void clean_up(int code)
 * \brief Add a node to the node list.
 * \param code The error code (zero is no error).
 */
void clean_up(int code)
{
    int rc;
	FILE *file;
	char data[100];

	free(current_xmachine);
	/* Free x-machine memory */
	freexmachines();
	/* Free space partitions linked list */
	free_node_info();
	/* Free output list */
	free_FLAME_outputs(&FLAME_outputs);
	/* Free agent states */
	free_Firm_states();
	free_Household_states();
	free_Mall_states();
	free_IGFirm_states();
	free_Eurostat_states();
	free_Bank_states();
	free_Government_states();
	free_CentralBank_states();
	free_ClearingHouse_states();


	/* Free index maps */


	/* Free message boards */

	rc = MB_Delete(&b_bank_account_update);
	#ifdef ERRCHECK
    if (rc != MB_SUCCESS)
    {
       fprintf(stderr, "ERROR: Could not delete 'bank_account_update' board\n");
       switch(rc) {
           case MB_ERR_INVALID:
               fprintf(stderr, "\t reason: 'bank_account_update' board has not been created?\n");
               break;
           case MB_ERR_LOCKED:
               fprintf(stderr, "\t reason: 'bank_account_update' board is locked\n");
               break;
           case MB_ERR_INTERNAL:
               fprintf(stderr, "\t reason: internal error. Recompile libmoard in debug mode for more info \n");
               break;
	       default:
               fprintf(stderr, "\t MB_Delete returned error code: %d (see libmboard docs for details)\n", rc);
               break;
	       }

	       
       	   exit(rc);
    }
    #endif

	rc = MB_Delete(&b_bank_to_central_bank_account_update);
	#ifdef ERRCHECK
    if (rc != MB_SUCCESS)
    {
       fprintf(stderr, "ERROR: Could not delete 'bank_to_central_bank_account_update' board\n");
       switch(rc) {
           case MB_ERR_INVALID:
               fprintf(stderr, "\t reason: 'bank_to_central_bank_account_update' board has not been created?\n");
               break;
           case MB_ERR_LOCKED:
               fprintf(stderr, "\t reason: 'bank_to_central_bank_account_update' board is locked\n");
               break;
           case MB_ERR_INTERNAL:
               fprintf(stderr, "\t reason: internal error. Recompile libmoard in debug mode for more info \n");
               break;
	       default:
               fprintf(stderr, "\t MB_Delete returned error code: %d (see libmboard docs for details)\n", rc);
               break;
	       }

	       
       	   exit(rc);
    }
    #endif

	rc = MB_Delete(&b_gov_to_central_bank_account_update);
	#ifdef ERRCHECK
    if (rc != MB_SUCCESS)
    {
       fprintf(stderr, "ERROR: Could not delete 'gov_to_central_bank_account_update' board\n");
       switch(rc) {
           case MB_ERR_INVALID:
               fprintf(stderr, "\t reason: 'gov_to_central_bank_account_update' board has not been created?\n");
               break;
           case MB_ERR_LOCKED:
               fprintf(stderr, "\t reason: 'gov_to_central_bank_account_update' board is locked\n");
               break;
           case MB_ERR_INTERNAL:
               fprintf(stderr, "\t reason: internal error. Recompile libmoard in debug mode for more info \n");
               break;
	       default:
               fprintf(stderr, "\t MB_Delete returned error code: %d (see libmboard docs for details)\n", rc);
               break;
	       }

	       
       	   exit(rc);
    }
    #endif

	rc = MB_Delete(&b_wage_payment);
	#ifdef ERRCHECK
    if (rc != MB_SUCCESS)
    {
       fprintf(stderr, "ERROR: Could not delete 'wage_payment' board\n");
       switch(rc) {
           case MB_ERR_INVALID:
               fprintf(stderr, "\t reason: 'wage_payment' board has not been created?\n");
               break;
           case MB_ERR_LOCKED:
               fprintf(stderr, "\t reason: 'wage_payment' board is locked\n");
               break;
           case MB_ERR_INTERNAL:
               fprintf(stderr, "\t reason: internal error. Recompile libmoard in debug mode for more info \n");
               break;
	       default:
               fprintf(stderr, "\t MB_Delete returned error code: %d (see libmboard docs for details)\n", rc);
               break;
	       }

	       
       	   exit(rc);
    }
    #endif

	rc = MB_Delete(&b_quality_price_info_1);
	#ifdef ERRCHECK
    if (rc != MB_SUCCESS)
    {
       fprintf(stderr, "ERROR: Could not delete 'quality_price_info_1' board\n");
       switch(rc) {
           case MB_ERR_INVALID:
               fprintf(stderr, "\t reason: 'quality_price_info_1' board has not been created?\n");
               break;
           case MB_ERR_LOCKED:
               fprintf(stderr, "\t reason: 'quality_price_info_1' board is locked\n");
               break;
           case MB_ERR_INTERNAL:
               fprintf(stderr, "\t reason: internal error. Recompile libmoard in debug mode for more info \n");
               break;
	       default:
               fprintf(stderr, "\t MB_Delete returned error code: %d (see libmboard docs for details)\n", rc);
               break;
	       }

	       
       	   exit(rc);
    }
    #endif

	rc = MB_Delete(&b_quality_price_info_2);
	#ifdef ERRCHECK
    if (rc != MB_SUCCESS)
    {
       fprintf(stderr, "ERROR: Could not delete 'quality_price_info_2' board\n");
       switch(rc) {
           case MB_ERR_INVALID:
               fprintf(stderr, "\t reason: 'quality_price_info_2' board has not been created?\n");
               break;
           case MB_ERR_LOCKED:
               fprintf(stderr, "\t reason: 'quality_price_info_2' board is locked\n");
               break;
           case MB_ERR_INTERNAL:
               fprintf(stderr, "\t reason: internal error. Recompile libmoard in debug mode for more info \n");
               break;
	       default:
               fprintf(stderr, "\t MB_Delete returned error code: %d (see libmboard docs for details)\n", rc);
               break;
	       }

	       
       	   exit(rc);
    }
    #endif

	rc = MB_Delete(&b_update_mall_stock);
	#ifdef ERRCHECK
    if (rc != MB_SUCCESS)
    {
       fprintf(stderr, "ERROR: Could not delete 'update_mall_stock' board\n");
       switch(rc) {
           case MB_ERR_INVALID:
               fprintf(stderr, "\t reason: 'update_mall_stock' board has not been created?\n");
               break;
           case MB_ERR_LOCKED:
               fprintf(stderr, "\t reason: 'update_mall_stock' board is locked\n");
               break;
           case MB_ERR_INTERNAL:
               fprintf(stderr, "\t reason: internal error. Recompile libmoard in debug mode for more info \n");
               break;
	       default:
               fprintf(stderr, "\t MB_Delete returned error code: %d (see libmboard docs for details)\n", rc);
               break;
	       }

	       
       	   exit(rc);
    }
    #endif

	rc = MB_Delete(&b_consumption_request_1);
	#ifdef ERRCHECK
    if (rc != MB_SUCCESS)
    {
       fprintf(stderr, "ERROR: Could not delete 'consumption_request_1' board\n");
       switch(rc) {
           case MB_ERR_INVALID:
               fprintf(stderr, "\t reason: 'consumption_request_1' board has not been created?\n");
               break;
           case MB_ERR_LOCKED:
               fprintf(stderr, "\t reason: 'consumption_request_1' board is locked\n");
               break;
           case MB_ERR_INTERNAL:
               fprintf(stderr, "\t reason: internal error. Recompile libmoard in debug mode for more info \n");
               break;
	       default:
               fprintf(stderr, "\t MB_Delete returned error code: %d (see libmboard docs for details)\n", rc);
               break;
	       }

	       
       	   exit(rc);
    }
    #endif

	rc = MB_Delete(&b_consumption_request_2);
	#ifdef ERRCHECK
    if (rc != MB_SUCCESS)
    {
       fprintf(stderr, "ERROR: Could not delete 'consumption_request_2' board\n");
       switch(rc) {
           case MB_ERR_INVALID:
               fprintf(stderr, "\t reason: 'consumption_request_2' board has not been created?\n");
               break;
           case MB_ERR_LOCKED:
               fprintf(stderr, "\t reason: 'consumption_request_2' board is locked\n");
               break;
           case MB_ERR_INTERNAL:
               fprintf(stderr, "\t reason: internal error. Recompile libmoard in debug mode for more info \n");
               break;
	       default:
               fprintf(stderr, "\t MB_Delete returned error code: %d (see libmboard docs for details)\n", rc);
               break;
	       }

	       
       	   exit(rc);
    }
    #endif

	rc = MB_Delete(&b_accepted_consumption_1);
	#ifdef ERRCHECK
    if (rc != MB_SUCCESS)
    {
       fprintf(stderr, "ERROR: Could not delete 'accepted_consumption_1' board\n");
       switch(rc) {
           case MB_ERR_INVALID:
               fprintf(stderr, "\t reason: 'accepted_consumption_1' board has not been created?\n");
               break;
           case MB_ERR_LOCKED:
               fprintf(stderr, "\t reason: 'accepted_consumption_1' board is locked\n");
               break;
           case MB_ERR_INTERNAL:
               fprintf(stderr, "\t reason: internal error. Recompile libmoard in debug mode for more info \n");
               break;
	       default:
               fprintf(stderr, "\t MB_Delete returned error code: %d (see libmboard docs for details)\n", rc);
               break;
	       }

	       
       	   exit(rc);
    }
    #endif

	rc = MB_Delete(&b_accepted_consumption_2);
	#ifdef ERRCHECK
    if (rc != MB_SUCCESS)
    {
       fprintf(stderr, "ERROR: Could not delete 'accepted_consumption_2' board\n");
       switch(rc) {
           case MB_ERR_INVALID:
               fprintf(stderr, "\t reason: 'accepted_consumption_2' board has not been created?\n");
               break;
           case MB_ERR_LOCKED:
               fprintf(stderr, "\t reason: 'accepted_consumption_2' board is locked\n");
               break;
           case MB_ERR_INTERNAL:
               fprintf(stderr, "\t reason: internal error. Recompile libmoard in debug mode for more info \n");
               break;
	       default:
               fprintf(stderr, "\t MB_Delete returned error code: %d (see libmboard docs for details)\n", rc);
               break;
	       }

	       
       	   exit(rc);
    }
    #endif

	rc = MB_Delete(&b_sales);
	#ifdef ERRCHECK
    if (rc != MB_SUCCESS)
    {
       fprintf(stderr, "ERROR: Could not delete 'sales' board\n");
       switch(rc) {
           case MB_ERR_INVALID:
               fprintf(stderr, "\t reason: 'sales' board has not been created?\n");
               break;
           case MB_ERR_LOCKED:
               fprintf(stderr, "\t reason: 'sales' board is locked\n");
               break;
           case MB_ERR_INTERNAL:
               fprintf(stderr, "\t reason: internal error. Recompile libmoard in debug mode for more info \n");
               break;
	       default:
               fprintf(stderr, "\t MB_Delete returned error code: %d (see libmboard docs for details)\n", rc);
               break;
	       }

	       
       	   exit(rc);
    }
    #endif

	rc = MB_Delete(&b_specific_skill_update);
	#ifdef ERRCHECK
    if (rc != MB_SUCCESS)
    {
       fprintf(stderr, "ERROR: Could not delete 'specific_skill_update' board\n");
       switch(rc) {
           case MB_ERR_INVALID:
               fprintf(stderr, "\t reason: 'specific_skill_update' board has not been created?\n");
               break;
           case MB_ERR_LOCKED:
               fprintf(stderr, "\t reason: 'specific_skill_update' board is locked\n");
               break;
           case MB_ERR_INTERNAL:
               fprintf(stderr, "\t reason: internal error. Recompile libmoard in debug mode for more info \n");
               break;
	       default:
               fprintf(stderr, "\t MB_Delete returned error code: %d (see libmboard docs for details)\n", rc);
               break;
	       }

	       
       	   exit(rc);
    }
    #endif

	rc = MB_Delete(&b_policy_rate);
	#ifdef ERRCHECK
    if (rc != MB_SUCCESS)
    {
       fprintf(stderr, "ERROR: Could not delete 'policy_rate' board\n");
       switch(rc) {
           case MB_ERR_INVALID:
               fprintf(stderr, "\t reason: 'policy_rate' board has not been created?\n");
               break;
           case MB_ERR_LOCKED:
               fprintf(stderr, "\t reason: 'policy_rate' board is locked\n");
               break;
           case MB_ERR_INTERNAL:
               fprintf(stderr, "\t reason: internal error. Recompile libmoard in debug mode for more info \n");
               break;
	       default:
               fprintf(stderr, "\t MB_Delete returned error code: %d (see libmboard docs for details)\n", rc);
               break;
	       }

	       
       	   exit(rc);
    }
    #endif

	rc = MB_Delete(&b_bank_identity);
	#ifdef ERRCHECK
    if (rc != MB_SUCCESS)
    {
       fprintf(stderr, "ERROR: Could not delete 'bank_identity' board\n");
       switch(rc) {
           case MB_ERR_INVALID:
               fprintf(stderr, "\t reason: 'bank_identity' board has not been created?\n");
               break;
           case MB_ERR_LOCKED:
               fprintf(stderr, "\t reason: 'bank_identity' board is locked\n");
               break;
           case MB_ERR_INTERNAL:
               fprintf(stderr, "\t reason: internal error. Recompile libmoard in debug mode for more info \n");
               break;
	       default:
               fprintf(stderr, "\t MB_Delete returned error code: %d (see libmboard docs for details)\n", rc);
               break;
	       }

	       
       	   exit(rc);
    }
    #endif

	rc = MB_Delete(&b_loan_request);
	#ifdef ERRCHECK
    if (rc != MB_SUCCESS)
    {
       fprintf(stderr, "ERROR: Could not delete 'loan_request' board\n");
       switch(rc) {
           case MB_ERR_INVALID:
               fprintf(stderr, "\t reason: 'loan_request' board has not been created?\n");
               break;
           case MB_ERR_LOCKED:
               fprintf(stderr, "\t reason: 'loan_request' board is locked\n");
               break;
           case MB_ERR_INTERNAL:
               fprintf(stderr, "\t reason: internal error. Recompile libmoard in debug mode for more info \n");
               break;
	       default:
               fprintf(stderr, "\t MB_Delete returned error code: %d (see libmboard docs for details)\n", rc);
               break;
	       }

	       
       	   exit(rc);
    }
    #endif

	rc = MB_Delete(&b_loan_request_ranked);
	#ifdef ERRCHECK
    if (rc != MB_SUCCESS)
    {
       fprintf(stderr, "ERROR: Could not delete 'loan_request_ranked' board\n");
       switch(rc) {
           case MB_ERR_INVALID:
               fprintf(stderr, "\t reason: 'loan_request_ranked' board has not been created?\n");
               break;
           case MB_ERR_LOCKED:
               fprintf(stderr, "\t reason: 'loan_request_ranked' board is locked\n");
               break;
           case MB_ERR_INTERNAL:
               fprintf(stderr, "\t reason: internal error. Recompile libmoard in debug mode for more info \n");
               break;
	       default:
               fprintf(stderr, "\t MB_Delete returned error code: %d (see libmboard docs for details)\n", rc);
               break;
	       }

	       
       	   exit(rc);
    }
    #endif

	rc = MB_Delete(&b_loan_conditions);
	#ifdef ERRCHECK
    if (rc != MB_SUCCESS)
    {
       fprintf(stderr, "ERROR: Could not delete 'loan_conditions' board\n");
       switch(rc) {
           case MB_ERR_INVALID:
               fprintf(stderr, "\t reason: 'loan_conditions' board has not been created?\n");
               break;
           case MB_ERR_LOCKED:
               fprintf(stderr, "\t reason: 'loan_conditions' board is locked\n");
               break;
           case MB_ERR_INTERNAL:
               fprintf(stderr, "\t reason: internal error. Recompile libmoard in debug mode for more info \n");
               break;
	       default:
               fprintf(stderr, "\t MB_Delete returned error code: %d (see libmboard docs for details)\n", rc);
               break;
	       }

	       
       	   exit(rc);
    }
    #endif

	rc = MB_Delete(&b_loan_acceptance);
	#ifdef ERRCHECK
    if (rc != MB_SUCCESS)
    {
       fprintf(stderr, "ERROR: Could not delete 'loan_acceptance' board\n");
       switch(rc) {
           case MB_ERR_INVALID:
               fprintf(stderr, "\t reason: 'loan_acceptance' board has not been created?\n");
               break;
           case MB_ERR_LOCKED:
               fprintf(stderr, "\t reason: 'loan_acceptance' board is locked\n");
               break;
           case MB_ERR_INTERNAL:
               fprintf(stderr, "\t reason: internal error. Recompile libmoard in debug mode for more info \n");
               break;
	       default:
               fprintf(stderr, "\t MB_Delete returned error code: %d (see libmboard docs for details)\n", rc);
               break;
	       }

	       
       	   exit(rc);
    }
    #endif

	rc = MB_Delete(&b_installment);
	#ifdef ERRCHECK
    if (rc != MB_SUCCESS)
    {
       fprintf(stderr, "ERROR: Could not delete 'installment' board\n");
       switch(rc) {
           case MB_ERR_INVALID:
               fprintf(stderr, "\t reason: 'installment' board has not been created?\n");
               break;
           case MB_ERR_LOCKED:
               fprintf(stderr, "\t reason: 'installment' board is locked\n");
               break;
           case MB_ERR_INTERNAL:
               fprintf(stderr, "\t reason: internal error. Recompile libmoard in debug mode for more info \n");
               break;
	       default:
               fprintf(stderr, "\t MB_Delete returned error code: %d (see libmboard docs for details)\n", rc);
               break;
	       }

	       
       	   exit(rc);
    }
    #endif

	rc = MB_Delete(&b_bankruptcy);
	#ifdef ERRCHECK
    if (rc != MB_SUCCESS)
    {
       fprintf(stderr, "ERROR: Could not delete 'bankruptcy' board\n");
       switch(rc) {
           case MB_ERR_INVALID:
               fprintf(stderr, "\t reason: 'bankruptcy' board has not been created?\n");
               break;
           case MB_ERR_LOCKED:
               fprintf(stderr, "\t reason: 'bankruptcy' board is locked\n");
               break;
           case MB_ERR_INTERNAL:
               fprintf(stderr, "\t reason: internal error. Recompile libmoard in debug mode for more info \n");
               break;
	       default:
               fprintf(stderr, "\t MB_Delete returned error code: %d (see libmboard docs for details)\n", rc);
               break;
	       }

	       
       	   exit(rc);
    }
    #endif

	rc = MB_Delete(&b_bank_interest_payment);
	#ifdef ERRCHECK
    if (rc != MB_SUCCESS)
    {
       fprintf(stderr, "ERROR: Could not delete 'bank_interest_payment' board\n");
       switch(rc) {
           case MB_ERR_INVALID:
               fprintf(stderr, "\t reason: 'bank_interest_payment' board has not been created?\n");
               break;
           case MB_ERR_LOCKED:
               fprintf(stderr, "\t reason: 'bank_interest_payment' board is locked\n");
               break;
           case MB_ERR_INTERNAL:
               fprintf(stderr, "\t reason: internal error. Recompile libmoard in debug mode for more info \n");
               break;
	       default:
               fprintf(stderr, "\t MB_Delete returned error code: %d (see libmboard docs for details)\n", rc);
               break;
	       }

	       
       	   exit(rc);
    }
    #endif

	rc = MB_Delete(&b_account_interest);
	#ifdef ERRCHECK
    if (rc != MB_SUCCESS)
    {
       fprintf(stderr, "ERROR: Could not delete 'account_interest' board\n");
       switch(rc) {
           case MB_ERR_INVALID:
               fprintf(stderr, "\t reason: 'account_interest' board has not been created?\n");
               break;
           case MB_ERR_LOCKED:
               fprintf(stderr, "\t reason: 'account_interest' board is locked\n");
               break;
           case MB_ERR_INTERNAL:
               fprintf(stderr, "\t reason: internal error. Recompile libmoard in debug mode for more info \n");
               break;
	       default:
               fprintf(stderr, "\t MB_Delete returned error code: %d (see libmboard docs for details)\n", rc);
               break;
	       }

	       
       	   exit(rc);
    }
    #endif

	rc = MB_Delete(&b_ecb_dividend);
	#ifdef ERRCHECK
    if (rc != MB_SUCCESS)
    {
       fprintf(stderr, "ERROR: Could not delete 'ecb_dividend' board\n");
       switch(rc) {
           case MB_ERR_INVALID:
               fprintf(stderr, "\t reason: 'ecb_dividend' board has not been created?\n");
               break;
           case MB_ERR_LOCKED:
               fprintf(stderr, "\t reason: 'ecb_dividend' board is locked\n");
               break;
           case MB_ERR_INTERNAL:
               fprintf(stderr, "\t reason: internal error. Recompile libmoard in debug mode for more info \n");
               break;
	       default:
               fprintf(stderr, "\t MB_Delete returned error code: %d (see libmboard docs for details)\n", rc);
               break;
	       }

	       
       	   exit(rc);
    }
    #endif

	rc = MB_Delete(&b_credit_var_update);
	#ifdef ERRCHECK
    if (rc != MB_SUCCESS)
    {
       fprintf(stderr, "ERROR: Could not delete 'credit_var_update' board\n");
       switch(rc) {
           case MB_ERR_INVALID:
               fprintf(stderr, "\t reason: 'credit_var_update' board has not been created?\n");
               break;
           case MB_ERR_LOCKED:
               fprintf(stderr, "\t reason: 'credit_var_update' board is locked\n");
               break;
           case MB_ERR_INTERNAL:
               fprintf(stderr, "\t reason: internal error. Recompile libmoard in debug mode for more info \n");
               break;
	       default:
               fprintf(stderr, "\t MB_Delete returned error code: %d (see libmboard docs for details)\n", rc);
               break;
	       }

	       
       	   exit(rc);
    }
    #endif

	rc = MB_Delete(&b_bankruptcy_illiquidity);
	#ifdef ERRCHECK
    if (rc != MB_SUCCESS)
    {
       fprintf(stderr, "ERROR: Could not delete 'bankruptcy_illiquidity' board\n");
       switch(rc) {
           case MB_ERR_INVALID:
               fprintf(stderr, "\t reason: 'bankruptcy_illiquidity' board has not been created?\n");
               break;
           case MB_ERR_LOCKED:
               fprintf(stderr, "\t reason: 'bankruptcy_illiquidity' board is locked\n");
               break;
           case MB_ERR_INTERNAL:
               fprintf(stderr, "\t reason: internal error. Recompile libmoard in debug mode for more info \n");
               break;
	       default:
               fprintf(stderr, "\t MB_Delete returned error code: %d (see libmboard docs for details)\n", rc);
               break;
	       }

	       
       	   exit(rc);
    }
    #endif

	rc = MB_Delete(&b_bankruptcy_insolvency);
	#ifdef ERRCHECK
    if (rc != MB_SUCCESS)
    {
       fprintf(stderr, "ERROR: Could not delete 'bankruptcy_insolvency' board\n");
       switch(rc) {
           case MB_ERR_INVALID:
               fprintf(stderr, "\t reason: 'bankruptcy_insolvency' board has not been created?\n");
               break;
           case MB_ERR_LOCKED:
               fprintf(stderr, "\t reason: 'bankruptcy_insolvency' board is locked\n");
               break;
           case MB_ERR_INTERNAL:
               fprintf(stderr, "\t reason: internal error. Recompile libmoard in debug mode for more info \n");
               break;
	       default:
               fprintf(stderr, "\t MB_Delete returned error code: %d (see libmboard docs for details)\n", rc);
               break;
	       }

	       
       	   exit(rc);
    }
    #endif

	rc = MB_Delete(&b_index_info);
	#ifdef ERRCHECK
    if (rc != MB_SUCCESS)
    {
       fprintf(stderr, "ERROR: Could not delete 'index_info' board\n");
       switch(rc) {
           case MB_ERR_INVALID:
               fprintf(stderr, "\t reason: 'index_info' board has not been created?\n");
               break;
           case MB_ERR_LOCKED:
               fprintf(stderr, "\t reason: 'index_info' board is locked\n");
               break;
           case MB_ERR_INTERNAL:
               fprintf(stderr, "\t reason: internal error. Recompile libmoard in debug mode for more info \n");
               break;
	       default:
               fprintf(stderr, "\t MB_Delete returned error code: %d (see libmboard docs for details)\n", rc);
               break;
	       }

	       
       	   exit(rc);
    }
    #endif

	rc = MB_Delete(&b_index_price);
	#ifdef ERRCHECK
    if (rc != MB_SUCCESS)
    {
       fprintf(stderr, "ERROR: Could not delete 'index_price' board\n");
       switch(rc) {
           case MB_ERR_INVALID:
               fprintf(stderr, "\t reason: 'index_price' board has not been created?\n");
               break;
           case MB_ERR_LOCKED:
               fprintf(stderr, "\t reason: 'index_price' board is locked\n");
               break;
           case MB_ERR_INTERNAL:
               fprintf(stderr, "\t reason: internal error. Recompile libmoard in debug mode for more info \n");
               break;
	       default:
               fprintf(stderr, "\t MB_Delete returned error code: %d (see libmboard docs for details)\n", rc);
               break;
	       }

	       
       	   exit(rc);
    }
    #endif

	rc = MB_Delete(&b_order);
	#ifdef ERRCHECK
    if (rc != MB_SUCCESS)
    {
       fprintf(stderr, "ERROR: Could not delete 'order' board\n");
       switch(rc) {
           case MB_ERR_INVALID:
               fprintf(stderr, "\t reason: 'order' board has not been created?\n");
               break;
           case MB_ERR_LOCKED:
               fprintf(stderr, "\t reason: 'order' board is locked\n");
               break;
           case MB_ERR_INTERNAL:
               fprintf(stderr, "\t reason: internal error. Recompile libmoard in debug mode for more info \n");
               break;
	       default:
               fprintf(stderr, "\t MB_Delete returned error code: %d (see libmboard docs for details)\n", rc);
               break;
	       }

	       
       	   exit(rc);
    }
    #endif

	rc = MB_Delete(&b_order_status);
	#ifdef ERRCHECK
    if (rc != MB_SUCCESS)
    {
       fprintf(stderr, "ERROR: Could not delete 'order_status' board\n");
       switch(rc) {
           case MB_ERR_INVALID:
               fprintf(stderr, "\t reason: 'order_status' board has not been created?\n");
               break;
           case MB_ERR_LOCKED:
               fprintf(stderr, "\t reason: 'order_status' board is locked\n");
               break;
           case MB_ERR_INTERNAL:
               fprintf(stderr, "\t reason: internal error. Recompile libmoard in debug mode for more info \n");
               break;
	       default:
               fprintf(stderr, "\t MB_Delete returned error code: %d (see libmboard docs for details)\n", rc);
               break;
	       }

	       
       	   exit(rc);
    }
    #endif

	rc = MB_Delete(&b_dividend_info);
	#ifdef ERRCHECK
    if (rc != MB_SUCCESS)
    {
       fprintf(stderr, "ERROR: Could not delete 'dividend_info' board\n");
       switch(rc) {
           case MB_ERR_INVALID:
               fprintf(stderr, "\t reason: 'dividend_info' board has not been created?\n");
               break;
           case MB_ERR_LOCKED:
               fprintf(stderr, "\t reason: 'dividend_info' board is locked\n");
               break;
           case MB_ERR_INTERNAL:
               fprintf(stderr, "\t reason: internal error. Recompile libmoard in debug mode for more info \n");
               break;
	       default:
               fprintf(stderr, "\t MB_Delete returned error code: %d (see libmboard docs for details)\n", rc);
               break;
	       }

	       
       	   exit(rc);
    }
    #endif

	rc = MB_Delete(&b_productivity);
	#ifdef ERRCHECK
    if (rc != MB_SUCCESS)
    {
       fprintf(stderr, "ERROR: Could not delete 'productivity' board\n");
       switch(rc) {
           case MB_ERR_INVALID:
               fprintf(stderr, "\t reason: 'productivity' board has not been created?\n");
               break;
           case MB_ERR_LOCKED:
               fprintf(stderr, "\t reason: 'productivity' board is locked\n");
               break;
           case MB_ERR_INTERNAL:
               fprintf(stderr, "\t reason: internal error. Recompile libmoard in debug mode for more info \n");
               break;
	       default:
               fprintf(stderr, "\t MB_Delete returned error code: %d (see libmboard docs for details)\n", rc);
               break;
	       }

	       
       	   exit(rc);
    }
    #endif

	rc = MB_Delete(&b_capital_good_request);
	#ifdef ERRCHECK
    if (rc != MB_SUCCESS)
    {
       fprintf(stderr, "ERROR: Could not delete 'capital_good_request' board\n");
       switch(rc) {
           case MB_ERR_INVALID:
               fprintf(stderr, "\t reason: 'capital_good_request' board has not been created?\n");
               break;
           case MB_ERR_LOCKED:
               fprintf(stderr, "\t reason: 'capital_good_request' board is locked\n");
               break;
           case MB_ERR_INTERNAL:
               fprintf(stderr, "\t reason: internal error. Recompile libmoard in debug mode for more info \n");
               break;
	       default:
               fprintf(stderr, "\t MB_Delete returned error code: %d (see libmboard docs for details)\n", rc);
               break;
	       }

	       
       	   exit(rc);
    }
    #endif

	rc = MB_Delete(&b_capital_good_delivery);
	#ifdef ERRCHECK
    if (rc != MB_SUCCESS)
    {
       fprintf(stderr, "ERROR: Could not delete 'capital_good_delivery' board\n");
       switch(rc) {
           case MB_ERR_INVALID:
               fprintf(stderr, "\t reason: 'capital_good_delivery' board has not been created?\n");
               break;
           case MB_ERR_LOCKED:
               fprintf(stderr, "\t reason: 'capital_good_delivery' board is locked\n");
               break;
           case MB_ERR_INTERNAL:
               fprintf(stderr, "\t reason: internal error. Recompile libmoard in debug mode for more info \n");
               break;
	       default:
               fprintf(stderr, "\t MB_Delete returned error code: %d (see libmboard docs for details)\n", rc);
               break;
	       }

	       
       	   exit(rc);
    }
    #endif

	rc = MB_Delete(&b_pay_capital_goods);
	#ifdef ERRCHECK
    if (rc != MB_SUCCESS)
    {
       fprintf(stderr, "ERROR: Could not delete 'pay_capital_goods' board\n");
       switch(rc) {
           case MB_ERR_INVALID:
               fprintf(stderr, "\t reason: 'pay_capital_goods' board has not been created?\n");
               break;
           case MB_ERR_LOCKED:
               fprintf(stderr, "\t reason: 'pay_capital_goods' board is locked\n");
               break;
           case MB_ERR_INTERNAL:
               fprintf(stderr, "\t reason: internal error. Recompile libmoard in debug mode for more info \n");
               break;
	       default:
               fprintf(stderr, "\t MB_Delete returned error code: %d (see libmboard docs for details)\n", rc);
               break;
	       }

	       
       	   exit(rc);
    }
    #endif

	rc = MB_Delete(&b_vacancies);
	#ifdef ERRCHECK
    if (rc != MB_SUCCESS)
    {
       fprintf(stderr, "ERROR: Could not delete 'vacancies' board\n");
       switch(rc) {
           case MB_ERR_INVALID:
               fprintf(stderr, "\t reason: 'vacancies' board has not been created?\n");
               break;
           case MB_ERR_LOCKED:
               fprintf(stderr, "\t reason: 'vacancies' board is locked\n");
               break;
           case MB_ERR_INTERNAL:
               fprintf(stderr, "\t reason: internal error. Recompile libmoard in debug mode for more info \n");
               break;
	       default:
               fprintf(stderr, "\t MB_Delete returned error code: %d (see libmboard docs for details)\n", rc);
               break;
	       }

	       
       	   exit(rc);
    }
    #endif

	rc = MB_Delete(&b_vacancies2);
	#ifdef ERRCHECK
    if (rc != MB_SUCCESS)
    {
       fprintf(stderr, "ERROR: Could not delete 'vacancies2' board\n");
       switch(rc) {
           case MB_ERR_INVALID:
               fprintf(stderr, "\t reason: 'vacancies2' board has not been created?\n");
               break;
           case MB_ERR_LOCKED:
               fprintf(stderr, "\t reason: 'vacancies2' board is locked\n");
               break;
           case MB_ERR_INTERNAL:
               fprintf(stderr, "\t reason: internal error. Recompile libmoard in debug mode for more info \n");
               break;
	       default:
               fprintf(stderr, "\t MB_Delete returned error code: %d (see libmboard docs for details)\n", rc);
               break;
	       }

	       
       	   exit(rc);
    }
    #endif

	rc = MB_Delete(&b_vacancies_r_and_d_employees);
	#ifdef ERRCHECK
    if (rc != MB_SUCCESS)
    {
       fprintf(stderr, "ERROR: Could not delete 'vacancies_r_and_d_employees' board\n");
       switch(rc) {
           case MB_ERR_INVALID:
               fprintf(stderr, "\t reason: 'vacancies_r_and_d_employees' board has not been created?\n");
               break;
           case MB_ERR_LOCKED:
               fprintf(stderr, "\t reason: 'vacancies_r_and_d_employees' board is locked\n");
               break;
           case MB_ERR_INTERNAL:
               fprintf(stderr, "\t reason: internal error. Recompile libmoard in debug mode for more info \n");
               break;
	       default:
               fprintf(stderr, "\t MB_Delete returned error code: %d (see libmboard docs for details)\n", rc);
               break;
	       }

	       
       	   exit(rc);
    }
    #endif

	rc = MB_Delete(&b_vacancies_r_and_d_employees2);
	#ifdef ERRCHECK
    if (rc != MB_SUCCESS)
    {
       fprintf(stderr, "ERROR: Could not delete 'vacancies_r_and_d_employees2' board\n");
       switch(rc) {
           case MB_ERR_INVALID:
               fprintf(stderr, "\t reason: 'vacancies_r_and_d_employees2' board has not been created?\n");
               break;
           case MB_ERR_LOCKED:
               fprintf(stderr, "\t reason: 'vacancies_r_and_d_employees2' board is locked\n");
               break;
           case MB_ERR_INTERNAL:
               fprintf(stderr, "\t reason: internal error. Recompile libmoard in debug mode for more info \n");
               break;
	       default:
               fprintf(stderr, "\t MB_Delete returned error code: %d (see libmboard docs for details)\n", rc);
               break;
	       }

	       
       	   exit(rc);
    }
    #endif

	rc = MB_Delete(&b_firing);
	#ifdef ERRCHECK
    if (rc != MB_SUCCESS)
    {
       fprintf(stderr, "ERROR: Could not delete 'firing' board\n");
       switch(rc) {
           case MB_ERR_INVALID:
               fprintf(stderr, "\t reason: 'firing' board has not been created?\n");
               break;
           case MB_ERR_LOCKED:
               fprintf(stderr, "\t reason: 'firing' board is locked\n");
               break;
           case MB_ERR_INTERNAL:
               fprintf(stderr, "\t reason: internal error. Recompile libmoard in debug mode for more info \n");
               break;
	       default:
               fprintf(stderr, "\t MB_Delete returned error code: %d (see libmboard docs for details)\n", rc);
               break;
	       }

	       
       	   exit(rc);
    }
    #endif

	rc = MB_Delete(&b_job_application);
	#ifdef ERRCHECK
    if (rc != MB_SUCCESS)
    {
       fprintf(stderr, "ERROR: Could not delete 'job_application' board\n");
       switch(rc) {
           case MB_ERR_INVALID:
               fprintf(stderr, "\t reason: 'job_application' board has not been created?\n");
               break;
           case MB_ERR_LOCKED:
               fprintf(stderr, "\t reason: 'job_application' board is locked\n");
               break;
           case MB_ERR_INTERNAL:
               fprintf(stderr, "\t reason: internal error. Recompile libmoard in debug mode for more info \n");
               break;
	       default:
               fprintf(stderr, "\t MB_Delete returned error code: %d (see libmboard docs for details)\n", rc);
               break;
	       }

	       
       	   exit(rc);
    }
    #endif

	rc = MB_Delete(&b_job_application2);
	#ifdef ERRCHECK
    if (rc != MB_SUCCESS)
    {
       fprintf(stderr, "ERROR: Could not delete 'job_application2' board\n");
       switch(rc) {
           case MB_ERR_INVALID:
               fprintf(stderr, "\t reason: 'job_application2' board has not been created?\n");
               break;
           case MB_ERR_LOCKED:
               fprintf(stderr, "\t reason: 'job_application2' board is locked\n");
               break;
           case MB_ERR_INTERNAL:
               fprintf(stderr, "\t reason: internal error. Recompile libmoard in debug mode for more info \n");
               break;
	       default:
               fprintf(stderr, "\t MB_Delete returned error code: %d (see libmboard docs for details)\n", rc);
               break;
	       }

	       
       	   exit(rc);
    }
    #endif

	rc = MB_Delete(&b_job_offer);
	#ifdef ERRCHECK
    if (rc != MB_SUCCESS)
    {
       fprintf(stderr, "ERROR: Could not delete 'job_offer' board\n");
       switch(rc) {
           case MB_ERR_INVALID:
               fprintf(stderr, "\t reason: 'job_offer' board has not been created?\n");
               break;
           case MB_ERR_LOCKED:
               fprintf(stderr, "\t reason: 'job_offer' board is locked\n");
               break;
           case MB_ERR_INTERNAL:
               fprintf(stderr, "\t reason: internal error. Recompile libmoard in debug mode for more info \n");
               break;
	       default:
               fprintf(stderr, "\t MB_Delete returned error code: %d (see libmboard docs for details)\n", rc);
               break;
	       }

	       
       	   exit(rc);
    }
    #endif

	rc = MB_Delete(&b_job_offer2);
	#ifdef ERRCHECK
    if (rc != MB_SUCCESS)
    {
       fprintf(stderr, "ERROR: Could not delete 'job_offer2' board\n");
       switch(rc) {
           case MB_ERR_INVALID:
               fprintf(stderr, "\t reason: 'job_offer2' board has not been created?\n");
               break;
           case MB_ERR_LOCKED:
               fprintf(stderr, "\t reason: 'job_offer2' board is locked\n");
               break;
           case MB_ERR_INTERNAL:
               fprintf(stderr, "\t reason: internal error. Recompile libmoard in debug mode for more info \n");
               break;
	       default:
               fprintf(stderr, "\t MB_Delete returned error code: %d (see libmboard docs for details)\n", rc);
               break;
	       }

	       
       	   exit(rc);
    }
    #endif

	rc = MB_Delete(&b_job_acceptance);
	#ifdef ERRCHECK
    if (rc != MB_SUCCESS)
    {
       fprintf(stderr, "ERROR: Could not delete 'job_acceptance' board\n");
       switch(rc) {
           case MB_ERR_INVALID:
               fprintf(stderr, "\t reason: 'job_acceptance' board has not been created?\n");
               break;
           case MB_ERR_LOCKED:
               fprintf(stderr, "\t reason: 'job_acceptance' board is locked\n");
               break;
           case MB_ERR_INTERNAL:
               fprintf(stderr, "\t reason: internal error. Recompile libmoard in debug mode for more info \n");
               break;
	       default:
               fprintf(stderr, "\t MB_Delete returned error code: %d (see libmboard docs for details)\n", rc);
               break;
	       }

	       
       	   exit(rc);
    }
    #endif

	rc = MB_Delete(&b_job_acceptance2);
	#ifdef ERRCHECK
    if (rc != MB_SUCCESS)
    {
       fprintf(stderr, "ERROR: Could not delete 'job_acceptance2' board\n");
       switch(rc) {
           case MB_ERR_INVALID:
               fprintf(stderr, "\t reason: 'job_acceptance2' board has not been created?\n");
               break;
           case MB_ERR_LOCKED:
               fprintf(stderr, "\t reason: 'job_acceptance2' board is locked\n");
               break;
           case MB_ERR_INTERNAL:
               fprintf(stderr, "\t reason: internal error. Recompile libmoard in debug mode for more info \n");
               break;
	       default:
               fprintf(stderr, "\t MB_Delete returned error code: %d (see libmboard docs for details)\n", rc);
               break;
	       }

	       
       	   exit(rc);
    }
    #endif

	rc = MB_Delete(&b_quitting);
	#ifdef ERRCHECK
    if (rc != MB_SUCCESS)
    {
       fprintf(stderr, "ERROR: Could not delete 'quitting' board\n");
       switch(rc) {
           case MB_ERR_INVALID:
               fprintf(stderr, "\t reason: 'quitting' board has not been created?\n");
               break;
           case MB_ERR_LOCKED:
               fprintf(stderr, "\t reason: 'quitting' board is locked\n");
               break;
           case MB_ERR_INTERNAL:
               fprintf(stderr, "\t reason: internal error. Recompile libmoard in debug mode for more info \n");
               break;
	       default:
               fprintf(stderr, "\t MB_Delete returned error code: %d (see libmboard docs for details)\n", rc);
               break;
	       }

	       
       	   exit(rc);
    }
    #endif

	rc = MB_Delete(&b_quitting2);
	#ifdef ERRCHECK
    if (rc != MB_SUCCESS)
    {
       fprintf(stderr, "ERROR: Could not delete 'quitting2' board\n");
       switch(rc) {
           case MB_ERR_INVALID:
               fprintf(stderr, "\t reason: 'quitting2' board has not been created?\n");
               break;
           case MB_ERR_LOCKED:
               fprintf(stderr, "\t reason: 'quitting2' board is locked\n");
               break;
           case MB_ERR_INTERNAL:
               fprintf(stderr, "\t reason: internal error. Recompile libmoard in debug mode for more info \n");
               break;
	       default:
               fprintf(stderr, "\t MB_Delete returned error code: %d (see libmboard docs for details)\n", rc);
               break;
	       }

	       
       	   exit(rc);
    }
    #endif

	rc = MB_Delete(&b_unemployment_notification);
	#ifdef ERRCHECK
    if (rc != MB_SUCCESS)
    {
       fprintf(stderr, "ERROR: Could not delete 'unemployment_notification' board\n");
       switch(rc) {
           case MB_ERR_INVALID:
               fprintf(stderr, "\t reason: 'unemployment_notification' board has not been created?\n");
               break;
           case MB_ERR_LOCKED:
               fprintf(stderr, "\t reason: 'unemployment_notification' board is locked\n");
               break;
           case MB_ERR_INTERNAL:
               fprintf(stderr, "\t reason: internal error. Recompile libmoard in debug mode for more info \n");
               break;
	       default:
               fprintf(stderr, "\t MB_Delete returned error code: %d (see libmboard docs for details)\n", rc);
               break;
	       }

	       
       	   exit(rc);
    }
    #endif

	rc = MB_Delete(&b_policy_announcement);
	#ifdef ERRCHECK
    if (rc != MB_SUCCESS)
    {
       fprintf(stderr, "ERROR: Could not delete 'policy_announcement' board\n");
       switch(rc) {
           case MB_ERR_INVALID:
               fprintf(stderr, "\t reason: 'policy_announcement' board has not been created?\n");
               break;
           case MB_ERR_LOCKED:
               fprintf(stderr, "\t reason: 'policy_announcement' board is locked\n");
               break;
           case MB_ERR_INTERNAL:
               fprintf(stderr, "\t reason: internal error. Recompile libmoard in debug mode for more info \n");
               break;
	       default:
               fprintf(stderr, "\t MB_Delete returned error code: %d (see libmboard docs for details)\n", rc);
               break;
	       }

	       
       	   exit(rc);
    }
    #endif

	rc = MB_Delete(&b_tax_payment);
	#ifdef ERRCHECK
    if (rc != MB_SUCCESS)
    {
       fprintf(stderr, "ERROR: Could not delete 'tax_payment' board\n");
       switch(rc) {
           case MB_ERR_INVALID:
               fprintf(stderr, "\t reason: 'tax_payment' board has not been created?\n");
               break;
           case MB_ERR_LOCKED:
               fprintf(stderr, "\t reason: 'tax_payment' board is locked\n");
               break;
           case MB_ERR_INTERNAL:
               fprintf(stderr, "\t reason: internal error. Recompile libmoard in debug mode for more info \n");
               break;
	       default:
               fprintf(stderr, "\t MB_Delete returned error code: %d (see libmboard docs for details)\n", rc);
               break;
	       }

	       
       	   exit(rc);
    }
    #endif

	rc = MB_Delete(&b_unemployment_benefit_restitution);
	#ifdef ERRCHECK
    if (rc != MB_SUCCESS)
    {
       fprintf(stderr, "ERROR: Could not delete 'unemployment_benefit_restitution' board\n");
       switch(rc) {
           case MB_ERR_INVALID:
               fprintf(stderr, "\t reason: 'unemployment_benefit_restitution' board has not been created?\n");
               break;
           case MB_ERR_LOCKED:
               fprintf(stderr, "\t reason: 'unemployment_benefit_restitution' board is locked\n");
               break;
           case MB_ERR_INTERNAL:
               fprintf(stderr, "\t reason: internal error. Recompile libmoard in debug mode for more info \n");
               break;
	       default:
               fprintf(stderr, "\t MB_Delete returned error code: %d (see libmboard docs for details)\n", rc);
               break;
	       }

	       
       	   exit(rc);
    }
    #endif

	rc = MB_Delete(&b_hh_transfer_notification);
	#ifdef ERRCHECK
    if (rc != MB_SUCCESS)
    {
       fprintf(stderr, "ERROR: Could not delete 'hh_transfer_notification' board\n");
       switch(rc) {
           case MB_ERR_INVALID:
               fprintf(stderr, "\t reason: 'hh_transfer_notification' board has not been created?\n");
               break;
           case MB_ERR_LOCKED:
               fprintf(stderr, "\t reason: 'hh_transfer_notification' board is locked\n");
               break;
           case MB_ERR_INTERNAL:
               fprintf(stderr, "\t reason: internal error. Recompile libmoard in debug mode for more info \n");
               break;
	       default:
               fprintf(stderr, "\t MB_Delete returned error code: %d (see libmboard docs for details)\n", rc);
               break;
	       }

	       
       	   exit(rc);
    }
    #endif

	rc = MB_Delete(&b_hh_subsidy_notification);
	#ifdef ERRCHECK
    if (rc != MB_SUCCESS)
    {
       fprintf(stderr, "ERROR: Could not delete 'hh_subsidy_notification' board\n");
       switch(rc) {
           case MB_ERR_INVALID:
               fprintf(stderr, "\t reason: 'hh_subsidy_notification' board has not been created?\n");
               break;
           case MB_ERR_LOCKED:
               fprintf(stderr, "\t reason: 'hh_subsidy_notification' board is locked\n");
               break;
           case MB_ERR_INTERNAL:
               fprintf(stderr, "\t reason: internal error. Recompile libmoard in debug mode for more info \n");
               break;
	       default:
               fprintf(stderr, "\t MB_Delete returned error code: %d (see libmboard docs for details)\n", rc);
               break;
	       }

	       
       	   exit(rc);
    }
    #endif

	rc = MB_Delete(&b_human_capital_policy_announcement);
	#ifdef ERRCHECK
    if (rc != MB_SUCCESS)
    {
       fprintf(stderr, "ERROR: Could not delete 'human_capital_policy_announcement' board\n");
       switch(rc) {
           case MB_ERR_INVALID:
               fprintf(stderr, "\t reason: 'human_capital_policy_announcement' board has not been created?\n");
               break;
           case MB_ERR_LOCKED:
               fprintf(stderr, "\t reason: 'human_capital_policy_announcement' board is locked\n");
               break;
           case MB_ERR_INTERNAL:
               fprintf(stderr, "\t reason: internal error. Recompile libmoard in debug mode for more info \n");
               break;
	       default:
               fprintf(stderr, "\t MB_Delete returned error code: %d (see libmboard docs for details)\n", rc);
               break;
	       }

	       
       	   exit(rc);
    }
    #endif

	rc = MB_Delete(&b_firm_transfer_notification);
	#ifdef ERRCHECK
    if (rc != MB_SUCCESS)
    {
       fprintf(stderr, "ERROR: Could not delete 'firm_transfer_notification' board\n");
       switch(rc) {
           case MB_ERR_INVALID:
               fprintf(stderr, "\t reason: 'firm_transfer_notification' board has not been created?\n");
               break;
           case MB_ERR_LOCKED:
               fprintf(stderr, "\t reason: 'firm_transfer_notification' board is locked\n");
               break;
           case MB_ERR_INTERNAL:
               fprintf(stderr, "\t reason: internal error. Recompile libmoard in debug mode for more info \n");
               break;
	       default:
               fprintf(stderr, "\t MB_Delete returned error code: %d (see libmboard docs for details)\n", rc);
               break;
	       }

	       
       	   exit(rc);
    }
    #endif

	rc = MB_Delete(&b_firm_subsidy_notification);
	#ifdef ERRCHECK
    if (rc != MB_SUCCESS)
    {
       fprintf(stderr, "ERROR: Could not delete 'firm_subsidy_notification' board\n");
       switch(rc) {
           case MB_ERR_INVALID:
               fprintf(stderr, "\t reason: 'firm_subsidy_notification' board has not been created?\n");
               break;
           case MB_ERR_LOCKED:
               fprintf(stderr, "\t reason: 'firm_subsidy_notification' board is locked\n");
               break;
           case MB_ERR_INTERNAL:
               fprintf(stderr, "\t reason: internal error. Recompile libmoard in debug mode for more info \n");
               break;
	       default:
               fprintf(stderr, "\t MB_Delete returned error code: %d (see libmboard docs for details)\n", rc);
               break;
	       }

	       
       	   exit(rc);
    }
    #endif

	rc = MB_Delete(&b_request_fiat_money);
	#ifdef ERRCHECK
    if (rc != MB_SUCCESS)
    {
       fprintf(stderr, "ERROR: Could not delete 'request_fiat_money' board\n");
       switch(rc) {
           case MB_ERR_INVALID:
               fprintf(stderr, "\t reason: 'request_fiat_money' board has not been created?\n");
               break;
           case MB_ERR_LOCKED:
               fprintf(stderr, "\t reason: 'request_fiat_money' board is locked\n");
               break;
           case MB_ERR_INTERNAL:
               fprintf(stderr, "\t reason: internal error. Recompile libmoard in debug mode for more info \n");
               break;
	       default:
               fprintf(stderr, "\t MB_Delete returned error code: %d (see libmboard docs for details)\n", rc);
               break;
	       }

	       
       	   exit(rc);
    }
    #endif

	rc = MB_Delete(&b_human_capital_policy_general_skill_information);
	#ifdef ERRCHECK
    if (rc != MB_SUCCESS)
    {
       fprintf(stderr, "ERROR: Could not delete 'human_capital_policy_general_skill_information' board\n");
       switch(rc) {
           case MB_ERR_INVALID:
               fprintf(stderr, "\t reason: 'human_capital_policy_general_skill_information' board has not been created?\n");
               break;
           case MB_ERR_LOCKED:
               fprintf(stderr, "\t reason: 'human_capital_policy_general_skill_information' board is locked\n");
               break;
           case MB_ERR_INTERNAL:
               fprintf(stderr, "\t reason: internal error. Recompile libmoard in debug mode for more info \n");
               break;
	       default:
               fprintf(stderr, "\t MB_Delete returned error code: %d (see libmboard docs for details)\n", rc);
               break;
	       }

	       
       	   exit(rc);
    }
    #endif

	rc = MB_Delete(&b_human_capital_policy_new_general_skill_notification);
	#ifdef ERRCHECK
    if (rc != MB_SUCCESS)
    {
       fprintf(stderr, "ERROR: Could not delete 'human_capital_policy_new_general_skill_notification' board\n");
       switch(rc) {
           case MB_ERR_INVALID:
               fprintf(stderr, "\t reason: 'human_capital_policy_new_general_skill_notification' board has not been created?\n");
               break;
           case MB_ERR_LOCKED:
               fprintf(stderr, "\t reason: 'human_capital_policy_new_general_skill_notification' board is locked\n");
               break;
           case MB_ERR_INTERNAL:
               fprintf(stderr, "\t reason: internal error. Recompile libmoard in debug mode for more info \n");
               break;
	       default:
               fprintf(stderr, "\t MB_Delete returned error code: %d (see libmboard docs for details)\n", rc);
               break;
	       }

	       
       	   exit(rc);
    }
    #endif

	rc = MB_Delete(&b_firm_send_data);
	#ifdef ERRCHECK
    if (rc != MB_SUCCESS)
    {
       fprintf(stderr, "ERROR: Could not delete 'firm_send_data' board\n");
       switch(rc) {
           case MB_ERR_INVALID:
               fprintf(stderr, "\t reason: 'firm_send_data' board has not been created?\n");
               break;
           case MB_ERR_LOCKED:
               fprintf(stderr, "\t reason: 'firm_send_data' board is locked\n");
               break;
           case MB_ERR_INTERNAL:
               fprintf(stderr, "\t reason: internal error. Recompile libmoard in debug mode for more info \n");
               break;
	       default:
               fprintf(stderr, "\t MB_Delete returned error code: %d (see libmboard docs for details)\n", rc);
               break;
	       }

	       
       	   exit(rc);
    }
    #endif

	rc = MB_Delete(&b_government_send_data);
	#ifdef ERRCHECK
    if (rc != MB_SUCCESS)
    {
       fprintf(stderr, "ERROR: Could not delete 'government_send_data' board\n");
       switch(rc) {
           case MB_ERR_INVALID:
               fprintf(stderr, "\t reason: 'government_send_data' board has not been created?\n");
               break;
           case MB_ERR_LOCKED:
               fprintf(stderr, "\t reason: 'government_send_data' board is locked\n");
               break;
           case MB_ERR_INTERNAL:
               fprintf(stderr, "\t reason: internal error. Recompile libmoard in debug mode for more info \n");
               break;
	       default:
               fprintf(stderr, "\t MB_Delete returned error code: %d (see libmboard docs for details)\n", rc);
               break;
	       }

	       
       	   exit(rc);
    }
    #endif

	rc = MB_Delete(&b_household_send_data);
	#ifdef ERRCHECK
    if (rc != MB_SUCCESS)
    {
       fprintf(stderr, "ERROR: Could not delete 'household_send_data' board\n");
       switch(rc) {
           case MB_ERR_INVALID:
               fprintf(stderr, "\t reason: 'household_send_data' board has not been created?\n");
               break;
           case MB_ERR_LOCKED:
               fprintf(stderr, "\t reason: 'household_send_data' board is locked\n");
               break;
           case MB_ERR_INTERNAL:
               fprintf(stderr, "\t reason: internal error. Recompile libmoard in debug mode for more info \n");
               break;
	       default:
               fprintf(stderr, "\t MB_Delete returned error code: %d (see libmboard docs for details)\n", rc);
               break;
	       }

	       
       	   exit(rc);
    }
    #endif

	rc = MB_Delete(&b_mall_data);
	#ifdef ERRCHECK
    if (rc != MB_SUCCESS)
    {
       fprintf(stderr, "ERROR: Could not delete 'mall_data' board\n");
       switch(rc) {
           case MB_ERR_INVALID:
               fprintf(stderr, "\t reason: 'mall_data' board has not been created?\n");
               break;
           case MB_ERR_LOCKED:
               fprintf(stderr, "\t reason: 'mall_data' board is locked\n");
               break;
           case MB_ERR_INTERNAL:
               fprintf(stderr, "\t reason: internal error. Recompile libmoard in debug mode for more info \n");
               break;
	       default:
               fprintf(stderr, "\t MB_Delete returned error code: %d (see libmboard docs for details)\n", rc);
               break;
	       }

	       
       	   exit(rc);
    }
    #endif

	rc = MB_Delete(&b_eurostat_send_specific_skills);
	#ifdef ERRCHECK
    if (rc != MB_SUCCESS)
    {
       fprintf(stderr, "ERROR: Could not delete 'eurostat_send_specific_skills' board\n");
       switch(rc) {
           case MB_ERR_INVALID:
               fprintf(stderr, "\t reason: 'eurostat_send_specific_skills' board has not been created?\n");
               break;
           case MB_ERR_LOCKED:
               fprintf(stderr, "\t reason: 'eurostat_send_specific_skills' board is locked\n");
               break;
           case MB_ERR_INTERNAL:
               fprintf(stderr, "\t reason: internal error. Recompile libmoard in debug mode for more info \n");
               break;
	       default:
               fprintf(stderr, "\t MB_Delete returned error code: %d (see libmboard docs for details)\n", rc);
               break;
	       }

	       
       	   exit(rc);
    }
    #endif

	rc = MB_Delete(&b_data_for_government);
	#ifdef ERRCHECK
    if (rc != MB_SUCCESS)
    {
       fprintf(stderr, "ERROR: Could not delete 'data_for_government' board\n");
       switch(rc) {
           case MB_ERR_INVALID:
               fprintf(stderr, "\t reason: 'data_for_government' board has not been created?\n");
               break;
           case MB_ERR_LOCKED:
               fprintf(stderr, "\t reason: 'data_for_government' board is locked\n");
               break;
           case MB_ERR_INTERNAL:
               fprintf(stderr, "\t reason: internal error. Recompile libmoard in debug mode for more info \n");
               break;
	       default:
               fprintf(stderr, "\t MB_Delete returned error code: %d (see libmboard docs for details)\n", rc);
               break;
	       }

	       
       	   exit(rc);
    }
    #endif

	rc = MB_Delete(&b_eurostat_send_macrodata);
	#ifdef ERRCHECK
    if (rc != MB_SUCCESS)
    {
       fprintf(stderr, "ERROR: Could not delete 'eurostat_send_macrodata' board\n");
       switch(rc) {
           case MB_ERR_INVALID:
               fprintf(stderr, "\t reason: 'eurostat_send_macrodata' board has not been created?\n");
               break;
           case MB_ERR_LOCKED:
               fprintf(stderr, "\t reason: 'eurostat_send_macrodata' board is locked\n");
               break;
           case MB_ERR_INTERNAL:
               fprintf(stderr, "\t reason: internal error. Recompile libmoard in debug mode for more info \n");
               break;
	       default:
               fprintf(stderr, "\t MB_Delete returned error code: %d (see libmboard docs for details)\n", rc);
               break;
	       }

	       
       	   exit(rc);
    }
    #endif

	rc = MB_Delete(&b_msg_firm_id_to_malls);
	#ifdef ERRCHECK
    if (rc != MB_SUCCESS)
    {
       fprintf(stderr, "ERROR: Could not delete 'msg_firm_id_to_malls' board\n");
       switch(rc) {
           case MB_ERR_INVALID:
               fprintf(stderr, "\t reason: 'msg_firm_id_to_malls' board has not been created?\n");
               break;
           case MB_ERR_LOCKED:
               fprintf(stderr, "\t reason: 'msg_firm_id_to_malls' board is locked\n");
               break;
           case MB_ERR_INTERNAL:
               fprintf(stderr, "\t reason: internal error. Recompile libmoard in debug mode for more info \n");
               break;
	       default:
               fprintf(stderr, "\t MB_Delete returned error code: %d (see libmboard docs for details)\n", rc);
               break;
	       }

	       
       	   exit(rc);
    }
    #endif

	rc = MB_Delete(&b_msg_mall_id_to_firms);
	#ifdef ERRCHECK
    if (rc != MB_SUCCESS)
    {
       fprintf(stderr, "ERROR: Could not delete 'msg_mall_id_to_firms' board\n");
       switch(rc) {
           case MB_ERR_INVALID:
               fprintf(stderr, "\t reason: 'msg_mall_id_to_firms' board has not been created?\n");
               break;
           case MB_ERR_LOCKED:
               fprintf(stderr, "\t reason: 'msg_mall_id_to_firms' board is locked\n");
               break;
           case MB_ERR_INTERNAL:
               fprintf(stderr, "\t reason: internal error. Recompile libmoard in debug mode for more info \n");
               break;
	       default:
               fprintf(stderr, "\t MB_Delete returned error code: %d (see libmboard docs for details)\n", rc);
               break;
	       }

	       
       	   exit(rc);
    }
    #endif

	rc = MB_Delete(&b_msg_skills_eurostat_to_igfirm);
	#ifdef ERRCHECK
    if (rc != MB_SUCCESS)
    {
       fprintf(stderr, "ERROR: Could not delete 'msg_skills_eurostat_to_igfirm' board\n");
       switch(rc) {
           case MB_ERR_INVALID:
               fprintf(stderr, "\t reason: 'msg_skills_eurostat_to_igfirm' board has not been created?\n");
               break;
           case MB_ERR_LOCKED:
               fprintf(stderr, "\t reason: 'msg_skills_eurostat_to_igfirm' board is locked\n");
               break;
           case MB_ERR_INTERNAL:
               fprintf(stderr, "\t reason: internal error. Recompile libmoard in debug mode for more info \n");
               break;
	       default:
               fprintf(stderr, "\t MB_Delete returned error code: %d (see libmboard docs for details)\n", rc);
               break;
	       }

	       
       	   exit(rc);
    }
    #endif

	rc = MB_Delete(&b_msg_market_sizes);
	#ifdef ERRCHECK
    if (rc != MB_SUCCESS)
    {
       fprintf(stderr, "ERROR: Could not delete 'msg_market_sizes' board\n");
       switch(rc) {
           case MB_ERR_INVALID:
               fprintf(stderr, "\t reason: 'msg_market_sizes' board has not been created?\n");
               break;
           case MB_ERR_LOCKED:
               fprintf(stderr, "\t reason: 'msg_market_sizes' board is locked\n");
               break;
           case MB_ERR_INTERNAL:
               fprintf(stderr, "\t reason: internal error. Recompile libmoard in debug mode for more info \n");
               break;
	       default:
               fprintf(stderr, "\t MB_Delete returned error code: %d (see libmboard docs for details)\n", rc);
               break;
	       }

	       
       	   exit(rc);
    }
    #endif

	rc = MB_Delete(&b_total_subsidies);
	#ifdef ERRCHECK
    if (rc != MB_SUCCESS)
    {
       fprintf(stderr, "ERROR: Could not delete 'total_subsidies' board\n");
       switch(rc) {
           case MB_ERR_INVALID:
               fprintf(stderr, "\t reason: 'total_subsidies' board has not been created?\n");
               break;
           case MB_ERR_LOCKED:
               fprintf(stderr, "\t reason: 'total_subsidies' board is locked\n");
               break;
           case MB_ERR_INTERNAL:
               fprintf(stderr, "\t reason: internal error. Recompile libmoard in debug mode for more info \n");
               break;
	       default:
               fprintf(stderr, "\t MB_Delete returned error code: %d (see libmboard docs for details)\n", rc);
               break;
	       }

	       
       	   exit(rc);
    }
    #endif

	rc = MB_Delete(&b_redistributed_subsidies);
	#ifdef ERRCHECK
    if (rc != MB_SUCCESS)
    {
       fprintf(stderr, "ERROR: Could not delete 'redistributed_subsidies' board\n");
       switch(rc) {
           case MB_ERR_INVALID:
               fprintf(stderr, "\t reason: 'redistributed_subsidies' board has not been created?\n");
               break;
           case MB_ERR_LOCKED:
               fprintf(stderr, "\t reason: 'redistributed_subsidies' board is locked\n");
               break;
           case MB_ERR_INTERNAL:
               fprintf(stderr, "\t reason: internal error. Recompile libmoard in debug mode for more info \n");
               break;
	       default:
               fprintf(stderr, "\t MB_Delete returned error code: %d (see libmboard docs for details)\n", rc);
               break;
	       }

	       
       	   exit(rc);
    }
    #endif

	rc = MB_Delete(&b_quality_price);
	#ifdef ERRCHECK
    if (rc != MB_SUCCESS)
    {
       fprintf(stderr, "ERROR: Could not delete 'quality_price' board\n");
       switch(rc) {
           case MB_ERR_INVALID:
               fprintf(stderr, "\t reason: 'quality_price' board has not been created?\n");
               break;
           case MB_ERR_LOCKED:
               fprintf(stderr, "\t reason: 'quality_price' board is locked\n");
               break;
           case MB_ERR_INTERNAL:
               fprintf(stderr, "\t reason: internal error. Recompile libmoard in debug mode for more info \n");
               break;
	       default:
               fprintf(stderr, "\t MB_Delete returned error code: %d (see libmboard docs for details)\n", rc);
               break;
	       }

	       
       	   exit(rc);
    }
    #endif

	rc = MB_Delete(&b_interview_request);
	#ifdef ERRCHECK
    if (rc != MB_SUCCESS)
    {
       fprintf(stderr, "ERROR: Could not delete 'interview_request' board\n");
       switch(rc) {
           case MB_ERR_INVALID:
               fprintf(stderr, "\t reason: 'interview_request' board has not been created?\n");
               break;
           case MB_ERR_LOCKED:
               fprintf(stderr, "\t reason: 'interview_request' board is locked\n");
               break;
           case MB_ERR_INTERNAL:
               fprintf(stderr, "\t reason: internal error. Recompile libmoard in debug mode for more info \n");
               break;
	       default:
               fprintf(stderr, "\t MB_Delete returned error code: %d (see libmboard docs for details)\n", rc);
               break;
	       }

	       
       	   exit(rc);
    }
    #endif

	rc = MB_Delete(&b_interview_positive_response);
	#ifdef ERRCHECK
    if (rc != MB_SUCCESS)
    {
       fprintf(stderr, "ERROR: Could not delete 'interview_positive_response' board\n");
       switch(rc) {
           case MB_ERR_INVALID:
               fprintf(stderr, "\t reason: 'interview_positive_response' board has not been created?\n");
               break;
           case MB_ERR_LOCKED:
               fprintf(stderr, "\t reason: 'interview_positive_response' board is locked\n");
               break;
           case MB_ERR_INTERNAL:
               fprintf(stderr, "\t reason: internal error. Recompile libmoard in debug mode for more info \n");
               break;
	       default:
               fprintf(stderr, "\t MB_Delete returned error code: %d (see libmboard docs for details)\n", rc);
               break;
	       }

	       
       	   exit(rc);
    }
    #endif

	rc = MB_Delete(&b_questionnaire_innovation);
	#ifdef ERRCHECK
    if (rc != MB_SUCCESS)
    {
       fprintf(stderr, "ERROR: Could not delete 'questionnaire_innovation' board\n");
       switch(rc) {
           case MB_ERR_INVALID:
               fprintf(stderr, "\t reason: 'questionnaire_innovation' board has not been created?\n");
               break;
           case MB_ERR_LOCKED:
               fprintf(stderr, "\t reason: 'questionnaire_innovation' board is locked\n");
               break;
           case MB_ERR_INTERNAL:
               fprintf(stderr, "\t reason: internal error. Recompile libmoard in debug mode for more info \n");
               break;
	       default:
               fprintf(stderr, "\t MB_Delete returned error code: %d (see libmboard docs for details)\n", rc);
               break;
	       }

	       
       	   exit(rc);
    }
    #endif

	rc = MB_Delete(&b_filled_out_questionnaire_product_innovation);
	#ifdef ERRCHECK
    if (rc != MB_SUCCESS)
    {
       fprintf(stderr, "ERROR: Could not delete 'filled_out_questionnaire_product_innovation' board\n");
       switch(rc) {
           case MB_ERR_INVALID:
               fprintf(stderr, "\t reason: 'filled_out_questionnaire_product_innovation' board has not been created?\n");
               break;
           case MB_ERR_LOCKED:
               fprintf(stderr, "\t reason: 'filled_out_questionnaire_product_innovation' board is locked\n");
               break;
           case MB_ERR_INTERNAL:
               fprintf(stderr, "\t reason: internal error. Recompile libmoard in debug mode for more info \n");
               break;
	       default:
               fprintf(stderr, "\t MB_Delete returned error code: %d (see libmboard docs for details)\n", rc);
               break;
	       }

	       
       	   exit(rc);
    }
    #endif


    rc = MB_Env_Finalise();
    #ifdef ERRCHECK
    if (rc != MB_SUCCESS)
    {
       fprintf(stderr, "ERROR: Could not finalise MB environment\n");
       switch(rc) {
           case MB_ERR_ENV:
               fprintf(stderr, "\t reason: MB environment not yet started?\n");
               break;
	       default:
               fprintf(stderr, "\t MB_Env_Finalise returned error code: %d (see libmboard docs for details)\n", rc);
               break;
	       }

	       
       	   exit(rc);
    }
    #endif



	/* Write log file */
	sprintf(data, "%slog.xml", outputpath);
	file = fopen(data, "a");
	fputs("<!-- <totaltime> unit: seconds -->\n", file);
	fputs("<totaltime>", file);
	sprintf(data, "%.3f", total_time);
	fputs(data, file);
	fputs("</totaltime>\n", file);
	/*fputs("<totalmessages>", file);
	sprintf(data, "%i", total_messages);
	fputs(data, file);
	fputs("</totalmessages>", file);*/
	fputs("</model_run>", file);
	fclose(file);


	if(code != 0)
	{
		printf("*** Error: ");
		if(code == 100) printf("cannot handle specified number of space partitions");
		if(code == 101) printf("could not find number of space partitions config in file");

		printf(" ***");
		exit(0);
	}
}


/** \fn void propagate_agents()
 * \brief Check agent positions to see if any need to be moved to a another node.
 */
void propagate_agents()
{
/*	node_information * node_info;
	xmachine * before_xmachine, * temp_xmachine;
	xmachine ** p_temp_xmachine;
	double x_xmachine, y_xmachine, z_xmachine;
	current_xmachine = *p_xmachine;
	before_xmachine = NULL;
	while(current_xmachine)
	{
		if(current_xmachine->xmachine_Firm != NULL)
		{
			x_xmachine = current_xmachine->xmachine_Firm->0.0;
			y_xmachine = current_xmachine->xmachine_Firm->0.0;
			z_xmachine = 0.0;
		}
		else if(current_xmachine->xmachine_Household != NULL)
		{
			x_xmachine = current_xmachine->xmachine_Household->0.0;
			y_xmachine = current_xmachine->xmachine_Household->0.0;
			z_xmachine = 0.0;
		}
		else if(current_xmachine->xmachine_Mall != NULL)
		{
			x_xmachine = current_xmachine->xmachine_Mall->0.0;
			y_xmachine = current_xmachine->xmachine_Mall->0.0;
			z_xmachine = 0.0;
		}
		else if(current_xmachine->xmachine_IGFirm != NULL)
		{
			x_xmachine = current_xmachine->xmachine_IGFirm->0.0;
			y_xmachine = current_xmachine->xmachine_IGFirm->0.0;
			z_xmachine = 0.0;
		}
		else if(current_xmachine->xmachine_Eurostat != NULL)
		{
			x_xmachine = current_xmachine->xmachine_Eurostat->0.0;
			y_xmachine = current_xmachine->xmachine_Eurostat->0.0;
			z_xmachine = 0.0;
		}
		else if(current_xmachine->xmachine_Bank != NULL)
		{
			x_xmachine = current_xmachine->xmachine_Bank->0.0;
			y_xmachine = current_xmachine->xmachine_Bank->0.0;
			z_xmachine = 0.0;
		}
		else if(current_xmachine->xmachine_Government != NULL)
		{
			x_xmachine = current_xmachine->xmachine_Government->0.0;
			y_xmachine = current_xmachine->xmachine_Government->0.0;
			z_xmachine = 0.0;
		}
		else if(current_xmachine->xmachine_CentralBank != NULL)
		{
			x_xmachine = current_xmachine->xmachine_CentralBank->0.0;
			y_xmachine = current_xmachine->xmachine_CentralBank->0.0;
			z_xmachine = 0.0;
		}
		else if(current_xmachine->xmachine_ClearingHouse != NULL)
		{
			x_xmachine = current_xmachine->xmachine_ClearingHouse->0.0;
			y_xmachine = current_xmachine->xmachine_ClearingHouse->0.0;
			z_xmachine = 0.0;
		}

		if(x_xmachine < current_node->partition_data[0] ||
		   x_xmachine > current_node->partition_data[1] ||
		   y_xmachine < current_node->partition_data[2] ||
		   y_xmachine > current_node->partition_data[3] ||
		   z_xmachine < current_node->partition_data[4] ||
		   z_xmachine > current_node->partition_data[5])
		{
			node_info = *p_node_info;
			while(node_info)
			{
				if(node_info->node_id != current_node->node_id &&
				node_info->partition_data[0] < x_xmachine && node_info->partition_data[1] > x_xmachine &&
				node_info->partition_data[2] < y_xmachine && node_info->partition_data[3] > y_xmachine &&
				node_info->partition_data[4] < z_xmachine && node_info->partition_data[5] > z_xmachine)
				{
                    // Remove agent
                    if(before_xmachine) before_xmachine->next = current_xmachine->next;
                    else *p_xmachine = current_xmachine->next;
                    current_node->agent_total--;
                    // Add agent
                    p_temp_xmachine = &node_info->agents;
                    temp_xmachine = *p_temp_xmachine;
                    current_xmachine->next = temp_xmachine;
                    *p_temp_xmachine = current_xmachine;
                    node_info->agent_total++;
                    node_info = NULL;
				}
				else node_info = node_info->next;
				}
			}
			else before_xmachine = current_xmachine;

			if(before_xmachine) current_xmachine = before_xmachine->next;
			else current_xmachine = NULL;
		}*/
}


/** \fn int_array * init_int_array()
 * \brief Allocate memory for a dynamic integer array.
 * \return int_array Pointer to the new dynamic integer array.
 */
void init_int_array(int_array * array)
{
	(*array).size = 0;
	(*array).total_size = ARRAY_BLOCK_SIZE;
	(*array).array = (int *)malloc(ARRAY_BLOCK_SIZE * sizeof(int));
	CHECK_POINTER((*array).array);
}

/** \fn void reset_int_array(int_array * array)
* \brief Reset the int array to hold nothing.
* \param array Pointer to the dynamic integer array.
*/
void reset_int_array(int_array * array)
{
	(*array).size = 0;
}

/** \fn void free_int_array(int_array * array)
* \brief Free the memory of a dynamic integer array.
* \param array Pointer to the dynamic integer array.
*/
void free_int_array(int_array * array)
{
	free((*array).array);
}

void copy_int_array(int_array * from, int_array * to)
{
	int i;
	//to = init_int_array();

	for (i = 0; i < (*from).size; i++)
	{
		add_int(to, (*from).array[i]);
	}
}

/** \fn void sort_int_array(int_array * array)
* \brief Sort the elements of a dynamic integer array with smallest first.
* \param array Pointer to the dynamic integer array.
*/
/*void sort_int_array(int_array * array)
{
	int i, j, temp;

	for(i=0; i<((*array).size-1); i++)
	{
		for(j=0; j<((*array).size-1)-i; j++)
		{
			if(*((*array).array+j+1) < *((*array).array+j))
			{
                temp = *((*array).(*array)+j);
                *((*array).array+j) = *((*array).array+j+1);
                *((*array).array+j+1) = temp;
			}
		}
	}
}*/

/** \fn int quicksort_int(int *array, int elements)
 *  \brief Sorts the elements of the integer array in ascending order.
 *  \param Pointer to integer array
 *  \param Number of elements that must be sorted
 *  \return integer value indicating success(0) or failure(1)
 */
/*int quicksort_int(int array, int elements)
{
	#define  LEVEL  1000
	int  pivot, begin[LEVEL], end[LEVEL], i=0, left, right ;
	begin[0]=0; end[0]=elements;
	while (i>=0)
	{
		left=begin[i]; right=end[i]-1;
		if (left<right)
		{
			pivot=array[left]; if (i==LEVEL-1) return 1;
			while (left<right)
			{
				while (array[right]>=pivot && left<right) right--;
				if (left<right) array[left++]=array[right];
				while (array[left]<=pivot && left<right) left++;
				if (left<right) array[right--]=array[left];
			}
			array[left]=pivot;
			begin[i+1]=left+1;
			end[i+1]=end[i];
			end[i++]=left;
		}
	    else
	    {
	      i--;
	    }
	}
	return 0;
}*/

/** \fn void add_int(int_array * array, int new_int)
* \brief Add an integer to the dynamic integer array.
* \param array Pointer to the dynamic integer array.
* \param new_int The integer to add
*/
void add_int(int_array * array, int new_int)
{
	if((*array).size == (*array).total_size)
	{
		(*array).total_size = (int)((*array).total_size * ARRAY_GROWTH_RATE);
		(*array).array = (int *)realloc((*array).array, ((*array).total_size * sizeof(int)));
	}
	(*array).array[(*array).size] = new_int;
	(*array).size++;
}

/** \fn void remove_int(int_array * array, int index)
 * \brief Remove an integer from a dynamic integer array.
 * \param array Pointer to the dynamic integer array.
 * \param index The index of the integer to remove.
 */
void remove_int(int_array * array, int index)
{
	int i;

	if(index < (*array).size)
	{
		/* memcopy?? */
		for(i = index; i < (*array).size - 1; i++)
		{
			(*array).array[i] = (*array).array[i+1];
		}
		(*array).size--;
	}
}

/** \fn void print_int_array(int_array * array)
 * \brief Print the elements of a dynamic integer array.
 * \param array Pointer to the dynamic integer array.
 */
void print_int_array(int_array * array)
{
	int i;

	for(i=0; i<(*array).size; i++)
	{
		printf("%d> %d", i, (*array).array[i]);
	}
}

/** \fn float_array * init_float_array()
 * \brief Allocate memory for a dynamic float array.
 * \return float_array Pointer to the new dynamic float array.
 */
void init_float_array(float_array * array)
{
	(*array).size = 0;
	(*array).total_size = ARRAY_BLOCK_SIZE;
	(*array).array = (float *)malloc(ARRAY_BLOCK_SIZE * sizeof(float));
	CHECK_POINTER((*array).array);
}

/** \fn void reset_float_array(float_array * array)
* \brief Reset the float array to hold nothing.
* \param array Pointer to the dynamic float array.
*/
void reset_float_array(float_array * array)
{
	(*array).size = 0;
}

/** \fn void free_float_array(float_array * array)
* \brief Free the memory of a dynamic float array.
* \param array Pointer to the dynamic float array.
*/
void free_float_array(float_array * array)
{
	free((*array).array);
}

void copy_float_array(float_array * from, float_array * to)
{
	int i;
	//to = init_float_array();

	for (i = 0; i < (*from).size; i++)
	{
		add_float(to, (*from).array[i]);
	}
}

/** \fn void sort_float_array(float_array * array)
* \brief Sort the elements of a dynamic float array with smallest first.
* \param array Pointer to the dynamic float array.
*/
/*void sort_float_array(float_array array)
{
	int i, j;
	float temp;
	// Using bubble sorts nested loops //
	for(i=0; i<(array.size-1); i++)
	{
		for(j=0; j<(array.size-1)-i; j++)
		{
			// Comparing the values between neighbours //
			if(*(array.array+j+1) < *(array.array+j))
			{
                // Swap neighbours //
                temp = *(array.array+j);
                *(array.array+j) = *(array.array+j+1);
                *(array.array+j+1) = temp;
			}
		}
	}
}*/

/** \fn int quicksort_float(float *array, int elements)
 *  \brief Sorts the elements of the float array in ascending order.
 *  \param Pointer to float array
 *  \param Number of elements that must be sorted
 *  \return integer value indicating success(0) or failure(1)
 */
/*int quicksort_float(float array, int elements)
{
	#define  LEVEL  1000
	int i=0, left, right ;
	float pivot, begin[LEVEL], end[LEVEL];
	begin[0]=0; end[0]=elements;
	while (i>=0)
	{
		left=begin[i]; right=end[i]-1;
		if (left<right)
		{
			pivot=array[left]; if (i==LEVEL-1) return 1;
			while (left<right)
			{
				while (array[right]>=pivot && left<right) right--;
				if (left<right) array[left++]=array[right];
				while (array[left]<=pivot && left<right) left++;
				if (left<right) array[right--]=array[left];
			}
			array[left]=pivot;
			begin[i+1]=left+1;
			end[i+1]=end[i];
			end[i++]=left;
		}
	    else
	    {
	      i--;
	    }
	}
	return 0;
}*/

/** \fn void add_float(float_array * array, float new_float)
* \brief Add an floateger to the dynamic float array.
* \param array Pointer to the dynamic float array.
* \param new_float The float to add
*/
void add_float(float_array * array, float new_float)
{
	if((*array).size == (*array).total_size)
	{
		(*array).total_size = (int)((*array).total_size * ARRAY_GROWTH_RATE);
		(*array).array = (float *)realloc((*array).array, ((*array).total_size * sizeof(float)));
	}
	(*array).array[(*array).size] = new_float;
	(*array).size++;
}

/** \fn void remove_float(float_array * array, int index)
 * \brief Remove an floateger from a dynamic float array.
 * \param array Pointer to the dynamic float array.
 * \param index The index of the float to remove.
 */
void remove_float(float_array * array, int index)
{
	int i;

	if(index < (*array).size)
	{
		/* memcopy?? */
		for(i = index; i < (*array).size - 1; i++)
		{
			(*array).array[i] = (*array).array[i+1];
		}
		(*array).size--;
	}
}

/** \fn void print_float_array(float_array * array)
 * \brief Print the elements of a dynamic float array.
 * \param array Pointer to the dynamic float array.
 */
void print_float_array(float_array * array)
{
	int i;
	/* printf(""); // compiler does not like empty prfloats */
	for(i=0; i<(*array).size; i++)
	{
		printf("%d> %f", i, (*array).array[i]);
	}
}

/** \fn double_array * init_double_array()
 * \brief Allocate memory for a dynamic double array.
 * \return double_array Pointer to the new dynamic double array.
 */
void init_double_array(double_array * array)
{
	(*array).size = 0;
	(*array).total_size = ARRAY_BLOCK_SIZE;
	(*array).array = (double *)malloc(ARRAY_BLOCK_SIZE * sizeof(double));
	CHECK_POINTER((*array).array);
}

/** \fn void reset_double_array(double_array * array)
* \brief Reset the double array to hold nothing.
* \param array Pointer to the dynamic double array.
*/
void reset_double_array(double_array * array)
{
	(*array).size = 0;
}

/** \fn void free_double_array(double_array * array)
 * \brief Free the memory of a dynamic double array.
 * \param array Pointer to the dynamic double array.
 */
void free_double_array(double_array * array)
{
	free((*array).array);
}

void copy_double_array(double_array * from, double_array * to)
{
	int i;
	//to = init_double_array();

	for (i = 0; i < (*from).size; i++)
	{
		add_double(to, (*from).array[i]);
	}
}

/** \fn void sort_double_array(double_array * array)
 * \brief Sort the elements of a dynamic double array with smallest first.
 * \param array Pointer to the dynamic double array.
 */
/*void sort_double_array(double_array array)
{
	int i, j;
	double temp;

	// Using bubble sorts nested loops //
	for(i=0; i<(array.size-1); i++)
	{
		for(j=0; j<(array.size-1)-i; j++)
		{
			// Comparing the values between neighbours //
			if(*(array.array+j+1) < *(array.array+j))
			{
                // Swap neighbours //
                temp = *(array.array+j);
                *(array.array+j) = *(array.array+j+1);
                *(array.array+j+1) = temp;
			}
		}
	}
}*/

/** \fn int quicksort_double(double *array, int elements)
 *  \brief Sorts the elements of the double array in ascending order.
 *  \param Pointer to double array
 *  \param Number of elements that must be sorted
 *  \return integer value indicating success(0) or failure(1)
 */
/*int quicksort_double(double array, int elements)
{
	#define  LEVEL  1000
	double pivot, begin[LEVEL], end[LEVEL];
	int  i=0, left, right ;
	begin[0]=0; end[0]=elements;
	while (i>=0)
	{
		left=begin[i]; right=end[i]-1;
		if (left<right)
		{
			pivot=array[left]; if (i==LEVEL-1) return 1;
			while (left<right)
			{
				while (array[right]>=pivot && left<right) right--;
				if (left<right) array[left++]=array[right];
				while (array[left]<=pivot && left<right) left++;
				if (left<right) array[right--]=array[left];
			}
			array[left]=pivot;
			begin[i+1]=left+1;
			end[i+1]=end[i];
			end[i++]=left;
		}
	    else
	    {
	      i--;
	    }
	}
	return 0;
}*/

/** \fn void add_double(double_array * array, double new_double)
 * \brief Add an double to the dynamic double array.
 * \param array Pointer to the dynamic double array.
 * \param new_double The double to add
 */
void add_double(double_array * array, double new_double)
{
	if((*array).size == (*array).total_size)
	{
		(*array).total_size = (int)((*array).total_size * ARRAY_GROWTH_RATE);
		(*array).array = (double *)realloc((*array).array, ((*array).total_size * sizeof(double)));
	}
	(*array).array[(*array).size] = new_double;
	(*array).size++;
}

/** \fn void remove_double(double_array * array, int index)
 * \brief Remove an double from a dynamic double array.
 * \param array Pointer to the dynamic double array.
 * \param index The index of the double to remove.
 */
void remove_double(double_array * array, int index)
{
	int i;
	if(index < (*array).size)
	{
		/* memcopy?? */
		for(i = index; i < (*array).size - 1; i++)
		{
			(*array).array[i] = (*array).array[i+1];
		}
		(*array).size--;
	}
}

/** \fn void print_double_array(double_array * array)
 * \brief Print the elements of a dynamic double array.
 * \param array Pointer to the dynamic double array.
 */
void print_double_array(double_array * array)
{
	int i;

	for(i=0; i<(*array).size; i++)
	{
		printf("%d> %f", i, (*array).array[i]);
	}
}

/** \fn char_array * init_char_array()
 * \brief Allocate memory for a dynamic char array.
 * \return char_array Pointer to the new dynamic char array.
 */
void init_char_array(char_array * array)
{
	(*array).size = 0;
	(*array).total_size = ARRAY_BLOCK_SIZE;
	(*array).array = (char *)malloc(ARRAY_BLOCK_SIZE * sizeof(char));
	CHECK_POINTER((*array).array);
	(*array).array[0] = '\0';
}

/** \fn void reset_char_array(char_array * array)
* \brief Reset the char array to hold nothing.
* \param array Pointer to the dynamic char array.
*/
void reset_char_array(char_array * array)
{
	(*array).size = 0;
}

/** \fn void free_char_array(char_array * array)
 * \brief Free the memory of a dynamic char array.
 * \param array Pointer to the dynamic char array.
 */
void free_char_array(char_array * array)
{
	free((*array).array);
}

void copy_char_array(char_array * from, char_array * to)
{
	int i;

	for (i = 0; i < (*from).size; i++)
	{
		add_char(to, (*from).array[i]);
	}
}

/** \fn void add_char(char_array * array, char new_char)
 * \brief Add an char to the dynamic char array.
 * \param array Pointer to the dynamic char array.
 * \param new_char The char to add
 */
void add_char(char_array * array, char new_char)
{
	if((*array).size + 1 == (*array).total_size)
	{
		(*array).total_size = (int)((*array).total_size * ARRAY_GROWTH_RATE);
		(*array).array = (char *)realloc((*array).array, ((*array).total_size * sizeof(char)));
	}
	(*array).array[(*array).size] = new_char;
	(*array).array[(*array).size + 1] = '\0';
	(*array).size++;
}

/** \fn void remove_char(char_array * array, int index)
 * \brief Remove an char from a dynamic char array.
 * \param array Pointer to the dynamic char array.
 * \param index The index of the char to remove.
 */
void remove_char(char_array * array, int index)
{
	int i;
	if(index < (*array).size)
	{
		/* memcopy?? */
		for(i = index; i < (*array).size - 1; i++)
		{
			(*array).array[i] = (*array).array[i+1];
		}
		(*array).size--;
	}
}

/** \fn char * copy_array_to_str(char_array * array)
 * \brief Return pointer to string from a char_array.
 * \param array Pointer to the dynamic integer array.
 * \return char Pointer to the new string.
 */
char * copy_array_to_str(char_array * array)
{
	char * new_string = (char *)malloc( ((*array).size + 1) * sizeof(char));
	CHECK_POINTER(new_string);
	return strcpy(new_string, (*array).array);
}

/** \fn void print_char_array(char_array * array)
 * \brief Print the elements of a dynamic char array.
 * \param array Pointer to the dynamic char array.
 */
void print_char_array(char_array * array)
{
	printf("%s", (*array).array);
}

/* Functions for the consumption_goods_offer datatype */
/** \fn consumption_goods_offer_array * init_consumption_goods_offer_array()
 * \brief Allocate memory for a dynamic consumption_goods_offer array.
 * \return consumption_goods_offer_array Pointer to the new dynamic consumption_goods_offer array.
 */
void init_consumption_goods_offer_array(consumption_goods_offer_array * array)
{
	(*array).size = 0;
	(*array).total_size = ARRAY_BLOCK_SIZE;
	(*array).array = (consumption_goods_offer *)malloc(ARRAY_BLOCK_SIZE * sizeof(consumption_goods_offer));
	CHECK_POINTER((*array).array);
}

/** \fn void reset_consumption_goods_offer_array(consumption_goods_offer_array* array)
* \brief Reset the consumption_goods_offer array to hold nothing.
* \param array Pointer to the dynamic consumption_goods_offer array.
*/
void reset_consumption_goods_offer_array(consumption_goods_offer_array * array)
{
	(*array).size = 0;
}

/** \fn void free_consumption_goods_offer_array(consumption_goods_offer_array * array)
* \brief Free the memory of a dynamic consumption_goods_offer array.
* \param array Pointer to the dynamic consumption_goods_offer array.
*/
void free_consumption_goods_offer_array(consumption_goods_offer_array * array)
{
	int i;
	
	for(i = 0; i < array->size; i++)
	{
		free_consumption_goods_offer(&(*array).array[i]);
	}
	
	free((*array).array);
}

void copy_consumption_goods_offer_array(consumption_goods_offer_array * from, consumption_goods_offer_array * to)
{
	int i;

	//to = init_consumption_goods_offer_array();

	for(i = 0; i < (*from).size; i++)
	{
		add_consumption_goods_offer(to, (*from).array[i].id, (*from).array[i].quality, (*from).array[i].price);
	}
}

/** \fn void add_consumption_goods_offer(consumption_goods_offer_array * array, int id, double quality, double price)
* \brief Add an consumption_goods_offer to the dynamic consumption_goods_offer array.
* \param array Pointer to the dynamic consumption_goods_offer array.
* \param new_int The consumption_goods_offer to add
*/
void add_consumption_goods_offer(consumption_goods_offer_array * array,  int id,  double quality,  double price)
{
	if((*array).size == (*array).total_size)
	{
		(*array).total_size = (int)((*array).total_size * ARRAY_GROWTH_RATE);
		(*array).array = (consumption_goods_offer *)realloc((*array).array, ((*array).total_size * sizeof(consumption_goods_offer)));
	}
	init_consumption_goods_offer(&(*array).array[(*array).size]);
	(*array).array[(*array).size].id = id;
	(*array).array[(*array).size].quality = quality;
	(*array).array[(*array).size].price = price;

	(*array).size++;
}

/** \fn void remove_consumption_goods_offer(consumption_goods_offer_array * array, int index)
 * \brief Remove an consumption_goods_offer from a dynamic consumption_goods_offer array.
 * \param array Pointer to the dynamic consumption_goods_offer array.
 * \param index The index of the consumption_goods_offer to remove.
 */
void remove_consumption_goods_offer(consumption_goods_offer_array * array, int index)
{
	int i;

	/* Free element at index index */
	free_consumption_goods_offer(&(*array).array[index]);

	/* Copy all elements up by one */
	if(index < (*array).size)
	{
		for(i = index; i < (*array).size - 1; i++)
		{
			copy_consumption_goods_offer(&(*array).array[i+1], &(*array).array[i]);
		}
		(*array).size--;
	}
}
/* Functions for the estimators_linear_regression datatype */
/** \fn estimators_linear_regression_array * init_estimators_linear_regression_array()
 * \brief Allocate memory for a dynamic estimators_linear_regression array.
 * \return estimators_linear_regression_array Pointer to the new dynamic estimators_linear_regression array.
 */
void init_estimators_linear_regression_array(estimators_linear_regression_array * array)
{
	(*array).size = 0;
	(*array).total_size = ARRAY_BLOCK_SIZE;
	(*array).array = (estimators_linear_regression *)malloc(ARRAY_BLOCK_SIZE * sizeof(estimators_linear_regression));
	CHECK_POINTER((*array).array);
}

/** \fn void reset_estimators_linear_regression_array(estimators_linear_regression_array* array)
* \brief Reset the estimators_linear_regression array to hold nothing.
* \param array Pointer to the dynamic estimators_linear_regression array.
*/
void reset_estimators_linear_regression_array(estimators_linear_regression_array * array)
{
	(*array).size = 0;
}

/** \fn void free_estimators_linear_regression_array(estimators_linear_regression_array * array)
* \brief Free the memory of a dynamic estimators_linear_regression array.
* \param array Pointer to the dynamic estimators_linear_regression array.
*/
void free_estimators_linear_regression_array(estimators_linear_regression_array * array)
{
	int i;
	
	for(i = 0; i < array->size; i++)
	{
		free_estimators_linear_regression(&(*array).array[i]);
	}
	
	free((*array).array);
}

void copy_estimators_linear_regression_array(estimators_linear_regression_array * from, estimators_linear_regression_array * to)
{
	int i;

	//to = init_estimators_linear_regression_array();

	for(i = 0; i < (*from).size; i++)
	{
		add_estimators_linear_regression(to, (*from).array[i].mall_id, (*from).array[i].region_id, (*from).array[i].intercept, (*from).array[i].regressor, (*from).array[i].variance);
	}
}

/** \fn void add_estimators_linear_regression(estimators_linear_regression_array * array, int mall_id, int region_id, double intercept, double regressor, double variance)
* \brief Add an estimators_linear_regression to the dynamic estimators_linear_regression array.
* \param array Pointer to the dynamic estimators_linear_regression array.
* \param new_int The estimators_linear_regression to add
*/
void add_estimators_linear_regression(estimators_linear_regression_array * array,  int mall_id,  int region_id,  double intercept,  double regressor,  double variance)
{
	if((*array).size == (*array).total_size)
	{
		(*array).total_size = (int)((*array).total_size * ARRAY_GROWTH_RATE);
		(*array).array = (estimators_linear_regression *)realloc((*array).array, ((*array).total_size * sizeof(estimators_linear_regression)));
	}
	init_estimators_linear_regression(&(*array).array[(*array).size]);
	(*array).array[(*array).size].mall_id = mall_id;
	(*array).array[(*array).size].region_id = region_id;
	(*array).array[(*array).size].intercept = intercept;
	(*array).array[(*array).size].regressor = regressor;
	(*array).array[(*array).size].variance = variance;

	(*array).size++;
}

/** \fn void remove_estimators_linear_regression(estimators_linear_regression_array * array, int index)
 * \brief Remove an estimators_linear_regression from a dynamic estimators_linear_regression array.
 * \param array Pointer to the dynamic estimators_linear_regression array.
 * \param index The index of the estimators_linear_regression to remove.
 */
void remove_estimators_linear_regression(estimators_linear_regression_array * array, int index)
{
	int i;

	/* Free element at index index */
	free_estimators_linear_regression(&(*array).array[index]);

	/* Copy all elements up by one */
	if(index < (*array).size)
	{
		for(i = index; i < (*array).size - 1; i++)
		{
			copy_estimators_linear_regression(&(*array).array[i+1], &(*array).array[i]);
		}
		(*array).size--;
	}
}
/* Functions for the consumption_request datatype */
/** \fn consumption_request_array * init_consumption_request_array()
 * \brief Allocate memory for a dynamic consumption_request array.
 * \return consumption_request_array Pointer to the new dynamic consumption_request array.
 */
void init_consumption_request_array(consumption_request_array * array)
{
	(*array).size = 0;
	(*array).total_size = ARRAY_BLOCK_SIZE;
	(*array).array = (consumption_request *)malloc(ARRAY_BLOCK_SIZE * sizeof(consumption_request));
	CHECK_POINTER((*array).array);
}

/** \fn void reset_consumption_request_array(consumption_request_array* array)
* \brief Reset the consumption_request array to hold nothing.
* \param array Pointer to the dynamic consumption_request array.
*/
void reset_consumption_request_array(consumption_request_array * array)
{
	(*array).size = 0;
}

/** \fn void free_consumption_request_array(consumption_request_array * array)
* \brief Free the memory of a dynamic consumption_request array.
* \param array Pointer to the dynamic consumption_request array.
*/
void free_consumption_request_array(consumption_request_array * array)
{
	int i;
	
	for(i = 0; i < array->size; i++)
	{
		free_consumption_request(&(*array).array[i]);
	}
	
	free((*array).array);
}

void copy_consumption_request_array(consumption_request_array * from, consumption_request_array * to)
{
	int i;

	//to = init_consumption_request_array();

	for(i = 0; i < (*from).size; i++)
	{
		add_consumption_request(to, (*from).array[i].worker_id, (*from).array[i].consumer_region_id, (*from).array[i].firm_id, (*from).array[i].quantity);
	}
}

/** \fn void add_consumption_request(consumption_request_array * array, int worker_id, int consumer_region_id, int firm_id, double quantity)
* \brief Add an consumption_request to the dynamic consumption_request array.
* \param array Pointer to the dynamic consumption_request array.
* \param new_int The consumption_request to add
*/
void add_consumption_request(consumption_request_array * array,  int worker_id,  int consumer_region_id,  int firm_id,  double quantity)
{
	if((*array).size == (*array).total_size)
	{
		(*array).total_size = (int)((*array).total_size * ARRAY_GROWTH_RATE);
		(*array).array = (consumption_request *)realloc((*array).array, ((*array).total_size * sizeof(consumption_request)));
	}
	init_consumption_request(&(*array).array[(*array).size]);
	(*array).array[(*array).size].worker_id = worker_id;
	(*array).array[(*array).size].consumer_region_id = consumer_region_id;
	(*array).array[(*array).size].firm_id = firm_id;
	(*array).array[(*array).size].quantity = quantity;

	(*array).size++;
}

/** \fn void remove_consumption_request(consumption_request_array * array, int index)
 * \brief Remove an consumption_request from a dynamic consumption_request array.
 * \param array Pointer to the dynamic consumption_request array.
 * \param index The index of the consumption_request to remove.
 */
void remove_consumption_request(consumption_request_array * array, int index)
{
	int i;

	/* Free element at index index */
	free_consumption_request(&(*array).array[index]);

	/* Copy all elements up by one */
	if(index < (*array).size)
	{
		for(i = index; i < (*array).size - 1; i++)
		{
			copy_consumption_request(&(*array).array[i+1], &(*array).array[i]);
		}
		(*array).size--;
	}
}
/* Functions for the mall_info datatype */
/** \fn mall_info_array * init_mall_info_array()
 * \brief Allocate memory for a dynamic mall_info array.
 * \return mall_info_array Pointer to the new dynamic mall_info array.
 */
void init_mall_info_array(mall_info_array * array)
{
	(*array).size = 0;
	(*array).total_size = ARRAY_BLOCK_SIZE;
	(*array).array = (mall_info *)malloc(ARRAY_BLOCK_SIZE * sizeof(mall_info));
	CHECK_POINTER((*array).array);
}

/** \fn void reset_mall_info_array(mall_info_array* array)
* \brief Reset the mall_info array to hold nothing.
* \param array Pointer to the dynamic mall_info array.
*/
void reset_mall_info_array(mall_info_array * array)
{
	(*array).size = 0;
}

/** \fn void free_mall_info_array(mall_info_array * array)
* \brief Free the memory of a dynamic mall_info array.
* \param array Pointer to the dynamic mall_info array.
*/
void free_mall_info_array(mall_info_array * array)
{
	int i;
	
	for(i = 0; i < array->size; i++)
	{
		free_mall_info(&(*array).array[i]);
	}
	
	free((*array).array);
}

void copy_mall_info_array(mall_info_array * from, mall_info_array * to)
{
	int i;

	//to = init_mall_info_array();

	for(i = 0; i < (*from).size; i++)
	{
		add_mall_info(to, (*from).array[i].mall_id, (*from).array[i].critical_stock, (*from).array[i].current_stock);
	}
}

/** \fn void add_mall_info(mall_info_array * array, int mall_id, double critical_stock, double current_stock)
* \brief Add an mall_info to the dynamic mall_info array.
* \param array Pointer to the dynamic mall_info array.
* \param new_int The mall_info to add
*/
void add_mall_info(mall_info_array * array,  int mall_id,  double critical_stock,  double current_stock)
{
	if((*array).size == (*array).total_size)
	{
		(*array).total_size = (int)((*array).total_size * ARRAY_GROWTH_RATE);
		(*array).array = (mall_info *)realloc((*array).array, ((*array).total_size * sizeof(mall_info)));
	}
	init_mall_info(&(*array).array[(*array).size]);
	(*array).array[(*array).size].mall_id = mall_id;
	(*array).array[(*array).size].critical_stock = critical_stock;
	(*array).array[(*array).size].current_stock = current_stock;

	(*array).size++;
}

/** \fn void remove_mall_info(mall_info_array * array, int index)
 * \brief Remove an mall_info from a dynamic mall_info array.
 * \param array Pointer to the dynamic mall_info array.
 * \param index The index of the mall_info to remove.
 */
void remove_mall_info(mall_info_array * array, int index)
{
	int i;

	/* Free element at index index */
	free_mall_info(&(*array).array[index]);

	/* Copy all elements up by one */
	if(index < (*array).size)
	{
		for(i = index; i < (*array).size - 1; i++)
		{
			copy_mall_info(&(*array).array[i+1], &(*array).array[i]);
		}
		(*array).size--;
	}
}
/* Functions for the mall_quality_price_info datatype */
/** \fn mall_quality_price_info_array * init_mall_quality_price_info_array()
 * \brief Allocate memory for a dynamic mall_quality_price_info array.
 * \return mall_quality_price_info_array Pointer to the new dynamic mall_quality_price_info array.
 */
void init_mall_quality_price_info_array(mall_quality_price_info_array * array)
{
	(*array).size = 0;
	(*array).total_size = ARRAY_BLOCK_SIZE;
	(*array).array = (mall_quality_price_info *)malloc(ARRAY_BLOCK_SIZE * sizeof(mall_quality_price_info));
	CHECK_POINTER((*array).array);
}

/** \fn void reset_mall_quality_price_info_array(mall_quality_price_info_array* array)
* \brief Reset the mall_quality_price_info array to hold nothing.
* \param array Pointer to the dynamic mall_quality_price_info array.
*/
void reset_mall_quality_price_info_array(mall_quality_price_info_array * array)
{
	(*array).size = 0;
}

/** \fn void free_mall_quality_price_info_array(mall_quality_price_info_array * array)
* \brief Free the memory of a dynamic mall_quality_price_info array.
* \param array Pointer to the dynamic mall_quality_price_info array.
*/
void free_mall_quality_price_info_array(mall_quality_price_info_array * array)
{
	int i;
	
	for(i = 0; i < array->size; i++)
	{
		free_mall_quality_price_info(&(*array).array[i]);
	}
	
	free((*array).array);
}

void copy_mall_quality_price_info_array(mall_quality_price_info_array * from, mall_quality_price_info_array * to)
{
	int i;

	//to = init_mall_quality_price_info_array();

	for(i = 0; i < (*from).size; i++)
	{
		add_mall_quality_price_info(to, (*from).array[i].mall_id, (*from).array[i].firm_id, (*from).array[i].mall_region_id, (*from).array[i].quality, (*from).array[i].price, (*from).array[i].available);
	}
}

/** \fn void add_mall_quality_price_info(mall_quality_price_info_array * array, int mall_id, int firm_id, int mall_region_id, double quality, double price, int available)
* \brief Add an mall_quality_price_info to the dynamic mall_quality_price_info array.
* \param array Pointer to the dynamic mall_quality_price_info array.
* \param new_int The mall_quality_price_info to add
*/
void add_mall_quality_price_info(mall_quality_price_info_array * array,  int mall_id,  int firm_id,  int mall_region_id,  double quality,  double price,  int available)
{
	if((*array).size == (*array).total_size)
	{
		(*array).total_size = (int)((*array).total_size * ARRAY_GROWTH_RATE);
		(*array).array = (mall_quality_price_info *)realloc((*array).array, ((*array).total_size * sizeof(mall_quality_price_info)));
	}
	init_mall_quality_price_info(&(*array).array[(*array).size]);
	(*array).array[(*array).size].mall_id = mall_id;
	(*array).array[(*array).size].firm_id = firm_id;
	(*array).array[(*array).size].mall_region_id = mall_region_id;
	(*array).array[(*array).size].quality = quality;
	(*array).array[(*array).size].price = price;
	(*array).array[(*array).size].available = available;

	(*array).size++;
}

/** \fn void remove_mall_quality_price_info(mall_quality_price_info_array * array, int index)
 * \brief Remove an mall_quality_price_info from a dynamic mall_quality_price_info array.
 * \param array Pointer to the dynamic mall_quality_price_info array.
 * \param index The index of the mall_quality_price_info to remove.
 */
void remove_mall_quality_price_info(mall_quality_price_info_array * array, int index)
{
	int i;

	/* Free element at index index */
	free_mall_quality_price_info(&(*array).array[index]);

	/* Copy all elements up by one */
	if(index < (*array).size)
	{
		for(i = index; i < (*array).size - 1; i++)
		{
			copy_mall_quality_price_info(&(*array).array[i+1], &(*array).array[i]);
		}
		(*array).size--;
	}
}
/* Functions for the mall_stock datatype */
/** \fn mall_stock_array * init_mall_stock_array()
 * \brief Allocate memory for a dynamic mall_stock array.
 * \return mall_stock_array Pointer to the new dynamic mall_stock array.
 */
void init_mall_stock_array(mall_stock_array * array)
{
	(*array).size = 0;
	(*array).total_size = ARRAY_BLOCK_SIZE;
	(*array).array = (mall_stock *)malloc(ARRAY_BLOCK_SIZE * sizeof(mall_stock));
	CHECK_POINTER((*array).array);
}

/** \fn void reset_mall_stock_array(mall_stock_array* array)
* \brief Reset the mall_stock array to hold nothing.
* \param array Pointer to the dynamic mall_stock array.
*/
void reset_mall_stock_array(mall_stock_array * array)
{
	(*array).size = 0;
}

/** \fn void free_mall_stock_array(mall_stock_array * array)
* \brief Free the memory of a dynamic mall_stock array.
* \param array Pointer to the dynamic mall_stock array.
*/
void free_mall_stock_array(mall_stock_array * array)
{
	int i;
	
	for(i = 0; i < array->size; i++)
	{
		free_mall_stock(&(*array).array[i]);
	}
	
	free((*array).array);
}

void copy_mall_stock_array(mall_stock_array * from, mall_stock_array * to)
{
	int i;

	//to = init_mall_stock_array();

	for(i = 0; i < (*from).size; i++)
	{
		add_mall_stock(to, (*from).array[i].firm_id, (*from).array[i].region_id, (*from).array[i].stock, (*from).array[i].price, (*from).array[i].quality, (*from).array[i].previous_price);
	}
}

/** \fn void add_mall_stock(mall_stock_array * array, int firm_id, int region_id, double stock, double price, double quality, double previous_price)
* \brief Add an mall_stock to the dynamic mall_stock array.
* \param array Pointer to the dynamic mall_stock array.
* \param new_int The mall_stock to add
*/
void add_mall_stock(mall_stock_array * array,  int firm_id,  int region_id,  double stock,  double price,  double quality,  double previous_price)
{
	if((*array).size == (*array).total_size)
	{
		(*array).total_size = (int)((*array).total_size * ARRAY_GROWTH_RATE);
		(*array).array = (mall_stock *)realloc((*array).array, ((*array).total_size * sizeof(mall_stock)));
	}
	init_mall_stock(&(*array).array[(*array).size]);
	(*array).array[(*array).size].firm_id = firm_id;
	(*array).array[(*array).size].region_id = region_id;
	(*array).array[(*array).size].stock = stock;
	(*array).array[(*array).size].price = price;
	(*array).array[(*array).size].quality = quality;
	(*array).array[(*array).size].previous_price = previous_price;

	(*array).size++;
}

/** \fn void remove_mall_stock(mall_stock_array * array, int index)
 * \brief Remove an mall_stock from a dynamic mall_stock array.
 * \param array Pointer to the dynamic mall_stock array.
 * \param index The index of the mall_stock to remove.
 */
void remove_mall_stock(mall_stock_array * array, int index)
{
	int i;

	/* Free element at index index */
	free_mall_stock(&(*array).array[index]);

	/* Copy all elements up by one */
	if(index < (*array).size)
	{
		for(i = index; i < (*array).size - 1; i++)
		{
			copy_mall_stock(&(*array).array[i+1], &(*array).array[i]);
		}
		(*array).size--;
	}
}
/* Functions for the delivery_volume_per_mall datatype */
/** \fn delivery_volume_per_mall_array * init_delivery_volume_per_mall_array()
 * \brief Allocate memory for a dynamic delivery_volume_per_mall array.
 * \return delivery_volume_per_mall_array Pointer to the new dynamic delivery_volume_per_mall array.
 */
void init_delivery_volume_per_mall_array(delivery_volume_per_mall_array * array)
{
	(*array).size = 0;
	(*array).total_size = ARRAY_BLOCK_SIZE;
	(*array).array = (delivery_volume_per_mall *)malloc(ARRAY_BLOCK_SIZE * sizeof(delivery_volume_per_mall));
	CHECK_POINTER((*array).array);
}

/** \fn void reset_delivery_volume_per_mall_array(delivery_volume_per_mall_array* array)
* \brief Reset the delivery_volume_per_mall array to hold nothing.
* \param array Pointer to the dynamic delivery_volume_per_mall array.
*/
void reset_delivery_volume_per_mall_array(delivery_volume_per_mall_array * array)
{
	(*array).size = 0;
}

/** \fn void free_delivery_volume_per_mall_array(delivery_volume_per_mall_array * array)
* \brief Free the memory of a dynamic delivery_volume_per_mall array.
* \param array Pointer to the dynamic delivery_volume_per_mall array.
*/
void free_delivery_volume_per_mall_array(delivery_volume_per_mall_array * array)
{
	int i;
	
	for(i = 0; i < array->size; i++)
	{
		free_delivery_volume_per_mall(&(*array).array[i]);
	}
	
	free((*array).array);
}

void copy_delivery_volume_per_mall_array(delivery_volume_per_mall_array * from, delivery_volume_per_mall_array * to)
{
	int i;

	//to = init_delivery_volume_per_mall_array();

	for(i = 0; i < (*from).size; i++)
	{
		add_delivery_volume_per_mall(to, (*from).array[i].mall_id, (*from).array[i].quantity, (*from).array[i].price, (*from).array[i].quality);
	}
}

/** \fn void add_delivery_volume_per_mall(delivery_volume_per_mall_array * array, int mall_id, double quantity, double price, double quality)
* \brief Add an delivery_volume_per_mall to the dynamic delivery_volume_per_mall array.
* \param array Pointer to the dynamic delivery_volume_per_mall array.
* \param new_int The delivery_volume_per_mall to add
*/
void add_delivery_volume_per_mall(delivery_volume_per_mall_array * array,  int mall_id,  double quantity,  double price,  double quality)
{
	if((*array).size == (*array).total_size)
	{
		(*array).total_size = (int)((*array).total_size * ARRAY_GROWTH_RATE);
		(*array).array = (delivery_volume_per_mall *)realloc((*array).array, ((*array).total_size * sizeof(delivery_volume_per_mall)));
	}
	init_delivery_volume_per_mall(&(*array).array[(*array).size]);
	(*array).array[(*array).size].mall_id = mall_id;
	(*array).array[(*array).size].quantity = quantity;
	(*array).array[(*array).size].price = price;
	(*array).array[(*array).size].quality = quality;

	(*array).size++;
}

/** \fn void remove_delivery_volume_per_mall(delivery_volume_per_mall_array * array, int index)
 * \brief Remove an delivery_volume_per_mall from a dynamic delivery_volume_per_mall array.
 * \param array Pointer to the dynamic delivery_volume_per_mall array.
 * \param index The index of the delivery_volume_per_mall to remove.
 */
void remove_delivery_volume_per_mall(delivery_volume_per_mall_array * array, int index)
{
	int i;

	/* Free element at index index */
	free_delivery_volume_per_mall(&(*array).array[index]);

	/* Copy all elements up by one */
	if(index < (*array).size)
	{
		for(i = index; i < (*array).size - 1; i++)
		{
			copy_delivery_volume_per_mall(&(*array).array[i+1], &(*array).array[i]);
		}
		(*array).size--;
	}
}
/* Functions for the logit_firm_id datatype */
/** \fn logit_firm_id_array * init_logit_firm_id_array()
 * \brief Allocate memory for a dynamic logit_firm_id array.
 * \return logit_firm_id_array Pointer to the new dynamic logit_firm_id array.
 */
void init_logit_firm_id_array(logit_firm_id_array * array)
{
	(*array).size = 0;
	(*array).total_size = ARRAY_BLOCK_SIZE;
	(*array).array = (logit_firm_id *)malloc(ARRAY_BLOCK_SIZE * sizeof(logit_firm_id));
	CHECK_POINTER((*array).array);
}

/** \fn void reset_logit_firm_id_array(logit_firm_id_array* array)
* \brief Reset the logit_firm_id array to hold nothing.
* \param array Pointer to the dynamic logit_firm_id array.
*/
void reset_logit_firm_id_array(logit_firm_id_array * array)
{
	(*array).size = 0;
}

/** \fn void free_logit_firm_id_array(logit_firm_id_array * array)
* \brief Free the memory of a dynamic logit_firm_id array.
* \param array Pointer to the dynamic logit_firm_id array.
*/
void free_logit_firm_id_array(logit_firm_id_array * array)
{
	int i;
	
	for(i = 0; i < array->size; i++)
	{
		free_logit_firm_id(&(*array).array[i]);
	}
	
	free((*array).array);
}

void copy_logit_firm_id_array(logit_firm_id_array * from, logit_firm_id_array * to)
{
	int i;

	//to = init_logit_firm_id_array();

	for(i = 0; i < (*from).size; i++)
	{
		add_logit_firm_id(to, (*from).array[i].logit, (*from).array[i].firm_id);
	}
}

/** \fn void add_logit_firm_id(logit_firm_id_array * array, double logit, int firm_id)
* \brief Add an logit_firm_id to the dynamic logit_firm_id array.
* \param array Pointer to the dynamic logit_firm_id array.
* \param new_int The logit_firm_id to add
*/
void add_logit_firm_id(logit_firm_id_array * array,  double logit,  int firm_id)
{
	if((*array).size == (*array).total_size)
	{
		(*array).total_size = (int)((*array).total_size * ARRAY_GROWTH_RATE);
		(*array).array = (logit_firm_id *)realloc((*array).array, ((*array).total_size * sizeof(logit_firm_id)));
	}
	init_logit_firm_id(&(*array).array[(*array).size]);
	(*array).array[(*array).size].logit = logit;
	(*array).array[(*array).size].firm_id = firm_id;

	(*array).size++;
}

/** \fn void remove_logit_firm_id(logit_firm_id_array * array, int index)
 * \brief Remove an logit_firm_id from a dynamic logit_firm_id array.
 * \param array Pointer to the dynamic logit_firm_id array.
 * \param index The index of the logit_firm_id to remove.
 */
void remove_logit_firm_id(logit_firm_id_array * array, int index)
{
	int i;

	/* Free element at index index */
	free_logit_firm_id(&(*array).array[index]);

	/* Copy all elements up by one */
	if(index < (*array).size)
	{
		for(i = index; i < (*array).size - 1; i++)
		{
			copy_logit_firm_id(&(*array).array[i+1], &(*array).array[i]);
		}
		(*array).size--;
	}
}
/* Functions for the sales_in_mall datatype */
/** \fn sales_in_mall_array * init_sales_in_mall_array()
 * \brief Allocate memory for a dynamic sales_in_mall array.
 * \return sales_in_mall_array Pointer to the new dynamic sales_in_mall array.
 */
void init_sales_in_mall_array(sales_in_mall_array * array)
{
	(*array).size = 0;
	(*array).total_size = ARRAY_BLOCK_SIZE;
	(*array).array = (sales_in_mall *)malloc(ARRAY_BLOCK_SIZE * sizeof(sales_in_mall));
	CHECK_POINTER((*array).array);
}

/** \fn void reset_sales_in_mall_array(sales_in_mall_array* array)
* \brief Reset the sales_in_mall array to hold nothing.
* \param array Pointer to the dynamic sales_in_mall array.
*/
void reset_sales_in_mall_array(sales_in_mall_array * array)
{
	(*array).size = 0;
}

/** \fn void free_sales_in_mall_array(sales_in_mall_array * array)
* \brief Free the memory of a dynamic sales_in_mall array.
* \param array Pointer to the dynamic sales_in_mall array.
*/
void free_sales_in_mall_array(sales_in_mall_array * array)
{
	int i;
	
	for(i = 0; i < array->size; i++)
	{
		free_sales_in_mall(&(*array).array[i]);
	}
	
	free((*array).array);
}

void copy_sales_in_mall_array(sales_in_mall_array * from, sales_in_mall_array * to)
{
	int i;

	//to = init_sales_in_mall_array();

	for(i = 0; i < (*from).size; i++)
	{
		add_sales_in_mall(to, (*from).array[i].firm_id, (*from).array[i].sales);
	}
}

/** \fn void add_sales_in_mall(sales_in_mall_array * array, int firm_id, double sales)
* \brief Add an sales_in_mall to the dynamic sales_in_mall array.
* \param array Pointer to the dynamic sales_in_mall array.
* \param new_int The sales_in_mall to add
*/
void add_sales_in_mall(sales_in_mall_array * array,  int firm_id,  double sales)
{
	if((*array).size == (*array).total_size)
	{
		(*array).total_size = (int)((*array).total_size * ARRAY_GROWTH_RATE);
		(*array).array = (sales_in_mall *)realloc((*array).array, ((*array).total_size * sizeof(sales_in_mall)));
	}
	init_sales_in_mall(&(*array).array[(*array).size]);
	(*array).array[(*array).size].firm_id = firm_id;
	(*array).array[(*array).size].sales = sales;

	(*array).size++;
}

/** \fn void remove_sales_in_mall(sales_in_mall_array * array, int index)
 * \brief Remove an sales_in_mall from a dynamic sales_in_mall array.
 * \param array Pointer to the dynamic sales_in_mall array.
 * \param index The index of the sales_in_mall to remove.
 */
void remove_sales_in_mall(sales_in_mall_array * array, int index)
{
	int i;

	/* Free element at index index */
	free_sales_in_mall(&(*array).array[index]);

	/* Copy all elements up by one */
	if(index < (*array).size)
	{
		for(i = index; i < (*array).size - 1; i++)
		{
			copy_sales_in_mall(&(*array).array[i+1], &(*array).array[i]);
		}
		(*array).size--;
	}
}
/* Functions for the ordered_quantity datatype */
/** \fn ordered_quantity_array * init_ordered_quantity_array()
 * \brief Allocate memory for a dynamic ordered_quantity array.
 * \return ordered_quantity_array Pointer to the new dynamic ordered_quantity array.
 */
void init_ordered_quantity_array(ordered_quantity_array * array)
{
	(*array).size = 0;
	(*array).total_size = ARRAY_BLOCK_SIZE;
	(*array).array = (ordered_quantity *)malloc(ARRAY_BLOCK_SIZE * sizeof(ordered_quantity));
	CHECK_POINTER((*array).array);
}

/** \fn void reset_ordered_quantity_array(ordered_quantity_array* array)
* \brief Reset the ordered_quantity array to hold nothing.
* \param array Pointer to the dynamic ordered_quantity array.
*/
void reset_ordered_quantity_array(ordered_quantity_array * array)
{
	(*array).size = 0;
}

/** \fn void free_ordered_quantity_array(ordered_quantity_array * array)
* \brief Free the memory of a dynamic ordered_quantity array.
* \param array Pointer to the dynamic ordered_quantity array.
*/
void free_ordered_quantity_array(ordered_quantity_array * array)
{
	int i;
	
	for(i = 0; i < array->size; i++)
	{
		free_ordered_quantity(&(*array).array[i]);
	}
	
	free((*array).array);
}

void copy_ordered_quantity_array(ordered_quantity_array * from, ordered_quantity_array * to)
{
	int i;

	//to = init_ordered_quantity_array();

	for(i = 0; i < (*from).size; i++)
	{
		add_ordered_quantity(to, (*from).array[i].firm_id, (*from).array[i].quantity, (*from).array[i].price, (*from).array[i].quality);
	}
}

/** \fn void add_ordered_quantity(ordered_quantity_array * array, int firm_id, double quantity, double price, double quality)
* \brief Add an ordered_quantity to the dynamic ordered_quantity array.
* \param array Pointer to the dynamic ordered_quantity array.
* \param new_int The ordered_quantity to add
*/
void add_ordered_quantity(ordered_quantity_array * array,  int firm_id,  double quantity,  double price,  double quality)
{
	if((*array).size == (*array).total_size)
	{
		(*array).total_size = (int)((*array).total_size * ARRAY_GROWTH_RATE);
		(*array).array = (ordered_quantity *)realloc((*array).array, ((*array).total_size * sizeof(ordered_quantity)));
	}
	init_ordered_quantity(&(*array).array[(*array).size]);
	(*array).array[(*array).size].firm_id = firm_id;
	(*array).array[(*array).size].quantity = quantity;
	(*array).array[(*array).size].price = price;
	(*array).array[(*array).size].quality = quality;

	(*array).size++;
}

/** \fn void remove_ordered_quantity(ordered_quantity_array * array, int index)
 * \brief Remove an ordered_quantity from a dynamic ordered_quantity array.
 * \param array Pointer to the dynamic ordered_quantity array.
 * \param index The index of the ordered_quantity to remove.
 */
void remove_ordered_quantity(ordered_quantity_array * array, int index)
{
	int i;

	/* Free element at index index */
	free_ordered_quantity(&(*array).array[index]);

	/* Copy all elements up by one */
	if(index < (*array).size)
	{
		for(i = index; i < (*array).size - 1; i++)
		{
			copy_ordered_quantity(&(*array).array[i+1], &(*array).array[i]);
		}
		(*array).size--;
	}
}
/* Functions for the received_quantities datatype */
/** \fn received_quantities_array * init_received_quantities_array()
 * \brief Allocate memory for a dynamic received_quantities array.
 * \return received_quantities_array Pointer to the new dynamic received_quantities array.
 */
void init_received_quantities_array(received_quantities_array * array)
{
	(*array).size = 0;
	(*array).total_size = ARRAY_BLOCK_SIZE;
	(*array).array = (received_quantities *)malloc(ARRAY_BLOCK_SIZE * sizeof(received_quantities));
	CHECK_POINTER((*array).array);
}

/** \fn void reset_received_quantities_array(received_quantities_array* array)
* \brief Reset the received_quantities array to hold nothing.
* \param array Pointer to the dynamic received_quantities array.
*/
void reset_received_quantities_array(received_quantities_array * array)
{
	(*array).size = 0;
}

/** \fn void free_received_quantities_array(received_quantities_array * array)
* \brief Free the memory of a dynamic received_quantities array.
* \param array Pointer to the dynamic received_quantities array.
*/
void free_received_quantities_array(received_quantities_array * array)
{
	int i;
	
	for(i = 0; i < array->size; i++)
	{
		free_received_quantities(&(*array).array[i]);
	}
	
	free((*array).array);
}

void copy_received_quantities_array(received_quantities_array * from, received_quantities_array * to)
{
	int i;

	//to = init_received_quantities_array();

	for(i = 0; i < (*from).size; i++)
	{
		add_received_quantities(to, (*from).array[i].firm_id, (*from).array[i].quantity);
	}
}

/** \fn void add_received_quantities(received_quantities_array * array, int firm_id, double quantity)
* \brief Add an received_quantities to the dynamic received_quantities array.
* \param array Pointer to the dynamic received_quantities array.
* \param new_int The received_quantities to add
*/
void add_received_quantities(received_quantities_array * array,  int firm_id,  double quantity)
{
	if((*array).size == (*array).total_size)
	{
		(*array).total_size = (int)((*array).total_size * ARRAY_GROWTH_RATE);
		(*array).array = (received_quantities *)realloc((*array).array, ((*array).total_size * sizeof(received_quantities)));
	}
	init_received_quantities(&(*array).array[(*array).size]);
	(*array).array[(*array).size].firm_id = firm_id;
	(*array).array[(*array).size].quantity = quantity;

	(*array).size++;
}

/** \fn void remove_received_quantities(received_quantities_array * array, int index)
 * \brief Remove an received_quantities from a dynamic received_quantities array.
 * \param array Pointer to the dynamic received_quantities array.
 * \param index The index of the received_quantities to remove.
 */
void remove_received_quantities(received_quantities_array * array, int index)
{
	int i;

	/* Free element at index index */
	free_received_quantities(&(*array).array[index]);

	/* Copy all elements up by one */
	if(index < (*array).size)
	{
		for(i = index; i < (*array).size - 1; i++)
		{
			copy_received_quantities(&(*array).array[i+1], &(*array).array[i]);
		}
		(*array).size--;
	}
}
/* Functions for the sold_quantities_per_mall datatype */
/** \fn sold_quantities_per_mall_array * init_sold_quantities_per_mall_array()
 * \brief Allocate memory for a dynamic sold_quantities_per_mall array.
 * \return sold_quantities_per_mall_array Pointer to the new dynamic sold_quantities_per_mall array.
 */
void init_sold_quantities_per_mall_array(sold_quantities_per_mall_array * array)
{
	(*array).size = 0;
	(*array).total_size = ARRAY_BLOCK_SIZE;
	(*array).array = (sold_quantities_per_mall *)malloc(ARRAY_BLOCK_SIZE * sizeof(sold_quantities_per_mall));
	CHECK_POINTER((*array).array);
}

/** \fn void reset_sold_quantities_per_mall_array(sold_quantities_per_mall_array* array)
* \brief Reset the sold_quantities_per_mall array to hold nothing.
* \param array Pointer to the dynamic sold_quantities_per_mall array.
*/
void reset_sold_quantities_per_mall_array(sold_quantities_per_mall_array * array)
{
	(*array).size = 0;
}

/** \fn void free_sold_quantities_per_mall_array(sold_quantities_per_mall_array * array)
* \brief Free the memory of a dynamic sold_quantities_per_mall array.
* \param array Pointer to the dynamic sold_quantities_per_mall array.
*/
void free_sold_quantities_per_mall_array(sold_quantities_per_mall_array * array)
{
	int i;
	
	for(i = 0; i < array->size; i++)
	{
		free_sold_quantities_per_mall(&(*array).array[i]);
	}
	
	free((*array).array);
}

void copy_sold_quantities_per_mall_array(sold_quantities_per_mall_array * from, sold_quantities_per_mall_array * to)
{
	int i;

	//to = init_sold_quantities_per_mall_array();

	for(i = 0; i < (*from).size; i++)
	{
		add_sold_quantities_per_mall(to, (*from).array[i].mall_id, (*from).array[i].sold_quantity, (*from).array[i].stock_empty, (*from).array[i].estimated_demand);
	}
}

/** \fn void add_sold_quantities_per_mall(sold_quantities_per_mall_array * array, int mall_id, double sold_quantity, int stock_empty, double estimated_demand)
* \brief Add an sold_quantities_per_mall to the dynamic sold_quantities_per_mall array.
* \param array Pointer to the dynamic sold_quantities_per_mall array.
* \param new_int The sold_quantities_per_mall to add
*/
void add_sold_quantities_per_mall(sold_quantities_per_mall_array * array,  int mall_id,  double sold_quantity,  int stock_empty,  double estimated_demand)
{
	if((*array).size == (*array).total_size)
	{
		(*array).total_size = (int)((*array).total_size * ARRAY_GROWTH_RATE);
		(*array).array = (sold_quantities_per_mall *)realloc((*array).array, ((*array).total_size * sizeof(sold_quantities_per_mall)));
	}
	init_sold_quantities_per_mall(&(*array).array[(*array).size]);
	(*array).array[(*array).size].mall_id = mall_id;
	(*array).array[(*array).size].sold_quantity = sold_quantity;
	(*array).array[(*array).size].stock_empty = stock_empty;
	(*array).array[(*array).size].estimated_demand = estimated_demand;

	(*array).size++;
}

/** \fn void remove_sold_quantities_per_mall(sold_quantities_per_mall_array * array, int index)
 * \brief Remove an sold_quantities_per_mall from a dynamic sold_quantities_per_mall array.
 * \param array Pointer to the dynamic sold_quantities_per_mall array.
 * \param index The index of the sold_quantities_per_mall to remove.
 */
void remove_sold_quantities_per_mall(sold_quantities_per_mall_array * array, int index)
{
	int i;

	/* Free element at index index */
	free_sold_quantities_per_mall(&(*array).array[index]);

	/* Copy all elements up by one */
	if(index < (*array).size)
	{
		for(i = index; i < (*array).size - 1; i++)
		{
			copy_sold_quantities_per_mall(&(*array).array[i+1], &(*array).array[i]);
		}
		(*array).size--;
	}
}
/* Functions for the data_type_sales datatype */
/** \fn data_type_sales_array * init_data_type_sales_array()
 * \brief Allocate memory for a dynamic data_type_sales array.
 * \return data_type_sales_array Pointer to the new dynamic data_type_sales array.
 */
void init_data_type_sales_array(data_type_sales_array * array)
{
	(*array).size = 0;
	(*array).total_size = ARRAY_BLOCK_SIZE;
	(*array).array = (data_type_sales *)malloc(ARRAY_BLOCK_SIZE * sizeof(data_type_sales));
	CHECK_POINTER((*array).array);
}

/** \fn void reset_data_type_sales_array(data_type_sales_array* array)
* \brief Reset the data_type_sales array to hold nothing.
* \param array Pointer to the dynamic data_type_sales array.
*/
void reset_data_type_sales_array(data_type_sales_array * array)
{
	(*array).size = 0;
}

/** \fn void free_data_type_sales_array(data_type_sales_array * array)
* \brief Free the memory of a dynamic data_type_sales array.
* \param array Pointer to the dynamic data_type_sales array.
*/
void free_data_type_sales_array(data_type_sales_array * array)
{
	int i;
	
	for(i = 0; i < array->size; i++)
	{
		free_data_type_sales(&(*array).array[i]);
	}
	
	free((*array).array);
}

void copy_data_type_sales_array(data_type_sales_array * from, data_type_sales_array * to)
{
	int i;

	//to = init_data_type_sales_array();

	for(i = 0; i < (*from).size; i++)
	{
		add_data_type_sales(to, (*from).array[i].period, (*from).array[i].sales);
	}
}

/** \fn void add_data_type_sales(data_type_sales_array * array, int period, double sales)
* \brief Add an data_type_sales to the dynamic data_type_sales array.
* \param array Pointer to the dynamic data_type_sales array.
* \param new_int The data_type_sales to add
*/
void add_data_type_sales(data_type_sales_array * array,  int period,  double sales)
{
	if((*array).size == (*array).total_size)
	{
		(*array).total_size = (int)((*array).total_size * ARRAY_GROWTH_RATE);
		(*array).array = (data_type_sales *)realloc((*array).array, ((*array).total_size * sizeof(data_type_sales)));
	}
	init_data_type_sales(&(*array).array[(*array).size]);
	(*array).array[(*array).size].period = period;
	(*array).array[(*array).size].sales = sales;

	(*array).size++;
}

/** \fn void remove_data_type_sales(data_type_sales_array * array, int index)
 * \brief Remove an data_type_sales from a dynamic data_type_sales array.
 * \param array Pointer to the dynamic data_type_sales array.
 * \param index The index of the data_type_sales to remove.
 */
void remove_data_type_sales(data_type_sales_array * array, int index)
{
	int i;

	/* Free element at index index */
	free_data_type_sales(&(*array).array[index]);

	/* Copy all elements up by one */
	if(index < (*array).size)
	{
		for(i = index; i < (*array).size - 1; i++)
		{
			copy_data_type_sales(&(*array).array[i+1], &(*array).array[i]);
		}
		(*array).size--;
	}
}
/* Functions for the sales_statistics datatype */
/** \fn sales_statistics_array * init_sales_statistics_array()
 * \brief Allocate memory for a dynamic sales_statistics array.
 * \return sales_statistics_array Pointer to the new dynamic sales_statistics array.
 */
void init_sales_statistics_array(sales_statistics_array * array)
{
	(*array).size = 0;
	(*array).total_size = ARRAY_BLOCK_SIZE;
	(*array).array = (sales_statistics *)malloc(ARRAY_BLOCK_SIZE * sizeof(sales_statistics));
	CHECK_POINTER((*array).array);
}

/** \fn void reset_sales_statistics_array(sales_statistics_array* array)
* \brief Reset the sales_statistics array to hold nothing.
* \param array Pointer to the dynamic sales_statistics array.
*/
void reset_sales_statistics_array(sales_statistics_array * array)
{
	(*array).size = 0;
}

/** \fn void free_sales_statistics_array(sales_statistics_array * array)
* \brief Free the memory of a dynamic sales_statistics array.
* \param array Pointer to the dynamic sales_statistics array.
*/
void free_sales_statistics_array(sales_statistics_array * array)
{
	int i;
	
	for(i = 0; i < array->size; i++)
	{
		free_sales_statistics(&(*array).array[i]);
	}
	
	free((*array).array);
}

void copy_sales_statistics_array(sales_statistics_array * from, sales_statistics_array * to)
{
	int i;

	//to = init_sales_statistics_array();

	for(i = 0; i < (*from).size; i++)
	{
		add_sales_statistics(to, (*from).array[i].mall_id, (*from).array[i].region_id, &(*from).array[i].sales);
	}
}

/** \fn void add_sales_statistics(sales_statistics_array * array, int mall_id, int region_id, data_type_sales_array * sales)
* \brief Add an sales_statistics to the dynamic sales_statistics array.
* \param array Pointer to the dynamic sales_statistics array.
* \param new_int The sales_statistics to add
*/
void add_sales_statistics(sales_statistics_array * array,  int mall_id,  int region_id, /*@out@*/ data_type_sales_array * sales)
{
	if((*array).size == (*array).total_size)
	{
		(*array).total_size = (int)((*array).total_size * ARRAY_GROWTH_RATE);
		(*array).array = (sales_statistics *)realloc((*array).array, ((*array).total_size * sizeof(sales_statistics)));
	}
	init_sales_statistics(&(*array).array[(*array).size]);
	(*array).array[(*array).size].mall_id = mall_id;
	(*array).array[(*array).size].region_id = region_id;
	if(sales != NULL) copy_data_type_sales_array(sales, &(*array).array[(*array).size].sales);

	(*array).size++;
}

/** \fn void remove_sales_statistics(sales_statistics_array * array, int index)
 * \brief Remove an sales_statistics from a dynamic sales_statistics array.
 * \param array Pointer to the dynamic sales_statistics array.
 * \param index The index of the sales_statistics to remove.
 */
void remove_sales_statistics(sales_statistics_array * array, int index)
{
	int i;

	/* Free element at index index */
	free_sales_statistics(&(*array).array[index]);

	/* Copy all elements up by one */
	if(index < (*array).size)
	{
		for(i = index; i < (*array).size - 1; i++)
		{
			copy_sales_statistics(&(*array).array[i+1], &(*array).array[i]);
		}
		(*array).size--;
	}
}
/* Functions for the adt_technology_vintages datatype */
/** \fn adt_technology_vintages_array * init_adt_technology_vintages_array()
 * \brief Allocate memory for a dynamic adt_technology_vintages array.
 * \return adt_technology_vintages_array Pointer to the new dynamic adt_technology_vintages array.
 */
void init_adt_technology_vintages_array(adt_technology_vintages_array * array)
{
	(*array).size = 0;
	(*array).total_size = ARRAY_BLOCK_SIZE;
	(*array).array = (adt_technology_vintages *)malloc(ARRAY_BLOCK_SIZE * sizeof(adt_technology_vintages));
	CHECK_POINTER((*array).array);
}

/** \fn void reset_adt_technology_vintages_array(adt_technology_vintages_array* array)
* \brief Reset the adt_technology_vintages array to hold nothing.
* \param array Pointer to the dynamic adt_technology_vintages array.
*/
void reset_adt_technology_vintages_array(adt_technology_vintages_array * array)
{
	(*array).size = 0;
}

/** \fn void free_adt_technology_vintages_array(adt_technology_vintages_array * array)
* \brief Free the memory of a dynamic adt_technology_vintages array.
* \param array Pointer to the dynamic adt_technology_vintages array.
*/
void free_adt_technology_vintages_array(adt_technology_vintages_array * array)
{
	int i;
	
	for(i = 0; i < array->size; i++)
	{
		free_adt_technology_vintages(&(*array).array[i]);
	}
	
	free((*array).array);
}

void copy_adt_technology_vintages_array(adt_technology_vintages_array * from, adt_technology_vintages_array * to)
{
	int i;

	//to = init_adt_technology_vintages_array();

	for(i = 0; i < (*from).size; i++)
	{
		add_adt_technology_vintages(to, (*from).array[i].productivity, (*from).array[i].price, (*from).array[i].sum_effective_productivities);
	}
}

/** \fn void add_adt_technology_vintages(adt_technology_vintages_array * array, double productivity, double price, double sum_effective_productivities)
* \brief Add an adt_technology_vintages to the dynamic adt_technology_vintages array.
* \param array Pointer to the dynamic adt_technology_vintages array.
* \param new_int The adt_technology_vintages to add
*/
void add_adt_technology_vintages(adt_technology_vintages_array * array,  double productivity,  double price,  double sum_effective_productivities)
{
	if((*array).size == (*array).total_size)
	{
		(*array).total_size = (int)((*array).total_size * ARRAY_GROWTH_RATE);
		(*array).array = (adt_technology_vintages *)realloc((*array).array, ((*array).total_size * sizeof(adt_technology_vintages)));
	}
	init_adt_technology_vintages(&(*array).array[(*array).size]);
	(*array).array[(*array).size].productivity = productivity;
	(*array).array[(*array).size].price = price;
	(*array).array[(*array).size].sum_effective_productivities = sum_effective_productivities;

	(*array).size++;
}

/** \fn void remove_adt_technology_vintages(adt_technology_vintages_array * array, int index)
 * \brief Remove an adt_technology_vintages from a dynamic adt_technology_vintages array.
 * \param array Pointer to the dynamic adt_technology_vintages array.
 * \param index The index of the adt_technology_vintages to remove.
 */
void remove_adt_technology_vintages(adt_technology_vintages_array * array, int index)
{
	int i;

	/* Free element at index index */
	free_adt_technology_vintages(&(*array).array[index]);

	/* Copy all elements up by one */
	if(index < (*array).size)
	{
		for(i = index; i < (*array).size - 1; i++)
		{
			copy_adt_technology_vintages(&(*array).array[i+1], &(*array).array[i]);
		}
		(*array).size--;
	}
}
/* Functions for the adt_capital_stock_vintages datatype */
/** \fn adt_capital_stock_vintages_array * init_adt_capital_stock_vintages_array()
 * \brief Allocate memory for a dynamic adt_capital_stock_vintages array.
 * \return adt_capital_stock_vintages_array Pointer to the new dynamic adt_capital_stock_vintages array.
 */
void init_adt_capital_stock_vintages_array(adt_capital_stock_vintages_array * array)
{
	(*array).size = 0;
	(*array).total_size = ARRAY_BLOCK_SIZE;
	(*array).array = (adt_capital_stock_vintages *)malloc(ARRAY_BLOCK_SIZE * sizeof(adt_capital_stock_vintages));
	CHECK_POINTER((*array).array);
}

/** \fn void reset_adt_capital_stock_vintages_array(adt_capital_stock_vintages_array* array)
* \brief Reset the adt_capital_stock_vintages array to hold nothing.
* \param array Pointer to the dynamic adt_capital_stock_vintages array.
*/
void reset_adt_capital_stock_vintages_array(adt_capital_stock_vintages_array * array)
{
	(*array).size = 0;
}

/** \fn void free_adt_capital_stock_vintages_array(adt_capital_stock_vintages_array * array)
* \brief Free the memory of a dynamic adt_capital_stock_vintages array.
* \param array Pointer to the dynamic adt_capital_stock_vintages array.
*/
void free_adt_capital_stock_vintages_array(adt_capital_stock_vintages_array * array)
{
	int i;
	
	for(i = 0; i < array->size; i++)
	{
		free_adt_capital_stock_vintages(&(*array).array[i]);
	}
	
	free((*array).array);
}

void copy_adt_capital_stock_vintages_array(adt_capital_stock_vintages_array * from, adt_capital_stock_vintages_array * to)
{
	int i;

	//to = init_adt_capital_stock_vintages_array();

	for(i = 0; i < (*from).size; i++)
	{
		add_adt_capital_stock_vintages(to, (*from).array[i].amount, (*from).array[i].productivity);
	}
}

/** \fn void add_adt_capital_stock_vintages(adt_capital_stock_vintages_array * array, double amount, double productivity)
* \brief Add an adt_capital_stock_vintages to the dynamic adt_capital_stock_vintages array.
* \param array Pointer to the dynamic adt_capital_stock_vintages array.
* \param new_int The adt_capital_stock_vintages to add
*/
void add_adt_capital_stock_vintages(adt_capital_stock_vintages_array * array,  double amount,  double productivity)
{
	if((*array).size == (*array).total_size)
	{
		(*array).total_size = (int)((*array).total_size * ARRAY_GROWTH_RATE);
		(*array).array = (adt_capital_stock_vintages *)realloc((*array).array, ((*array).total_size * sizeof(adt_capital_stock_vintages)));
	}
	init_adt_capital_stock_vintages(&(*array).array[(*array).size]);
	(*array).array[(*array).size].amount = amount;
	(*array).array[(*array).size].productivity = productivity;

	(*array).size++;
}

/** \fn void remove_adt_capital_stock_vintages(adt_capital_stock_vintages_array * array, int index)
 * \brief Remove an adt_capital_stock_vintages from a dynamic adt_capital_stock_vintages array.
 * \param array Pointer to the dynamic adt_capital_stock_vintages array.
 * \param index The index of the adt_capital_stock_vintages to remove.
 */
void remove_adt_capital_stock_vintages(adt_capital_stock_vintages_array * array, int index)
{
	int i;

	/* Free element at index index */
	free_adt_capital_stock_vintages(&(*array).array[index]);

	/* Copy all elements up by one */
	if(index < (*array).size)
	{
		for(i = index; i < (*array).size - 1; i++)
		{
			copy_adt_capital_stock_vintages(&(*array).array[i+1], &(*array).array[i]);
		}
		(*array).size--;
	}
}
/* Functions for the financing_capital datatype */
/** \fn financing_capital_array * init_financing_capital_array()
 * \brief Allocate memory for a dynamic financing_capital array.
 * \return financing_capital_array Pointer to the new dynamic financing_capital array.
 */
void init_financing_capital_array(financing_capital_array * array)
{
	(*array).size = 0;
	(*array).total_size = ARRAY_BLOCK_SIZE;
	(*array).array = (financing_capital *)malloc(ARRAY_BLOCK_SIZE * sizeof(financing_capital));
	CHECK_POINTER((*array).array);
}

/** \fn void reset_financing_capital_array(financing_capital_array* array)
* \brief Reset the financing_capital array to hold nothing.
* \param array Pointer to the dynamic financing_capital array.
*/
void reset_financing_capital_array(financing_capital_array * array)
{
	(*array).size = 0;
}

/** \fn void free_financing_capital_array(financing_capital_array * array)
* \brief Free the memory of a dynamic financing_capital array.
* \param array Pointer to the dynamic financing_capital array.
*/
void free_financing_capital_array(financing_capital_array * array)
{
	int i;
	
	for(i = 0; i < array->size; i++)
	{
		free_financing_capital(&(*array).array[i]);
	}
	
	free((*array).array);
}

void copy_financing_capital_array(financing_capital_array * from, financing_capital_array * to)
{
	int i;

	//to = init_financing_capital_array();

	for(i = 0; i < (*from).size; i++)
	{
		add_financing_capital(to, (*from).array[i].financing_per_month, (*from).array[i].nr_periods_before_repayment);
	}
}

/** \fn void add_financing_capital(financing_capital_array * array, double financing_per_month, int nr_periods_before_repayment)
* \brief Add an financing_capital to the dynamic financing_capital array.
* \param array Pointer to the dynamic financing_capital array.
* \param new_int The financing_capital to add
*/
void add_financing_capital(financing_capital_array * array,  double financing_per_month,  int nr_periods_before_repayment)
{
	if((*array).size == (*array).total_size)
	{
		(*array).total_size = (int)((*array).total_size * ARRAY_GROWTH_RATE);
		(*array).array = (financing_capital *)realloc((*array).array, ((*array).total_size * sizeof(financing_capital)));
	}
	init_financing_capital(&(*array).array[(*array).size]);
	(*array).array[(*array).size].financing_per_month = financing_per_month;
	(*array).array[(*array).size].nr_periods_before_repayment = nr_periods_before_repayment;

	(*array).size++;
}

/** \fn void remove_financing_capital(financing_capital_array * array, int index)
 * \brief Remove an financing_capital from a dynamic financing_capital array.
 * \param array Pointer to the dynamic financing_capital array.
 * \param index The index of the financing_capital to remove.
 */
void remove_financing_capital(financing_capital_array * array, int index)
{
	int i;

	/* Free element at index index */
	free_financing_capital(&(*array).array[index]);

	/* Copy all elements up by one */
	if(index < (*array).size)
	{
		for(i = index; i < (*array).size - 1; i++)
		{
			copy_financing_capital(&(*array).array[i+1], &(*array).array[i]);
		}
		(*array).size--;
	}
}
/* Functions for the temporary_sales_statistics datatype */
/** \fn temporary_sales_statistics_array * init_temporary_sales_statistics_array()
 * \brief Allocate memory for a dynamic temporary_sales_statistics array.
 * \return temporary_sales_statistics_array Pointer to the new dynamic temporary_sales_statistics array.
 */
void init_temporary_sales_statistics_array(temporary_sales_statistics_array * array)
{
	(*array).size = 0;
	(*array).total_size = ARRAY_BLOCK_SIZE;
	(*array).array = (temporary_sales_statistics *)malloc(ARRAY_BLOCK_SIZE * sizeof(temporary_sales_statistics));
	CHECK_POINTER((*array).array);
}

/** \fn void reset_temporary_sales_statistics_array(temporary_sales_statistics_array* array)
* \brief Reset the temporary_sales_statistics array to hold nothing.
* \param array Pointer to the dynamic temporary_sales_statistics array.
*/
void reset_temporary_sales_statistics_array(temporary_sales_statistics_array * array)
{
	(*array).size = 0;
}

/** \fn void free_temporary_sales_statistics_array(temporary_sales_statistics_array * array)
* \brief Free the memory of a dynamic temporary_sales_statistics array.
* \param array Pointer to the dynamic temporary_sales_statistics array.
*/
void free_temporary_sales_statistics_array(temporary_sales_statistics_array * array)
{
	int i;
	
	for(i = 0; i < array->size; i++)
	{
		free_temporary_sales_statistics(&(*array).array[i]);
	}
	
	free((*array).array);
}

void copy_temporary_sales_statistics_array(temporary_sales_statistics_array * from, temporary_sales_statistics_array * to)
{
	int i;

	//to = init_temporary_sales_statistics_array();

	for(i = 0; i < (*from).size; i++)
	{
		add_temporary_sales_statistics(to, (*from).array[i].mall_id, (*from).array[i].period, (*from).array[i].sales);
	}
}

/** \fn void add_temporary_sales_statistics(temporary_sales_statistics_array * array, int mall_id, int period, double sales)
* \brief Add an temporary_sales_statistics to the dynamic temporary_sales_statistics array.
* \param array Pointer to the dynamic temporary_sales_statistics array.
* \param new_int The temporary_sales_statistics to add
*/
void add_temporary_sales_statistics(temporary_sales_statistics_array * array,  int mall_id,  int period,  double sales)
{
	if((*array).size == (*array).total_size)
	{
		(*array).total_size = (int)((*array).total_size * ARRAY_GROWTH_RATE);
		(*array).array = (temporary_sales_statistics *)realloc((*array).array, ((*array).total_size * sizeof(temporary_sales_statistics)));
	}
	init_temporary_sales_statistics(&(*array).array[(*array).size]);
	(*array).array[(*array).size].mall_id = mall_id;
	(*array).array[(*array).size].period = period;
	(*array).array[(*array).size].sales = sales;

	(*array).size++;
}

/** \fn void remove_temporary_sales_statistics(temporary_sales_statistics_array * array, int index)
 * \brief Remove an temporary_sales_statistics from a dynamic temporary_sales_statistics array.
 * \param array Pointer to the dynamic temporary_sales_statistics array.
 * \param index The index of the temporary_sales_statistics to remove.
 */
void remove_temporary_sales_statistics(temporary_sales_statistics_array * array, int index)
{
	int i;

	/* Free element at index index */
	free_temporary_sales_statistics(&(*array).array[index]);

	/* Copy all elements up by one */
	if(index < (*array).size)
	{
		for(i = index; i < (*array).size - 1; i++)
		{
			copy_temporary_sales_statistics(&(*array).array[i+1], &(*array).array[i]);
		}
		(*array).size--;
	}
}
/* Functions for the account_item datatype */
/** \fn account_item_array * init_account_item_array()
 * \brief Allocate memory for a dynamic account_item array.
 * \return account_item_array Pointer to the new dynamic account_item array.
 */
void init_account_item_array(account_item_array * array)
{
	(*array).size = 0;
	(*array).total_size = ARRAY_BLOCK_SIZE;
	(*array).array = (account_item *)malloc(ARRAY_BLOCK_SIZE * sizeof(account_item));
	CHECK_POINTER((*array).array);
}

/** \fn void reset_account_item_array(account_item_array* array)
* \brief Reset the account_item array to hold nothing.
* \param array Pointer to the dynamic account_item array.
*/
void reset_account_item_array(account_item_array * array)
{
	(*array).size = 0;
}

/** \fn void free_account_item_array(account_item_array * array)
* \brief Free the memory of a dynamic account_item array.
* \param array Pointer to the dynamic account_item array.
*/
void free_account_item_array(account_item_array * array)
{
	int i;
	
	for(i = 0; i < array->size; i++)
	{
		free_account_item(&(*array).array[i]);
	}
	
	free((*array).array);
}

void copy_account_item_array(account_item_array * from, account_item_array * to)
{
	int i;

	//to = init_account_item_array();

	for(i = 0; i < (*from).size; i++)
	{
		add_account_item(to, (*from).array[i].id, (*from).array[i].payment_account);
	}
}

/** \fn void add_account_item(account_item_array * array, int id, double payment_account)
* \brief Add an account_item to the dynamic account_item array.
* \param array Pointer to the dynamic account_item array.
* \param new_int The account_item to add
*/
void add_account_item(account_item_array * array,  int id,  double payment_account)
{
	if((*array).size == (*array).total_size)
	{
		(*array).total_size = (int)((*array).total_size * ARRAY_GROWTH_RATE);
		(*array).array = (account_item *)realloc((*array).array, ((*array).total_size * sizeof(account_item)));
	}
	init_account_item(&(*array).array[(*array).size]);
	(*array).array[(*array).size].id = id;
	(*array).array[(*array).size].payment_account = payment_account;

	(*array).size++;
}

/** \fn void remove_account_item(account_item_array * array, int index)
 * \brief Remove an account_item from a dynamic account_item array.
 * \param array Pointer to the dynamic account_item array.
 * \param index The index of the account_item to remove.
 */
void remove_account_item(account_item_array * array, int index)
{
	int i;

	/* Free element at index index */
	free_account_item(&(*array).array[index]);

	/* Copy all elements up by one */
	if(index < (*array).size)
	{
		for(i = index; i < (*array).size - 1; i++)
		{
			copy_account_item(&(*array).array[i+1], &(*array).array[i]);
		}
		(*array).size--;
	}
}
/* Functions for the debt_item datatype */
/** \fn debt_item_array * init_debt_item_array()
 * \brief Allocate memory for a dynamic debt_item array.
 * \return debt_item_array Pointer to the new dynamic debt_item array.
 */
void init_debt_item_array(debt_item_array * array)
{
	(*array).size = 0;
	(*array).total_size = ARRAY_BLOCK_SIZE;
	(*array).array = (debt_item *)malloc(ARRAY_BLOCK_SIZE * sizeof(debt_item));
	CHECK_POINTER((*array).array);
}

/** \fn void reset_debt_item_array(debt_item_array* array)
* \brief Reset the debt_item array to hold nothing.
* \param array Pointer to the dynamic debt_item array.
*/
void reset_debt_item_array(debt_item_array * array)
{
	(*array).size = 0;
}

/** \fn void free_debt_item_array(debt_item_array * array)
* \brief Free the memory of a dynamic debt_item array.
* \param array Pointer to the dynamic debt_item array.
*/
void free_debt_item_array(debt_item_array * array)
{
	int i;
	
	for(i = 0; i < array->size; i++)
	{
		free_debt_item(&(*array).array[i]);
	}
	
	free((*array).array);
}

void copy_debt_item_array(debt_item_array * from, debt_item_array * to)
{
	int i;

	//to = init_debt_item_array();

	for(i = 0; i < (*from).size; i++)
	{
		add_debt_item(to, (*from).array[i].bank_id, (*from).array[i].loan_value, (*from).array[i].interest_rate, (*from).array[i].installment_amount, (*from).array[i].var_per_installment, (*from).array[i].residual_var, (*from).array[i].bad_debt, (*from).array[i].nr_periods_before_repayment);
	}
}

/** \fn void add_debt_item(debt_item_array * array, int bank_id, double loan_value, double interest_rate, double installment_amount, double var_per_installment, double residual_var, double bad_debt, int nr_periods_before_repayment)
* \brief Add an debt_item to the dynamic debt_item array.
* \param array Pointer to the dynamic debt_item array.
* \param new_int The debt_item to add
*/
void add_debt_item(debt_item_array * array,  int bank_id,  double loan_value,  double interest_rate,  double installment_amount,  double var_per_installment,  double residual_var,  double bad_debt,  int nr_periods_before_repayment)
{
	if((*array).size == (*array).total_size)
	{
		(*array).total_size = (int)((*array).total_size * ARRAY_GROWTH_RATE);
		(*array).array = (debt_item *)realloc((*array).array, ((*array).total_size * sizeof(debt_item)));
	}
	init_debt_item(&(*array).array[(*array).size]);
	(*array).array[(*array).size].bank_id = bank_id;
	(*array).array[(*array).size].loan_value = loan_value;
	(*array).array[(*array).size].interest_rate = interest_rate;
	(*array).array[(*array).size].installment_amount = installment_amount;
	(*array).array[(*array).size].var_per_installment = var_per_installment;
	(*array).array[(*array).size].residual_var = residual_var;
	(*array).array[(*array).size].bad_debt = bad_debt;
	(*array).array[(*array).size].nr_periods_before_repayment = nr_periods_before_repayment;

	(*array).size++;
}

/** \fn void remove_debt_item(debt_item_array * array, int index)
 * \brief Remove an debt_item from a dynamic debt_item array.
 * \param array Pointer to the dynamic debt_item array.
 * \param index The index of the debt_item to remove.
 */
void remove_debt_item(debt_item_array * array, int index)
{
	int i;

	/* Free element at index index */
	free_debt_item(&(*array).array[index]);

	/* Copy all elements up by one */
	if(index < (*array).size)
	{
		for(i = index; i < (*array).size - 1; i++)
		{
			copy_debt_item(&(*array).array[i+1], &(*array).array[i]);
		}
		(*array).size--;
	}
}
/* Functions for the order datatype */
/** \fn order_array * init_order_array()
 * \brief Allocate memory for a dynamic order array.
 * \return order_array Pointer to the new dynamic order array.
 */
void init_order_array(order_array * array)
{
	(*array).size = 0;
	(*array).total_size = ARRAY_BLOCK_SIZE;
	(*array).array = (order *)malloc(ARRAY_BLOCK_SIZE * sizeof(order));
	CHECK_POINTER((*array).array);
}

/** \fn void reset_order_array(order_array* array)
* \brief Reset the order array to hold nothing.
* \param array Pointer to the dynamic order array.
*/
void reset_order_array(order_array * array)
{
	(*array).size = 0;
}

/** \fn void free_order_array(order_array * array)
* \brief Free the memory of a dynamic order array.
* \param array Pointer to the dynamic order array.
*/
void free_order_array(order_array * array)
{
	int i;
	
	for(i = 0; i < array->size; i++)
	{
		free_order(&(*array).array[i]);
	}
	
	free((*array).array);
}

void copy_order_array(order_array * from, order_array * to)
{
	int i;

	//to = init_order_array();

	for(i = 0; i < (*from).size; i++)
	{
		add_order(to, (*from).array[i].trader_id, (*from).array[i].value, (*from).array[i].quantity);
	}
}

/** \fn void add_order(order_array * array, int trader_id, double value, int quantity)
* \brief Add an order to the dynamic order array.
* \param array Pointer to the dynamic order array.
* \param new_int The order to add
*/
void add_order(order_array * array,  int trader_id,  double value,  int quantity)
{
	if((*array).size == (*array).total_size)
	{
		(*array).total_size = (int)((*array).total_size * ARRAY_GROWTH_RATE);
		(*array).array = (order *)realloc((*array).array, ((*array).total_size * sizeof(order)));
	}
	init_order(&(*array).array[(*array).size]);
	(*array).array[(*array).size].trader_id = trader_id;
	(*array).array[(*array).size].value = value;
	(*array).array[(*array).size].quantity = quantity;

	(*array).size++;
}

/** \fn void remove_order(order_array * array, int index)
 * \brief Remove an order from a dynamic order array.
 * \param array Pointer to the dynamic order array.
 * \param index The index of the order to remove.
 */
void remove_order(order_array * array, int index)
{
	int i;

	/* Free element at index index */
	free_order(&(*array).array[index]);

	/* Copy all elements up by one */
	if(index < (*array).size)
	{
		for(i = index; i < (*array).size - 1; i++)
		{
			copy_order(&(*array).array[i+1], &(*array).array[i]);
		}
		(*array).size--;
	}
}
/* Functions for the index_adt datatype */
/** \fn index_adt_array * init_index_adt_array()
 * \brief Allocate memory for a dynamic index_adt array.
 * \return index_adt_array Pointer to the new dynamic index_adt array.
 */
void init_index_adt_array(index_adt_array * array)
{
	(*array).size = 0;
	(*array).total_size = ARRAY_BLOCK_SIZE;
	(*array).array = (index_adt *)malloc(ARRAY_BLOCK_SIZE * sizeof(index_adt));
	CHECK_POINTER((*array).array);
}

/** \fn void reset_index_adt_array(index_adt_array* array)
* \brief Reset the index_adt array to hold nothing.
* \param array Pointer to the dynamic index_adt array.
*/
void reset_index_adt_array(index_adt_array * array)
{
	(*array).size = 0;
}

/** \fn void free_index_adt_array(index_adt_array * array)
* \brief Free the memory of a dynamic index_adt array.
* \param array Pointer to the dynamic index_adt array.
*/
void free_index_adt_array(index_adt_array * array)
{
	int i;
	
	for(i = 0; i < array->size; i++)
	{
		free_index_adt(&(*array).array[i]);
	}
	
	free((*array).array);
}

void copy_index_adt_array(index_adt_array * from, index_adt_array * to)
{
	int i;

	//to = init_index_adt_array();

	for(i = 0; i < (*from).size; i++)
	{
		add_index_adt(to, (*from).array[i].price, (*from).array[i].weight, (*from).array[i].total_dividend, (*from).array[i].dividend_per_share, (*from).array[i].nr_shares, (*from).array[i].moving_avg_price, &(*from).array[i].price_history);
	}
}

/** \fn void add_index_adt(index_adt_array * array, double price, double weight, double total_dividend, double dividend_per_share, int nr_shares, double moving_avg_price, double_array price_history)
* \brief Add an index_adt to the dynamic index_adt array.
* \param array Pointer to the dynamic index_adt array.
* \param new_int The index_adt to add
*/
void add_index_adt(index_adt_array * array,  double price,  double weight,  double total_dividend,  double dividend_per_share,  int nr_shares,  double moving_avg_price, /*@out@*/ double_array * price_history)
{
	if((*array).size == (*array).total_size)
	{
		(*array).total_size = (int)((*array).total_size * ARRAY_GROWTH_RATE);
		(*array).array = (index_adt *)realloc((*array).array, ((*array).total_size * sizeof(index_adt)));
	}
	init_index_adt(&(*array).array[(*array).size]);
	(*array).array[(*array).size].price = price;
	(*array).array[(*array).size].weight = weight;
	(*array).array[(*array).size].total_dividend = total_dividend;
	(*array).array[(*array).size].dividend_per_share = dividend_per_share;
	(*array).array[(*array).size].nr_shares = nr_shares;
	(*array).array[(*array).size].moving_avg_price = moving_avg_price;
	if(price_history != NULL) copy_double_array(price_history, &(*array).array[(*array).size].price_history);

	(*array).size++;
}

/** \fn void remove_index_adt(index_adt_array * array, int index)
 * \brief Remove an index_adt from a dynamic index_adt array.
 * \param array Pointer to the dynamic index_adt array.
 * \param index The index of the index_adt to remove.
 */
void remove_index_adt(index_adt_array * array, int index)
{
	int i;

	/* Free element at index index */
	free_index_adt(&(*array).array[index]);

	/* Copy all elements up by one */
	if(index < (*array).size)
	{
		for(i = index; i < (*array).size - 1; i++)
		{
			copy_index_adt(&(*array).array[i+1], &(*array).array[i]);
		}
		(*array).size--;
	}
}
/* Functions for the index_portfolio datatype */
/** \fn index_portfolio_array * init_index_portfolio_array()
 * \brief Allocate memory for a dynamic index_portfolio array.
 * \return index_portfolio_array Pointer to the new dynamic index_portfolio array.
 */
void init_index_portfolio_array(index_portfolio_array * array)
{
	(*array).size = 0;
	(*array).total_size = ARRAY_BLOCK_SIZE;
	(*array).array = (index_portfolio *)malloc(ARRAY_BLOCK_SIZE * sizeof(index_portfolio));
	CHECK_POINTER((*array).array);
}

/** \fn void reset_index_portfolio_array(index_portfolio_array* array)
* \brief Reset the index_portfolio array to hold nothing.
* \param array Pointer to the dynamic index_portfolio array.
*/
void reset_index_portfolio_array(index_portfolio_array * array)
{
	(*array).size = 0;
}

/** \fn void free_index_portfolio_array(index_portfolio_array * array)
* \brief Free the memory of a dynamic index_portfolio array.
* \param array Pointer to the dynamic index_portfolio array.
*/
void free_index_portfolio_array(index_portfolio_array * array)
{
	int i;
	
	for(i = 0; i < array->size; i++)
	{
		free_index_portfolio(&(*array).array[i]);
	}
	
	free((*array).array);
}

void copy_index_portfolio_array(index_portfolio_array * from, index_portfolio_array * to)
{
	int i;

	//to = init_index_portfolio_array();

	for(i = 0; i < (*from).size; i++)
	{
		add_index_portfolio(to, (*from).array[i].lastprice, (*from).array[i].units, (*from).array[i].moving_avg_price);
	}
}

/** \fn void add_index_portfolio(index_portfolio_array * array, double lastprice, int units, double moving_avg_price)
* \brief Add an index_portfolio to the dynamic index_portfolio array.
* \param array Pointer to the dynamic index_portfolio array.
* \param new_int The index_portfolio to add
*/
void add_index_portfolio(index_portfolio_array * array,  double lastprice,  int units,  double moving_avg_price)
{
	if((*array).size == (*array).total_size)
	{
		(*array).total_size = (int)((*array).total_size * ARRAY_GROWTH_RATE);
		(*array).array = (index_portfolio *)realloc((*array).array, ((*array).total_size * sizeof(index_portfolio)));
	}
	init_index_portfolio(&(*array).array[(*array).size]);
	(*array).array[(*array).size].lastprice = lastprice;
	(*array).array[(*array).size].units = units;
	(*array).array[(*array).size].moving_avg_price = moving_avg_price;

	(*array).size++;
}

/** \fn void remove_index_portfolio(index_portfolio_array * array, int index)
 * \brief Remove an index_portfolio from a dynamic index_portfolio array.
 * \param array Pointer to the dynamic index_portfolio array.
 * \param index The index of the index_portfolio to remove.
 */
void remove_index_portfolio(index_portfolio_array * array, int index)
{
	int i;

	/* Free element at index index */
	free_index_portfolio(&(*array).array[index]);

	/* Copy all elements up by one */
	if(index < (*array).size)
	{
		for(i = index; i < (*array).size - 1; i++)
		{
			copy_index_portfolio(&(*array).array[i+1], &(*array).array[i]);
		}
		(*array).size--;
	}
}
/* Functions for the Belief datatype */
/** \fn Belief_array * init_Belief_array()
 * \brief Allocate memory for a dynamic Belief array.
 * \return Belief_array Pointer to the new dynamic Belief array.
 */
void init_Belief_array(Belief_array * array)
{
	(*array).size = 0;
	(*array).total_size = ARRAY_BLOCK_SIZE;
	(*array).array = (Belief *)malloc(ARRAY_BLOCK_SIZE * sizeof(Belief));
	CHECK_POINTER((*array).array);
}

/** \fn void reset_Belief_array(Belief_array* array)
* \brief Reset the Belief array to hold nothing.
* \param array Pointer to the dynamic Belief array.
*/
void reset_Belief_array(Belief_array * array)
{
	(*array).size = 0;
}

/** \fn void free_Belief_array(Belief_array * array)
* \brief Free the memory of a dynamic Belief array.
* \param array Pointer to the dynamic Belief array.
*/
void free_Belief_array(Belief_array * array)
{
	int i;
	
	for(i = 0; i < array->size; i++)
	{
		free_Belief(&(*array).array[i]);
	}
	
	free((*array).array);
}

void copy_Belief_array(Belief_array * from, Belief_array * to)
{
	int i;

	//to = init_Belief_array();

	for(i = 0; i < (*from).size; i++)
	{
		add_Belief(to, (*from).array[i].expected_dividend, (*from).array[i].expected_price, (*from).array[i].expected_return, (*from).array[i].expected_volatility, (*from).array[i].last_price, (*from).array[i].fraction_to_invest);
	}
}

/** \fn void add_Belief(Belief_array * array, double expected_dividend, double expected_price, double expected_return, double expected_volatility, double last_price, double fraction_to_invest)
* \brief Add an Belief to the dynamic Belief array.
* \param array Pointer to the dynamic Belief array.
* \param new_int The Belief to add
*/
void add_Belief(Belief_array * array,  double expected_dividend,  double expected_price,  double expected_return,  double expected_volatility,  double last_price,  double fraction_to_invest)
{
	if((*array).size == (*array).total_size)
	{
		(*array).total_size = (int)((*array).total_size * ARRAY_GROWTH_RATE);
		(*array).array = (Belief *)realloc((*array).array, ((*array).total_size * sizeof(Belief)));
	}
	init_Belief(&(*array).array[(*array).size]);
	(*array).array[(*array).size].expected_dividend = expected_dividend;
	(*array).array[(*array).size].expected_price = expected_price;
	(*array).array[(*array).size].expected_return = expected_return;
	(*array).array[(*array).size].expected_volatility = expected_volatility;
	(*array).array[(*array).size].last_price = last_price;
	(*array).array[(*array).size].fraction_to_invest = fraction_to_invest;

	(*array).size++;
}

/** \fn void remove_Belief(Belief_array * array, int index)
 * \brief Remove an Belief from a dynamic Belief array.
 * \param array Pointer to the dynamic Belief array.
 * \param index The index of the Belief to remove.
 */
void remove_Belief(Belief_array * array, int index)
{
	int i;

	/* Free element at index index */
	free_Belief(&(*array).array[index]);

	/* Copy all elements up by one */
	if(index < (*array).size)
	{
		for(i = index; i < (*array).size - 1; i++)
		{
			copy_Belief(&(*array).array[i+1], &(*array).array[i]);
		}
		(*array).size--;
	}
}
/* Functions for the capital_good_request datatype */
/** \fn capital_good_request_array * init_capital_good_request_array()
 * \brief Allocate memory for a dynamic capital_good_request array.
 * \return capital_good_request_array Pointer to the new dynamic capital_good_request array.
 */
void init_capital_good_request_array(capital_good_request_array * array)
{
	(*array).size = 0;
	(*array).total_size = ARRAY_BLOCK_SIZE;
	(*array).array = (capital_good_request *)malloc(ARRAY_BLOCK_SIZE * sizeof(capital_good_request));
	CHECK_POINTER((*array).array);
}

/** \fn void reset_capital_good_request_array(capital_good_request_array* array)
* \brief Reset the capital_good_request array to hold nothing.
* \param array Pointer to the dynamic capital_good_request array.
*/
void reset_capital_good_request_array(capital_good_request_array * array)
{
	(*array).size = 0;
}

/** \fn void free_capital_good_request_array(capital_good_request_array * array)
* \brief Free the memory of a dynamic capital_good_request array.
* \param array Pointer to the dynamic capital_good_request array.
*/
void free_capital_good_request_array(capital_good_request_array * array)
{
	int i;
	
	for(i = 0; i < array->size; i++)
	{
		free_capital_good_request(&(*array).array[i]);
	}
	
	free((*array).array);
}

void copy_capital_good_request_array(capital_good_request_array * from, capital_good_request_array * to)
{
	int i;

	//to = init_capital_good_request_array();

	for(i = 0; i < (*from).size; i++)
	{
		add_capital_good_request(to, (*from).array[i].firm_id, (*from).array[i].capital_good_order, (*from).array[i].vintage);
	}
}

/** \fn void add_capital_good_request(capital_good_request_array * array, int firm_id, double capital_good_order, int vintage)
* \brief Add an capital_good_request to the dynamic capital_good_request array.
* \param array Pointer to the dynamic capital_good_request array.
* \param new_int The capital_good_request to add
*/
void add_capital_good_request(capital_good_request_array * array,  int firm_id,  double capital_good_order,  int vintage)
{
	if((*array).size == (*array).total_size)
	{
		(*array).total_size = (int)((*array).total_size * ARRAY_GROWTH_RATE);
		(*array).array = (capital_good_request *)realloc((*array).array, ((*array).total_size * sizeof(capital_good_request)));
	}
	init_capital_good_request(&(*array).array[(*array).size]);
	(*array).array[(*array).size].firm_id = firm_id;
	(*array).array[(*array).size].capital_good_order = capital_good_order;
	(*array).array[(*array).size].vintage = vintage;

	(*array).size++;
}

/** \fn void remove_capital_good_request(capital_good_request_array * array, int index)
 * \brief Remove an capital_good_request from a dynamic capital_good_request array.
 * \param array Pointer to the dynamic capital_good_request array.
 * \param index The index of the capital_good_request to remove.
 */
void remove_capital_good_request(capital_good_request_array * array, int index)
{
	int i;

	/* Free element at index index */
	free_capital_good_request(&(*array).array[index]);

	/* Copy all elements up by one */
	if(index < (*array).size)
	{
		for(i = index; i < (*array).size - 1; i++)
		{
			copy_capital_good_request(&(*array).array[i+1], &(*array).array[i]);
		}
		(*array).size--;
	}
}
/* Functions for the vintage datatype */
/** \fn vintage_array * init_vintage_array()
 * \brief Allocate memory for a dynamic vintage array.
 * \return vintage_array Pointer to the new dynamic vintage array.
 */
void init_vintage_array(vintage_array * array)
{
	(*array).size = 0;
	(*array).total_size = ARRAY_BLOCK_SIZE;
	(*array).array = (vintage *)malloc(ARRAY_BLOCK_SIZE * sizeof(vintage));
	CHECK_POINTER((*array).array);
}

/** \fn void reset_vintage_array(vintage_array* array)
* \brief Reset the vintage array to hold nothing.
* \param array Pointer to the dynamic vintage array.
*/
void reset_vintage_array(vintage_array * array)
{
	(*array).size = 0;
}

/** \fn void free_vintage_array(vintage_array * array)
* \brief Free the memory of a dynamic vintage array.
* \param array Pointer to the dynamic vintage array.
*/
void free_vintage_array(vintage_array * array)
{
	int i;
	
	for(i = 0; i < array->size; i++)
	{
		free_vintage(&(*array).array[i]);
	}
	
	free((*array).array);
}

void copy_vintage_array(vintage_array * from, vintage_array * to)
{
	int i;

	//to = init_vintage_array();

	for(i = 0; i < (*from).size; i++)
	{
		add_vintage(to, (*from).array[i].productivity, (*from).array[i].price, (*from).array[i].discounted_productivity, (*from).array[i].sales);
	}
}

/** \fn void add_vintage(vintage_array * array, double productivity, double price, double discounted_productivity, double sales)
* \brief Add an vintage to the dynamic vintage array.
* \param array Pointer to the dynamic vintage array.
* \param new_int The vintage to add
*/
void add_vintage(vintage_array * array,  double productivity,  double price,  double discounted_productivity,  double sales)
{
	if((*array).size == (*array).total_size)
	{
		(*array).total_size = (int)((*array).total_size * ARRAY_GROWTH_RATE);
		(*array).array = (vintage *)realloc((*array).array, ((*array).total_size * sizeof(vintage)));
	}
	init_vintage(&(*array).array[(*array).size]);
	(*array).array[(*array).size].productivity = productivity;
	(*array).array[(*array).size].price = price;
	(*array).array[(*array).size].discounted_productivity = discounted_productivity;
	(*array).array[(*array).size].sales = sales;

	(*array).size++;
}

/** \fn void remove_vintage(vintage_array * array, int index)
 * \brief Remove an vintage from a dynamic vintage array.
 * \param array Pointer to the dynamic vintage array.
 * \param index The index of the vintage to remove.
 */
void remove_vintage(vintage_array * array, int index)
{
	int i;

	/* Free element at index index */
	free_vintage(&(*array).array[index]);

	/* Copy all elements up by one */
	if(index < (*array).size)
	{
		for(i = index; i < (*array).size - 1; i++)
		{
			copy_vintage(&(*array).array[i+1], &(*array).array[i]);
		}
		(*array).size--;
	}
}
/* Functions for the adt_sales_per_vintage datatype */
/** \fn adt_sales_per_vintage_array * init_adt_sales_per_vintage_array()
 * \brief Allocate memory for a dynamic adt_sales_per_vintage array.
 * \return adt_sales_per_vintage_array Pointer to the new dynamic adt_sales_per_vintage array.
 */
void init_adt_sales_per_vintage_array(adt_sales_per_vintage_array * array)
{
	(*array).size = 0;
	(*array).total_size = ARRAY_BLOCK_SIZE;
	(*array).array = (adt_sales_per_vintage *)malloc(ARRAY_BLOCK_SIZE * sizeof(adt_sales_per_vintage));
	CHECK_POINTER((*array).array);
}

/** \fn void reset_adt_sales_per_vintage_array(adt_sales_per_vintage_array* array)
* \brief Reset the adt_sales_per_vintage array to hold nothing.
* \param array Pointer to the dynamic adt_sales_per_vintage array.
*/
void reset_adt_sales_per_vintage_array(adt_sales_per_vintage_array * array)
{
	(*array).size = 0;
}

/** \fn void free_adt_sales_per_vintage_array(adt_sales_per_vintage_array * array)
* \brief Free the memory of a dynamic adt_sales_per_vintage array.
* \param array Pointer to the dynamic adt_sales_per_vintage array.
*/
void free_adt_sales_per_vintage_array(adt_sales_per_vintage_array * array)
{
	int i;
	
	for(i = 0; i < array->size; i++)
	{
		free_adt_sales_per_vintage(&(*array).array[i]);
	}
	
	free((*array).array);
}

void copy_adt_sales_per_vintage_array(adt_sales_per_vintage_array * from, adt_sales_per_vintage_array * to)
{
	int i;

	//to = init_adt_sales_per_vintage_array();

	for(i = 0; i < (*from).size; i++)
	{
		add_adt_sales_per_vintage(to, (*from).array[i].productivity_of_vintage, (*from).array[i].sales, (*from).array[i].revenue);
	}
}

/** \fn void add_adt_sales_per_vintage(adt_sales_per_vintage_array * array, double productivity_of_vintage, double sales, double revenue)
* \brief Add an adt_sales_per_vintage to the dynamic adt_sales_per_vintage array.
* \param array Pointer to the dynamic adt_sales_per_vintage array.
* \param new_int The adt_sales_per_vintage to add
*/
void add_adt_sales_per_vintage(adt_sales_per_vintage_array * array,  double productivity_of_vintage,  double sales,  double revenue)
{
	if((*array).size == (*array).total_size)
	{
		(*array).total_size = (int)((*array).total_size * ARRAY_GROWTH_RATE);
		(*array).array = (adt_sales_per_vintage *)realloc((*array).array, ((*array).total_size * sizeof(adt_sales_per_vintage)));
	}
	init_adt_sales_per_vintage(&(*array).array[(*array).size]);
	(*array).array[(*array).size].productivity_of_vintage = productivity_of_vintage;
	(*array).array[(*array).size].sales = sales;
	(*array).array[(*array).size].revenue = revenue;

	(*array).size++;
}

/** \fn void remove_adt_sales_per_vintage(adt_sales_per_vintage_array * array, int index)
 * \brief Remove an adt_sales_per_vintage from a dynamic adt_sales_per_vintage array.
 * \param array Pointer to the dynamic adt_sales_per_vintage array.
 * \param index The index of the adt_sales_per_vintage to remove.
 */
void remove_adt_sales_per_vintage(adt_sales_per_vintage_array * array, int index)
{
	int i;

	/* Free element at index index */
	free_adt_sales_per_vintage(&(*array).array[index]);

	/* Copy all elements up by one */
	if(index < (*array).size)
	{
		for(i = index; i < (*array).size - 1; i++)
		{
			copy_adt_sales_per_vintage(&(*array).array[i+1], &(*array).array[i]);
		}
		(*array).size--;
	}
}
/* Functions for the adt_list_adaptation_speed datatype */
/** \fn adt_list_adaptation_speed_array * init_adt_list_adaptation_speed_array()
 * \brief Allocate memory for a dynamic adt_list_adaptation_speed array.
 * \return adt_list_adaptation_speed_array Pointer to the new dynamic adt_list_adaptation_speed array.
 */
void init_adt_list_adaptation_speed_array(adt_list_adaptation_speed_array * array)
{
	(*array).size = 0;
	(*array).total_size = ARRAY_BLOCK_SIZE;
	(*array).array = (adt_list_adaptation_speed *)malloc(ARRAY_BLOCK_SIZE * sizeof(adt_list_adaptation_speed));
	CHECK_POINTER((*array).array);
}

/** \fn void reset_adt_list_adaptation_speed_array(adt_list_adaptation_speed_array* array)
* \brief Reset the adt_list_adaptation_speed array to hold nothing.
* \param array Pointer to the dynamic adt_list_adaptation_speed array.
*/
void reset_adt_list_adaptation_speed_array(adt_list_adaptation_speed_array * array)
{
	(*array).size = 0;
}

/** \fn void free_adt_list_adaptation_speed_array(adt_list_adaptation_speed_array * array)
* \brief Free the memory of a dynamic adt_list_adaptation_speed array.
* \param array Pointer to the dynamic adt_list_adaptation_speed array.
*/
void free_adt_list_adaptation_speed_array(adt_list_adaptation_speed_array * array)
{
	int i;
	
	for(i = 0; i < array->size; i++)
	{
		free_adt_list_adaptation_speed(&(*array).array[i]);
	}
	
	free((*array).array);
}

void copy_adt_list_adaptation_speed_array(adt_list_adaptation_speed_array * from, adt_list_adaptation_speed_array * to)
{
	int i;

	//to = init_adt_list_adaptation_speed_array();

	for(i = 0; i < (*from).size; i++)
	{
		add_adt_list_adaptation_speed(to, (*from).array[i].general_skill_level, (*from).array[i].adaptation_speed);
	}
}

/** \fn void add_adt_list_adaptation_speed(adt_list_adaptation_speed_array * array, int general_skill_level, double adaptation_speed)
* \brief Add an adt_list_adaptation_speed to the dynamic adt_list_adaptation_speed array.
* \param array Pointer to the dynamic adt_list_adaptation_speed array.
* \param new_int The adt_list_adaptation_speed to add
*/
void add_adt_list_adaptation_speed(adt_list_adaptation_speed_array * array,  int general_skill_level,  double adaptation_speed)
{
	if((*array).size == (*array).total_size)
	{
		(*array).total_size = (int)((*array).total_size * ARRAY_GROWTH_RATE);
		(*array).array = (adt_list_adaptation_speed *)realloc((*array).array, ((*array).total_size * sizeof(adt_list_adaptation_speed)));
	}
	init_adt_list_adaptation_speed(&(*array).array[(*array).size]);
	(*array).array[(*array).size].general_skill_level = general_skill_level;
	(*array).array[(*array).size].adaptation_speed = adaptation_speed;

	(*array).size++;
}

/** \fn void remove_adt_list_adaptation_speed(adt_list_adaptation_speed_array * array, int index)
 * \brief Remove an adt_list_adaptation_speed from a dynamic adt_list_adaptation_speed array.
 * \param array Pointer to the dynamic adt_list_adaptation_speed array.
 * \param index The index of the adt_list_adaptation_speed to remove.
 */
void remove_adt_list_adaptation_speed(adt_list_adaptation_speed_array * array, int index)
{
	int i;

	/* Free element at index index */
	free_adt_list_adaptation_speed(&(*array).array[index]);

	/* Copy all elements up by one */
	if(index < (*array).size)
	{
		for(i = index; i < (*array).size - 1; i++)
		{
			copy_adt_list_adaptation_speed(&(*array).array[i+1], &(*array).array[i]);
		}
		(*array).size--;
	}
}
/* Functions for the employee datatype */
/** \fn employee_array * init_employee_array()
 * \brief Allocate memory for a dynamic employee array.
 * \return employee_array Pointer to the new dynamic employee array.
 */
void init_employee_array(employee_array * array)
{
	(*array).size = 0;
	(*array).total_size = ARRAY_BLOCK_SIZE;
	(*array).array = (employee *)malloc(ARRAY_BLOCK_SIZE * sizeof(employee));
	CHECK_POINTER((*array).array);
}

/** \fn void reset_employee_array(employee_array* array)
* \brief Reset the employee array to hold nothing.
* \param array Pointer to the dynamic employee array.
*/
void reset_employee_array(employee_array * array)
{
	(*array).size = 0;
}

/** \fn void free_employee_array(employee_array * array)
* \brief Free the memory of a dynamic employee array.
* \param array Pointer to the dynamic employee array.
*/
void free_employee_array(employee_array * array)
{
	int i;
	
	for(i = 0; i < array->size; i++)
	{
		free_employee(&(*array).array[i]);
	}
	
	free((*array).array);
}

void copy_employee_array(employee_array * from, employee_array * to)
{
	int i;

	//to = init_employee_array();

	for(i = 0; i < (*from).size; i++)
	{
		add_employee(to, (*from).array[i].id, (*from).array[i].region_id, (*from).array[i].wage, (*from).array[i].general_skill, (*from).array[i].specific_skill, (*from).array[i].subsidy_pct);
	}
}

/** \fn void add_employee(employee_array * array, int id, int region_id, double wage, int general_skill, double specific_skill, double subsidy_pct)
* \brief Add an employee to the dynamic employee array.
* \param array Pointer to the dynamic employee array.
* \param new_int The employee to add
*/
void add_employee(employee_array * array,  int id,  int region_id,  double wage,  int general_skill,  double specific_skill,  double subsidy_pct)
{
	if((*array).size == (*array).total_size)
	{
		(*array).total_size = (int)((*array).total_size * ARRAY_GROWTH_RATE);
		(*array).array = (employee *)realloc((*array).array, ((*array).total_size * sizeof(employee)));
	}
	init_employee(&(*array).array[(*array).size]);
	(*array).array[(*array).size].id = id;
	(*array).array[(*array).size].region_id = region_id;
	(*array).array[(*array).size].wage = wage;
	(*array).array[(*array).size].general_skill = general_skill;
	(*array).array[(*array).size].specific_skill = specific_skill;
	(*array).array[(*array).size].subsidy_pct = subsidy_pct;

	(*array).size++;
}

/** \fn void remove_employee(employee_array * array, int index)
 * \brief Remove an employee from a dynamic employee array.
 * \param array Pointer to the dynamic employee array.
 * \param index The index of the employee to remove.
 */
void remove_employee(employee_array * array, int index)
{
	int i;

	/* Free element at index index */
	free_employee(&(*array).array[index]);

	/* Copy all elements up by one */
	if(index < (*array).size)
	{
		for(i = index; i < (*array).size - 1; i++)
		{
			copy_employee(&(*array).array[i+1], &(*array).array[i]);
		}
		(*array).size--;
	}
}
/* Functions for the vacancy datatype */
/** \fn vacancy_array * init_vacancy_array()
 * \brief Allocate memory for a dynamic vacancy array.
 * \return vacancy_array Pointer to the new dynamic vacancy array.
 */
void init_vacancy_array(vacancy_array * array)
{
	(*array).size = 0;
	(*array).total_size = ARRAY_BLOCK_SIZE;
	(*array).array = (vacancy *)malloc(ARRAY_BLOCK_SIZE * sizeof(vacancy));
	CHECK_POINTER((*array).array);
}

/** \fn void reset_vacancy_array(vacancy_array* array)
* \brief Reset the vacancy array to hold nothing.
* \param array Pointer to the dynamic vacancy array.
*/
void reset_vacancy_array(vacancy_array * array)
{
	(*array).size = 0;
}

/** \fn void free_vacancy_array(vacancy_array * array)
* \brief Free the memory of a dynamic vacancy array.
* \param array Pointer to the dynamic vacancy array.
*/
void free_vacancy_array(vacancy_array * array)
{
	int i;
	
	for(i = 0; i < array->size; i++)
	{
		free_vacancy(&(*array).array[i]);
	}
	
	free((*array).array);
}

void copy_vacancy_array(vacancy_array * from, vacancy_array * to)
{
	int i;

	//to = init_vacancy_array();

	for(i = 0; i < (*from).size; i++)
	{
		add_vacancy(to, (*from).array[i].firm_id, (*from).array[i].region_id, (*from).array[i].wage_offer, (*from).array[i].job_type);
	}
}

/** \fn void add_vacancy(vacancy_array * array, int firm_id, int region_id, double wage_offer, int job_type)
* \brief Add an vacancy to the dynamic vacancy array.
* \param array Pointer to the dynamic vacancy array.
* \param new_int The vacancy to add
*/
void add_vacancy(vacancy_array * array,  int firm_id,  int region_id,  double wage_offer,  int job_type)
{
	if((*array).size == (*array).total_size)
	{
		(*array).total_size = (int)((*array).total_size * ARRAY_GROWTH_RATE);
		(*array).array = (vacancy *)realloc((*array).array, ((*array).total_size * sizeof(vacancy)));
	}
	init_vacancy(&(*array).array[(*array).size]);
	(*array).array[(*array).size].firm_id = firm_id;
	(*array).array[(*array).size].region_id = region_id;
	(*array).array[(*array).size].wage_offer = wage_offer;
	(*array).array[(*array).size].job_type = job_type;

	(*array).size++;
}

/** \fn void remove_vacancy(vacancy_array * array, int index)
 * \brief Remove an vacancy from a dynamic vacancy array.
 * \param array Pointer to the dynamic vacancy array.
 * \param index The index of the vacancy to remove.
 */
void remove_vacancy(vacancy_array * array, int index)
{
	int i;

	/* Free element at index index */
	free_vacancy(&(*array).array[index]);

	/* Copy all elements up by one */
	if(index < (*array).size)
	{
		for(i = index; i < (*array).size - 1; i++)
		{
			copy_vacancy(&(*array).array[i+1], &(*array).array[i]);
		}
		(*array).size--;
	}
}
/* Functions for the job_application datatype */
/** \fn job_application_array * init_job_application_array()
 * \brief Allocate memory for a dynamic job_application array.
 * \return job_application_array Pointer to the new dynamic job_application array.
 */
void init_job_application_array(job_application_array * array)
{
	(*array).size = 0;
	(*array).total_size = ARRAY_BLOCK_SIZE;
	(*array).array = (job_application *)malloc(ARRAY_BLOCK_SIZE * sizeof(job_application));
	CHECK_POINTER((*array).array);
}

/** \fn void reset_job_application_array(job_application_array* array)
* \brief Reset the job_application array to hold nothing.
* \param array Pointer to the dynamic job_application array.
*/
void reset_job_application_array(job_application_array * array)
{
	(*array).size = 0;
}

/** \fn void free_job_application_array(job_application_array * array)
* \brief Free the memory of a dynamic job_application array.
* \param array Pointer to the dynamic job_application array.
*/
void free_job_application_array(job_application_array * array)
{
	int i;
	
	for(i = 0; i < array->size; i++)
	{
		free_job_application(&(*array).array[i]);
	}
	
	free((*array).array);
}

void copy_job_application_array(job_application_array * from, job_application_array * to)
{
	int i;

	//to = init_job_application_array();

	for(i = 0; i < (*from).size; i++)
	{
		add_job_application(to, (*from).array[i].worker_id, (*from).array[i].region_id, (*from).array[i].general_skill, (*from).array[i].specific_skill, (*from).array[i].wage_offer, (*from).array[i].job_type);
	}
}

/** \fn void add_job_application(job_application_array * array, int worker_id, int region_id, int general_skill, double specific_skill, double wage_offer, int job_type)
* \brief Add an job_application to the dynamic job_application array.
* \param array Pointer to the dynamic job_application array.
* \param new_int The job_application to add
*/
void add_job_application(job_application_array * array,  int worker_id,  int region_id,  int general_skill,  double specific_skill,  double wage_offer,  int job_type)
{
	if((*array).size == (*array).total_size)
	{
		(*array).total_size = (int)((*array).total_size * ARRAY_GROWTH_RATE);
		(*array).array = (job_application *)realloc((*array).array, ((*array).total_size * sizeof(job_application)));
	}
	init_job_application(&(*array).array[(*array).size]);
	(*array).array[(*array).size].worker_id = worker_id;
	(*array).array[(*array).size].region_id = region_id;
	(*array).array[(*array).size].general_skill = general_skill;
	(*array).array[(*array).size].specific_skill = specific_skill;
	(*array).array[(*array).size].wage_offer = wage_offer;
	(*array).array[(*array).size].job_type = job_type;

	(*array).size++;
}

/** \fn void remove_job_application(job_application_array * array, int index)
 * \brief Remove an job_application from a dynamic job_application array.
 * \param array Pointer to the dynamic job_application array.
 * \param index The index of the job_application to remove.
 */
void remove_job_application(job_application_array * array, int index)
{
	int i;

	/* Free element at index index */
	free_job_application(&(*array).array[index]);

	/* Copy all elements up by one */
	if(index < (*array).size)
	{
		for(i = index; i < (*array).size - 1; i++)
		{
			copy_job_application(&(*array).array[i+1], &(*array).array[i]);
		}
		(*array).size--;
	}
}
/* Functions for the job_offer datatype */
/** \fn job_offer_array * init_job_offer_array()
 * \brief Allocate memory for a dynamic job_offer array.
 * \return job_offer_array Pointer to the new dynamic job_offer array.
 */
void init_job_offer_array(job_offer_array * array)
{
	(*array).size = 0;
	(*array).total_size = ARRAY_BLOCK_SIZE;
	(*array).array = (job_offer *)malloc(ARRAY_BLOCK_SIZE * sizeof(job_offer));
	CHECK_POINTER((*array).array);
}

/** \fn void reset_job_offer_array(job_offer_array* array)
* \brief Reset the job_offer array to hold nothing.
* \param array Pointer to the dynamic job_offer array.
*/
void reset_job_offer_array(job_offer_array * array)
{
	(*array).size = 0;
}

/** \fn void free_job_offer_array(job_offer_array * array)
* \brief Free the memory of a dynamic job_offer array.
* \param array Pointer to the dynamic job_offer array.
*/
void free_job_offer_array(job_offer_array * array)
{
	int i;
	
	for(i = 0; i < array->size; i++)
	{
		free_job_offer(&(*array).array[i]);
	}
	
	free((*array).array);
}

void copy_job_offer_array(job_offer_array * from, job_offer_array * to)
{
	int i;

	//to = init_job_offer_array();

	for(i = 0; i < (*from).size; i++)
	{
		add_job_offer(to, (*from).array[i].firm_id, (*from).array[i].region_id, (*from).array[i].wage_offer, (*from).array[i].job_type);
	}
}

/** \fn void add_job_offer(job_offer_array * array, int firm_id, int region_id, double wage_offer, int job_type)
* \brief Add an job_offer to the dynamic job_offer array.
* \param array Pointer to the dynamic job_offer array.
* \param new_int The job_offer to add
*/
void add_job_offer(job_offer_array * array,  int firm_id,  int region_id,  double wage_offer,  int job_type)
{
	if((*array).size == (*array).total_size)
	{
		(*array).total_size = (int)((*array).total_size * ARRAY_GROWTH_RATE);
		(*array).array = (job_offer *)realloc((*array).array, ((*array).total_size * sizeof(job_offer)));
	}
	init_job_offer(&(*array).array[(*array).size]);
	(*array).array[(*array).size].firm_id = firm_id;
	(*array).array[(*array).size].region_id = region_id;
	(*array).array[(*array).size].wage_offer = wage_offer;
	(*array).array[(*array).size].job_type = job_type;

	(*array).size++;
}

/** \fn void remove_job_offer(job_offer_array * array, int index)
 * \brief Remove an job_offer from a dynamic job_offer array.
 * \param array Pointer to the dynamic job_offer array.
 * \param index The index of the job_offer to remove.
 */
void remove_job_offer(job_offer_array * array, int index)
{
	int i;

	/* Free element at index index */
	free_job_offer(&(*array).array[index]);

	/* Copy all elements up by one */
	if(index < (*array).size)
	{
		for(i = index; i < (*array).size - 1; i++)
		{
			copy_job_offer(&(*array).array[i+1], &(*array).array[i]);
		}
		(*array).size--;
	}
}
/* Functions for the logit datatype */
/** \fn logit_array * init_logit_array()
 * \brief Allocate memory for a dynamic logit array.
 * \return logit_array Pointer to the new dynamic logit array.
 */
void init_logit_array(logit_array * array)
{
	(*array).size = 0;
	(*array).total_size = ARRAY_BLOCK_SIZE;
	(*array).array = (logit *)malloc(ARRAY_BLOCK_SIZE * sizeof(logit));
	CHECK_POINTER((*array).array);
}

/** \fn void reset_logit_array(logit_array* array)
* \brief Reset the logit array to hold nothing.
* \param array Pointer to the dynamic logit array.
*/
void reset_logit_array(logit_array * array)
{
	(*array).size = 0;
}

/** \fn void free_logit_array(logit_array * array)
* \brief Free the memory of a dynamic logit array.
* \param array Pointer to the dynamic logit array.
*/
void free_logit_array(logit_array * array)
{
	int i;
	
	for(i = 0; i < array->size; i++)
	{
		free_logit(&(*array).array[i]);
	}
	
	free((*array).array);
}

void copy_logit_array(logit_array * from, logit_array * to)
{
	int i;

	//to = init_logit_array();

	for(i = 0; i < (*from).size; i++)
	{
		add_logit(to, (*from).array[i].logit_value, (*from).array[i].worker_id, (*from).array[i].general_skill, (*from).array[i].wage_offer, (*from).array[i].job_type);
	}
}

/** \fn void add_logit(logit_array * array, double logit_value, int worker_id, int general_skill, double wage_offer, int job_type)
* \brief Add an logit to the dynamic logit array.
* \param array Pointer to the dynamic logit array.
* \param new_int The logit to add
*/
void add_logit(logit_array * array,  double logit_value,  int worker_id,  int general_skill,  double wage_offer,  int job_type)
{
	if((*array).size == (*array).total_size)
	{
		(*array).total_size = (int)((*array).total_size * ARRAY_GROWTH_RATE);
		(*array).array = (logit *)realloc((*array).array, ((*array).total_size * sizeof(logit)));
	}
	init_logit(&(*array).array[(*array).size]);
	(*array).array[(*array).size].logit_value = logit_value;
	(*array).array[(*array).size].worker_id = worker_id;
	(*array).array[(*array).size].general_skill = general_skill;
	(*array).array[(*array).size].wage_offer = wage_offer;
	(*array).array[(*array).size].job_type = job_type;

	(*array).size++;
}

/** \fn void remove_logit(logit_array * array, int index)
 * \brief Remove an logit from a dynamic logit array.
 * \param array Pointer to the dynamic logit array.
 * \param index The index of the logit to remove.
 */
void remove_logit(logit_array * array, int index)
{
	int i;

	/* Free element at index index */
	free_logit(&(*array).array[index]);

	/* Copy all elements up by one */
	if(index < (*array).size)
	{
		for(i = index; i < (*array).size - 1; i++)
		{
			copy_logit(&(*array).array[i+1], &(*array).array[i]);
		}
		(*array).size--;
	}
}
/* Functions for the adt_skill_distribution datatype */
/** \fn adt_skill_distribution_array * init_adt_skill_distribution_array()
 * \brief Allocate memory for a dynamic adt_skill_distribution array.
 * \return adt_skill_distribution_array Pointer to the new dynamic adt_skill_distribution array.
 */
void init_adt_skill_distribution_array(adt_skill_distribution_array * array)
{
	(*array).size = 0;
	(*array).total_size = ARRAY_BLOCK_SIZE;
	(*array).array = (adt_skill_distribution *)malloc(ARRAY_BLOCK_SIZE * sizeof(adt_skill_distribution));
	CHECK_POINTER((*array).array);
}

/** \fn void reset_adt_skill_distribution_array(adt_skill_distribution_array* array)
* \brief Reset the adt_skill_distribution array to hold nothing.
* \param array Pointer to the dynamic adt_skill_distribution array.
*/
void reset_adt_skill_distribution_array(adt_skill_distribution_array * array)
{
	(*array).size = 0;
}

/** \fn void free_adt_skill_distribution_array(adt_skill_distribution_array * array)
* \brief Free the memory of a dynamic adt_skill_distribution array.
* \param array Pointer to the dynamic adt_skill_distribution array.
*/
void free_adt_skill_distribution_array(adt_skill_distribution_array * array)
{
	int i;
	
	for(i = 0; i < array->size; i++)
	{
		free_adt_skill_distribution(&(*array).array[i]);
	}
	
	free((*array).array);
}

void copy_adt_skill_distribution_array(adt_skill_distribution_array * from, adt_skill_distribution_array * to)
{
	int i;

	//to = init_adt_skill_distribution_array();

	for(i = 0; i < (*from).size; i++)
	{
		add_adt_skill_distribution(to, (*from).array[i].general_skill_group, (*from).array[i].percentage);
	}
}

/** \fn void add_adt_skill_distribution(adt_skill_distribution_array * array, int general_skill_group, double percentage)
* \brief Add an adt_skill_distribution to the dynamic adt_skill_distribution array.
* \param array Pointer to the dynamic adt_skill_distribution array.
* \param new_int The adt_skill_distribution to add
*/
void add_adt_skill_distribution(adt_skill_distribution_array * array,  int general_skill_group,  double percentage)
{
	if((*array).size == (*array).total_size)
	{
		(*array).total_size = (int)((*array).total_size * ARRAY_GROWTH_RATE);
		(*array).array = (adt_skill_distribution *)realloc((*array).array, ((*array).total_size * sizeof(adt_skill_distribution)));
	}
	init_adt_skill_distribution(&(*array).array[(*array).size]);
	(*array).array[(*array).size].general_skill_group = general_skill_group;
	(*array).array[(*array).size].percentage = percentage;

	(*array).size++;
}

/** \fn void remove_adt_skill_distribution(adt_skill_distribution_array * array, int index)
 * \brief Remove an adt_skill_distribution from a dynamic adt_skill_distribution array.
 * \param array Pointer to the dynamic adt_skill_distribution array.
 * \param index The index of the adt_skill_distribution to remove.
 */
void remove_adt_skill_distribution(adt_skill_distribution_array * array, int index)
{
	int i;

	/* Free element at index index */
	free_adt_skill_distribution(&(*array).array[index]);

	/* Copy all elements up by one */
	if(index < (*array).size)
	{
		for(i = index; i < (*array).size - 1; i++)
		{
			copy_adt_skill_distribution(&(*array).array[i+1], &(*array).array[i]);
		}
		(*array).size--;
	}
}
/* Functions for the adt_actual_skill_distribution_with_ids datatype */
/** \fn adt_actual_skill_distribution_with_ids_array * init_adt_actual_skill_distribution_with_ids_array()
 * \brief Allocate memory for a dynamic adt_actual_skill_distribution_with_ids array.
 * \return adt_actual_skill_distribution_with_ids_array Pointer to the new dynamic adt_actual_skill_distribution_with_ids array.
 */
void init_adt_actual_skill_distribution_with_ids_array(adt_actual_skill_distribution_with_ids_array * array)
{
	(*array).size = 0;
	(*array).total_size = ARRAY_BLOCK_SIZE;
	(*array).array = (adt_actual_skill_distribution_with_ids *)malloc(ARRAY_BLOCK_SIZE * sizeof(adt_actual_skill_distribution_with_ids));
	CHECK_POINTER((*array).array);
}

/** \fn void reset_adt_actual_skill_distribution_with_ids_array(adt_actual_skill_distribution_with_ids_array* array)
* \brief Reset the adt_actual_skill_distribution_with_ids array to hold nothing.
* \param array Pointer to the dynamic adt_actual_skill_distribution_with_ids array.
*/
void reset_adt_actual_skill_distribution_with_ids_array(adt_actual_skill_distribution_with_ids_array * array)
{
	(*array).size = 0;
}

/** \fn void free_adt_actual_skill_distribution_with_ids_array(adt_actual_skill_distribution_with_ids_array * array)
* \brief Free the memory of a dynamic adt_actual_skill_distribution_with_ids array.
* \param array Pointer to the dynamic adt_actual_skill_distribution_with_ids array.
*/
void free_adt_actual_skill_distribution_with_ids_array(adt_actual_skill_distribution_with_ids_array * array)
{
	int i;
	
	for(i = 0; i < array->size; i++)
	{
		free_adt_actual_skill_distribution_with_ids(&(*array).array[i]);
	}
	
	free((*array).array);
}

void copy_adt_actual_skill_distribution_with_ids_array(adt_actual_skill_distribution_with_ids_array * from, adt_actual_skill_distribution_with_ids_array * to)
{
	int i;

	//to = init_adt_actual_skill_distribution_with_ids_array();

	for(i = 0; i < (*from).size; i++)
	{
		add_adt_actual_skill_distribution_with_ids(to, (*from).array[i].general_skill_group, &(*from).array[i].id_list);
	}
}

/** \fn void add_adt_actual_skill_distribution_with_ids(adt_actual_skill_distribution_with_ids_array * array, int general_skill_group, int_array id_list)
* \brief Add an adt_actual_skill_distribution_with_ids to the dynamic adt_actual_skill_distribution_with_ids array.
* \param array Pointer to the dynamic adt_actual_skill_distribution_with_ids array.
* \param new_int The adt_actual_skill_distribution_with_ids to add
*/
void add_adt_actual_skill_distribution_with_ids(adt_actual_skill_distribution_with_ids_array * array,  int general_skill_group, /*@out@*/ int_array * id_list)
{
	if((*array).size == (*array).total_size)
	{
		(*array).total_size = (int)((*array).total_size * ARRAY_GROWTH_RATE);
		(*array).array = (adt_actual_skill_distribution_with_ids *)realloc((*array).array, ((*array).total_size * sizeof(adt_actual_skill_distribution_with_ids)));
	}
	init_adt_actual_skill_distribution_with_ids(&(*array).array[(*array).size]);
	(*array).array[(*array).size].general_skill_group = general_skill_group;
	if(id_list != NULL) copy_int_array(id_list, &(*array).array[(*array).size].id_list);

	(*array).size++;
}

/** \fn void remove_adt_actual_skill_distribution_with_ids(adt_actual_skill_distribution_with_ids_array * array, int index)
 * \brief Remove an adt_actual_skill_distribution_with_ids from a dynamic adt_actual_skill_distribution_with_ids array.
 * \param array Pointer to the dynamic adt_actual_skill_distribution_with_ids array.
 * \param index The index of the adt_actual_skill_distribution_with_ids to remove.
 */
void remove_adt_actual_skill_distribution_with_ids(adt_actual_skill_distribution_with_ids_array * array, int index)
{
	int i;

	/* Free element at index index */
	free_adt_actual_skill_distribution_with_ids(&(*array).array[index]);

	/* Copy all elements up by one */
	if(index < (*array).size)
	{
		for(i = index; i < (*array).size - 1; i++)
		{
			copy_adt_actual_skill_distribution_with_ids(&(*array).array[i+1], &(*array).array[i]);
		}
		(*array).size--;
	}
}
/* Functions for the adt_gov_inflows_outflows datatype */
/** \fn adt_gov_inflows_outflows_array * init_adt_gov_inflows_outflows_array()
 * \brief Allocate memory for a dynamic adt_gov_inflows_outflows array.
 * \return adt_gov_inflows_outflows_array Pointer to the new dynamic adt_gov_inflows_outflows array.
 */
void init_adt_gov_inflows_outflows_array(adt_gov_inflows_outflows_array * array)
{
	(*array).size = 0;
	(*array).total_size = ARRAY_BLOCK_SIZE;
	(*array).array = (adt_gov_inflows_outflows *)malloc(ARRAY_BLOCK_SIZE * sizeof(adt_gov_inflows_outflows));
	CHECK_POINTER((*array).array);
}

/** \fn void reset_adt_gov_inflows_outflows_array(adt_gov_inflows_outflows_array* array)
* \brief Reset the adt_gov_inflows_outflows array to hold nothing.
* \param array Pointer to the dynamic adt_gov_inflows_outflows array.
*/
void reset_adt_gov_inflows_outflows_array(adt_gov_inflows_outflows_array * array)
{
	(*array).size = 0;
}

/** \fn void free_adt_gov_inflows_outflows_array(adt_gov_inflows_outflows_array * array)
* \brief Free the memory of a dynamic adt_gov_inflows_outflows array.
* \param array Pointer to the dynamic adt_gov_inflows_outflows array.
*/
void free_adt_gov_inflows_outflows_array(adt_gov_inflows_outflows_array * array)
{
	int i;
	
	for(i = 0; i < array->size; i++)
	{
		free_adt_gov_inflows_outflows(&(*array).array[i]);
	}
	
	free((*array).array);
}

void copy_adt_gov_inflows_outflows_array(adt_gov_inflows_outflows_array * from, adt_gov_inflows_outflows_array * to)
{
	int i;

	//to = init_adt_gov_inflows_outflows_array();

	for(i = 0; i < (*from).size; i++)
	{
		add_adt_gov_inflows_outflows(to, (*from).array[i].inflows, (*from).array[i].outflows, (*from).array[i].tax_basis);
	}
}

/** \fn void add_adt_gov_inflows_outflows(adt_gov_inflows_outflows_array * array, double inflows, double outflows, double tax_basis)
* \brief Add an adt_gov_inflows_outflows to the dynamic adt_gov_inflows_outflows array.
* \param array Pointer to the dynamic adt_gov_inflows_outflows array.
* \param new_int The adt_gov_inflows_outflows to add
*/
void add_adt_gov_inflows_outflows(adt_gov_inflows_outflows_array * array,  double inflows,  double outflows,  double tax_basis)
{
	if((*array).size == (*array).total_size)
	{
		(*array).total_size = (int)((*array).total_size * ARRAY_GROWTH_RATE);
		(*array).array = (adt_gov_inflows_outflows *)realloc((*array).array, ((*array).total_size * sizeof(adt_gov_inflows_outflows)));
	}
	init_adt_gov_inflows_outflows(&(*array).array[(*array).size]);
	(*array).array[(*array).size].inflows = inflows;
	(*array).array[(*array).size].outflows = outflows;
	(*array).array[(*array).size].tax_basis = tax_basis;

	(*array).size++;
}

/** \fn void remove_adt_gov_inflows_outflows(adt_gov_inflows_outflows_array * array, int index)
 * \brief Remove an adt_gov_inflows_outflows from a dynamic adt_gov_inflows_outflows array.
 * \param array Pointer to the dynamic adt_gov_inflows_outflows array.
 * \param index The index of the adt_gov_inflows_outflows to remove.
 */
void remove_adt_gov_inflows_outflows(adt_gov_inflows_outflows_array * array, int index)
{
	int i;

	/* Free element at index index */
	free_adt_gov_inflows_outflows(&(*array).array[index]);

	/* Copy all elements up by one */
	if(index < (*array).size)
	{
		for(i = index; i < (*array).size - 1; i++)
		{
			copy_adt_gov_inflows_outflows(&(*array).array[i+1], &(*array).array[i]);
		}
		(*array).size--;
	}
}
/* Functions for the household_data datatype */
/** \fn household_data_array * init_household_data_array()
 * \brief Allocate memory for a dynamic household_data array.
 * \return household_data_array Pointer to the new dynamic household_data array.
 */
void init_household_data_array(household_data_array * array)
{
	(*array).size = 0;
	(*array).total_size = ARRAY_BLOCK_SIZE;
	(*array).array = (household_data *)malloc(ARRAY_BLOCK_SIZE * sizeof(household_data));
	CHECK_POINTER((*array).array);
}

/** \fn void reset_household_data_array(household_data_array* array)
* \brief Reset the household_data array to hold nothing.
* \param array Pointer to the dynamic household_data array.
*/
void reset_household_data_array(household_data_array * array)
{
	(*array).size = 0;
}

/** \fn void free_household_data_array(household_data_array * array)
* \brief Free the memory of a dynamic household_data array.
* \param array Pointer to the dynamic household_data array.
*/
void free_household_data_array(household_data_array * array)
{
	int i;
	
	for(i = 0; i < array->size; i++)
	{
		free_household_data(&(*array).array[i]);
	}
	
	free((*array).array);
}

void copy_household_data_array(household_data_array * from, household_data_array * to)
{
	int i;

	//to = init_household_data_array();

	for(i = 0; i < (*from).size; i++)
	{
		add_household_data(to, (*from).array[i].region_id, (*from).array[i].no_households, (*from).array[i].no_households_skill_1, (*from).array[i].no_households_skill_2, (*from).array[i].no_households_skill_3, (*from).array[i].no_households_skill_4, (*from).array[i].no_households_skill_5, (*from).array[i].employed, (*from).array[i].employed_skill_1, (*from).array[i].employed_skill_2, (*from).array[i].employed_skill_3, (*from).array[i].employed_skill_4, (*from).array[i].employed_skill_5, (*from).array[i].unemployed, (*from).array[i].unemployment_rate, (*from).array[i].unemployment_rate_skill_1, (*from).array[i].unemployment_rate_skill_2, (*from).array[i].unemployment_rate_skill_3, (*from).array[i].unemployment_rate_skill_4, (*from).array[i].unemployment_rate_skill_5, (*from).array[i].consumption_budget, (*from).array[i].average_wage, (*from).array[i].average_wage_skill_1, (*from).array[i].average_wage_skill_2, (*from).array[i].average_wage_skill_3, (*from).array[i].average_wage_skill_4, (*from).array[i].average_wage_skill_5, (*from).array[i].average_s_skill, (*from).array[i].average_s_skill_1, (*from).array[i].average_s_skill_2, (*from).array[i].average_s_skill_3, (*from).array[i].average_s_skill_4, (*from).array[i].average_s_skill_5);
	}
}

/** \fn void add_household_data(household_data_array * array, int region_id, int no_households, int no_households_skill_1, int no_households_skill_2, int no_households_skill_3, int no_households_skill_4, int no_households_skill_5, int employed, int employed_skill_1, int employed_skill_2, int employed_skill_3, int employed_skill_4, int employed_skill_5, int unemployed, double unemployment_rate, double unemployment_rate_skill_1, double unemployment_rate_skill_2, double unemployment_rate_skill_3, double unemployment_rate_skill_4, double unemployment_rate_skill_5, double consumption_budget, double average_wage, double average_wage_skill_1, double average_wage_skill_2, double average_wage_skill_3, double average_wage_skill_4, double average_wage_skill_5, double average_s_skill, double average_s_skill_1, double average_s_skill_2, double average_s_skill_3, double average_s_skill_4, double average_s_skill_5)
* \brief Add an household_data to the dynamic household_data array.
* \param array Pointer to the dynamic household_data array.
* \param new_int The household_data to add
*/
void add_household_data(household_data_array * array,  int region_id,  int no_households,  int no_households_skill_1,  int no_households_skill_2,  int no_households_skill_3,  int no_households_skill_4,  int no_households_skill_5,  int employed,  int employed_skill_1,  int employed_skill_2,  int employed_skill_3,  int employed_skill_4,  int employed_skill_5,  int unemployed,  double unemployment_rate,  double unemployment_rate_skill_1,  double unemployment_rate_skill_2,  double unemployment_rate_skill_3,  double unemployment_rate_skill_4,  double unemployment_rate_skill_5,  double consumption_budget,  double average_wage,  double average_wage_skill_1,  double average_wage_skill_2,  double average_wage_skill_3,  double average_wage_skill_4,  double average_wage_skill_5,  double average_s_skill,  double average_s_skill_1,  double average_s_skill_2,  double average_s_skill_3,  double average_s_skill_4,  double average_s_skill_5)
{
	if((*array).size == (*array).total_size)
	{
		(*array).total_size = (int)((*array).total_size * ARRAY_GROWTH_RATE);
		(*array).array = (household_data *)realloc((*array).array, ((*array).total_size * sizeof(household_data)));
	}
	init_household_data(&(*array).array[(*array).size]);
	(*array).array[(*array).size].region_id = region_id;
	(*array).array[(*array).size].no_households = no_households;
	(*array).array[(*array).size].no_households_skill_1 = no_households_skill_1;
	(*array).array[(*array).size].no_households_skill_2 = no_households_skill_2;
	(*array).array[(*array).size].no_households_skill_3 = no_households_skill_3;
	(*array).array[(*array).size].no_households_skill_4 = no_households_skill_4;
	(*array).array[(*array).size].no_households_skill_5 = no_households_skill_5;
	(*array).array[(*array).size].employed = employed;
	(*array).array[(*array).size].employed_skill_1 = employed_skill_1;
	(*array).array[(*array).size].employed_skill_2 = employed_skill_2;
	(*array).array[(*array).size].employed_skill_3 = employed_skill_3;
	(*array).array[(*array).size].employed_skill_4 = employed_skill_4;
	(*array).array[(*array).size].employed_skill_5 = employed_skill_5;
	(*array).array[(*array).size].unemployed = unemployed;
	(*array).array[(*array).size].unemployment_rate = unemployment_rate;
	(*array).array[(*array).size].unemployment_rate_skill_1 = unemployment_rate_skill_1;
	(*array).array[(*array).size].unemployment_rate_skill_2 = unemployment_rate_skill_2;
	(*array).array[(*array).size].unemployment_rate_skill_3 = unemployment_rate_skill_3;
	(*array).array[(*array).size].unemployment_rate_skill_4 = unemployment_rate_skill_4;
	(*array).array[(*array).size].unemployment_rate_skill_5 = unemployment_rate_skill_5;
	(*array).array[(*array).size].consumption_budget = consumption_budget;
	(*array).array[(*array).size].average_wage = average_wage;
	(*array).array[(*array).size].average_wage_skill_1 = average_wage_skill_1;
	(*array).array[(*array).size].average_wage_skill_2 = average_wage_skill_2;
	(*array).array[(*array).size].average_wage_skill_3 = average_wage_skill_3;
	(*array).array[(*array).size].average_wage_skill_4 = average_wage_skill_4;
	(*array).array[(*array).size].average_wage_skill_5 = average_wage_skill_5;
	(*array).array[(*array).size].average_s_skill = average_s_skill;
	(*array).array[(*array).size].average_s_skill_1 = average_s_skill_1;
	(*array).array[(*array).size].average_s_skill_2 = average_s_skill_2;
	(*array).array[(*array).size].average_s_skill_3 = average_s_skill_3;
	(*array).array[(*array).size].average_s_skill_4 = average_s_skill_4;
	(*array).array[(*array).size].average_s_skill_5 = average_s_skill_5;

	(*array).size++;
}

/** \fn void remove_household_data(household_data_array * array, int index)
 * \brief Remove an household_data from a dynamic household_data array.
 * \param array Pointer to the dynamic household_data array.
 * \param index The index of the household_data to remove.
 */
void remove_household_data(household_data_array * array, int index)
{
	int i;

	/* Free element at index index */
	free_household_data(&(*array).array[index]);

	/* Copy all elements up by one */
	if(index < (*array).size)
	{
		for(i = index; i < (*array).size - 1; i++)
		{
			copy_household_data(&(*array).array[i+1], &(*array).array[i]);
		}
		(*array).size--;
	}
}
/* Functions for the price_quality_pair datatype */
/** \fn price_quality_pair_array * init_price_quality_pair_array()
 * \brief Allocate memory for a dynamic price_quality_pair array.
 * \return price_quality_pair_array Pointer to the new dynamic price_quality_pair array.
 */
void init_price_quality_pair_array(price_quality_pair_array * array)
{
	(*array).size = 0;
	(*array).total_size = ARRAY_BLOCK_SIZE;
	(*array).array = (price_quality_pair *)malloc(ARRAY_BLOCK_SIZE * sizeof(price_quality_pair));
	CHECK_POINTER((*array).array);
}

/** \fn void reset_price_quality_pair_array(price_quality_pair_array* array)
* \brief Reset the price_quality_pair array to hold nothing.
* \param array Pointer to the dynamic price_quality_pair array.
*/
void reset_price_quality_pair_array(price_quality_pair_array * array)
{
	(*array).size = 0;
}

/** \fn void free_price_quality_pair_array(price_quality_pair_array * array)
* \brief Free the memory of a dynamic price_quality_pair array.
* \param array Pointer to the dynamic price_quality_pair array.
*/
void free_price_quality_pair_array(price_quality_pair_array * array)
{
	int i;
	
	for(i = 0; i < array->size; i++)
	{
		free_price_quality_pair(&(*array).array[i]);
	}
	
	free((*array).array);
}

void copy_price_quality_pair_array(price_quality_pair_array * from, price_quality_pair_array * to)
{
	int i;

	//to = init_price_quality_pair_array();

	for(i = 0; i < (*from).size; i++)
	{
		add_price_quality_pair(to, (*from).array[i].region_id, (*from).array[i].price, (*from).array[i].quality);
	}
}

/** \fn void add_price_quality_pair(price_quality_pair_array * array, int region_id, double price, double quality)
* \brief Add an price_quality_pair to the dynamic price_quality_pair array.
* \param array Pointer to the dynamic price_quality_pair array.
* \param new_int The price_quality_pair to add
*/
void add_price_quality_pair(price_quality_pair_array * array,  int region_id,  double price,  double quality)
{
	if((*array).size == (*array).total_size)
	{
		(*array).total_size = (int)((*array).total_size * ARRAY_GROWTH_RATE);
		(*array).array = (price_quality_pair *)realloc((*array).array, ((*array).total_size * sizeof(price_quality_pair)));
	}
	init_price_quality_pair(&(*array).array[(*array).size]);
	(*array).array[(*array).size].region_id = region_id;
	(*array).array[(*array).size].price = price;
	(*array).array[(*array).size].quality = quality;

	(*array).size++;
}

/** \fn void remove_price_quality_pair(price_quality_pair_array * array, int index)
 * \brief Remove an price_quality_pair from a dynamic price_quality_pair array.
 * \param array Pointer to the dynamic price_quality_pair array.
 * \param index The index of the price_quality_pair to remove.
 */
void remove_price_quality_pair(price_quality_pair_array * array, int index)
{
	int i;

	/* Free element at index index */
	free_price_quality_pair(&(*array).array[index]);

	/* Copy all elements up by one */
	if(index < (*array).size)
	{
		for(i = index; i < (*array).size - 1; i++)
		{
			copy_price_quality_pair(&(*array).array[i+1], &(*array).array[i]);
		}
		(*array).size--;
	}
}
/* Functions for the firm_data datatype */
/** \fn firm_data_array * init_firm_data_array()
 * \brief Allocate memory for a dynamic firm_data array.
 * \return firm_data_array Pointer to the new dynamic firm_data array.
 */
void init_firm_data_array(firm_data_array * array)
{
	(*array).size = 0;
	(*array).total_size = ARRAY_BLOCK_SIZE;
	(*array).array = (firm_data *)malloc(ARRAY_BLOCK_SIZE * sizeof(firm_data));
	CHECK_POINTER((*array).array);
}

/** \fn void reset_firm_data_array(firm_data_array* array)
* \brief Reset the firm_data array to hold nothing.
* \param array Pointer to the dynamic firm_data array.
*/
void reset_firm_data_array(firm_data_array * array)
{
	(*array).size = 0;
}

/** \fn void free_firm_data_array(firm_data_array * array)
* \brief Free the memory of a dynamic firm_data array.
* \param array Pointer to the dynamic firm_data array.
*/
void free_firm_data_array(firm_data_array * array)
{
	int i;
	
	for(i = 0; i < array->size; i++)
	{
		free_firm_data(&(*array).array[i]);
	}
	
	free((*array).array);
}

void copy_firm_data_array(firm_data_array * from, firm_data_array * to)
{
	int i;

	//to = init_firm_data_array();

	for(i = 0; i < (*from).size; i++)
	{
		add_firm_data(to, (*from).array[i].region_id, (*from).array[i].no_firms, (*from).array[i].no_active_firms, (*from).array[i].vacancies, (*from).array[i].posted_vacancies, (*from).array[i].employees, (*from).array[i].employees_skill_1, (*from).array[i].employees_skill_2, (*from).array[i].employees_skill_3, (*from).array[i].employees_skill_4, (*from).array[i].employees_skill_5, (*from).array[i].average_wage, (*from).array[i].average_wage_skill_1, (*from).array[i].average_wage_skill_2, (*from).array[i].average_wage_skill_3, (*from).array[i].average_wage_skill_4, (*from).array[i].average_wage_skill_5, (*from).array[i].average_s_skill, (*from).array[i].average_s_skill_1, (*from).array[i].average_s_skill_2, (*from).array[i].average_s_skill_3, (*from).array[i].average_s_skill_4, (*from).array[i].average_s_skill_5, (*from).array[i].labour_productivity, (*from).array[i].total_earnings, (*from).array[i].total_debt, (*from).array[i].total_assets, (*from).array[i].total_equity, (*from).array[i].average_debt_earnings_ratio, (*from).array[i].average_debt_equity_ratio, (*from).array[i].labour_share_ratio, (*from).array[i].monthly_sold_quantity, (*from).array[i].monthly_output, (*from).array[i].monthly_revenue, (*from).array[i].monthly_planned_output, (*from).array[i].monthly_investment_value, (*from).array[i].investment_gdp_ratio, (*from).array[i].gdp, (*from).array[i].cpi, (*from).array[i].cpi_last_month, (*from).array[i].no_firm_births, (*from).array[i].no_firm_deaths, (*from).array[i].productivity_progress, (*from).array[i].productivity, (*from).array[i].wage_offer, (*from).array[i].technology);
	}
}

/** \fn void add_firm_data(firm_data_array * array, int region_id, int no_firms, int no_active_firms, int vacancies, int posted_vacancies, int employees, int employees_skill_1, int employees_skill_2, int employees_skill_3, int employees_skill_4, int employees_skill_5, double average_wage, double average_wage_skill_1, double average_wage_skill_2, double average_wage_skill_3, double average_wage_skill_4, double average_wage_skill_5, double average_s_skill, double average_s_skill_1, double average_s_skill_2, double average_s_skill_3, double average_s_skill_4, double average_s_skill_5, double labour_productivity, double total_earnings, double total_debt, double total_assets, double total_equity, double average_debt_earnings_ratio, double average_debt_equity_ratio, double labour_share_ratio, double monthly_sold_quantity, double monthly_output, double monthly_revenue, double monthly_planned_output, double monthly_investment_value, double investment_gdp_ratio, double gdp, double cpi, double cpi_last_month, int no_firm_births, int no_firm_deaths, double productivity_progress, double productivity, double wage_offer, double technology)
* \brief Add an firm_data to the dynamic firm_data array.
* \param array Pointer to the dynamic firm_data array.
* \param new_int The firm_data to add
*/
void add_firm_data(firm_data_array * array,  int region_id,  int no_firms,  int no_active_firms,  int vacancies,  int posted_vacancies,  int employees,  int employees_skill_1,  int employees_skill_2,  int employees_skill_3,  int employees_skill_4,  int employees_skill_5,  double average_wage,  double average_wage_skill_1,  double average_wage_skill_2,  double average_wage_skill_3,  double average_wage_skill_4,  double average_wage_skill_5,  double average_s_skill,  double average_s_skill_1,  double average_s_skill_2,  double average_s_skill_3,  double average_s_skill_4,  double average_s_skill_5,  double labour_productivity,  double total_earnings,  double total_debt,  double total_assets,  double total_equity,  double average_debt_earnings_ratio,  double average_debt_equity_ratio,  double labour_share_ratio,  double monthly_sold_quantity,  double monthly_output,  double monthly_revenue,  double monthly_planned_output,  double monthly_investment_value,  double investment_gdp_ratio,  double gdp,  double cpi,  double cpi_last_month,  int no_firm_births,  int no_firm_deaths,  double productivity_progress,  double productivity,  double wage_offer,  double technology)
{
	if((*array).size == (*array).total_size)
	{
		(*array).total_size = (int)((*array).total_size * ARRAY_GROWTH_RATE);
		(*array).array = (firm_data *)realloc((*array).array, ((*array).total_size * sizeof(firm_data)));
	}
	init_firm_data(&(*array).array[(*array).size]);
	(*array).array[(*array).size].region_id = region_id;
	(*array).array[(*array).size].no_firms = no_firms;
	(*array).array[(*array).size].no_active_firms = no_active_firms;
	(*array).array[(*array).size].vacancies = vacancies;
	(*array).array[(*array).size].posted_vacancies = posted_vacancies;
	(*array).array[(*array).size].employees = employees;
	(*array).array[(*array).size].employees_skill_1 = employees_skill_1;
	(*array).array[(*array).size].employees_skill_2 = employees_skill_2;
	(*array).array[(*array).size].employees_skill_3 = employees_skill_3;
	(*array).array[(*array).size].employees_skill_4 = employees_skill_4;
	(*array).array[(*array).size].employees_skill_5 = employees_skill_5;
	(*array).array[(*array).size].average_wage = average_wage;
	(*array).array[(*array).size].average_wage_skill_1 = average_wage_skill_1;
	(*array).array[(*array).size].average_wage_skill_2 = average_wage_skill_2;
	(*array).array[(*array).size].average_wage_skill_3 = average_wage_skill_3;
	(*array).array[(*array).size].average_wage_skill_4 = average_wage_skill_4;
	(*array).array[(*array).size].average_wage_skill_5 = average_wage_skill_5;
	(*array).array[(*array).size].average_s_skill = average_s_skill;
	(*array).array[(*array).size].average_s_skill_1 = average_s_skill_1;
	(*array).array[(*array).size].average_s_skill_2 = average_s_skill_2;
	(*array).array[(*array).size].average_s_skill_3 = average_s_skill_3;
	(*array).array[(*array).size].average_s_skill_4 = average_s_skill_4;
	(*array).array[(*array).size].average_s_skill_5 = average_s_skill_5;
	(*array).array[(*array).size].labour_productivity = labour_productivity;
	(*array).array[(*array).size].total_earnings = total_earnings;
	(*array).array[(*array).size].total_debt = total_debt;
	(*array).array[(*array).size].total_assets = total_assets;
	(*array).array[(*array).size].total_equity = total_equity;
	(*array).array[(*array).size].average_debt_earnings_ratio = average_debt_earnings_ratio;
	(*array).array[(*array).size].average_debt_equity_ratio = average_debt_equity_ratio;
	(*array).array[(*array).size].labour_share_ratio = labour_share_ratio;
	(*array).array[(*array).size].monthly_sold_quantity = monthly_sold_quantity;
	(*array).array[(*array).size].monthly_output = monthly_output;
	(*array).array[(*array).size].monthly_revenue = monthly_revenue;
	(*array).array[(*array).size].monthly_planned_output = monthly_planned_output;
	(*array).array[(*array).size].monthly_investment_value = monthly_investment_value;
	(*array).array[(*array).size].investment_gdp_ratio = investment_gdp_ratio;
	(*array).array[(*array).size].gdp = gdp;
	(*array).array[(*array).size].cpi = cpi;
	(*array).array[(*array).size].cpi_last_month = cpi_last_month;
	(*array).array[(*array).size].no_firm_births = no_firm_births;
	(*array).array[(*array).size].no_firm_deaths = no_firm_deaths;
	(*array).array[(*array).size].productivity_progress = productivity_progress;
	(*array).array[(*array).size].productivity = productivity;
	(*array).array[(*array).size].wage_offer = wage_offer;
	(*array).array[(*array).size].technology = technology;

	(*array).size++;
}

/** \fn void remove_firm_data(firm_data_array * array, int index)
 * \brief Remove an firm_data from a dynamic firm_data array.
 * \param array Pointer to the dynamic firm_data array.
 * \param index The index of the firm_data to remove.
 */
void remove_firm_data(firm_data_array * array, int index)
{
	int i;

	/* Free element at index index */
	free_firm_data(&(*array).array[index]);

	/* Copy all elements up by one */
	if(index < (*array).size)
	{
		for(i = index; i < (*array).size - 1; i++)
		{
			copy_firm_data(&(*array).array[i+1], &(*array).array[i]);
		}
		(*array).size--;
	}
}
/* Functions for the government_data datatype */
/** \fn government_data_array * init_government_data_array()
 * \brief Allocate memory for a dynamic government_data array.
 * \return government_data_array Pointer to the new dynamic government_data array.
 */
void init_government_data_array(government_data_array * array)
{
	(*array).size = 0;
	(*array).total_size = ARRAY_BLOCK_SIZE;
	(*array).array = (government_data *)malloc(ARRAY_BLOCK_SIZE * sizeof(government_data));
	CHECK_POINTER((*array).array);
}

/** \fn void reset_government_data_array(government_data_array* array)
* \brief Reset the government_data array to hold nothing.
* \param array Pointer to the dynamic government_data array.
*/
void reset_government_data_array(government_data_array * array)
{
	(*array).size = 0;
}

/** \fn void free_government_data_array(government_data_array * array)
* \brief Free the memory of a dynamic government_data array.
* \param array Pointer to the dynamic government_data array.
*/
void free_government_data_array(government_data_array * array)
{
	int i;
	
	for(i = 0; i < array->size; i++)
	{
		free_government_data(&(*array).array[i]);
	}
	
	free((*array).array);
}

void copy_government_data_array(government_data_array * from, government_data_array * to)
{
	int i;

	//to = init_government_data_array();

	for(i = 0; i < (*from).size; i++)
	{
		add_government_data(to, (*from).array[i].region_id, (*from).array[i].consumption_expenditures);
	}
}

/** \fn void add_government_data(government_data_array * array, int region_id, double consumption_expenditures)
* \brief Add an government_data to the dynamic government_data array.
* \param array Pointer to the dynamic government_data array.
* \param new_int The government_data to add
*/
void add_government_data(government_data_array * array,  int region_id,  double consumption_expenditures)
{
	if((*array).size == (*array).total_size)
	{
		(*array).total_size = (int)((*array).total_size * ARRAY_GROWTH_RATE);
		(*array).array = (government_data *)realloc((*array).array, ((*array).total_size * sizeof(government_data)));
	}
	init_government_data(&(*array).array[(*array).size]);
	(*array).array[(*array).size].region_id = region_id;
	(*array).array[(*array).size].consumption_expenditures = consumption_expenditures;

	(*array).size++;
}

/** \fn void remove_government_data(government_data_array * array, int index)
 * \brief Remove an government_data from a dynamic government_data array.
 * \param array Pointer to the dynamic government_data array.
 * \param index The index of the government_data to remove.
 */
void remove_government_data(government_data_array * array, int index)
{
	int i;

	/* Free element at index index */
	free_government_data(&(*array).array[index]);

	/* Copy all elements up by one */
	if(index < (*array).size)
	{
		for(i = index; i < (*array).size - 1; i++)
		{
			copy_government_data(&(*array).array[i+1], &(*array).array[i]);
		}
		(*array).size--;
	}
}
/* Functions for the region_data_item datatype */
/** \fn region_data_item_array * init_region_data_item_array()
 * \brief Allocate memory for a dynamic region_data_item array.
 * \return region_data_item_array Pointer to the new dynamic region_data_item array.
 */
void init_region_data_item_array(region_data_item_array * array)
{
	(*array).size = 0;
	(*array).total_size = ARRAY_BLOCK_SIZE;
	(*array).array = (region_data_item *)malloc(ARRAY_BLOCK_SIZE * sizeof(region_data_item));
	CHECK_POINTER((*array).array);
}

/** \fn void reset_region_data_item_array(region_data_item_array* array)
* \brief Reset the region_data_item array to hold nothing.
* \param array Pointer to the dynamic region_data_item array.
*/
void reset_region_data_item_array(region_data_item_array * array)
{
	(*array).size = 0;
}

/** \fn void free_region_data_item_array(region_data_item_array * array)
* \brief Free the memory of a dynamic region_data_item array.
* \param array Pointer to the dynamic region_data_item array.
*/
void free_region_data_item_array(region_data_item_array * array)
{
	int i;
	
	for(i = 0; i < array->size; i++)
	{
		free_region_data_item(&(*array).array[i]);
	}
	
	free((*array).array);
}

void copy_region_data_item_array(region_data_item_array * from, region_data_item_array * to)
{
	int i;

	//to = init_region_data_item_array();

	for(i = 0; i < (*from).size; i++)
	{
		add_region_data_item(to, (*from).array[i].cpi, (*from).array[i].cpi_last_month, (*from).array[i].gdp, (*from).array[i].output, (*from).array[i].employment, (*from).array[i].unemployment_rate, (*from).array[i].unemployment_rate_skill_1, (*from).array[i].unemployment_rate_skill_2, (*from).array[i].unemployment_rate_skill_3, (*from).array[i].unemployment_rate_skill_4, (*from).array[i].unemployment_rate_skill_5, (*from).array[i].average_wage, (*from).array[i].no_firms, (*from).array[i].no_active_firms, (*from).array[i].no_firm_births, (*from).array[i].no_firm_deaths, (*from).array[i].investment_value);
	}
}

/** \fn void add_region_data_item(region_data_item_array * array, double cpi, double cpi_last_month, double gdp, double output, int employment, double unemployment_rate, double unemployment_rate_skill_1, double unemployment_rate_skill_2, double unemployment_rate_skill_3, double unemployment_rate_skill_4, double unemployment_rate_skill_5, double average_wage, int no_firms, int no_active_firms, int no_firm_births, int no_firm_deaths, double investment_value)
* \brief Add an region_data_item to the dynamic region_data_item array.
* \param array Pointer to the dynamic region_data_item array.
* \param new_int The region_data_item to add
*/
void add_region_data_item(region_data_item_array * array,  double cpi,  double cpi_last_month,  double gdp,  double output,  int employment,  double unemployment_rate,  double unemployment_rate_skill_1,  double unemployment_rate_skill_2,  double unemployment_rate_skill_3,  double unemployment_rate_skill_4,  double unemployment_rate_skill_5,  double average_wage,  int no_firms,  int no_active_firms,  int no_firm_births,  int no_firm_deaths,  double investment_value)
{
	if((*array).size == (*array).total_size)
	{
		(*array).total_size = (int)((*array).total_size * ARRAY_GROWTH_RATE);
		(*array).array = (region_data_item *)realloc((*array).array, ((*array).total_size * sizeof(region_data_item)));
	}
	init_region_data_item(&(*array).array[(*array).size]);
	(*array).array[(*array).size].cpi = cpi;
	(*array).array[(*array).size].cpi_last_month = cpi_last_month;
	(*array).array[(*array).size].gdp = gdp;
	(*array).array[(*array).size].output = output;
	(*array).array[(*array).size].employment = employment;
	(*array).array[(*array).size].unemployment_rate = unemployment_rate;
	(*array).array[(*array).size].unemployment_rate_skill_1 = unemployment_rate_skill_1;
	(*array).array[(*array).size].unemployment_rate_skill_2 = unemployment_rate_skill_2;
	(*array).array[(*array).size].unemployment_rate_skill_3 = unemployment_rate_skill_3;
	(*array).array[(*array).size].unemployment_rate_skill_4 = unemployment_rate_skill_4;
	(*array).array[(*array).size].unemployment_rate_skill_5 = unemployment_rate_skill_5;
	(*array).array[(*array).size].average_wage = average_wage;
	(*array).array[(*array).size].no_firms = no_firms;
	(*array).array[(*array).size].no_active_firms = no_active_firms;
	(*array).array[(*array).size].no_firm_births = no_firm_births;
	(*array).array[(*array).size].no_firm_deaths = no_firm_deaths;
	(*array).array[(*array).size].investment_value = investment_value;

	(*array).size++;
}

/** \fn void remove_region_data_item(region_data_item_array * array, int index)
 * \brief Remove an region_data_item from a dynamic region_data_item array.
 * \param array Pointer to the dynamic region_data_item array.
 * \param index The index of the region_data_item to remove.
 */
void remove_region_data_item(region_data_item_array * array, int index)
{
	int i;

	/* Free element at index index */
	free_region_data_item(&(*array).array[index]);

	/* Copy all elements up by one */
	if(index < (*array).size)
	{
		for(i = index; i < (*array).size - 1; i++)
		{
			copy_region_data_item(&(*array).array[i+1], &(*array).array[i]);
		}
		(*array).size--;
	}
}
/* Functions for the history_item datatype */
/** \fn history_item_array * init_history_item_array()
 * \brief Allocate memory for a dynamic history_item array.
 * \return history_item_array Pointer to the new dynamic history_item array.
 */
void init_history_item_array(history_item_array * array)
{
	(*array).size = 0;
	(*array).total_size = ARRAY_BLOCK_SIZE;
	(*array).array = (history_item *)malloc(ARRAY_BLOCK_SIZE * sizeof(history_item));
	CHECK_POINTER((*array).array);
}

/** \fn void reset_history_item_array(history_item_array* array)
* \brief Reset the history_item array to hold nothing.
* \param array Pointer to the dynamic history_item array.
*/
void reset_history_item_array(history_item_array * array)
{
	(*array).size = 0;
}

/** \fn void free_history_item_array(history_item_array * array)
* \brief Free the memory of a dynamic history_item array.
* \param array Pointer to the dynamic history_item array.
*/
void free_history_item_array(history_item_array * array)
{
	int i;
	
	for(i = 0; i < array->size; i++)
	{
		free_history_item(&(*array).array[i]);
	}
	
	free((*array).array);
}

void copy_history_item_array(history_item_array * from, history_item_array * to)
{
	int i;

	//to = init_history_item_array();

	for(i = 0; i < (*from).size; i++)
	{
		add_history_item(to, (*from).array[i].cpi, (*from).array[i].gdp, (*from).array[i].output, (*from).array[i].employment, (*from).array[i].unemployment_rate, (*from).array[i].unemployment_rate_skill_1, (*from).array[i].unemployment_rate_skill_2, (*from).array[i].unemployment_rate_skill_3, (*from).array[i].unemployment_rate_skill_4, (*from).array[i].unemployment_rate_skill_5, (*from).array[i].average_wage, (*from).array[i].no_firms, (*from).array[i].no_active_firms, (*from).array[i].no_firm_births, (*from).array[i].no_firm_deaths, (*from).array[i].investment_value, &(*from).array[i].region_data);
	}
}

/** \fn void add_history_item(history_item_array * array, double cpi, double gdp, double output, int employment, double unemployment_rate, double unemployment_rate_skill_1, double unemployment_rate_skill_2, double unemployment_rate_skill_3, double unemployment_rate_skill_4, double unemployment_rate_skill_5, double average_wage, int no_firms, int no_active_firms, int no_firm_births, int no_firm_deaths, double investment_value, region_data_item_array * region_data)
* \brief Add an history_item to the dynamic history_item array.
* \param array Pointer to the dynamic history_item array.
* \param new_int The history_item to add
*/
void add_history_item(history_item_array * array,  double cpi,  double gdp,  double output,  int employment,  double unemployment_rate,  double unemployment_rate_skill_1,  double unemployment_rate_skill_2,  double unemployment_rate_skill_3,  double unemployment_rate_skill_4,  double unemployment_rate_skill_5,  double average_wage,  int no_firms,  int no_active_firms,  int no_firm_births,  int no_firm_deaths,  double investment_value, /*@out@*/ region_data_item_array * region_data)
{
	if((*array).size == (*array).total_size)
	{
		(*array).total_size = (int)((*array).total_size * ARRAY_GROWTH_RATE);
		(*array).array = (history_item *)realloc((*array).array, ((*array).total_size * sizeof(history_item)));
	}
	init_history_item(&(*array).array[(*array).size]);
	(*array).array[(*array).size].cpi = cpi;
	(*array).array[(*array).size].gdp = gdp;
	(*array).array[(*array).size].output = output;
	(*array).array[(*array).size].employment = employment;
	(*array).array[(*array).size].unemployment_rate = unemployment_rate;
	(*array).array[(*array).size].unemployment_rate_skill_1 = unemployment_rate_skill_1;
	(*array).array[(*array).size].unemployment_rate_skill_2 = unemployment_rate_skill_2;
	(*array).array[(*array).size].unemployment_rate_skill_3 = unemployment_rate_skill_3;
	(*array).array[(*array).size].unemployment_rate_skill_4 = unemployment_rate_skill_4;
	(*array).array[(*array).size].unemployment_rate_skill_5 = unemployment_rate_skill_5;
	(*array).array[(*array).size].average_wage = average_wage;
	(*array).array[(*array).size].no_firms = no_firms;
	(*array).array[(*array).size].no_active_firms = no_active_firms;
	(*array).array[(*array).size].no_firm_births = no_firm_births;
	(*array).array[(*array).size].no_firm_deaths = no_firm_deaths;
	(*array).array[(*array).size].investment_value = investment_value;
	if(region_data != NULL) copy_region_data_item_array(region_data, &(*array).array[(*array).size].region_data);

	(*array).size++;
}

/** \fn void remove_history_item(history_item_array * array, int index)
 * \brief Remove an history_item from a dynamic history_item array.
 * \param array Pointer to the dynamic history_item array.
 * \param index The index of the history_item to remove.
 */
void remove_history_item(history_item_array * array, int index)
{
	int i;

	/* Free element at index index */
	free_history_item(&(*array).array[index]);

	/* Copy all elements up by one */
	if(index < (*array).size)
	{
		for(i = index; i < (*array).size - 1; i++)
		{
			copy_history_item(&(*array).array[i+1], &(*array).array[i]);
		}
		(*array).size--;
	}
}
/* Functions for the firm_stocks_adt datatype */
/** \fn firm_stocks_adt_array * init_firm_stocks_adt_array()
 * \brief Allocate memory for a dynamic firm_stocks_adt array.
 * \return firm_stocks_adt_array Pointer to the new dynamic firm_stocks_adt array.
 */
void init_firm_stocks_adt_array(firm_stocks_adt_array * array)
{
	(*array).size = 0;
	(*array).total_size = ARRAY_BLOCK_SIZE;
	(*array).array = (firm_stocks_adt *)malloc(ARRAY_BLOCK_SIZE * sizeof(firm_stocks_adt));
	CHECK_POINTER((*array).array);
}

/** \fn void reset_firm_stocks_adt_array(firm_stocks_adt_array* array)
* \brief Reset the firm_stocks_adt array to hold nothing.
* \param array Pointer to the dynamic firm_stocks_adt array.
*/
void reset_firm_stocks_adt_array(firm_stocks_adt_array * array)
{
	(*array).size = 0;
}

/** \fn void free_firm_stocks_adt_array(firm_stocks_adt_array * array)
* \brief Free the memory of a dynamic firm_stocks_adt array.
* \param array Pointer to the dynamic firm_stocks_adt array.
*/
void free_firm_stocks_adt_array(firm_stocks_adt_array * array)
{
	int i;
	
	for(i = 0; i < array->size; i++)
	{
		free_firm_stocks_adt(&(*array).array[i]);
	}
	
	free((*array).array);
}

void copy_firm_stocks_adt_array(firm_stocks_adt_array * from, firm_stocks_adt_array * to)
{
	int i;

	//to = init_firm_stocks_adt_array();

	for(i = 0; i < (*from).size; i++)
	{
		add_firm_stocks_adt(to, (*from).array[i].payment_account, (*from).array[i].total_value_local_inventory, (*from).array[i].total_value_capital_stock, (*from).array[i].total_assets, (*from).array[i].total_debt, (*from).array[i].equity, (*from).array[i].total_liabilities, (*from).array[i].current_shares_outstanding, (*from).array[i].payment_account_day_1, (*from).array[i].payment_account_day_20);
	}
}

/** \fn void add_firm_stocks_adt(firm_stocks_adt_array * array, double payment_account, double total_value_local_inventory, double total_value_capital_stock, double total_assets, double total_debt, double equity, double total_liabilities, int current_shares_outstanding, double payment_account_day_1, double payment_account_day_20)
* \brief Add an firm_stocks_adt to the dynamic firm_stocks_adt array.
* \param array Pointer to the dynamic firm_stocks_adt array.
* \param new_int The firm_stocks_adt to add
*/
void add_firm_stocks_adt(firm_stocks_adt_array * array,  double payment_account,  double total_value_local_inventory,  double total_value_capital_stock,  double total_assets,  double total_debt,  double equity,  double total_liabilities,  int current_shares_outstanding,  double payment_account_day_1,  double payment_account_day_20)
{
	if((*array).size == (*array).total_size)
	{
		(*array).total_size = (int)((*array).total_size * ARRAY_GROWTH_RATE);
		(*array).array = (firm_stocks_adt *)realloc((*array).array, ((*array).total_size * sizeof(firm_stocks_adt)));
	}
	init_firm_stocks_adt(&(*array).array[(*array).size]);
	(*array).array[(*array).size].payment_account = payment_account;
	(*array).array[(*array).size].total_value_local_inventory = total_value_local_inventory;
	(*array).array[(*array).size].total_value_capital_stock = total_value_capital_stock;
	(*array).array[(*array).size].total_assets = total_assets;
	(*array).array[(*array).size].total_debt = total_debt;
	(*array).array[(*array).size].equity = equity;
	(*array).array[(*array).size].total_liabilities = total_liabilities;
	(*array).array[(*array).size].current_shares_outstanding = current_shares_outstanding;
	(*array).array[(*array).size].payment_account_day_1 = payment_account_day_1;
	(*array).array[(*array).size].payment_account_day_20 = payment_account_day_20;

	(*array).size++;
}

/** \fn void remove_firm_stocks_adt(firm_stocks_adt_array * array, int index)
 * \brief Remove an firm_stocks_adt from a dynamic firm_stocks_adt array.
 * \param array Pointer to the dynamic firm_stocks_adt array.
 * \param index The index of the firm_stocks_adt to remove.
 */
void remove_firm_stocks_adt(firm_stocks_adt_array * array, int index)
{
	int i;

	/* Free element at index index */
	free_firm_stocks_adt(&(*array).array[index]);

	/* Copy all elements up by one */
	if(index < (*array).size)
	{
		for(i = index; i < (*array).size - 1; i++)
		{
			copy_firm_stocks_adt(&(*array).array[i+1], &(*array).array[i]);
		}
		(*array).size--;
	}
}
/* Functions for the firm_outflows_adt datatype */
/** \fn firm_outflows_adt_array * init_firm_outflows_adt_array()
 * \brief Allocate memory for a dynamic firm_outflows_adt array.
 * \return firm_outflows_adt_array Pointer to the new dynamic firm_outflows_adt array.
 */
void init_firm_outflows_adt_array(firm_outflows_adt_array * array)
{
	(*array).size = 0;
	(*array).total_size = ARRAY_BLOCK_SIZE;
	(*array).array = (firm_outflows_adt *)malloc(ARRAY_BLOCK_SIZE * sizeof(firm_outflows_adt));
	CHECK_POINTER((*array).array);
}

/** \fn void reset_firm_outflows_adt_array(firm_outflows_adt_array* array)
* \brief Reset the firm_outflows_adt array to hold nothing.
* \param array Pointer to the dynamic firm_outflows_adt array.
*/
void reset_firm_outflows_adt_array(firm_outflows_adt_array * array)
{
	(*array).size = 0;
}

/** \fn void free_firm_outflows_adt_array(firm_outflows_adt_array * array)
* \brief Free the memory of a dynamic firm_outflows_adt array.
* \param array Pointer to the dynamic firm_outflows_adt array.
*/
void free_firm_outflows_adt_array(firm_outflows_adt_array * array)
{
	int i;
	
	for(i = 0; i < array->size; i++)
	{
		free_firm_outflows_adt(&(*array).array[i]);
	}
	
	free((*array).array);
}

void copy_firm_outflows_adt_array(firm_outflows_adt_array * from, firm_outflows_adt_array * to)
{
	int i;

	//to = init_firm_outflows_adt_array();

	for(i = 0; i < (*from).size; i++)
	{
		add_firm_outflows_adt(to, (*from).array[i].labour_costs, (*from).array[i].capital_costs, (*from).array[i].energy_costs, (*from).array[i].tax_payment, (*from).array[i].total_debt_installment_payment, (*from).array[i].total_interest_payment, (*from).array[i].total_dividend_payment, (*from).array[i].value_of_repurchased_shares, (*from).array[i].total_expenses);
	}
}

/** \fn void add_firm_outflows_adt(firm_outflows_adt_array * array, double labour_costs, double capital_costs, double energy_costs, double tax_payment, double total_debt_installment_payment, double total_interest_payment, double total_dividend_payment, double value_of_repurchased_shares, double total_expenses)
* \brief Add an firm_outflows_adt to the dynamic firm_outflows_adt array.
* \param array Pointer to the dynamic firm_outflows_adt array.
* \param new_int The firm_outflows_adt to add
*/
void add_firm_outflows_adt(firm_outflows_adt_array * array,  double labour_costs,  double capital_costs,  double energy_costs,  double tax_payment,  double total_debt_installment_payment,  double total_interest_payment,  double total_dividend_payment,  double value_of_repurchased_shares,  double total_expenses)
{
	if((*array).size == (*array).total_size)
	{
		(*array).total_size = (int)((*array).total_size * ARRAY_GROWTH_RATE);
		(*array).array = (firm_outflows_adt *)realloc((*array).array, ((*array).total_size * sizeof(firm_outflows_adt)));
	}
	init_firm_outflows_adt(&(*array).array[(*array).size]);
	(*array).array[(*array).size].labour_costs = labour_costs;
	(*array).array[(*array).size].capital_costs = capital_costs;
	(*array).array[(*array).size].energy_costs = energy_costs;
	(*array).array[(*array).size].tax_payment = tax_payment;
	(*array).array[(*array).size].total_debt_installment_payment = total_debt_installment_payment;
	(*array).array[(*array).size].total_interest_payment = total_interest_payment;
	(*array).array[(*array).size].total_dividend_payment = total_dividend_payment;
	(*array).array[(*array).size].value_of_repurchased_shares = value_of_repurchased_shares;
	(*array).array[(*array).size].total_expenses = total_expenses;

	(*array).size++;
}

/** \fn void remove_firm_outflows_adt(firm_outflows_adt_array * array, int index)
 * \brief Remove an firm_outflows_adt from a dynamic firm_outflows_adt array.
 * \param array Pointer to the dynamic firm_outflows_adt array.
 * \param index The index of the firm_outflows_adt to remove.
 */
void remove_firm_outflows_adt(firm_outflows_adt_array * array, int index)
{
	int i;

	/* Free element at index index */
	free_firm_outflows_adt(&(*array).array[index]);

	/* Copy all elements up by one */
	if(index < (*array).size)
	{
		for(i = index; i < (*array).size - 1; i++)
		{
			copy_firm_outflows_adt(&(*array).array[i+1], &(*array).array[i]);
		}
		(*array).size--;
	}
}
/* Functions for the firm_inflows_adt datatype */
/** \fn firm_inflows_adt_array * init_firm_inflows_adt_array()
 * \brief Allocate memory for a dynamic firm_inflows_adt array.
 * \return firm_inflows_adt_array Pointer to the new dynamic firm_inflows_adt array.
 */
void init_firm_inflows_adt_array(firm_inflows_adt_array * array)
{
	(*array).size = 0;
	(*array).total_size = ARRAY_BLOCK_SIZE;
	(*array).array = (firm_inflows_adt *)malloc(ARRAY_BLOCK_SIZE * sizeof(firm_inflows_adt));
	CHECK_POINTER((*array).array);
}

/** \fn void reset_firm_inflows_adt_array(firm_inflows_adt_array* array)
* \brief Reset the firm_inflows_adt array to hold nothing.
* \param array Pointer to the dynamic firm_inflows_adt array.
*/
void reset_firm_inflows_adt_array(firm_inflows_adt_array * array)
{
	(*array).size = 0;
}

/** \fn void free_firm_inflows_adt_array(firm_inflows_adt_array * array)
* \brief Free the memory of a dynamic firm_inflows_adt array.
* \param array Pointer to the dynamic firm_inflows_adt array.
*/
void free_firm_inflows_adt_array(firm_inflows_adt_array * array)
{
	int i;
	
	for(i = 0; i < array->size; i++)
	{
		free_firm_inflows_adt(&(*array).array[i]);
	}
	
	free((*array).array);
}

void copy_firm_inflows_adt_array(firm_inflows_adt_array * from, firm_inflows_adt_array * to)
{
	int i;

	//to = init_firm_inflows_adt_array();

	for(i = 0; i < (*from).size; i++)
	{
		add_firm_inflows_adt(to, (*from).array[i].cum_revenue, (*from).array[i].new_loans, (*from).array[i].value_of_issued_shares, (*from).array[i].subsidy, (*from).array[i].total_income, (*from).array[i].deposit_interest, (*from).array[i].net_inflow);
	}
}

/** \fn void add_firm_inflows_adt(firm_inflows_adt_array * array, double cum_revenue, double new_loans, double value_of_issued_shares, double subsidy, double total_income, double deposit_interest, double net_inflow)
* \brief Add an firm_inflows_adt to the dynamic firm_inflows_adt array.
* \param array Pointer to the dynamic firm_inflows_adt array.
* \param new_int The firm_inflows_adt to add
*/
void add_firm_inflows_adt(firm_inflows_adt_array * array,  double cum_revenue,  double new_loans,  double value_of_issued_shares,  double subsidy,  double total_income,  double deposit_interest,  double net_inflow)
{
	if((*array).size == (*array).total_size)
	{
		(*array).total_size = (int)((*array).total_size * ARRAY_GROWTH_RATE);
		(*array).array = (firm_inflows_adt *)realloc((*array).array, ((*array).total_size * sizeof(firm_inflows_adt)));
	}
	init_firm_inflows_adt(&(*array).array[(*array).size]);
	(*array).array[(*array).size].cum_revenue = cum_revenue;
	(*array).array[(*array).size].new_loans = new_loans;
	(*array).array[(*array).size].value_of_issued_shares = value_of_issued_shares;
	(*array).array[(*array).size].subsidy = subsidy;
	(*array).array[(*array).size].total_income = total_income;
	(*array).array[(*array).size].deposit_interest = deposit_interest;
	(*array).array[(*array).size].net_inflow = net_inflow;

	(*array).size++;
}

/** \fn void remove_firm_inflows_adt(firm_inflows_adt_array * array, int index)
 * \brief Remove an firm_inflows_adt from a dynamic firm_inflows_adt array.
 * \param array Pointer to the dynamic firm_inflows_adt array.
 * \param index The index of the firm_inflows_adt to remove.
 */
void remove_firm_inflows_adt(firm_inflows_adt_array * array, int index)
{
	int i;

	/* Free element at index index */
	free_firm_inflows_adt(&(*array).array[index]);

	/* Copy all elements up by one */
	if(index < (*array).size)
	{
		for(i = index; i < (*array).size - 1; i++)
		{
			copy_firm_inflows_adt(&(*array).array[i+1], &(*array).array[i]);
		}
		(*array).size--;
	}
}
/* Functions for the household_stocks_adt datatype */
/** \fn household_stocks_adt_array * init_household_stocks_adt_array()
 * \brief Allocate memory for a dynamic household_stocks_adt array.
 * \return household_stocks_adt_array Pointer to the new dynamic household_stocks_adt array.
 */
void init_household_stocks_adt_array(household_stocks_adt_array * array)
{
	(*array).size = 0;
	(*array).total_size = ARRAY_BLOCK_SIZE;
	(*array).array = (household_stocks_adt *)malloc(ARRAY_BLOCK_SIZE * sizeof(household_stocks_adt));
	CHECK_POINTER((*array).array);
}

/** \fn void reset_household_stocks_adt_array(household_stocks_adt_array* array)
* \brief Reset the household_stocks_adt array to hold nothing.
* \param array Pointer to the dynamic household_stocks_adt array.
*/
void reset_household_stocks_adt_array(household_stocks_adt_array * array)
{
	(*array).size = 0;
}

/** \fn void free_household_stocks_adt_array(household_stocks_adt_array * array)
* \brief Free the memory of a dynamic household_stocks_adt array.
* \param array Pointer to the dynamic household_stocks_adt array.
*/
void free_household_stocks_adt_array(household_stocks_adt_array * array)
{
	int i;
	
	for(i = 0; i < array->size; i++)
	{
		free_household_stocks_adt(&(*array).array[i]);
	}
	
	free((*array).array);
}

void copy_household_stocks_adt_array(household_stocks_adt_array * from, household_stocks_adt_array * to)
{
	int i;

	//to = init_household_stocks_adt_array();

	for(i = 0; i < (*from).size; i++)
	{
		add_household_stocks_adt(to, (*from).array[i].payment_account, (*from).array[i].portfolio_value, (*from).array[i].total_assets, (*from).array[i].total_liabilities, (*from).array[i].nr_assets, (*from).array[i].payment_account_day_1, (*from).array[i].payment_account_day_20);
	}
}

/** \fn void add_household_stocks_adt(household_stocks_adt_array * array, double payment_account, double portfolio_value, double total_assets, double total_liabilities, int nr_assets, double payment_account_day_1, double payment_account_day_20)
* \brief Add an household_stocks_adt to the dynamic household_stocks_adt array.
* \param array Pointer to the dynamic household_stocks_adt array.
* \param new_int The household_stocks_adt to add
*/
void add_household_stocks_adt(household_stocks_adt_array * array,  double payment_account,  double portfolio_value,  double total_assets,  double total_liabilities,  int nr_assets,  double payment_account_day_1,  double payment_account_day_20)
{
	if((*array).size == (*array).total_size)
	{
		(*array).total_size = (int)((*array).total_size * ARRAY_GROWTH_RATE);
		(*array).array = (household_stocks_adt *)realloc((*array).array, ((*array).total_size * sizeof(household_stocks_adt)));
	}
	init_household_stocks_adt(&(*array).array[(*array).size]);
	(*array).array[(*array).size].payment_account = payment_account;
	(*array).array[(*array).size].portfolio_value = portfolio_value;
	(*array).array[(*array).size].total_assets = total_assets;
	(*array).array[(*array).size].total_liabilities = total_liabilities;
	(*array).array[(*array).size].nr_assets = nr_assets;
	(*array).array[(*array).size].payment_account_day_1 = payment_account_day_1;
	(*array).array[(*array).size].payment_account_day_20 = payment_account_day_20;

	(*array).size++;
}

/** \fn void remove_household_stocks_adt(household_stocks_adt_array * array, int index)
 * \brief Remove an household_stocks_adt from a dynamic household_stocks_adt array.
 * \param array Pointer to the dynamic household_stocks_adt array.
 * \param index The index of the household_stocks_adt to remove.
 */
void remove_household_stocks_adt(household_stocks_adt_array * array, int index)
{
	int i;

	/* Free element at index index */
	free_household_stocks_adt(&(*array).array[index]);

	/* Copy all elements up by one */
	if(index < (*array).size)
	{
		for(i = index; i < (*array).size - 1; i++)
		{
			copy_household_stocks_adt(&(*array).array[i+1], &(*array).array[i]);
		}
		(*array).size--;
	}
}
/* Functions for the household_outflows_adt datatype */
/** \fn household_outflows_adt_array * init_household_outflows_adt_array()
 * \brief Allocate memory for a dynamic household_outflows_adt array.
 * \return household_outflows_adt_array Pointer to the new dynamic household_outflows_adt array.
 */
void init_household_outflows_adt_array(household_outflows_adt_array * array)
{
	(*array).size = 0;
	(*array).total_size = ARRAY_BLOCK_SIZE;
	(*array).array = (household_outflows_adt *)malloc(ARRAY_BLOCK_SIZE * sizeof(household_outflows_adt));
	CHECK_POINTER((*array).array);
}

/** \fn void reset_household_outflows_adt_array(household_outflows_adt_array* array)
* \brief Reset the household_outflows_adt array to hold nothing.
* \param array Pointer to the dynamic household_outflows_adt array.
*/
void reset_household_outflows_adt_array(household_outflows_adt_array * array)
{
	(*array).size = 0;
}

/** \fn void free_household_outflows_adt_array(household_outflows_adt_array * array)
* \brief Free the memory of a dynamic household_outflows_adt array.
* \param array Pointer to the dynamic household_outflows_adt array.
*/
void free_household_outflows_adt_array(household_outflows_adt_array * array)
{
	int i;
	
	for(i = 0; i < array->size; i++)
	{
		free_household_outflows_adt(&(*array).array[i]);
	}
	
	free((*array).array);
}

void copy_household_outflows_adt_array(household_outflows_adt_array * from, household_outflows_adt_array * to)
{
	int i;

	//to = init_household_outflows_adt_array();

	for(i = 0; i < (*from).size; i++)
	{
		add_household_outflows_adt(to, (*from).array[i].consumption_expenditure, (*from).array[i].tax_payment, (*from).array[i].restitution_payment, (*from).array[i].asset_purchases, (*from).array[i].total_expenses);
	}
}

/** \fn void add_household_outflows_adt(household_outflows_adt_array * array, double consumption_expenditure, double tax_payment, double restitution_payment, double asset_purchases, double total_expenses)
* \brief Add an household_outflows_adt to the dynamic household_outflows_adt array.
* \param array Pointer to the dynamic household_outflows_adt array.
* \param new_int The household_outflows_adt to add
*/
void add_household_outflows_adt(household_outflows_adt_array * array,  double consumption_expenditure,  double tax_payment,  double restitution_payment,  double asset_purchases,  double total_expenses)
{
	if((*array).size == (*array).total_size)
	{
		(*array).total_size = (int)((*array).total_size * ARRAY_GROWTH_RATE);
		(*array).array = (household_outflows_adt *)realloc((*array).array, ((*array).total_size * sizeof(household_outflows_adt)));
	}
	init_household_outflows_adt(&(*array).array[(*array).size]);
	(*array).array[(*array).size].consumption_expenditure = consumption_expenditure;
	(*array).array[(*array).size].tax_payment = tax_payment;
	(*array).array[(*array).size].restitution_payment = restitution_payment;
	(*array).array[(*array).size].asset_purchases = asset_purchases;
	(*array).array[(*array).size].total_expenses = total_expenses;

	(*array).size++;
}

/** \fn void remove_household_outflows_adt(household_outflows_adt_array * array, int index)
 * \brief Remove an household_outflows_adt from a dynamic household_outflows_adt array.
 * \param array Pointer to the dynamic household_outflows_adt array.
 * \param index The index of the household_outflows_adt to remove.
 */
void remove_household_outflows_adt(household_outflows_adt_array * array, int index)
{
	int i;

	/* Free element at index index */
	free_household_outflows_adt(&(*array).array[index]);

	/* Copy all elements up by one */
	if(index < (*array).size)
	{
		for(i = index; i < (*array).size - 1; i++)
		{
			copy_household_outflows_adt(&(*array).array[i+1], &(*array).array[i]);
		}
		(*array).size--;
	}
}
/* Functions for the household_inflows_adt datatype */
/** \fn household_inflows_adt_array * init_household_inflows_adt_array()
 * \brief Allocate memory for a dynamic household_inflows_adt array.
 * \return household_inflows_adt_array Pointer to the new dynamic household_inflows_adt array.
 */
void init_household_inflows_adt_array(household_inflows_adt_array * array)
{
	(*array).size = 0;
	(*array).total_size = ARRAY_BLOCK_SIZE;
	(*array).array = (household_inflows_adt *)malloc(ARRAY_BLOCK_SIZE * sizeof(household_inflows_adt));
	CHECK_POINTER((*array).array);
}

/** \fn void reset_household_inflows_adt_array(household_inflows_adt_array* array)
* \brief Reset the household_inflows_adt array to hold nothing.
* \param array Pointer to the dynamic household_inflows_adt array.
*/
void reset_household_inflows_adt_array(household_inflows_adt_array * array)
{
	(*array).size = 0;
}

/** \fn void free_household_inflows_adt_array(household_inflows_adt_array * array)
* \brief Free the memory of a dynamic household_inflows_adt array.
* \param array Pointer to the dynamic household_inflows_adt array.
*/
void free_household_inflows_adt_array(household_inflows_adt_array * array)
{
	int i;
	
	for(i = 0; i < array->size; i++)
	{
		free_household_inflows_adt(&(*array).array[i]);
	}
	
	free((*array).array);
}

void copy_household_inflows_adt_array(household_inflows_adt_array * from, household_inflows_adt_array * to)
{
	int i;

	//to = init_household_inflows_adt_array();

	for(i = 0; i < (*from).size; i++)
	{
		add_household_inflows_adt(to, (*from).array[i].wage, (*from).array[i].unemployment_benefit, (*from).array[i].subsidies, (*from).array[i].transfer, (*from).array[i].gov_interest, (*from).array[i].asset_sales, (*from).array[i].total_dividends, (*from).array[i].deposit_interest, (*from).array[i].total_income, (*from).array[i].net_inflow);
	}
}

/** \fn void add_household_inflows_adt(household_inflows_adt_array * array, double wage, double unemployment_benefit, double subsidies, double transfer, double gov_interest, double asset_sales, double total_dividends, double deposit_interest, double total_income, double net_inflow)
* \brief Add an household_inflows_adt to the dynamic household_inflows_adt array.
* \param array Pointer to the dynamic household_inflows_adt array.
* \param new_int The household_inflows_adt to add
*/
void add_household_inflows_adt(household_inflows_adt_array * array,  double wage,  double unemployment_benefit,  double subsidies,  double transfer,  double gov_interest,  double asset_sales,  double total_dividends,  double deposit_interest,  double total_income,  double net_inflow)
{
	if((*array).size == (*array).total_size)
	{
		(*array).total_size = (int)((*array).total_size * ARRAY_GROWTH_RATE);
		(*array).array = (household_inflows_adt *)realloc((*array).array, ((*array).total_size * sizeof(household_inflows_adt)));
	}
	init_household_inflows_adt(&(*array).array[(*array).size]);
	(*array).array[(*array).size].wage = wage;
	(*array).array[(*array).size].unemployment_benefit = unemployment_benefit;
	(*array).array[(*array).size].subsidies = subsidies;
	(*array).array[(*array).size].transfer = transfer;
	(*array).array[(*array).size].gov_interest = gov_interest;
	(*array).array[(*array).size].asset_sales = asset_sales;
	(*array).array[(*array).size].total_dividends = total_dividends;
	(*array).array[(*array).size].deposit_interest = deposit_interest;
	(*array).array[(*array).size].total_income = total_income;
	(*array).array[(*array).size].net_inflow = net_inflow;

	(*array).size++;
}

/** \fn void remove_household_inflows_adt(household_inflows_adt_array * array, int index)
 * \brief Remove an household_inflows_adt from a dynamic household_inflows_adt array.
 * \param array Pointer to the dynamic household_inflows_adt array.
 * \param index The index of the household_inflows_adt to remove.
 */
void remove_household_inflows_adt(household_inflows_adt_array * array, int index)
{
	int i;

	/* Free element at index index */
	free_household_inflows_adt(&(*array).array[index]);

	/* Copy all elements up by one */
	if(index < (*array).size)
	{
		for(i = index; i < (*array).size - 1; i++)
		{
			copy_household_inflows_adt(&(*array).array[i+1], &(*array).array[i]);
		}
		(*array).size--;
	}
}
/* Functions for the igfirm_stocks_adt datatype */
/** \fn igfirm_stocks_adt_array * init_igfirm_stocks_adt_array()
 * \brief Allocate memory for a dynamic igfirm_stocks_adt array.
 * \return igfirm_stocks_adt_array Pointer to the new dynamic igfirm_stocks_adt array.
 */
void init_igfirm_stocks_adt_array(igfirm_stocks_adt_array * array)
{
	(*array).size = 0;
	(*array).total_size = ARRAY_BLOCK_SIZE;
	(*array).array = (igfirm_stocks_adt *)malloc(ARRAY_BLOCK_SIZE * sizeof(igfirm_stocks_adt));
	CHECK_POINTER((*array).array);
}

/** \fn void reset_igfirm_stocks_adt_array(igfirm_stocks_adt_array* array)
* \brief Reset the igfirm_stocks_adt array to hold nothing.
* \param array Pointer to the dynamic igfirm_stocks_adt array.
*/
void reset_igfirm_stocks_adt_array(igfirm_stocks_adt_array * array)
{
	(*array).size = 0;
}

/** \fn void free_igfirm_stocks_adt_array(igfirm_stocks_adt_array * array)
* \brief Free the memory of a dynamic igfirm_stocks_adt array.
* \param array Pointer to the dynamic igfirm_stocks_adt array.
*/
void free_igfirm_stocks_adt_array(igfirm_stocks_adt_array * array)
{
	int i;
	
	for(i = 0; i < array->size; i++)
	{
		free_igfirm_stocks_adt(&(*array).array[i]);
	}
	
	free((*array).array);
}

void copy_igfirm_stocks_adt_array(igfirm_stocks_adt_array * from, igfirm_stocks_adt_array * to)
{
	int i;

	//to = init_igfirm_stocks_adt_array();

	for(i = 0; i < (*from).size; i++)
	{
		add_igfirm_stocks_adt(to, (*from).array[i].payment_account, (*from).array[i].total_value_local_inventory, (*from).array[i].total_value_capital_stock, (*from).array[i].total_assets, (*from).array[i].total_debt, (*from).array[i].equity, (*from).array[i].total_liabilities, (*from).array[i].current_shares_outstanding, (*from).array[i].payment_account_day_1, (*from).array[i].payment_account_day_20);
	}
}

/** \fn void add_igfirm_stocks_adt(igfirm_stocks_adt_array * array, double payment_account, double total_value_local_inventory, double total_value_capital_stock, double total_assets, double total_debt, double equity, double total_liabilities, int current_shares_outstanding, double payment_account_day_1, double payment_account_day_20)
* \brief Add an igfirm_stocks_adt to the dynamic igfirm_stocks_adt array.
* \param array Pointer to the dynamic igfirm_stocks_adt array.
* \param new_int The igfirm_stocks_adt to add
*/
void add_igfirm_stocks_adt(igfirm_stocks_adt_array * array,  double payment_account,  double total_value_local_inventory,  double total_value_capital_stock,  double total_assets,  double total_debt,  double equity,  double total_liabilities,  int current_shares_outstanding,  double payment_account_day_1,  double payment_account_day_20)
{
	if((*array).size == (*array).total_size)
	{
		(*array).total_size = (int)((*array).total_size * ARRAY_GROWTH_RATE);
		(*array).array = (igfirm_stocks_adt *)realloc((*array).array, ((*array).total_size * sizeof(igfirm_stocks_adt)));
	}
	init_igfirm_stocks_adt(&(*array).array[(*array).size]);
	(*array).array[(*array).size].payment_account = payment_account;
	(*array).array[(*array).size].total_value_local_inventory = total_value_local_inventory;
	(*array).array[(*array).size].total_value_capital_stock = total_value_capital_stock;
	(*array).array[(*array).size].total_assets = total_assets;
	(*array).array[(*array).size].total_debt = total_debt;
	(*array).array[(*array).size].equity = equity;
	(*array).array[(*array).size].total_liabilities = total_liabilities;
	(*array).array[(*array).size].current_shares_outstanding = current_shares_outstanding;
	(*array).array[(*array).size].payment_account_day_1 = payment_account_day_1;
	(*array).array[(*array).size].payment_account_day_20 = payment_account_day_20;

	(*array).size++;
}

/** \fn void remove_igfirm_stocks_adt(igfirm_stocks_adt_array * array, int index)
 * \brief Remove an igfirm_stocks_adt from a dynamic igfirm_stocks_adt array.
 * \param array Pointer to the dynamic igfirm_stocks_adt array.
 * \param index The index of the igfirm_stocks_adt to remove.
 */
void remove_igfirm_stocks_adt(igfirm_stocks_adt_array * array, int index)
{
	int i;

	/* Free element at index index */
	free_igfirm_stocks_adt(&(*array).array[index]);

	/* Copy all elements up by one */
	if(index < (*array).size)
	{
		for(i = index; i < (*array).size - 1; i++)
		{
			copy_igfirm_stocks_adt(&(*array).array[i+1], &(*array).array[i]);
		}
		(*array).size--;
	}
}
/* Functions for the igfirm_outflows_adt datatype */
/** \fn igfirm_outflows_adt_array * init_igfirm_outflows_adt_array()
 * \brief Allocate memory for a dynamic igfirm_outflows_adt array.
 * \return igfirm_outflows_adt_array Pointer to the new dynamic igfirm_outflows_adt array.
 */
void init_igfirm_outflows_adt_array(igfirm_outflows_adt_array * array)
{
	(*array).size = 0;
	(*array).total_size = ARRAY_BLOCK_SIZE;
	(*array).array = (igfirm_outflows_adt *)malloc(ARRAY_BLOCK_SIZE * sizeof(igfirm_outflows_adt));
	CHECK_POINTER((*array).array);
}

/** \fn void reset_igfirm_outflows_adt_array(igfirm_outflows_adt_array* array)
* \brief Reset the igfirm_outflows_adt array to hold nothing.
* \param array Pointer to the dynamic igfirm_outflows_adt array.
*/
void reset_igfirm_outflows_adt_array(igfirm_outflows_adt_array * array)
{
	(*array).size = 0;
}

/** \fn void free_igfirm_outflows_adt_array(igfirm_outflows_adt_array * array)
* \brief Free the memory of a dynamic igfirm_outflows_adt array.
* \param array Pointer to the dynamic igfirm_outflows_adt array.
*/
void free_igfirm_outflows_adt_array(igfirm_outflows_adt_array * array)
{
	int i;
	
	for(i = 0; i < array->size; i++)
	{
		free_igfirm_outflows_adt(&(*array).array[i]);
	}
	
	free((*array).array);
}

void copy_igfirm_outflows_adt_array(igfirm_outflows_adt_array * from, igfirm_outflows_adt_array * to)
{
	int i;

	//to = init_igfirm_outflows_adt_array();

	for(i = 0; i < (*from).size; i++)
	{
		add_igfirm_outflows_adt(to, (*from).array[i].labour_costs, (*from).array[i].capital_costs, (*from).array[i].energy_costs, (*from).array[i].tax_payment, (*from).array[i].total_debt_installment_payment, (*from).array[i].total_interest_payment, (*from).array[i].total_dividend_payment, (*from).array[i].value_of_repurchased_shares, (*from).array[i].total_expenses);
	}
}

/** \fn void add_igfirm_outflows_adt(igfirm_outflows_adt_array * array, double labour_costs, double capital_costs, double energy_costs, double tax_payment, double total_debt_installment_payment, double total_interest_payment, double total_dividend_payment, double value_of_repurchased_shares, double total_expenses)
* \brief Add an igfirm_outflows_adt to the dynamic igfirm_outflows_adt array.
* \param array Pointer to the dynamic igfirm_outflows_adt array.
* \param new_int The igfirm_outflows_adt to add
*/
void add_igfirm_outflows_adt(igfirm_outflows_adt_array * array,  double labour_costs,  double capital_costs,  double energy_costs,  double tax_payment,  double total_debt_installment_payment,  double total_interest_payment,  double total_dividend_payment,  double value_of_repurchased_shares,  double total_expenses)
{
	if((*array).size == (*array).total_size)
	{
		(*array).total_size = (int)((*array).total_size * ARRAY_GROWTH_RATE);
		(*array).array = (igfirm_outflows_adt *)realloc((*array).array, ((*array).total_size * sizeof(igfirm_outflows_adt)));
	}
	init_igfirm_outflows_adt(&(*array).array[(*array).size]);
	(*array).array[(*array).size].labour_costs = labour_costs;
	(*array).array[(*array).size].capital_costs = capital_costs;
	(*array).array[(*array).size].energy_costs = energy_costs;
	(*array).array[(*array).size].tax_payment = tax_payment;
	(*array).array[(*array).size].total_debt_installment_payment = total_debt_installment_payment;
	(*array).array[(*array).size].total_interest_payment = total_interest_payment;
	(*array).array[(*array).size].total_dividend_payment = total_dividend_payment;
	(*array).array[(*array).size].value_of_repurchased_shares = value_of_repurchased_shares;
	(*array).array[(*array).size].total_expenses = total_expenses;

	(*array).size++;
}

/** \fn void remove_igfirm_outflows_adt(igfirm_outflows_adt_array * array, int index)
 * \brief Remove an igfirm_outflows_adt from a dynamic igfirm_outflows_adt array.
 * \param array Pointer to the dynamic igfirm_outflows_adt array.
 * \param index The index of the igfirm_outflows_adt to remove.
 */
void remove_igfirm_outflows_adt(igfirm_outflows_adt_array * array, int index)
{
	int i;

	/* Free element at index index */
	free_igfirm_outflows_adt(&(*array).array[index]);

	/* Copy all elements up by one */
	if(index < (*array).size)
	{
		for(i = index; i < (*array).size - 1; i++)
		{
			copy_igfirm_outflows_adt(&(*array).array[i+1], &(*array).array[i]);
		}
		(*array).size--;
	}
}
/* Functions for the igfirm_inflows_adt datatype */
/** \fn igfirm_inflows_adt_array * init_igfirm_inflows_adt_array()
 * \brief Allocate memory for a dynamic igfirm_inflows_adt array.
 * \return igfirm_inflows_adt_array Pointer to the new dynamic igfirm_inflows_adt array.
 */
void init_igfirm_inflows_adt_array(igfirm_inflows_adt_array * array)
{
	(*array).size = 0;
	(*array).total_size = ARRAY_BLOCK_SIZE;
	(*array).array = (igfirm_inflows_adt *)malloc(ARRAY_BLOCK_SIZE * sizeof(igfirm_inflows_adt));
	CHECK_POINTER((*array).array);
}

/** \fn void reset_igfirm_inflows_adt_array(igfirm_inflows_adt_array* array)
* \brief Reset the igfirm_inflows_adt array to hold nothing.
* \param array Pointer to the dynamic igfirm_inflows_adt array.
*/
void reset_igfirm_inflows_adt_array(igfirm_inflows_adt_array * array)
{
	(*array).size = 0;
}

/** \fn void free_igfirm_inflows_adt_array(igfirm_inflows_adt_array * array)
* \brief Free the memory of a dynamic igfirm_inflows_adt array.
* \param array Pointer to the dynamic igfirm_inflows_adt array.
*/
void free_igfirm_inflows_adt_array(igfirm_inflows_adt_array * array)
{
	int i;
	
	for(i = 0; i < array->size; i++)
	{
		free_igfirm_inflows_adt(&(*array).array[i]);
	}
	
	free((*array).array);
}

void copy_igfirm_inflows_adt_array(igfirm_inflows_adt_array * from, igfirm_inflows_adt_array * to)
{
	int i;

	//to = init_igfirm_inflows_adt_array();

	for(i = 0; i < (*from).size; i++)
	{
		add_igfirm_inflows_adt(to, (*from).array[i].cum_revenue, (*from).array[i].new_loans, (*from).array[i].value_of_issued_shares, (*from).array[i].subsidy, (*from).array[i].total_income, (*from).array[i].deposit_interest, (*from).array[i].net_inflow);
	}
}

/** \fn void add_igfirm_inflows_adt(igfirm_inflows_adt_array * array, double cum_revenue, double new_loans, double value_of_issued_shares, double subsidy, double total_income, double deposit_interest, double net_inflow)
* \brief Add an igfirm_inflows_adt to the dynamic igfirm_inflows_adt array.
* \param array Pointer to the dynamic igfirm_inflows_adt array.
* \param new_int The igfirm_inflows_adt to add
*/
void add_igfirm_inflows_adt(igfirm_inflows_adt_array * array,  double cum_revenue,  double new_loans,  double value_of_issued_shares,  double subsidy,  double total_income,  double deposit_interest,  double net_inflow)
{
	if((*array).size == (*array).total_size)
	{
		(*array).total_size = (int)((*array).total_size * ARRAY_GROWTH_RATE);
		(*array).array = (igfirm_inflows_adt *)realloc((*array).array, ((*array).total_size * sizeof(igfirm_inflows_adt)));
	}
	init_igfirm_inflows_adt(&(*array).array[(*array).size]);
	(*array).array[(*array).size].cum_revenue = cum_revenue;
	(*array).array[(*array).size].new_loans = new_loans;
	(*array).array[(*array).size].value_of_issued_shares = value_of_issued_shares;
	(*array).array[(*array).size].subsidy = subsidy;
	(*array).array[(*array).size].total_income = total_income;
	(*array).array[(*array).size].deposit_interest = deposit_interest;
	(*array).array[(*array).size].net_inflow = net_inflow;

	(*array).size++;
}

/** \fn void remove_igfirm_inflows_adt(igfirm_inflows_adt_array * array, int index)
 * \brief Remove an igfirm_inflows_adt from a dynamic igfirm_inflows_adt array.
 * \param array Pointer to the dynamic igfirm_inflows_adt array.
 * \param index The index of the igfirm_inflows_adt to remove.
 */
void remove_igfirm_inflows_adt(igfirm_inflows_adt_array * array, int index)
{
	int i;

	/* Free element at index index */
	free_igfirm_inflows_adt(&(*array).array[index]);

	/* Copy all elements up by one */
	if(index < (*array).size)
	{
		for(i = index; i < (*array).size - 1; i++)
		{
			copy_igfirm_inflows_adt(&(*array).array[i+1], &(*array).array[i]);
		}
		(*array).size--;
	}
}
/* Functions for the bank_stocks_adt datatype */
/** \fn bank_stocks_adt_array * init_bank_stocks_adt_array()
 * \brief Allocate memory for a dynamic bank_stocks_adt array.
 * \return bank_stocks_adt_array Pointer to the new dynamic bank_stocks_adt array.
 */
void init_bank_stocks_adt_array(bank_stocks_adt_array * array)
{
	(*array).size = 0;
	(*array).total_size = ARRAY_BLOCK_SIZE;
	(*array).array = (bank_stocks_adt *)malloc(ARRAY_BLOCK_SIZE * sizeof(bank_stocks_adt));
	CHECK_POINTER((*array).array);
}

/** \fn void reset_bank_stocks_adt_array(bank_stocks_adt_array* array)
* \brief Reset the bank_stocks_adt array to hold nothing.
* \param array Pointer to the dynamic bank_stocks_adt array.
*/
void reset_bank_stocks_adt_array(bank_stocks_adt_array * array)
{
	(*array).size = 0;
}

/** \fn void free_bank_stocks_adt_array(bank_stocks_adt_array * array)
* \brief Free the memory of a dynamic bank_stocks_adt array.
* \param array Pointer to the dynamic bank_stocks_adt array.
*/
void free_bank_stocks_adt_array(bank_stocks_adt_array * array)
{
	int i;
	
	for(i = 0; i < array->size; i++)
	{
		free_bank_stocks_adt(&(*array).array[i]);
	}
	
	free((*array).array);
}

void copy_bank_stocks_adt_array(bank_stocks_adt_array * from, bank_stocks_adt_array * to)
{
	int i;

	//to = init_bank_stocks_adt_array();

	for(i = 0; i < (*from).size; i++)
	{
		add_bank_stocks_adt(to, (*from).array[i].cash, (*from).array[i].total_credit, (*from).array[i].total_assets, (*from).array[i].deposits, (*from).array[i].ecb_debt, (*from).array[i].equity, (*from).array[i].total_liabilities, (*from).array[i].current_shares_outstanding, (*from).array[i].cash_day_1, (*from).array[i].cash_day_20);
	}
}

/** \fn void add_bank_stocks_adt(bank_stocks_adt_array * array, double cash, double total_credit, double total_assets, double deposits, double ecb_debt, double equity, double total_liabilities, int current_shares_outstanding, double cash_day_1, double cash_day_20)
* \brief Add an bank_stocks_adt to the dynamic bank_stocks_adt array.
* \param array Pointer to the dynamic bank_stocks_adt array.
* \param new_int The bank_stocks_adt to add
*/
void add_bank_stocks_adt(bank_stocks_adt_array * array,  double cash,  double total_credit,  double total_assets,  double deposits,  double ecb_debt,  double equity,  double total_liabilities,  int current_shares_outstanding,  double cash_day_1,  double cash_day_20)
{
	if((*array).size == (*array).total_size)
	{
		(*array).total_size = (int)((*array).total_size * ARRAY_GROWTH_RATE);
		(*array).array = (bank_stocks_adt *)realloc((*array).array, ((*array).total_size * sizeof(bank_stocks_adt)));
	}
	init_bank_stocks_adt(&(*array).array[(*array).size]);
	(*array).array[(*array).size].cash = cash;
	(*array).array[(*array).size].total_credit = total_credit;
	(*array).array[(*array).size].total_assets = total_assets;
	(*array).array[(*array).size].deposits = deposits;
	(*array).array[(*array).size].ecb_debt = ecb_debt;
	(*array).array[(*array).size].equity = equity;
	(*array).array[(*array).size].total_liabilities = total_liabilities;
	(*array).array[(*array).size].current_shares_outstanding = current_shares_outstanding;
	(*array).array[(*array).size].cash_day_1 = cash_day_1;
	(*array).array[(*array).size].cash_day_20 = cash_day_20;

	(*array).size++;
}

/** \fn void remove_bank_stocks_adt(bank_stocks_adt_array * array, int index)
 * \brief Remove an bank_stocks_adt from a dynamic bank_stocks_adt array.
 * \param array Pointer to the dynamic bank_stocks_adt array.
 * \param index The index of the bank_stocks_adt to remove.
 */
void remove_bank_stocks_adt(bank_stocks_adt_array * array, int index)
{
	int i;

	/* Free element at index index */
	free_bank_stocks_adt(&(*array).array[index]);

	/* Copy all elements up by one */
	if(index < (*array).size)
	{
		for(i = index; i < (*array).size - 1; i++)
		{
			copy_bank_stocks_adt(&(*array).array[i+1], &(*array).array[i]);
		}
		(*array).size--;
	}
}
/* Functions for the bank_outflows_adt datatype */
/** \fn bank_outflows_adt_array * init_bank_outflows_adt_array()
 * \brief Allocate memory for a dynamic bank_outflows_adt array.
 * \return bank_outflows_adt_array Pointer to the new dynamic bank_outflows_adt array.
 */
void init_bank_outflows_adt_array(bank_outflows_adt_array * array)
{
	(*array).size = 0;
	(*array).total_size = ARRAY_BLOCK_SIZE;
	(*array).array = (bank_outflows_adt *)malloc(ARRAY_BLOCK_SIZE * sizeof(bank_outflows_adt));
	CHECK_POINTER((*array).array);
}

/** \fn void reset_bank_outflows_adt_array(bank_outflows_adt_array* array)
* \brief Reset the bank_outflows_adt array to hold nothing.
* \param array Pointer to the dynamic bank_outflows_adt array.
*/
void reset_bank_outflows_adt_array(bank_outflows_adt_array * array)
{
	(*array).size = 0;
}

/** \fn void free_bank_outflows_adt_array(bank_outflows_adt_array * array)
* \brief Free the memory of a dynamic bank_outflows_adt array.
* \param array Pointer to the dynamic bank_outflows_adt array.
*/
void free_bank_outflows_adt_array(bank_outflows_adt_array * array)
{
	int i;
	
	for(i = 0; i < array->size; i++)
	{
		free_bank_outflows_adt(&(*array).array[i]);
	}
	
	free((*array).array);
}

void copy_bank_outflows_adt_array(bank_outflows_adt_array * from, bank_outflows_adt_array * to)
{
	int i;

	//to = init_bank_outflows_adt_array();

	for(i = 0; i < (*from).size; i++)
	{
		add_bank_outflows_adt(to, (*from).array[i].firm_loan_issues, (*from).array[i].debt_installment_to_ecb, (*from).array[i].ecb_interest_payment, (*from).array[i].deposit_interest_payment, (*from).array[i].dividend_payment, (*from).array[i].tax_payment, (*from).array[i].deposit_outflow, (*from).array[i].total_expenses);
	}
}

/** \fn void add_bank_outflows_adt(bank_outflows_adt_array * array, double firm_loan_issues, double debt_installment_to_ecb, double ecb_interest_payment, double deposit_interest_payment, double dividend_payment, double tax_payment, double deposit_outflow, double total_expenses)
* \brief Add an bank_outflows_adt to the dynamic bank_outflows_adt array.
* \param array Pointer to the dynamic bank_outflows_adt array.
* \param new_int The bank_outflows_adt to add
*/
void add_bank_outflows_adt(bank_outflows_adt_array * array,  double firm_loan_issues,  double debt_installment_to_ecb,  double ecb_interest_payment,  double deposit_interest_payment,  double dividend_payment,  double tax_payment,  double deposit_outflow,  double total_expenses)
{
	if((*array).size == (*array).total_size)
	{
		(*array).total_size = (int)((*array).total_size * ARRAY_GROWTH_RATE);
		(*array).array = (bank_outflows_adt *)realloc((*array).array, ((*array).total_size * sizeof(bank_outflows_adt)));
	}
	init_bank_outflows_adt(&(*array).array[(*array).size]);
	(*array).array[(*array).size].firm_loan_issues = firm_loan_issues;
	(*array).array[(*array).size].debt_installment_to_ecb = debt_installment_to_ecb;
	(*array).array[(*array).size].ecb_interest_payment = ecb_interest_payment;
	(*array).array[(*array).size].deposit_interest_payment = deposit_interest_payment;
	(*array).array[(*array).size].dividend_payment = dividend_payment;
	(*array).array[(*array).size].tax_payment = tax_payment;
	(*array).array[(*array).size].deposit_outflow = deposit_outflow;
	(*array).array[(*array).size].total_expenses = total_expenses;

	(*array).size++;
}

/** \fn void remove_bank_outflows_adt(bank_outflows_adt_array * array, int index)
 * \brief Remove an bank_outflows_adt from a dynamic bank_outflows_adt array.
 * \param array Pointer to the dynamic bank_outflows_adt array.
 * \param index The index of the bank_outflows_adt to remove.
 */
void remove_bank_outflows_adt(bank_outflows_adt_array * array, int index)
{
	int i;

	/* Free element at index index */
	free_bank_outflows_adt(&(*array).array[index]);

	/* Copy all elements up by one */
	if(index < (*array).size)
	{
		for(i = index; i < (*array).size - 1; i++)
		{
			copy_bank_outflows_adt(&(*array).array[i+1], &(*array).array[i]);
		}
		(*array).size--;
	}
}
/* Functions for the bank_inflows_adt datatype */
/** \fn bank_inflows_adt_array * init_bank_inflows_adt_array()
 * \brief Allocate memory for a dynamic bank_inflows_adt array.
 * \return bank_inflows_adt_array Pointer to the new dynamic bank_inflows_adt array.
 */
void init_bank_inflows_adt_array(bank_inflows_adt_array * array)
{
	(*array).size = 0;
	(*array).total_size = ARRAY_BLOCK_SIZE;
	(*array).array = (bank_inflows_adt *)malloc(ARRAY_BLOCK_SIZE * sizeof(bank_inflows_adt));
	CHECK_POINTER((*array).array);
}

/** \fn void reset_bank_inflows_adt_array(bank_inflows_adt_array* array)
* \brief Reset the bank_inflows_adt array to hold nothing.
* \param array Pointer to the dynamic bank_inflows_adt array.
*/
void reset_bank_inflows_adt_array(bank_inflows_adt_array * array)
{
	(*array).size = 0;
}

/** \fn void free_bank_inflows_adt_array(bank_inflows_adt_array * array)
* \brief Free the memory of a dynamic bank_inflows_adt array.
* \param array Pointer to the dynamic bank_inflows_adt array.
*/
void free_bank_inflows_adt_array(bank_inflows_adt_array * array)
{
	int i;
	
	for(i = 0; i < array->size; i++)
	{
		free_bank_inflows_adt(&(*array).array[i]);
	}
	
	free((*array).array);
}

void copy_bank_inflows_adt_array(bank_inflows_adt_array * from, bank_inflows_adt_array * to)
{
	int i;

	//to = init_bank_inflows_adt_array();

	for(i = 0; i < (*from).size; i++)
	{
		add_bank_inflows_adt(to, (*from).array[i].firm_loan_installments, (*from).array[i].firm_interest_payments, (*from).array[i].new_ecb_debt, (*from).array[i].deposit_inflow, (*from).array[i].total_income, (*from).array[i].net_inflow, (*from).array[i].net_deposit_inflow);
	}
}

/** \fn void add_bank_inflows_adt(bank_inflows_adt_array * array, double firm_loan_installments, double firm_interest_payments, double new_ecb_debt, double deposit_inflow, double total_income, double net_inflow, double net_deposit_inflow)
* \brief Add an bank_inflows_adt to the dynamic bank_inflows_adt array.
* \param array Pointer to the dynamic bank_inflows_adt array.
* \param new_int The bank_inflows_adt to add
*/
void add_bank_inflows_adt(bank_inflows_adt_array * array,  double firm_loan_installments,  double firm_interest_payments,  double new_ecb_debt,  double deposit_inflow,  double total_income,  double net_inflow,  double net_deposit_inflow)
{
	if((*array).size == (*array).total_size)
	{
		(*array).total_size = (int)((*array).total_size * ARRAY_GROWTH_RATE);
		(*array).array = (bank_inflows_adt *)realloc((*array).array, ((*array).total_size * sizeof(bank_inflows_adt)));
	}
	init_bank_inflows_adt(&(*array).array[(*array).size]);
	(*array).array[(*array).size].firm_loan_installments = firm_loan_installments;
	(*array).array[(*array).size].firm_interest_payments = firm_interest_payments;
	(*array).array[(*array).size].new_ecb_debt = new_ecb_debt;
	(*array).array[(*array).size].deposit_inflow = deposit_inflow;
	(*array).array[(*array).size].total_income = total_income;
	(*array).array[(*array).size].net_inflow = net_inflow;
	(*array).array[(*array).size].net_deposit_inflow = net_deposit_inflow;

	(*array).size++;
}

/** \fn void remove_bank_inflows_adt(bank_inflows_adt_array * array, int index)
 * \brief Remove an bank_inflows_adt from a dynamic bank_inflows_adt array.
 * \param array Pointer to the dynamic bank_inflows_adt array.
 * \param index The index of the bank_inflows_adt to remove.
 */
void remove_bank_inflows_adt(bank_inflows_adt_array * array, int index)
{
	int i;

	/* Free element at index index */
	free_bank_inflows_adt(&(*array).array[index]);

	/* Copy all elements up by one */
	if(index < (*array).size)
	{
		for(i = index; i < (*array).size - 1; i++)
		{
			copy_bank_inflows_adt(&(*array).array[i+1], &(*array).array[i]);
		}
		(*array).size--;
	}
}
/* Functions for the gov_stocks_adt datatype */
/** \fn gov_stocks_adt_array * init_gov_stocks_adt_array()
 * \brief Allocate memory for a dynamic gov_stocks_adt array.
 * \return gov_stocks_adt_array Pointer to the new dynamic gov_stocks_adt array.
 */
void init_gov_stocks_adt_array(gov_stocks_adt_array * array)
{
	(*array).size = 0;
	(*array).total_size = ARRAY_BLOCK_SIZE;
	(*array).array = (gov_stocks_adt *)malloc(ARRAY_BLOCK_SIZE * sizeof(gov_stocks_adt));
	CHECK_POINTER((*array).array);
}

/** \fn void reset_gov_stocks_adt_array(gov_stocks_adt_array* array)
* \brief Reset the gov_stocks_adt array to hold nothing.
* \param array Pointer to the dynamic gov_stocks_adt array.
*/
void reset_gov_stocks_adt_array(gov_stocks_adt_array * array)
{
	(*array).size = 0;
}

/** \fn void free_gov_stocks_adt_array(gov_stocks_adt_array * array)
* \brief Free the memory of a dynamic gov_stocks_adt array.
* \param array Pointer to the dynamic gov_stocks_adt array.
*/
void free_gov_stocks_adt_array(gov_stocks_adt_array * array)
{
	int i;
	
	for(i = 0; i < array->size; i++)
	{
		free_gov_stocks_adt(&(*array).array[i]);
	}
	
	free((*array).array);
}

void copy_gov_stocks_adt_array(gov_stocks_adt_array * from, gov_stocks_adt_array * to)
{
	int i;

	//to = init_gov_stocks_adt_array();

	for(i = 0; i < (*from).size; i++)
	{
		add_gov_stocks_adt(to, (*from).array[i].payment_account, (*from).array[i].total_assets, (*from).array[i].value_bonds_outstanding, (*from).array[i].ecb_money, (*from).array[i].equity, (*from).array[i].total_liabilities, (*from).array[i].nr_bonds_outstanding, (*from).array[i].payment_account_day_1, (*from).array[i].payment_account_day_20);
	}
}

/** \fn void add_gov_stocks_adt(gov_stocks_adt_array * array, double payment_account, double total_assets, double value_bonds_outstanding, double ecb_money, double equity, double total_liabilities, int nr_bonds_outstanding, double payment_account_day_1, double payment_account_day_20)
* \brief Add an gov_stocks_adt to the dynamic gov_stocks_adt array.
* \param array Pointer to the dynamic gov_stocks_adt array.
* \param new_int The gov_stocks_adt to add
*/
void add_gov_stocks_adt(gov_stocks_adt_array * array,  double payment_account,  double total_assets,  double value_bonds_outstanding,  double ecb_money,  double equity,  double total_liabilities,  int nr_bonds_outstanding,  double payment_account_day_1,  double payment_account_day_20)
{
	if((*array).size == (*array).total_size)
	{
		(*array).total_size = (int)((*array).total_size * ARRAY_GROWTH_RATE);
		(*array).array = (gov_stocks_adt *)realloc((*array).array, ((*array).total_size * sizeof(gov_stocks_adt)));
	}
	init_gov_stocks_adt(&(*array).array[(*array).size]);
	(*array).array[(*array).size].payment_account = payment_account;
	(*array).array[(*array).size].total_assets = total_assets;
	(*array).array[(*array).size].value_bonds_outstanding = value_bonds_outstanding;
	(*array).array[(*array).size].ecb_money = ecb_money;
	(*array).array[(*array).size].equity = equity;
	(*array).array[(*array).size].total_liabilities = total_liabilities;
	(*array).array[(*array).size].nr_bonds_outstanding = nr_bonds_outstanding;
	(*array).array[(*array).size].payment_account_day_1 = payment_account_day_1;
	(*array).array[(*array).size].payment_account_day_20 = payment_account_day_20;

	(*array).size++;
}

/** \fn void remove_gov_stocks_adt(gov_stocks_adt_array * array, int index)
 * \brief Remove an gov_stocks_adt from a dynamic gov_stocks_adt array.
 * \param array Pointer to the dynamic gov_stocks_adt array.
 * \param index The index of the gov_stocks_adt to remove.
 */
void remove_gov_stocks_adt(gov_stocks_adt_array * array, int index)
{
	int i;

	/* Free element at index index */
	free_gov_stocks_adt(&(*array).array[index]);

	/* Copy all elements up by one */
	if(index < (*array).size)
	{
		for(i = index; i < (*array).size - 1; i++)
		{
			copy_gov_stocks_adt(&(*array).array[i+1], &(*array).array[i]);
		}
		(*array).size--;
	}
}
/* Functions for the gov_outflows_adt datatype */
/** \fn gov_outflows_adt_array * init_gov_outflows_adt_array()
 * \brief Allocate memory for a dynamic gov_outflows_adt array.
 * \return gov_outflows_adt_array Pointer to the new dynamic gov_outflows_adt array.
 */
void init_gov_outflows_adt_array(gov_outflows_adt_array * array)
{
	(*array).size = 0;
	(*array).total_size = ARRAY_BLOCK_SIZE;
	(*array).array = (gov_outflows_adt *)malloc(ARRAY_BLOCK_SIZE * sizeof(gov_outflows_adt));
	CHECK_POINTER((*array).array);
}

/** \fn void reset_gov_outflows_adt_array(gov_outflows_adt_array* array)
* \brief Reset the gov_outflows_adt array to hold nothing.
* \param array Pointer to the dynamic gov_outflows_adt array.
*/
void reset_gov_outflows_adt_array(gov_outflows_adt_array * array)
{
	(*array).size = 0;
}

/** \fn void free_gov_outflows_adt_array(gov_outflows_adt_array * array)
* \brief Free the memory of a dynamic gov_outflows_adt array.
* \param array Pointer to the dynamic gov_outflows_adt array.
*/
void free_gov_outflows_adt_array(gov_outflows_adt_array * array)
{
	int i;
	
	for(i = 0; i < array->size; i++)
	{
		free_gov_outflows_adt(&(*array).array[i]);
	}
	
	free((*array).array);
}

void copy_gov_outflows_adt_array(gov_outflows_adt_array * from, gov_outflows_adt_array * to)
{
	int i;

	//to = init_gov_outflows_adt_array();

	for(i = 0; i < (*from).size; i++)
	{
		add_gov_outflows_adt(to, (*from).array[i].investment_expenditure, (*from).array[i].consumption_expenditure, (*from).array[i].benefit_payment, (*from).array[i].subsidy_payment_household, (*from).array[i].subsidy_payment_firm, (*from).array[i].transfer_payment_household, (*from).array[i].transfer_payment_firm, (*from).array[i].bond_interest_payment, (*from).array[i].debt_installment, (*from).array[i].total_bond_repurchase, (*from).array[i].total_expenses);
	}
}

/** \fn void add_gov_outflows_adt(gov_outflows_adt_array * array, double investment_expenditure, double consumption_expenditure, double benefit_payment, double subsidy_payment_household, double subsidy_payment_firm, double transfer_payment_household, double transfer_payment_firm, double bond_interest_payment, double debt_installment, double total_bond_repurchase, double total_expenses)
* \brief Add an gov_outflows_adt to the dynamic gov_outflows_adt array.
* \param array Pointer to the dynamic gov_outflows_adt array.
* \param new_int The gov_outflows_adt to add
*/
void add_gov_outflows_adt(gov_outflows_adt_array * array,  double investment_expenditure,  double consumption_expenditure,  double benefit_payment,  double subsidy_payment_household,  double subsidy_payment_firm,  double transfer_payment_household,  double transfer_payment_firm,  double bond_interest_payment,  double debt_installment,  double total_bond_repurchase,  double total_expenses)
{
	if((*array).size == (*array).total_size)
	{
		(*array).total_size = (int)((*array).total_size * ARRAY_GROWTH_RATE);
		(*array).array = (gov_outflows_adt *)realloc((*array).array, ((*array).total_size * sizeof(gov_outflows_adt)));
	}
	init_gov_outflows_adt(&(*array).array[(*array).size]);
	(*array).array[(*array).size].investment_expenditure = investment_expenditure;
	(*array).array[(*array).size].consumption_expenditure = consumption_expenditure;
	(*array).array[(*array).size].benefit_payment = benefit_payment;
	(*array).array[(*array).size].subsidy_payment_household = subsidy_payment_household;
	(*array).array[(*array).size].subsidy_payment_firm = subsidy_payment_firm;
	(*array).array[(*array).size].transfer_payment_household = transfer_payment_household;
	(*array).array[(*array).size].transfer_payment_firm = transfer_payment_firm;
	(*array).array[(*array).size].bond_interest_payment = bond_interest_payment;
	(*array).array[(*array).size].debt_installment = debt_installment;
	(*array).array[(*array).size].total_bond_repurchase = total_bond_repurchase;
	(*array).array[(*array).size].total_expenses = total_expenses;

	(*array).size++;
}

/** \fn void remove_gov_outflows_adt(gov_outflows_adt_array * array, int index)
 * \brief Remove an gov_outflows_adt from a dynamic gov_outflows_adt array.
 * \param array Pointer to the dynamic gov_outflows_adt array.
 * \param index The index of the gov_outflows_adt to remove.
 */
void remove_gov_outflows_adt(gov_outflows_adt_array * array, int index)
{
	int i;

	/* Free element at index index */
	free_gov_outflows_adt(&(*array).array[index]);

	/* Copy all elements up by one */
	if(index < (*array).size)
	{
		for(i = index; i < (*array).size - 1; i++)
		{
			copy_gov_outflows_adt(&(*array).array[i+1], &(*array).array[i]);
		}
		(*array).size--;
	}
}
/* Functions for the gov_inflows_adt datatype */
/** \fn gov_inflows_adt_array * init_gov_inflows_adt_array()
 * \brief Allocate memory for a dynamic gov_inflows_adt array.
 * \return gov_inflows_adt_array Pointer to the new dynamic gov_inflows_adt array.
 */
void init_gov_inflows_adt_array(gov_inflows_adt_array * array)
{
	(*array).size = 0;
	(*array).total_size = ARRAY_BLOCK_SIZE;
	(*array).array = (gov_inflows_adt *)malloc(ARRAY_BLOCK_SIZE * sizeof(gov_inflows_adt));
	CHECK_POINTER((*array).array);
}

/** \fn void reset_gov_inflows_adt_array(gov_inflows_adt_array* array)
* \brief Reset the gov_inflows_adt array to hold nothing.
* \param array Pointer to the dynamic gov_inflows_adt array.
*/
void reset_gov_inflows_adt_array(gov_inflows_adt_array * array)
{
	(*array).size = 0;
}

/** \fn void free_gov_inflows_adt_array(gov_inflows_adt_array * array)
* \brief Free the memory of a dynamic gov_inflows_adt array.
* \param array Pointer to the dynamic gov_inflows_adt array.
*/
void free_gov_inflows_adt_array(gov_inflows_adt_array * array)
{
	int i;
	
	for(i = 0; i < array->size; i++)
	{
		free_gov_inflows_adt(&(*array).array[i]);
	}
	
	free((*array).array);
}

void copy_gov_inflows_adt_array(gov_inflows_adt_array * from, gov_inflows_adt_array * to)
{
	int i;

	//to = init_gov_inflows_adt_array();

	for(i = 0; i < (*from).size; i++)
	{
		add_gov_inflows_adt(to, (*from).array[i].tax_revenues, (*from).array[i].restitution_payment, (*from).array[i].total_bond_financing, (*from).array[i].total_money_financing, (*from).array[i].ecb_dividend, (*from).array[i].total_income, (*from).array[i].net_inflow);
	}
}

/** \fn void add_gov_inflows_adt(gov_inflows_adt_array * array, double tax_revenues, double restitution_payment, double total_bond_financing, double total_money_financing, double ecb_dividend, double total_income, double net_inflow)
* \brief Add an gov_inflows_adt to the dynamic gov_inflows_adt array.
* \param array Pointer to the dynamic gov_inflows_adt array.
* \param new_int The gov_inflows_adt to add
*/
void add_gov_inflows_adt(gov_inflows_adt_array * array,  double tax_revenues,  double restitution_payment,  double total_bond_financing,  double total_money_financing,  double ecb_dividend,  double total_income,  double net_inflow)
{
	if((*array).size == (*array).total_size)
	{
		(*array).total_size = (int)((*array).total_size * ARRAY_GROWTH_RATE);
		(*array).array = (gov_inflows_adt *)realloc((*array).array, ((*array).total_size * sizeof(gov_inflows_adt)));
	}
	init_gov_inflows_adt(&(*array).array[(*array).size]);
	(*array).array[(*array).size].tax_revenues = tax_revenues;
	(*array).array[(*array).size].restitution_payment = restitution_payment;
	(*array).array[(*array).size].total_bond_financing = total_bond_financing;
	(*array).array[(*array).size].total_money_financing = total_money_financing;
	(*array).array[(*array).size].ecb_dividend = ecb_dividend;
	(*array).array[(*array).size].total_income = total_income;
	(*array).array[(*array).size].net_inflow = net_inflow;

	(*array).size++;
}

/** \fn void remove_gov_inflows_adt(gov_inflows_adt_array * array, int index)
 * \brief Remove an gov_inflows_adt from a dynamic gov_inflows_adt array.
 * \param array Pointer to the dynamic gov_inflows_adt array.
 * \param index The index of the gov_inflows_adt to remove.
 */
void remove_gov_inflows_adt(gov_inflows_adt_array * array, int index)
{
	int i;

	/* Free element at index index */
	free_gov_inflows_adt(&(*array).array[index]);

	/* Copy all elements up by one */
	if(index < (*array).size)
	{
		for(i = index; i < (*array).size - 1; i++)
		{
			copy_gov_inflows_adt(&(*array).array[i+1], &(*array).array[i]);
		}
		(*array).size--;
	}
}
/* Functions for the ecb_stocks_adt datatype */
/** \fn ecb_stocks_adt_array * init_ecb_stocks_adt_array()
 * \brief Allocate memory for a dynamic ecb_stocks_adt array.
 * \return ecb_stocks_adt_array Pointer to the new dynamic ecb_stocks_adt array.
 */
void init_ecb_stocks_adt_array(ecb_stocks_adt_array * array)
{
	(*array).size = 0;
	(*array).total_size = ARRAY_BLOCK_SIZE;
	(*array).array = (ecb_stocks_adt *)malloc(ARRAY_BLOCK_SIZE * sizeof(ecb_stocks_adt));
	CHECK_POINTER((*array).array);
}

/** \fn void reset_ecb_stocks_adt_array(ecb_stocks_adt_array* array)
* \brief Reset the ecb_stocks_adt array to hold nothing.
* \param array Pointer to the dynamic ecb_stocks_adt array.
*/
void reset_ecb_stocks_adt_array(ecb_stocks_adt_array * array)
{
	(*array).size = 0;
}

/** \fn void free_ecb_stocks_adt_array(ecb_stocks_adt_array * array)
* \brief Free the memory of a dynamic ecb_stocks_adt array.
* \param array Pointer to the dynamic ecb_stocks_adt array.
*/
void free_ecb_stocks_adt_array(ecb_stocks_adt_array * array)
{
	int i;
	
	for(i = 0; i < array->size; i++)
	{
		free_ecb_stocks_adt(&(*array).array[i]);
	}
	
	free((*array).array);
}

void copy_ecb_stocks_adt_array(ecb_stocks_adt_array * from, ecb_stocks_adt_array * to)
{
	int i;

	//to = init_ecb_stocks_adt_array();

	for(i = 0; i < (*from).size; i++)
	{
		add_ecb_stocks_adt(to, (*from).array[i].cash, (*from).array[i].gov_bond_holdings, (*from).array[i].fiat_money_banks, (*from).array[i].fiat_money_govs, (*from).array[i].total_assets, (*from).array[i].payment_account_banks, (*from).array[i].payment_account_govs, (*from).array[i].fiat_money, (*from).array[i].equity, (*from).array[i].total_liabilities, (*from).array[i].nr_gov_bonds, (*from).array[i].equity_day_1, (*from).array[i].fiat_money_govs_bond);
	}
}

/** \fn void add_ecb_stocks_adt(ecb_stocks_adt_array * array, double cash, double gov_bond_holdings, double fiat_money_banks, double fiat_money_govs, double total_assets, double payment_account_banks, double payment_account_govs, double fiat_money, double equity, double total_liabilities, int nr_gov_bonds, double equity_day_1, double fiat_money_govs_bond)
* \brief Add an ecb_stocks_adt to the dynamic ecb_stocks_adt array.
* \param array Pointer to the dynamic ecb_stocks_adt array.
* \param new_int The ecb_stocks_adt to add
*/
void add_ecb_stocks_adt(ecb_stocks_adt_array * array,  double cash,  double gov_bond_holdings,  double fiat_money_banks,  double fiat_money_govs,  double total_assets,  double payment_account_banks,  double payment_account_govs,  double fiat_money,  double equity,  double total_liabilities,  int nr_gov_bonds,  double equity_day_1,  double fiat_money_govs_bond)
{
	if((*array).size == (*array).total_size)
	{
		(*array).total_size = (int)((*array).total_size * ARRAY_GROWTH_RATE);
		(*array).array = (ecb_stocks_adt *)realloc((*array).array, ((*array).total_size * sizeof(ecb_stocks_adt)));
	}
	init_ecb_stocks_adt(&(*array).array[(*array).size]);
	(*array).array[(*array).size].cash = cash;
	(*array).array[(*array).size].gov_bond_holdings = gov_bond_holdings;
	(*array).array[(*array).size].fiat_money_banks = fiat_money_banks;
	(*array).array[(*array).size].fiat_money_govs = fiat_money_govs;
	(*array).array[(*array).size].total_assets = total_assets;
	(*array).array[(*array).size].payment_account_banks = payment_account_banks;
	(*array).array[(*array).size].payment_account_govs = payment_account_govs;
	(*array).array[(*array).size].fiat_money = fiat_money;
	(*array).array[(*array).size].equity = equity;
	(*array).array[(*array).size].total_liabilities = total_liabilities;
	(*array).array[(*array).size].nr_gov_bonds = nr_gov_bonds;
	(*array).array[(*array).size].equity_day_1 = equity_day_1;
	(*array).array[(*array).size].fiat_money_govs_bond = fiat_money_govs_bond;

	(*array).size++;
}

/** \fn void remove_ecb_stocks_adt(ecb_stocks_adt_array * array, int index)
 * \brief Remove an ecb_stocks_adt from a dynamic ecb_stocks_adt array.
 * \param array Pointer to the dynamic ecb_stocks_adt array.
 * \param index The index of the ecb_stocks_adt to remove.
 */
void remove_ecb_stocks_adt(ecb_stocks_adt_array * array, int index)
{
	int i;

	/* Free element at index index */
	free_ecb_stocks_adt(&(*array).array[index]);

	/* Copy all elements up by one */
	if(index < (*array).size)
	{
		for(i = index; i < (*array).size - 1; i++)
		{
			copy_ecb_stocks_adt(&(*array).array[i+1], &(*array).array[i]);
		}
		(*array).size--;
	}
}
/* Functions for the ecb_outflows_adt datatype */
/** \fn ecb_outflows_adt_array * init_ecb_outflows_adt_array()
 * \brief Allocate memory for a dynamic ecb_outflows_adt array.
 * \return ecb_outflows_adt_array Pointer to the new dynamic ecb_outflows_adt array.
 */
void init_ecb_outflows_adt_array(ecb_outflows_adt_array * array)
{
	(*array).size = 0;
	(*array).total_size = ARRAY_BLOCK_SIZE;
	(*array).array = (ecb_outflows_adt *)malloc(ARRAY_BLOCK_SIZE * sizeof(ecb_outflows_adt));
	CHECK_POINTER((*array).array);
}

/** \fn void reset_ecb_outflows_adt_array(ecb_outflows_adt_array* array)
* \brief Reset the ecb_outflows_adt array to hold nothing.
* \param array Pointer to the dynamic ecb_outflows_adt array.
*/
void reset_ecb_outflows_adt_array(ecb_outflows_adt_array * array)
{
	(*array).size = 0;
}

/** \fn void free_ecb_outflows_adt_array(ecb_outflows_adt_array * array)
* \brief Free the memory of a dynamic ecb_outflows_adt array.
* \param array Pointer to the dynamic ecb_outflows_adt array.
*/
void free_ecb_outflows_adt_array(ecb_outflows_adt_array * array)
{
	int i;
	
	for(i = 0; i < array->size; i++)
	{
		free_ecb_outflows_adt(&(*array).array[i]);
	}
	
	free((*array).array);
}

void copy_ecb_outflows_adt_array(ecb_outflows_adt_array * from, ecb_outflows_adt_array * to)
{
	int i;

	//to = init_ecb_outflows_adt_array();

	for(i = 0; i < (*from).size; i++)
	{
		add_ecb_outflows_adt(to, (*from).array[i].gov_bond_purchase, (*from).array[i].bank_fiat_money, (*from).array[i].bank_deposits, (*from).array[i].gov_deposits, (*from).array[i].dividend_payment, (*from).array[i].total_expenses);
	}
}

/** \fn void add_ecb_outflows_adt(ecb_outflows_adt_array * array, double gov_bond_purchase, double bank_fiat_money, double bank_deposits, double gov_deposits, double dividend_payment, double total_expenses)
* \brief Add an ecb_outflows_adt to the dynamic ecb_outflows_adt array.
* \param array Pointer to the dynamic ecb_outflows_adt array.
* \param new_int The ecb_outflows_adt to add
*/
void add_ecb_outflows_adt(ecb_outflows_adt_array * array,  double gov_bond_purchase,  double bank_fiat_money,  double bank_deposits,  double gov_deposits,  double dividend_payment,  double total_expenses)
{
	if((*array).size == (*array).total_size)
	{
		(*array).total_size = (int)((*array).total_size * ARRAY_GROWTH_RATE);
		(*array).array = (ecb_outflows_adt *)realloc((*array).array, ((*array).total_size * sizeof(ecb_outflows_adt)));
	}
	init_ecb_outflows_adt(&(*array).array[(*array).size]);
	(*array).array[(*array).size].gov_bond_purchase = gov_bond_purchase;
	(*array).array[(*array).size].bank_fiat_money = bank_fiat_money;
	(*array).array[(*array).size].bank_deposits = bank_deposits;
	(*array).array[(*array).size].gov_deposits = gov_deposits;
	(*array).array[(*array).size].dividend_payment = dividend_payment;
	(*array).array[(*array).size].total_expenses = total_expenses;

	(*array).size++;
}

/** \fn void remove_ecb_outflows_adt(ecb_outflows_adt_array * array, int index)
 * \brief Remove an ecb_outflows_adt from a dynamic ecb_outflows_adt array.
 * \param array Pointer to the dynamic ecb_outflows_adt array.
 * \param index The index of the ecb_outflows_adt to remove.
 */
void remove_ecb_outflows_adt(ecb_outflows_adt_array * array, int index)
{
	int i;

	/* Free element at index index */
	free_ecb_outflows_adt(&(*array).array[index]);

	/* Copy all elements up by one */
	if(index < (*array).size)
	{
		for(i = index; i < (*array).size - 1; i++)
		{
			copy_ecb_outflows_adt(&(*array).array[i+1], &(*array).array[i]);
		}
		(*array).size--;
	}
}
/* Functions for the ecb_inflows_adt datatype */
/** \fn ecb_inflows_adt_array * init_ecb_inflows_adt_array()
 * \brief Allocate memory for a dynamic ecb_inflows_adt array.
 * \return ecb_inflows_adt_array Pointer to the new dynamic ecb_inflows_adt array.
 */
void init_ecb_inflows_adt_array(ecb_inflows_adt_array * array)
{
	(*array).size = 0;
	(*array).total_size = ARRAY_BLOCK_SIZE;
	(*array).array = (ecb_inflows_adt *)malloc(ARRAY_BLOCK_SIZE * sizeof(ecb_inflows_adt));
	CHECK_POINTER((*array).array);
}

/** \fn void reset_ecb_inflows_adt_array(ecb_inflows_adt_array* array)
* \brief Reset the ecb_inflows_adt array to hold nothing.
* \param array Pointer to the dynamic ecb_inflows_adt array.
*/
void reset_ecb_inflows_adt_array(ecb_inflows_adt_array * array)
{
	(*array).size = 0;
}

/** \fn void free_ecb_inflows_adt_array(ecb_inflows_adt_array * array)
* \brief Free the memory of a dynamic ecb_inflows_adt array.
* \param array Pointer to the dynamic ecb_inflows_adt array.
*/
void free_ecb_inflows_adt_array(ecb_inflows_adt_array * array)
{
	int i;
	
	for(i = 0; i < array->size; i++)
	{
		free_ecb_inflows_adt(&(*array).array[i]);
	}
	
	free((*array).array);
}

void copy_ecb_inflows_adt_array(ecb_inflows_adt_array * from, ecb_inflows_adt_array * to)
{
	int i;

	//to = init_ecb_inflows_adt_array();

	for(i = 0; i < (*from).size; i++)
	{
		add_ecb_inflows_adt(to, (*from).array[i].bank_interest, (*from).array[i].bank_debt_installment, (*from).array[i].gov_interest, (*from).array[i].bank_deposits, (*from).array[i].gov_deposits, (*from).array[i].total_income, (*from).array[i].net_inflow);
	}
}

/** \fn void add_ecb_inflows_adt(ecb_inflows_adt_array * array, double bank_interest, double bank_debt_installment, double gov_interest, double bank_deposits, double gov_deposits, double total_income, double net_inflow)
* \brief Add an ecb_inflows_adt to the dynamic ecb_inflows_adt array.
* \param array Pointer to the dynamic ecb_inflows_adt array.
* \param new_int The ecb_inflows_adt to add
*/
void add_ecb_inflows_adt(ecb_inflows_adt_array * array,  double bank_interest,  double bank_debt_installment,  double gov_interest,  double bank_deposits,  double gov_deposits,  double total_income,  double net_inflow)
{
	if((*array).size == (*array).total_size)
	{
		(*array).total_size = (int)((*array).total_size * ARRAY_GROWTH_RATE);
		(*array).array = (ecb_inflows_adt *)realloc((*array).array, ((*array).total_size * sizeof(ecb_inflows_adt)));
	}
	init_ecb_inflows_adt(&(*array).array[(*array).size]);
	(*array).array[(*array).size].bank_interest = bank_interest;
	(*array).array[(*array).size].bank_debt_installment = bank_debt_installment;
	(*array).array[(*array).size].gov_interest = gov_interest;
	(*array).array[(*array).size].bank_deposits = bank_deposits;
	(*array).array[(*array).size].gov_deposits = gov_deposits;
	(*array).array[(*array).size].total_income = total_income;
	(*array).array[(*array).size].net_inflow = net_inflow;

	(*array).size++;
}

/** \fn void remove_ecb_inflows_adt(ecb_inflows_adt_array * array, int index)
 * \brief Remove an ecb_inflows_adt from a dynamic ecb_inflows_adt array.
 * \param array Pointer to the dynamic ecb_inflows_adt array.
 * \param index The index of the ecb_inflows_adt to remove.
 */
void remove_ecb_inflows_adt(ecb_inflows_adt_array * array, int index)
{
	int i;

	/* Free element at index index */
	free_ecb_inflows_adt(&(*array).array[index]);

	/* Copy all elements up by one */
	if(index < (*array).size)
	{
		for(i = index; i < (*array).size - 1; i++)
		{
			copy_ecb_inflows_adt(&(*array).array[i+1], &(*array).array[i]);
		}
		(*array).size--;
	}
}
/* Functions for the firm_balance_sheet_adt datatype */
/** \fn firm_balance_sheet_adt_array * init_firm_balance_sheet_adt_array()
 * \brief Allocate memory for a dynamic firm_balance_sheet_adt array.
 * \return firm_balance_sheet_adt_array Pointer to the new dynamic firm_balance_sheet_adt array.
 */
void init_firm_balance_sheet_adt_array(firm_balance_sheet_adt_array * array)
{
	(*array).size = 0;
	(*array).total_size = ARRAY_BLOCK_SIZE;
	(*array).array = (firm_balance_sheet_adt *)malloc(ARRAY_BLOCK_SIZE * sizeof(firm_balance_sheet_adt));
	CHECK_POINTER((*array).array);
}

/** \fn void reset_firm_balance_sheet_adt_array(firm_balance_sheet_adt_array* array)
* \brief Reset the firm_balance_sheet_adt array to hold nothing.
* \param array Pointer to the dynamic firm_balance_sheet_adt array.
*/
void reset_firm_balance_sheet_adt_array(firm_balance_sheet_adt_array * array)
{
	(*array).size = 0;
}

/** \fn void free_firm_balance_sheet_adt_array(firm_balance_sheet_adt_array * array)
* \brief Free the memory of a dynamic firm_balance_sheet_adt array.
* \param array Pointer to the dynamic firm_balance_sheet_adt array.
*/
void free_firm_balance_sheet_adt_array(firm_balance_sheet_adt_array * array)
{
	int i;
	
	for(i = 0; i < array->size; i++)
	{
		free_firm_balance_sheet_adt(&(*array).array[i]);
	}
	
	free((*array).array);
}

void copy_firm_balance_sheet_adt_array(firm_balance_sheet_adt_array * from, firm_balance_sheet_adt_array * to)
{
	int i;

	//to = init_firm_balance_sheet_adt_array();

	for(i = 0; i < (*from).size; i++)
	{
		add_firm_balance_sheet_adt(to, &(*from).array[i].stocks, &(*from).array[i].outflows, &(*from).array[i].inflows);
	}
}

/** \fn void add_firm_balance_sheet_adt(firm_balance_sheet_adt_array * array, firm_stocks_adt * stocks, firm_outflows_adt * outflows, firm_inflows_adt * inflows)
* \brief Add an firm_balance_sheet_adt to the dynamic firm_balance_sheet_adt array.
* \param array Pointer to the dynamic firm_balance_sheet_adt array.
* \param new_int The firm_balance_sheet_adt to add
*/
void add_firm_balance_sheet_adt(firm_balance_sheet_adt_array * array, /*@out@*/ firm_stocks_adt * stocks, /*@out@*/ firm_outflows_adt * outflows, /*@out@*/ firm_inflows_adt * inflows)
{
	if((*array).size == (*array).total_size)
	{
		(*array).total_size = (int)((*array).total_size * ARRAY_GROWTH_RATE);
		(*array).array = (firm_balance_sheet_adt *)realloc((*array).array, ((*array).total_size * sizeof(firm_balance_sheet_adt)));
	}
	init_firm_balance_sheet_adt(&(*array).array[(*array).size]);
	copy_firm_stocks_adt(stocks, &(*array).array[(*array).size].stocks);
	copy_firm_outflows_adt(outflows, &(*array).array[(*array).size].outflows);
	copy_firm_inflows_adt(inflows, &(*array).array[(*array).size].inflows);

	(*array).size++;
}

/** \fn void remove_firm_balance_sheet_adt(firm_balance_sheet_adt_array * array, int index)
 * \brief Remove an firm_balance_sheet_adt from a dynamic firm_balance_sheet_adt array.
 * \param array Pointer to the dynamic firm_balance_sheet_adt array.
 * \param index The index of the firm_balance_sheet_adt to remove.
 */
void remove_firm_balance_sheet_adt(firm_balance_sheet_adt_array * array, int index)
{
	int i;

	/* Free element at index index */
	free_firm_balance_sheet_adt(&(*array).array[index]);

	/* Copy all elements up by one */
	if(index < (*array).size)
	{
		for(i = index; i < (*array).size - 1; i++)
		{
			copy_firm_balance_sheet_adt(&(*array).array[i+1], &(*array).array[i]);
		}
		(*array).size--;
	}
}
/* Functions for the household_balance_sheet_adt datatype */
/** \fn household_balance_sheet_adt_array * init_household_balance_sheet_adt_array()
 * \brief Allocate memory for a dynamic household_balance_sheet_adt array.
 * \return household_balance_sheet_adt_array Pointer to the new dynamic household_balance_sheet_adt array.
 */
void init_household_balance_sheet_adt_array(household_balance_sheet_adt_array * array)
{
	(*array).size = 0;
	(*array).total_size = ARRAY_BLOCK_SIZE;
	(*array).array = (household_balance_sheet_adt *)malloc(ARRAY_BLOCK_SIZE * sizeof(household_balance_sheet_adt));
	CHECK_POINTER((*array).array);
}

/** \fn void reset_household_balance_sheet_adt_array(household_balance_sheet_adt_array* array)
* \brief Reset the household_balance_sheet_adt array to hold nothing.
* \param array Pointer to the dynamic household_balance_sheet_adt array.
*/
void reset_household_balance_sheet_adt_array(household_balance_sheet_adt_array * array)
{
	(*array).size = 0;
}

/** \fn void free_household_balance_sheet_adt_array(household_balance_sheet_adt_array * array)
* \brief Free the memory of a dynamic household_balance_sheet_adt array.
* \param array Pointer to the dynamic household_balance_sheet_adt array.
*/
void free_household_balance_sheet_adt_array(household_balance_sheet_adt_array * array)
{
	int i;
	
	for(i = 0; i < array->size; i++)
	{
		free_household_balance_sheet_adt(&(*array).array[i]);
	}
	
	free((*array).array);
}

void copy_household_balance_sheet_adt_array(household_balance_sheet_adt_array * from, household_balance_sheet_adt_array * to)
{
	int i;

	//to = init_household_balance_sheet_adt_array();

	for(i = 0; i < (*from).size; i++)
	{
		add_household_balance_sheet_adt(to, &(*from).array[i].stocks, &(*from).array[i].outflows, &(*from).array[i].inflows);
	}
}

/** \fn void add_household_balance_sheet_adt(household_balance_sheet_adt_array * array, household_stocks_adt * stocks, household_outflows_adt * outflows, household_inflows_adt * inflows)
* \brief Add an household_balance_sheet_adt to the dynamic household_balance_sheet_adt array.
* \param array Pointer to the dynamic household_balance_sheet_adt array.
* \param new_int The household_balance_sheet_adt to add
*/
void add_household_balance_sheet_adt(household_balance_sheet_adt_array * array, /*@out@*/ household_stocks_adt * stocks, /*@out@*/ household_outflows_adt * outflows, /*@out@*/ household_inflows_adt * inflows)
{
	if((*array).size == (*array).total_size)
	{
		(*array).total_size = (int)((*array).total_size * ARRAY_GROWTH_RATE);
		(*array).array = (household_balance_sheet_adt *)realloc((*array).array, ((*array).total_size * sizeof(household_balance_sheet_adt)));
	}
	init_household_balance_sheet_adt(&(*array).array[(*array).size]);
	copy_household_stocks_adt(stocks, &(*array).array[(*array).size].stocks);
	copy_household_outflows_adt(outflows, &(*array).array[(*array).size].outflows);
	copy_household_inflows_adt(inflows, &(*array).array[(*array).size].inflows);

	(*array).size++;
}

/** \fn void remove_household_balance_sheet_adt(household_balance_sheet_adt_array * array, int index)
 * \brief Remove an household_balance_sheet_adt from a dynamic household_balance_sheet_adt array.
 * \param array Pointer to the dynamic household_balance_sheet_adt array.
 * \param index The index of the household_balance_sheet_adt to remove.
 */
void remove_household_balance_sheet_adt(household_balance_sheet_adt_array * array, int index)
{
	int i;

	/* Free element at index index */
	free_household_balance_sheet_adt(&(*array).array[index]);

	/* Copy all elements up by one */
	if(index < (*array).size)
	{
		for(i = index; i < (*array).size - 1; i++)
		{
			copy_household_balance_sheet_adt(&(*array).array[i+1], &(*array).array[i]);
		}
		(*array).size--;
	}
}
/* Functions for the igfirm_balance_sheet_adt datatype */
/** \fn igfirm_balance_sheet_adt_array * init_igfirm_balance_sheet_adt_array()
 * \brief Allocate memory for a dynamic igfirm_balance_sheet_adt array.
 * \return igfirm_balance_sheet_adt_array Pointer to the new dynamic igfirm_balance_sheet_adt array.
 */
void init_igfirm_balance_sheet_adt_array(igfirm_balance_sheet_adt_array * array)
{
	(*array).size = 0;
	(*array).total_size = ARRAY_BLOCK_SIZE;
	(*array).array = (igfirm_balance_sheet_adt *)malloc(ARRAY_BLOCK_SIZE * sizeof(igfirm_balance_sheet_adt));
	CHECK_POINTER((*array).array);
}

/** \fn void reset_igfirm_balance_sheet_adt_array(igfirm_balance_sheet_adt_array* array)
* \brief Reset the igfirm_balance_sheet_adt array to hold nothing.
* \param array Pointer to the dynamic igfirm_balance_sheet_adt array.
*/
void reset_igfirm_balance_sheet_adt_array(igfirm_balance_sheet_adt_array * array)
{
	(*array).size = 0;
}

/** \fn void free_igfirm_balance_sheet_adt_array(igfirm_balance_sheet_adt_array * array)
* \brief Free the memory of a dynamic igfirm_balance_sheet_adt array.
* \param array Pointer to the dynamic igfirm_balance_sheet_adt array.
*/
void free_igfirm_balance_sheet_adt_array(igfirm_balance_sheet_adt_array * array)
{
	int i;
	
	for(i = 0; i < array->size; i++)
	{
		free_igfirm_balance_sheet_adt(&(*array).array[i]);
	}
	
	free((*array).array);
}

void copy_igfirm_balance_sheet_adt_array(igfirm_balance_sheet_adt_array * from, igfirm_balance_sheet_adt_array * to)
{
	int i;

	//to = init_igfirm_balance_sheet_adt_array();

	for(i = 0; i < (*from).size; i++)
	{
		add_igfirm_balance_sheet_adt(to, &(*from).array[i].stocks, &(*from).array[i].outflows, &(*from).array[i].inflows);
	}
}

/** \fn void add_igfirm_balance_sheet_adt(igfirm_balance_sheet_adt_array * array, igfirm_stocks_adt * stocks, igfirm_outflows_adt * outflows, igfirm_inflows_adt * inflows)
* \brief Add an igfirm_balance_sheet_adt to the dynamic igfirm_balance_sheet_adt array.
* \param array Pointer to the dynamic igfirm_balance_sheet_adt array.
* \param new_int The igfirm_balance_sheet_adt to add
*/
void add_igfirm_balance_sheet_adt(igfirm_balance_sheet_adt_array * array, /*@out@*/ igfirm_stocks_adt * stocks, /*@out@*/ igfirm_outflows_adt * outflows, /*@out@*/ igfirm_inflows_adt * inflows)
{
	if((*array).size == (*array).total_size)
	{
		(*array).total_size = (int)((*array).total_size * ARRAY_GROWTH_RATE);
		(*array).array = (igfirm_balance_sheet_adt *)realloc((*array).array, ((*array).total_size * sizeof(igfirm_balance_sheet_adt)));
	}
	init_igfirm_balance_sheet_adt(&(*array).array[(*array).size]);
	copy_igfirm_stocks_adt(stocks, &(*array).array[(*array).size].stocks);
	copy_igfirm_outflows_adt(outflows, &(*array).array[(*array).size].outflows);
	copy_igfirm_inflows_adt(inflows, &(*array).array[(*array).size].inflows);

	(*array).size++;
}

/** \fn void remove_igfirm_balance_sheet_adt(igfirm_balance_sheet_adt_array * array, int index)
 * \brief Remove an igfirm_balance_sheet_adt from a dynamic igfirm_balance_sheet_adt array.
 * \param array Pointer to the dynamic igfirm_balance_sheet_adt array.
 * \param index The index of the igfirm_balance_sheet_adt to remove.
 */
void remove_igfirm_balance_sheet_adt(igfirm_balance_sheet_adt_array * array, int index)
{
	int i;

	/* Free element at index index */
	free_igfirm_balance_sheet_adt(&(*array).array[index]);

	/* Copy all elements up by one */
	if(index < (*array).size)
	{
		for(i = index; i < (*array).size - 1; i++)
		{
			copy_igfirm_balance_sheet_adt(&(*array).array[i+1], &(*array).array[i]);
		}
		(*array).size--;
	}
}
/* Functions for the bank_balance_sheet_adt datatype */
/** \fn bank_balance_sheet_adt_array * init_bank_balance_sheet_adt_array()
 * \brief Allocate memory for a dynamic bank_balance_sheet_adt array.
 * \return bank_balance_sheet_adt_array Pointer to the new dynamic bank_balance_sheet_adt array.
 */
void init_bank_balance_sheet_adt_array(bank_balance_sheet_adt_array * array)
{
	(*array).size = 0;
	(*array).total_size = ARRAY_BLOCK_SIZE;
	(*array).array = (bank_balance_sheet_adt *)malloc(ARRAY_BLOCK_SIZE * sizeof(bank_balance_sheet_adt));
	CHECK_POINTER((*array).array);
}

/** \fn void reset_bank_balance_sheet_adt_array(bank_balance_sheet_adt_array* array)
* \brief Reset the bank_balance_sheet_adt array to hold nothing.
* \param array Pointer to the dynamic bank_balance_sheet_adt array.
*/
void reset_bank_balance_sheet_adt_array(bank_balance_sheet_adt_array * array)
{
	(*array).size = 0;
}

/** \fn void free_bank_balance_sheet_adt_array(bank_balance_sheet_adt_array * array)
* \brief Free the memory of a dynamic bank_balance_sheet_adt array.
* \param array Pointer to the dynamic bank_balance_sheet_adt array.
*/
void free_bank_balance_sheet_adt_array(bank_balance_sheet_adt_array * array)
{
	int i;
	
	for(i = 0; i < array->size; i++)
	{
		free_bank_balance_sheet_adt(&(*array).array[i]);
	}
	
	free((*array).array);
}

void copy_bank_balance_sheet_adt_array(bank_balance_sheet_adt_array * from, bank_balance_sheet_adt_array * to)
{
	int i;

	//to = init_bank_balance_sheet_adt_array();

	for(i = 0; i < (*from).size; i++)
	{
		add_bank_balance_sheet_adt(to, &(*from).array[i].stocks, &(*from).array[i].outflows, &(*from).array[i].inflows);
	}
}

/** \fn void add_bank_balance_sheet_adt(bank_balance_sheet_adt_array * array, bank_stocks_adt * stocks, bank_outflows_adt * outflows, bank_inflows_adt * inflows)
* \brief Add an bank_balance_sheet_adt to the dynamic bank_balance_sheet_adt array.
* \param array Pointer to the dynamic bank_balance_sheet_adt array.
* \param new_int The bank_balance_sheet_adt to add
*/
void add_bank_balance_sheet_adt(bank_balance_sheet_adt_array * array, /*@out@*/ bank_stocks_adt * stocks, /*@out@*/ bank_outflows_adt * outflows, /*@out@*/ bank_inflows_adt * inflows)
{
	if((*array).size == (*array).total_size)
	{
		(*array).total_size = (int)((*array).total_size * ARRAY_GROWTH_RATE);
		(*array).array = (bank_balance_sheet_adt *)realloc((*array).array, ((*array).total_size * sizeof(bank_balance_sheet_adt)));
	}
	init_bank_balance_sheet_adt(&(*array).array[(*array).size]);
	copy_bank_stocks_adt(stocks, &(*array).array[(*array).size].stocks);
	copy_bank_outflows_adt(outflows, &(*array).array[(*array).size].outflows);
	copy_bank_inflows_adt(inflows, &(*array).array[(*array).size].inflows);

	(*array).size++;
}

/** \fn void remove_bank_balance_sheet_adt(bank_balance_sheet_adt_array * array, int index)
 * \brief Remove an bank_balance_sheet_adt from a dynamic bank_balance_sheet_adt array.
 * \param array Pointer to the dynamic bank_balance_sheet_adt array.
 * \param index The index of the bank_balance_sheet_adt to remove.
 */
void remove_bank_balance_sheet_adt(bank_balance_sheet_adt_array * array, int index)
{
	int i;

	/* Free element at index index */
	free_bank_balance_sheet_adt(&(*array).array[index]);

	/* Copy all elements up by one */
	if(index < (*array).size)
	{
		for(i = index; i < (*array).size - 1; i++)
		{
			copy_bank_balance_sheet_adt(&(*array).array[i+1], &(*array).array[i]);
		}
		(*array).size--;
	}
}
/* Functions for the gov_balance_sheet_adt datatype */
/** \fn gov_balance_sheet_adt_array * init_gov_balance_sheet_adt_array()
 * \brief Allocate memory for a dynamic gov_balance_sheet_adt array.
 * \return gov_balance_sheet_adt_array Pointer to the new dynamic gov_balance_sheet_adt array.
 */
void init_gov_balance_sheet_adt_array(gov_balance_sheet_adt_array * array)
{
	(*array).size = 0;
	(*array).total_size = ARRAY_BLOCK_SIZE;
	(*array).array = (gov_balance_sheet_adt *)malloc(ARRAY_BLOCK_SIZE * sizeof(gov_balance_sheet_adt));
	CHECK_POINTER((*array).array);
}

/** \fn void reset_gov_balance_sheet_adt_array(gov_balance_sheet_adt_array* array)
* \brief Reset the gov_balance_sheet_adt array to hold nothing.
* \param array Pointer to the dynamic gov_balance_sheet_adt array.
*/
void reset_gov_balance_sheet_adt_array(gov_balance_sheet_adt_array * array)
{
	(*array).size = 0;
}

/** \fn void free_gov_balance_sheet_adt_array(gov_balance_sheet_adt_array * array)
* \brief Free the memory of a dynamic gov_balance_sheet_adt array.
* \param array Pointer to the dynamic gov_balance_sheet_adt array.
*/
void free_gov_balance_sheet_adt_array(gov_balance_sheet_adt_array * array)
{
	int i;
	
	for(i = 0; i < array->size; i++)
	{
		free_gov_balance_sheet_adt(&(*array).array[i]);
	}
	
	free((*array).array);
}

void copy_gov_balance_sheet_adt_array(gov_balance_sheet_adt_array * from, gov_balance_sheet_adt_array * to)
{
	int i;

	//to = init_gov_balance_sheet_adt_array();

	for(i = 0; i < (*from).size; i++)
	{
		add_gov_balance_sheet_adt(to, &(*from).array[i].stocks, &(*from).array[i].outflows, &(*from).array[i].inflows);
	}
}

/** \fn void add_gov_balance_sheet_adt(gov_balance_sheet_adt_array * array, gov_stocks_adt * stocks, gov_outflows_adt * outflows, gov_inflows_adt * inflows)
* \brief Add an gov_balance_sheet_adt to the dynamic gov_balance_sheet_adt array.
* \param array Pointer to the dynamic gov_balance_sheet_adt array.
* \param new_int The gov_balance_sheet_adt to add
*/
void add_gov_balance_sheet_adt(gov_balance_sheet_adt_array * array, /*@out@*/ gov_stocks_adt * stocks, /*@out@*/ gov_outflows_adt * outflows, /*@out@*/ gov_inflows_adt * inflows)
{
	if((*array).size == (*array).total_size)
	{
		(*array).total_size = (int)((*array).total_size * ARRAY_GROWTH_RATE);
		(*array).array = (gov_balance_sheet_adt *)realloc((*array).array, ((*array).total_size * sizeof(gov_balance_sheet_adt)));
	}
	init_gov_balance_sheet_adt(&(*array).array[(*array).size]);
	copy_gov_stocks_adt(stocks, &(*array).array[(*array).size].stocks);
	copy_gov_outflows_adt(outflows, &(*array).array[(*array).size].outflows);
	copy_gov_inflows_adt(inflows, &(*array).array[(*array).size].inflows);

	(*array).size++;
}

/** \fn void remove_gov_balance_sheet_adt(gov_balance_sheet_adt_array * array, int index)
 * \brief Remove an gov_balance_sheet_adt from a dynamic gov_balance_sheet_adt array.
 * \param array Pointer to the dynamic gov_balance_sheet_adt array.
 * \param index The index of the gov_balance_sheet_adt to remove.
 */
void remove_gov_balance_sheet_adt(gov_balance_sheet_adt_array * array, int index)
{
	int i;

	/* Free element at index index */
	free_gov_balance_sheet_adt(&(*array).array[index]);

	/* Copy all elements up by one */
	if(index < (*array).size)
	{
		for(i = index; i < (*array).size - 1; i++)
		{
			copy_gov_balance_sheet_adt(&(*array).array[i+1], &(*array).array[i]);
		}
		(*array).size--;
	}
}
/* Functions for the ecb_balance_sheet_adt datatype */
/** \fn ecb_balance_sheet_adt_array * init_ecb_balance_sheet_adt_array()
 * \brief Allocate memory for a dynamic ecb_balance_sheet_adt array.
 * \return ecb_balance_sheet_adt_array Pointer to the new dynamic ecb_balance_sheet_adt array.
 */
void init_ecb_balance_sheet_adt_array(ecb_balance_sheet_adt_array * array)
{
	(*array).size = 0;
	(*array).total_size = ARRAY_BLOCK_SIZE;
	(*array).array = (ecb_balance_sheet_adt *)malloc(ARRAY_BLOCK_SIZE * sizeof(ecb_balance_sheet_adt));
	CHECK_POINTER((*array).array);
}

/** \fn void reset_ecb_balance_sheet_adt_array(ecb_balance_sheet_adt_array* array)
* \brief Reset the ecb_balance_sheet_adt array to hold nothing.
* \param array Pointer to the dynamic ecb_balance_sheet_adt array.
*/
void reset_ecb_balance_sheet_adt_array(ecb_balance_sheet_adt_array * array)
{
	(*array).size = 0;
}

/** \fn void free_ecb_balance_sheet_adt_array(ecb_balance_sheet_adt_array * array)
* \brief Free the memory of a dynamic ecb_balance_sheet_adt array.
* \param array Pointer to the dynamic ecb_balance_sheet_adt array.
*/
void free_ecb_balance_sheet_adt_array(ecb_balance_sheet_adt_array * array)
{
	int i;
	
	for(i = 0; i < array->size; i++)
	{
		free_ecb_balance_sheet_adt(&(*array).array[i]);
	}
	
	free((*array).array);
}

void copy_ecb_balance_sheet_adt_array(ecb_balance_sheet_adt_array * from, ecb_balance_sheet_adt_array * to)
{
	int i;

	//to = init_ecb_balance_sheet_adt_array();

	for(i = 0; i < (*from).size; i++)
	{
		add_ecb_balance_sheet_adt(to, &(*from).array[i].stocks, &(*from).array[i].outflows, &(*from).array[i].inflows);
	}
}

/** \fn void add_ecb_balance_sheet_adt(ecb_balance_sheet_adt_array * array, ecb_stocks_adt * stocks, ecb_outflows_adt * outflows, ecb_inflows_adt * inflows)
* \brief Add an ecb_balance_sheet_adt to the dynamic ecb_balance_sheet_adt array.
* \param array Pointer to the dynamic ecb_balance_sheet_adt array.
* \param new_int The ecb_balance_sheet_adt to add
*/
void add_ecb_balance_sheet_adt(ecb_balance_sheet_adt_array * array, /*@out@*/ ecb_stocks_adt * stocks, /*@out@*/ ecb_outflows_adt * outflows, /*@out@*/ ecb_inflows_adt * inflows)
{
	if((*array).size == (*array).total_size)
	{
		(*array).total_size = (int)((*array).total_size * ARRAY_GROWTH_RATE);
		(*array).array = (ecb_balance_sheet_adt *)realloc((*array).array, ((*array).total_size * sizeof(ecb_balance_sheet_adt)));
	}
	init_ecb_balance_sheet_adt(&(*array).array[(*array).size]);
	copy_ecb_stocks_adt(stocks, &(*array).array[(*array).size].stocks);
	copy_ecb_outflows_adt(outflows, &(*array).array[(*array).size].outflows);
	copy_ecb_inflows_adt(inflows, &(*array).array[(*array).size].inflows);

	(*array).size++;
}

/** \fn void remove_ecb_balance_sheet_adt(ecb_balance_sheet_adt_array * array, int index)
 * \brief Remove an ecb_balance_sheet_adt from a dynamic ecb_balance_sheet_adt array.
 * \param array Pointer to the dynamic ecb_balance_sheet_adt array.
 * \param index The index of the ecb_balance_sheet_adt to remove.
 */
void remove_ecb_balance_sheet_adt(ecb_balance_sheet_adt_array * array, int index)
{
	int i;

	/* Free element at index index */
	free_ecb_balance_sheet_adt(&(*array).array[index]);

	/* Copy all elements up by one */
	if(index < (*array).size)
	{
		for(i = index; i < (*array).size - 1; i++)
		{
			copy_ecb_balance_sheet_adt(&(*array).array[i+1], &(*array).array[i]);
		}
		(*array).size--;
	}
}
/* Functions for the adt_subsidies_per_government datatype */
/** \fn adt_subsidies_per_government_array * init_adt_subsidies_per_government_array()
 * \brief Allocate memory for a dynamic adt_subsidies_per_government array.
 * \return adt_subsidies_per_government_array Pointer to the new dynamic adt_subsidies_per_government array.
 */
void init_adt_subsidies_per_government_array(adt_subsidies_per_government_array * array)
{
	(*array).size = 0;
	(*array).total_size = ARRAY_BLOCK_SIZE;
	(*array).array = (adt_subsidies_per_government *)malloc(ARRAY_BLOCK_SIZE * sizeof(adt_subsidies_per_government));
	CHECK_POINTER((*array).array);
}

/** \fn void reset_adt_subsidies_per_government_array(adt_subsidies_per_government_array* array)
* \brief Reset the adt_subsidies_per_government array to hold nothing.
* \param array Pointer to the dynamic adt_subsidies_per_government array.
*/
void reset_adt_subsidies_per_government_array(adt_subsidies_per_government_array * array)
{
	(*array).size = 0;
}

/** \fn void free_adt_subsidies_per_government_array(adt_subsidies_per_government_array * array)
* \brief Free the memory of a dynamic adt_subsidies_per_government array.
* \param array Pointer to the dynamic adt_subsidies_per_government array.
*/
void free_adt_subsidies_per_government_array(adt_subsidies_per_government_array * array)
{
	int i;
	
	for(i = 0; i < array->size; i++)
	{
		free_adt_subsidies_per_government(&(*array).array[i]);
	}
	
	free((*array).array);
}

void copy_adt_subsidies_per_government_array(adt_subsidies_per_government_array * from, adt_subsidies_per_government_array * to)
{
	int i;

	//to = init_adt_subsidies_per_government_array();

	for(i = 0; i < (*from).size; i++)
	{
		add_adt_subsidies_per_government(to, (*from).array[i].gov_id, (*from).array[i].region_id, (*from).array[i].amount);
	}
}

/** \fn void add_adt_subsidies_per_government(adt_subsidies_per_government_array * array, int gov_id, int region_id, double amount)
* \brief Add an adt_subsidies_per_government to the dynamic adt_subsidies_per_government array.
* \param array Pointer to the dynamic adt_subsidies_per_government array.
* \param new_int The adt_subsidies_per_government to add
*/
void add_adt_subsidies_per_government(adt_subsidies_per_government_array * array,  int gov_id,  int region_id,  double amount)
{
	if((*array).size == (*array).total_size)
	{
		(*array).total_size = (int)((*array).total_size * ARRAY_GROWTH_RATE);
		(*array).array = (adt_subsidies_per_government *)realloc((*array).array, ((*array).total_size * sizeof(adt_subsidies_per_government)));
	}
	init_adt_subsidies_per_government(&(*array).array[(*array).size]);
	(*array).array[(*array).size].gov_id = gov_id;
	(*array).array[(*array).size].region_id = region_id;
	(*array).array[(*array).size].amount = amount;

	(*array).size++;
}

/** \fn void remove_adt_subsidies_per_government(adt_subsidies_per_government_array * array, int index)
 * \brief Remove an adt_subsidies_per_government from a dynamic adt_subsidies_per_government array.
 * \param array Pointer to the dynamic adt_subsidies_per_government array.
 * \param index The index of the adt_subsidies_per_government to remove.
 */
void remove_adt_subsidies_per_government(adt_subsidies_per_government_array * array, int index)
{
	int i;

	/* Free element at index index */
	free_adt_subsidies_per_government(&(*array).array[index]);

	/* Copy all elements up by one */
	if(index < (*array).size)
	{
		for(i = index; i < (*array).size - 1; i++)
		{
			copy_adt_subsidies_per_government(&(*array).array[i+1], &(*array).array[i]);
		}
		(*array).size--;
	}
}
/* Functions for the estimated_values_adt datatype */
/** \fn estimated_values_adt_array * init_estimated_values_adt_array()
 * \brief Allocate memory for a dynamic estimated_values_adt array.
 * \return estimated_values_adt_array Pointer to the new dynamic estimated_values_adt array.
 */
void init_estimated_values_adt_array(estimated_values_adt_array * array)
{
	(*array).size = 0;
	(*array).total_size = ARRAY_BLOCK_SIZE;
	(*array).array = (estimated_values_adt *)malloc(ARRAY_BLOCK_SIZE * sizeof(estimated_values_adt));
	CHECK_POINTER((*array).array);
}

/** \fn void reset_estimated_values_adt_array(estimated_values_adt_array* array)
* \brief Reset the estimated_values_adt array to hold nothing.
* \param array Pointer to the dynamic estimated_values_adt array.
*/
void reset_estimated_values_adt_array(estimated_values_adt_array * array)
{
	(*array).size = 0;
}

/** \fn void free_estimated_values_adt_array(estimated_values_adt_array * array)
* \brief Free the memory of a dynamic estimated_values_adt array.
* \param array Pointer to the dynamic estimated_values_adt array.
*/
void free_estimated_values_adt_array(estimated_values_adt_array * array)
{
	int i;
	
	for(i = 0; i < array->size; i++)
	{
		free_estimated_values_adt(&(*array).array[i]);
	}
	
	free((*array).array);
}

void copy_estimated_values_adt_array(estimated_values_adt_array * from, estimated_values_adt_array * to)
{
	int i;

	//to = init_estimated_values_adt_array();

	for(i = 0; i < (*from).size; i++)
	{
		add_estimated_values_adt(to, (*from).array[i].no_positive_response, (*from).array[i].probability, (*from).array[i].estimated_fix_costs, (*from).array[i].estimated_variable_costs, (*from).array[i].estimated_earnings, (*from).array[i].additional_capital_Investments_depreciated, (*from).array[i].mean_specific_skills, (*from).array[i].mean_wage, (*from).array[i].no_employees);
	}
}

/** \fn void add_estimated_values_adt(estimated_values_adt_array * array, int no_positive_response, double probability, double estimated_fix_costs, double estimated_variable_costs, double estimated_earnings, double additional_capital_Investments_depreciated, double mean_specific_skills, double mean_wage, int no_employees)
* \brief Add an estimated_values_adt to the dynamic estimated_values_adt array.
* \param array Pointer to the dynamic estimated_values_adt array.
* \param new_int The estimated_values_adt to add
*/
void add_estimated_values_adt(estimated_values_adt_array * array,  int no_positive_response,  double probability,  double estimated_fix_costs,  double estimated_variable_costs,  double estimated_earnings,  double additional_capital_Investments_depreciated,  double mean_specific_skills,  double mean_wage,  int no_employees)
{
	if((*array).size == (*array).total_size)
	{
		(*array).total_size = (int)((*array).total_size * ARRAY_GROWTH_RATE);
		(*array).array = (estimated_values_adt *)realloc((*array).array, ((*array).total_size * sizeof(estimated_values_adt)));
	}
	init_estimated_values_adt(&(*array).array[(*array).size]);
	(*array).array[(*array).size].no_positive_response = no_positive_response;
	(*array).array[(*array).size].probability = probability;
	(*array).array[(*array).size].estimated_fix_costs = estimated_fix_costs;
	(*array).array[(*array).size].estimated_variable_costs = estimated_variable_costs;
	(*array).array[(*array).size].estimated_earnings = estimated_earnings;
	(*array).array[(*array).size].additional_capital_Investments_depreciated = additional_capital_Investments_depreciated;
	(*array).array[(*array).size].mean_specific_skills = mean_specific_skills;
	(*array).array[(*array).size].mean_wage = mean_wage;
	(*array).array[(*array).size].no_employees = no_employees;

	(*array).size++;
}

/** \fn void remove_estimated_values_adt(estimated_values_adt_array * array, int index)
 * \brief Remove an estimated_values_adt from a dynamic estimated_values_adt array.
 * \param array Pointer to the dynamic estimated_values_adt array.
 * \param index The index of the estimated_values_adt to remove.
 */
void remove_estimated_values_adt(estimated_values_adt_array * array, int index)
{
	int i;

	/* Free element at index index */
	free_estimated_values_adt(&(*array).array[index]);

	/* Copy all elements up by one */
	if(index < (*array).size)
	{
		for(i = index; i < (*array).size - 1; i++)
		{
			copy_estimated_values_adt(&(*array).array[i+1], &(*array).array[i]);
		}
		(*array).size--;
	}
}
/* Functions for the dt_market_research_price datatype */
/** \fn dt_market_research_price_array * init_dt_market_research_price_array()
 * \brief Allocate memory for a dynamic dt_market_research_price array.
 * \return dt_market_research_price_array Pointer to the new dynamic dt_market_research_price array.
 */
void init_dt_market_research_price_array(dt_market_research_price_array * array)
{
	(*array).size = 0;
	(*array).total_size = ARRAY_BLOCK_SIZE;
	(*array).array = (dt_market_research_price *)malloc(ARRAY_BLOCK_SIZE * sizeof(dt_market_research_price));
	CHECK_POINTER((*array).array);
}

/** \fn void reset_dt_market_research_price_array(dt_market_research_price_array* array)
* \brief Reset the dt_market_research_price array to hold nothing.
* \param array Pointer to the dynamic dt_market_research_price array.
*/
void reset_dt_market_research_price_array(dt_market_research_price_array * array)
{
	(*array).size = 0;
}

/** \fn void free_dt_market_research_price_array(dt_market_research_price_array * array)
* \brief Free the memory of a dynamic dt_market_research_price array.
* \param array Pointer to the dynamic dt_market_research_price array.
*/
void free_dt_market_research_price_array(dt_market_research_price_array * array)
{
	int i;
	
	for(i = 0; i < array->size; i++)
	{
		free_dt_market_research_price(&(*array).array[i]);
	}
	
	free((*array).array);
}

void copy_dt_market_research_price_array(dt_market_research_price_array * from, dt_market_research_price_array * to)
{
	int i;

	//to = init_dt_market_research_price_array();

	for(i = 0; i < (*from).size; i++)
	{
		add_dt_market_research_price(to, (*from).array[i].price_change, (*from).array[i].price, &(*from).array[i].estimated_values);
	}
}

/** \fn void add_dt_market_research_price(dt_market_research_price_array * array, double price_change, double price, estimated_values_adt_array * estimated_values)
* \brief Add an dt_market_research_price to the dynamic dt_market_research_price array.
* \param array Pointer to the dynamic dt_market_research_price array.
* \param new_int The dt_market_research_price to add
*/
void add_dt_market_research_price(dt_market_research_price_array * array,  double price_change,  double price, /*@out@*/ estimated_values_adt_array * estimated_values)
{
	if((*array).size == (*array).total_size)
	{
		(*array).total_size = (int)((*array).total_size * ARRAY_GROWTH_RATE);
		(*array).array = (dt_market_research_price *)realloc((*array).array, ((*array).total_size * sizeof(dt_market_research_price)));
	}
	init_dt_market_research_price(&(*array).array[(*array).size]);
	(*array).array[(*array).size].price_change = price_change;
	(*array).array[(*array).size].price = price;
	if(estimated_values != NULL) copy_estimated_values_adt_array(estimated_values, &(*array).array[(*array).size].estimated_values);

	(*array).size++;
}

/** \fn void remove_dt_market_research_price(dt_market_research_price_array * array, int index)
 * \brief Remove an dt_market_research_price from a dynamic dt_market_research_price array.
 * \param array Pointer to the dynamic dt_market_research_price array.
 * \param index The index of the dt_market_research_price to remove.
 */
void remove_dt_market_research_price(dt_market_research_price_array * array, int index)
{
	int i;

	/* Free element at index index */
	free_dt_market_research_price(&(*array).array[index]);

	/* Copy all elements up by one */
	if(index < (*array).size)
	{
		for(i = index; i < (*array).size - 1; i++)
		{
			copy_dt_market_research_price(&(*array).array[i+1], &(*array).array[i]);
		}
		(*array).size--;
	}
}
/* Functions for the dt_market_research_qualities datatype */
/** \fn dt_market_research_qualities_array * init_dt_market_research_qualities_array()
 * \brief Allocate memory for a dynamic dt_market_research_qualities array.
 * \return dt_market_research_qualities_array Pointer to the new dynamic dt_market_research_qualities array.
 */
void init_dt_market_research_qualities_array(dt_market_research_qualities_array * array)
{
	(*array).size = 0;
	(*array).total_size = ARRAY_BLOCK_SIZE;
	(*array).array = (dt_market_research_qualities *)malloc(ARRAY_BLOCK_SIZE * sizeof(dt_market_research_qualities));
	CHECK_POINTER((*array).array);
}

/** \fn void reset_dt_market_research_qualities_array(dt_market_research_qualities_array* array)
* \brief Reset the dt_market_research_qualities array to hold nothing.
* \param array Pointer to the dynamic dt_market_research_qualities array.
*/
void reset_dt_market_research_qualities_array(dt_market_research_qualities_array * array)
{
	(*array).size = 0;
}

/** \fn void free_dt_market_research_qualities_array(dt_market_research_qualities_array * array)
* \brief Free the memory of a dynamic dt_market_research_qualities array.
* \param array Pointer to the dynamic dt_market_research_qualities array.
*/
void free_dt_market_research_qualities_array(dt_market_research_qualities_array * array)
{
	int i;
	
	for(i = 0; i < array->size; i++)
	{
		free_dt_market_research_qualities(&(*array).array[i]);
	}
	
	free((*array).array);
}

void copy_dt_market_research_qualities_array(dt_market_research_qualities_array * from, dt_market_research_qualities_array * to)
{
	int i;

	//to = init_dt_market_research_qualities_array();

	for(i = 0; i < (*from).size; i++)
	{
		add_dt_market_research_qualities(to, (*from).array[i].quality, &(*from).array[i].market_research_price);
	}
}

/** \fn void add_dt_market_research_qualities(dt_market_research_qualities_array * array, double quality, dt_market_research_price_array * market_research_price)
* \brief Add an dt_market_research_qualities to the dynamic dt_market_research_qualities array.
* \param array Pointer to the dynamic dt_market_research_qualities array.
* \param new_int The dt_market_research_qualities to add
*/
void add_dt_market_research_qualities(dt_market_research_qualities_array * array,  double quality, /*@out@*/ dt_market_research_price_array * market_research_price)
{
	if((*array).size == (*array).total_size)
	{
		(*array).total_size = (int)((*array).total_size * ARRAY_GROWTH_RATE);
		(*array).array = (dt_market_research_qualities *)realloc((*array).array, ((*array).total_size * sizeof(dt_market_research_qualities)));
	}
	init_dt_market_research_qualities(&(*array).array[(*array).size]);
	(*array).array[(*array).size].quality = quality;
	if(market_research_price != NULL) copy_dt_market_research_price_array(market_research_price, &(*array).array[(*array).size].market_research_price);

	(*array).size++;
}

/** \fn void remove_dt_market_research_qualities(dt_market_research_qualities_array * array, int index)
 * \brief Remove an dt_market_research_qualities from a dynamic dt_market_research_qualities array.
 * \param array Pointer to the dynamic dt_market_research_qualities array.
 * \param index The index of the dt_market_research_qualities to remove.
 */
void remove_dt_market_research_qualities(dt_market_research_qualities_array * array, int index)
{
	int i;

	/* Free element at index index */
	free_dt_market_research_qualities(&(*array).array[index]);

	/* Copy all elements up by one */
	if(index < (*array).size)
	{
		for(i = index; i < (*array).size - 1; i++)
		{
			copy_dt_market_research_qualities(&(*array).array[i+1], &(*array).array[i]);
		}
		(*array).size--;
	}
}
/* Functions for the dt_best_price_strategies datatype */
/** \fn dt_best_price_strategies_array * init_dt_best_price_strategies_array()
 * \brief Allocate memory for a dynamic dt_best_price_strategies array.
 * \return dt_best_price_strategies_array Pointer to the new dynamic dt_best_price_strategies array.
 */
void init_dt_best_price_strategies_array(dt_best_price_strategies_array * array)
{
	(*array).size = 0;
	(*array).total_size = ARRAY_BLOCK_SIZE;
	(*array).array = (dt_best_price_strategies *)malloc(ARRAY_BLOCK_SIZE * sizeof(dt_best_price_strategies));
	CHECK_POINTER((*array).array);
}

/** \fn void reset_dt_best_price_strategies_array(dt_best_price_strategies_array* array)
* \brief Reset the dt_best_price_strategies array to hold nothing.
* \param array Pointer to the dynamic dt_best_price_strategies array.
*/
void reset_dt_best_price_strategies_array(dt_best_price_strategies_array * array)
{
	(*array).size = 0;
}

/** \fn void free_dt_best_price_strategies_array(dt_best_price_strategies_array * array)
* \brief Free the memory of a dynamic dt_best_price_strategies array.
* \param array Pointer to the dynamic dt_best_price_strategies array.
*/
void free_dt_best_price_strategies_array(dt_best_price_strategies_array * array)
{
	int i;
	
	for(i = 0; i < array->size; i++)
	{
		free_dt_best_price_strategies(&(*array).array[i]);
	}
	
	free((*array).array);
}

void copy_dt_best_price_strategies_array(dt_best_price_strategies_array * from, dt_best_price_strategies_array * to)
{
	int i;

	//to = init_dt_best_price_strategies_array();

	for(i = 0; i < (*from).size; i++)
	{
		add_dt_best_price_strategies(to, (*from).array[i].quality, (*from).array[i].price, (*from).array[i].expected_earnings, (*from).array[i].sum_earnings, (*from).array[i].sum_expected_earnings_discounted);
	}
}

/** \fn void add_dt_best_price_strategies(dt_best_price_strategies_array * array, double quality, double price, double expected_earnings, double sum_earnings, double sum_expected_earnings_discounted)
* \brief Add an dt_best_price_strategies to the dynamic dt_best_price_strategies array.
* \param array Pointer to the dynamic dt_best_price_strategies array.
* \param new_int The dt_best_price_strategies to add
*/
void add_dt_best_price_strategies(dt_best_price_strategies_array * array,  double quality,  double price,  double expected_earnings,  double sum_earnings,  double sum_expected_earnings_discounted)
{
	if((*array).size == (*array).total_size)
	{
		(*array).total_size = (int)((*array).total_size * ARRAY_GROWTH_RATE);
		(*array).array = (dt_best_price_strategies *)realloc((*array).array, ((*array).total_size * sizeof(dt_best_price_strategies)));
	}
	init_dt_best_price_strategies(&(*array).array[(*array).size]);
	(*array).array[(*array).size].quality = quality;
	(*array).array[(*array).size].price = price;
	(*array).array[(*array).size].expected_earnings = expected_earnings;
	(*array).array[(*array).size].sum_earnings = sum_earnings;
	(*array).array[(*array).size].sum_expected_earnings_discounted = sum_expected_earnings_discounted;

	(*array).size++;
}

/** \fn void remove_dt_best_price_strategies(dt_best_price_strategies_array * array, int index)
 * \brief Remove an dt_best_price_strategies from a dynamic dt_best_price_strategies array.
 * \param array Pointer to the dynamic dt_best_price_strategies array.
 * \param index The index of the dt_best_price_strategies to remove.
 */
void remove_dt_best_price_strategies(dt_best_price_strategies_array * array, int index)
{
	int i;

	/* Free element at index index */
	free_dt_best_price_strategies(&(*array).array[index]);

	/* Copy all elements up by one */
	if(index < (*array).size)
	{
		for(i = index; i < (*array).size - 1; i++)
		{
			copy_dt_best_price_strategies(&(*array).array[i+1], &(*array).array[i]);
		}
		(*array).size--;
	}
}
/* Functions for the dt_price_range datatype */
/** \fn dt_price_range_array * init_dt_price_range_array()
 * \brief Allocate memory for a dynamic dt_price_range array.
 * \return dt_price_range_array Pointer to the new dynamic dt_price_range array.
 */
void init_dt_price_range_array(dt_price_range_array * array)
{
	(*array).size = 0;
	(*array).total_size = ARRAY_BLOCK_SIZE;
	(*array).array = (dt_price_range *)malloc(ARRAY_BLOCK_SIZE * sizeof(dt_price_range));
	CHECK_POINTER((*array).array);
}

/** \fn void reset_dt_price_range_array(dt_price_range_array* array)
* \brief Reset the dt_price_range array to hold nothing.
* \param array Pointer to the dynamic dt_price_range array.
*/
void reset_dt_price_range_array(dt_price_range_array * array)
{
	(*array).size = 0;
}

/** \fn void free_dt_price_range_array(dt_price_range_array * array)
* \brief Free the memory of a dynamic dt_price_range array.
* \param array Pointer to the dynamic dt_price_range array.
*/
void free_dt_price_range_array(dt_price_range_array * array)
{
	int i;
	
	for(i = 0; i < array->size; i++)
	{
		free_dt_price_range(&(*array).array[i]);
	}
	
	free((*array).array);
}

void copy_dt_price_range_array(dt_price_range_array * from, dt_price_range_array * to)
{
	int i;

	//to = init_dt_price_range_array();

	for(i = 0; i < (*from).size; i++)
	{
		add_dt_price_range(to, (*from).array[i].start_price, (*from).array[i].end_price, (*from).array[i].increment);
	}
}

/** \fn void add_dt_price_range(dt_price_range_array * array, double start_price, double end_price, double increment)
* \brief Add an dt_price_range to the dynamic dt_price_range array.
* \param array Pointer to the dynamic dt_price_range array.
* \param new_int The dt_price_range to add
*/
void add_dt_price_range(dt_price_range_array * array,  double start_price,  double end_price,  double increment)
{
	if((*array).size == (*array).total_size)
	{
		(*array).total_size = (int)((*array).total_size * ARRAY_GROWTH_RATE);
		(*array).array = (dt_price_range *)realloc((*array).array, ((*array).total_size * sizeof(dt_price_range)));
	}
	init_dt_price_range(&(*array).array[(*array).size]);
	(*array).array[(*array).size].start_price = start_price;
	(*array).array[(*array).size].end_price = end_price;
	(*array).array[(*array).size].increment = increment;

	(*array).size++;
}

/** \fn void remove_dt_price_range(dt_price_range_array * array, int index)
 * \brief Remove an dt_price_range from a dynamic dt_price_range array.
 * \param array Pointer to the dynamic dt_price_range array.
 * \param index The index of the dt_price_range to remove.
 */
void remove_dt_price_range(dt_price_range_array * array, int index)
{
	int i;

	/* Free element at index index */
	free_dt_price_range(&(*array).array[index]);

	/* Copy all elements up by one */
	if(index < (*array).size)
	{
		for(i = index; i < (*array).size - 1; i++)
		{
			copy_dt_price_range(&(*array).array[i+1], &(*array).array[i]);
		}
		(*array).size--;
	}
}
/* Functions for the dt_prospective_variables datatype */
/** \fn dt_prospective_variables_array * init_dt_prospective_variables_array()
 * \brief Allocate memory for a dynamic dt_prospective_variables array.
 * \return dt_prospective_variables_array Pointer to the new dynamic dt_prospective_variables array.
 */
void init_dt_prospective_variables_array(dt_prospective_variables_array * array)
{
	(*array).size = 0;
	(*array).total_size = ARRAY_BLOCK_SIZE;
	(*array).array = (dt_prospective_variables *)malloc(ARRAY_BLOCK_SIZE * sizeof(dt_prospective_variables));
	CHECK_POINTER((*array).array);
}

/** \fn void reset_dt_prospective_variables_array(dt_prospective_variables_array* array)
* \brief Reset the dt_prospective_variables array to hold nothing.
* \param array Pointer to the dynamic dt_prospective_variables array.
*/
void reset_dt_prospective_variables_array(dt_prospective_variables_array * array)
{
	(*array).size = 0;
}

/** \fn void free_dt_prospective_variables_array(dt_prospective_variables_array * array)
* \brief Free the memory of a dynamic dt_prospective_variables array.
* \param array Pointer to the dynamic dt_prospective_variables array.
*/
void free_dt_prospective_variables_array(dt_prospective_variables_array * array)
{
	int i;
	
	for(i = 0; i < array->size; i++)
	{
		free_dt_prospective_variables(&(*array).array[i]);
	}
	
	free((*array).array);
}

void copy_dt_prospective_variables_array(dt_prospective_variables_array * from, dt_prospective_variables_array * to)
{
	int i;

	//to = init_dt_prospective_variables_array();

	for(i = 0; i < (*from).size; i++)
	{
		add_dt_prospective_variables(to, (*from).array[i].mean_specific_skills, (*from).array[i].estimated_mean_wage, (*from).array[i].no_employees, (*from).array[i].earnings, (*from).array[i].payment_account, (*from).array[i].buffer, &(*from).array[i].capital_stock_vintages, &(*from).array[i].capital_financing, &(*from).array[i].loans);
	}
}

/** \fn void add_dt_prospective_variables(dt_prospective_variables_array * array, double mean_specific_skills, double estimated_mean_wage, double no_employees, double earnings, double payment_account, double buffer, adt_capital_stock_vintages_array * capital_stock_vintages, financing_capital_array * capital_financing, debt_item_array * loans)
* \brief Add an dt_prospective_variables to the dynamic dt_prospective_variables array.
* \param array Pointer to the dynamic dt_prospective_variables array.
* \param new_int The dt_prospective_variables to add
*/
void add_dt_prospective_variables(dt_prospective_variables_array * array,  double mean_specific_skills,  double estimated_mean_wage,  double no_employees,  double earnings,  double payment_account,  double buffer, /*@out@*/ adt_capital_stock_vintages_array * capital_stock_vintages, /*@out@*/ financing_capital_array * capital_financing, /*@out@*/ debt_item_array * loans)
{
	if((*array).size == (*array).total_size)
	{
		(*array).total_size = (int)((*array).total_size * ARRAY_GROWTH_RATE);
		(*array).array = (dt_prospective_variables *)realloc((*array).array, ((*array).total_size * sizeof(dt_prospective_variables)));
	}
	init_dt_prospective_variables(&(*array).array[(*array).size]);
	(*array).array[(*array).size].mean_specific_skills = mean_specific_skills;
	(*array).array[(*array).size].estimated_mean_wage = estimated_mean_wage;
	(*array).array[(*array).size].no_employees = no_employees;
	(*array).array[(*array).size].earnings = earnings;
	(*array).array[(*array).size].payment_account = payment_account;
	(*array).array[(*array).size].buffer = buffer;
	if(capital_stock_vintages != NULL) copy_adt_capital_stock_vintages_array(capital_stock_vintages, &(*array).array[(*array).size].capital_stock_vintages);
	if(capital_financing != NULL) copy_financing_capital_array(capital_financing, &(*array).array[(*array).size].capital_financing);
	if(loans != NULL) copy_debt_item_array(loans, &(*array).array[(*array).size].loans);

	(*array).size++;
}

/** \fn void remove_dt_prospective_variables(dt_prospective_variables_array * array, int index)
 * \brief Remove an dt_prospective_variables from a dynamic dt_prospective_variables array.
 * \param array Pointer to the dynamic dt_prospective_variables array.
 * \param index The index of the dt_prospective_variables to remove.
 */
void remove_dt_prospective_variables(dt_prospective_variables_array * array, int index)
{
	int i;

	/* Free element at index index */
	free_dt_prospective_variables(&(*array).array[index]);

	/* Copy all elements up by one */
	if(index < (*array).size)
	{
		for(i = index; i < (*array).size - 1; i++)
		{
			copy_dt_prospective_variables(&(*array).array[i+1], &(*array).array[i]);
		}
		(*array).size--;
	}
}
/* Functions for the dt_variables_changed datatype */
/** \fn dt_variables_changed_array * init_dt_variables_changed_array()
 * \brief Allocate memory for a dynamic dt_variables_changed array.
 * \return dt_variables_changed_array Pointer to the new dynamic dt_variables_changed array.
 */
void init_dt_variables_changed_array(dt_variables_changed_array * array)
{
	(*array).size = 0;
	(*array).total_size = ARRAY_BLOCK_SIZE;
	(*array).array = (dt_variables_changed *)malloc(ARRAY_BLOCK_SIZE * sizeof(dt_variables_changed));
	CHECK_POINTER((*array).array);
}

/** \fn void reset_dt_variables_changed_array(dt_variables_changed_array* array)
* \brief Reset the dt_variables_changed array to hold nothing.
* \param array Pointer to the dynamic dt_variables_changed array.
*/
void reset_dt_variables_changed_array(dt_variables_changed_array * array)
{
	(*array).size = 0;
}

/** \fn void free_dt_variables_changed_array(dt_variables_changed_array * array)
* \brief Free the memory of a dynamic dt_variables_changed array.
* \param array Pointer to the dynamic dt_variables_changed array.
*/
void free_dt_variables_changed_array(dt_variables_changed_array * array)
{
	int i;
	
	for(i = 0; i < array->size; i++)
	{
		free_dt_variables_changed(&(*array).array[i]);
	}
	
	free((*array).array);
}

void copy_dt_variables_changed_array(dt_variables_changed_array * from, dt_variables_changed_array * to)
{
	int i;

	//to = init_dt_variables_changed_array();

	for(i = 0; i < (*from).size; i++)
	{
		add_dt_variables_changed(to, (*from).array[i].price_index, (*from).array[i].quality_index, (*from).array[i].productivity_progress);
	}
}

/** \fn void add_dt_variables_changed(dt_variables_changed_array * array, double price_index, double quality_index, double productivity_progress)
* \brief Add an dt_variables_changed to the dynamic dt_variables_changed array.
* \param array Pointer to the dynamic dt_variables_changed array.
* \param new_int The dt_variables_changed to add
*/
void add_dt_variables_changed(dt_variables_changed_array * array,  double price_index,  double quality_index,  double productivity_progress)
{
	if((*array).size == (*array).total_size)
	{
		(*array).total_size = (int)((*array).total_size * ARRAY_GROWTH_RATE);
		(*array).array = (dt_variables_changed *)realloc((*array).array, ((*array).total_size * sizeof(dt_variables_changed)));
	}
	init_dt_variables_changed(&(*array).array[(*array).size]);
	(*array).array[(*array).size].price_index = price_index;
	(*array).array[(*array).size].quality_index = quality_index;
	(*array).array[(*array).size].productivity_progress = productivity_progress;

	(*array).size++;
}

/** \fn void remove_dt_variables_changed(dt_variables_changed_array * array, int index)
 * \brief Remove an dt_variables_changed from a dynamic dt_variables_changed array.
 * \param array Pointer to the dynamic dt_variables_changed array.
 * \param index The index of the dt_variables_changed to remove.
 */
void remove_dt_variables_changed(dt_variables_changed_array * array, int index)
{
	int i;

	/* Free element at index index */
	free_dt_variables_changed(&(*array).array[index]);

	/* Copy all elements up by one */
	if(index < (*array).size)
	{
		for(i = index; i < (*array).size - 1; i++)
		{
			copy_dt_variables_changed(&(*array).array[i+1], &(*array).array[i]);
		}
		(*array).size--;
	}
}
/* Functions for the dt_innovation_choice datatype */
/** \fn dt_innovation_choice_array * init_dt_innovation_choice_array()
 * \brief Allocate memory for a dynamic dt_innovation_choice array.
 * \return dt_innovation_choice_array Pointer to the new dynamic dt_innovation_choice array.
 */
void init_dt_innovation_choice_array(dt_innovation_choice_array * array)
{
	(*array).size = 0;
	(*array).total_size = ARRAY_BLOCK_SIZE;
	(*array).array = (dt_innovation_choice *)malloc(ARRAY_BLOCK_SIZE * sizeof(dt_innovation_choice));
	CHECK_POINTER((*array).array);
}

/** \fn void reset_dt_innovation_choice_array(dt_innovation_choice_array* array)
* \brief Reset the dt_innovation_choice array to hold nothing.
* \param array Pointer to the dynamic dt_innovation_choice array.
*/
void reset_dt_innovation_choice_array(dt_innovation_choice_array * array)
{
	(*array).size = 0;
}

/** \fn void free_dt_innovation_choice_array(dt_innovation_choice_array * array)
* \brief Free the memory of a dynamic dt_innovation_choice array.
* \param array Pointer to the dynamic dt_innovation_choice array.
*/
void free_dt_innovation_choice_array(dt_innovation_choice_array * array)
{
	int i;
	
	for(i = 0; i < array->size; i++)
	{
		free_dt_innovation_choice(&(*array).array[i]);
	}
	
	free((*array).array);
}

void copy_dt_innovation_choice_array(dt_innovation_choice_array * from, dt_innovation_choice_array * to)
{
	int i;

	//to = init_dt_innovation_choice_array();

	for(i = 0; i < (*from).size; i++)
	{
		add_dt_innovation_choice(to, (*from).array[i].development_period, (*from).array[i].employees_needed, (*from).array[i].quality, (*from).array[i].expected_discounted_earnings);
	}
}

/** \fn void add_dt_innovation_choice(dt_innovation_choice_array * array, int development_period, int employees_needed, double quality, double expected_discounted_earnings)
* \brief Add an dt_innovation_choice to the dynamic dt_innovation_choice array.
* \param array Pointer to the dynamic dt_innovation_choice array.
* \param new_int The dt_innovation_choice to add
*/
void add_dt_innovation_choice(dt_innovation_choice_array * array,  int development_period,  int employees_needed,  double quality,  double expected_discounted_earnings)
{
	if((*array).size == (*array).total_size)
	{
		(*array).total_size = (int)((*array).total_size * ARRAY_GROWTH_RATE);
		(*array).array = (dt_innovation_choice *)realloc((*array).array, ((*array).total_size * sizeof(dt_innovation_choice)));
	}
	init_dt_innovation_choice(&(*array).array[(*array).size]);
	(*array).array[(*array).size].development_period = development_period;
	(*array).array[(*array).size].employees_needed = employees_needed;
	(*array).array[(*array).size].quality = quality;
	(*array).array[(*array).size].expected_discounted_earnings = expected_discounted_earnings;

	(*array).size++;
}

/** \fn void remove_dt_innovation_choice(dt_innovation_choice_array * array, int index)
 * \brief Remove an dt_innovation_choice from a dynamic dt_innovation_choice array.
 * \param array Pointer to the dynamic dt_innovation_choice array.
 * \param index The index of the dt_innovation_choice to remove.
 */
void remove_dt_innovation_choice(dt_innovation_choice_array * array, int index)
{
	int i;

	/* Free element at index index */
	free_dt_innovation_choice(&(*array).array[index]);

	/* Copy all elements up by one */
	if(index < (*array).size)
	{
		for(i = index; i < (*array).size - 1; i++)
		{
			copy_dt_innovation_choice(&(*array).array[i+1], &(*array).array[i]);
		}
		(*array).size--;
	}
}
/* Functions for the dt_demand_function datatype */
/** \fn dt_demand_function_array * init_dt_demand_function_array()
 * \brief Allocate memory for a dynamic dt_demand_function array.
 * \return dt_demand_function_array Pointer to the new dynamic dt_demand_function array.
 */
void init_dt_demand_function_array(dt_demand_function_array * array)
{
	(*array).size = 0;
	(*array).total_size = ARRAY_BLOCK_SIZE;
	(*array).array = (dt_demand_function *)malloc(ARRAY_BLOCK_SIZE * sizeof(dt_demand_function));
	CHECK_POINTER((*array).array);
}

/** \fn void reset_dt_demand_function_array(dt_demand_function_array* array)
* \brief Reset the dt_demand_function array to hold nothing.
* \param array Pointer to the dynamic dt_demand_function array.
*/
void reset_dt_demand_function_array(dt_demand_function_array * array)
{
	(*array).size = 0;
}

/** \fn void free_dt_demand_function_array(dt_demand_function_array * array)
* \brief Free the memory of a dynamic dt_demand_function array.
* \param array Pointer to the dynamic dt_demand_function array.
*/
void free_dt_demand_function_array(dt_demand_function_array * array)
{
	int i;
	
	for(i = 0; i < array->size; i++)
	{
		free_dt_demand_function(&(*array).array[i]);
	}
	
	free((*array).array);
}

void copy_dt_demand_function_array(dt_demand_function_array * from, dt_demand_function_array * to)
{
	int i;

	//to = init_dt_demand_function_array();

	for(i = 0; i < (*from).size; i++)
	{
		add_dt_demand_function(to, (*from).array[i].quality, (*from).array[i].year, (*from).array[i].factor, (*from).array[i].exponent, (*from).array[i].variance);
	}
}

/** \fn void add_dt_demand_function(dt_demand_function_array * array, double quality, int year, double factor, double exponent, double variance)
* \brief Add an dt_demand_function to the dynamic dt_demand_function array.
* \param array Pointer to the dynamic dt_demand_function array.
* \param new_int The dt_demand_function to add
*/
void add_dt_demand_function(dt_demand_function_array * array,  double quality,  int year,  double factor,  double exponent,  double variance)
{
	if((*array).size == (*array).total_size)
	{
		(*array).total_size = (int)((*array).total_size * ARRAY_GROWTH_RATE);
		(*array).array = (dt_demand_function *)realloc((*array).array, ((*array).total_size * sizeof(dt_demand_function)));
	}
	init_dt_demand_function(&(*array).array[(*array).size]);
	(*array).array[(*array).size].quality = quality;
	(*array).array[(*array).size].year = year;
	(*array).array[(*array).size].factor = factor;
	(*array).array[(*array).size].exponent = exponent;
	(*array).array[(*array).size].variance = variance;

	(*array).size++;
}

/** \fn void remove_dt_demand_function(dt_demand_function_array * array, int index)
 * \brief Remove an dt_demand_function from a dynamic dt_demand_function array.
 * \param array Pointer to the dynamic dt_demand_function array.
 * \param index The index of the dt_demand_function to remove.
 */
void remove_dt_demand_function(dt_demand_function_array * array, int index)
{
	int i;

	/* Free element at index index */
	free_dt_demand_function(&(*array).array[index]);

	/* Copy all elements up by one */
	if(index < (*array).size)
	{
		for(i = index; i < (*array).size - 1; i++)
		{
			copy_dt_demand_function(&(*array).array[i+1], &(*array).array[i]);
		}
		(*array).size--;
	}
}
/* Functions for the dt_price_quantity_touple datatype */
/** \fn dt_price_quantity_touple_array * init_dt_price_quantity_touple_array()
 * \brief Allocate memory for a dynamic dt_price_quantity_touple array.
 * \return dt_price_quantity_touple_array Pointer to the new dynamic dt_price_quantity_touple array.
 */
void init_dt_price_quantity_touple_array(dt_price_quantity_touple_array * array)
{
	(*array).size = 0;
	(*array).total_size = ARRAY_BLOCK_SIZE;
	(*array).array = (dt_price_quantity_touple *)malloc(ARRAY_BLOCK_SIZE * sizeof(dt_price_quantity_touple));
	CHECK_POINTER((*array).array);
}

/** \fn void reset_dt_price_quantity_touple_array(dt_price_quantity_touple_array* array)
* \brief Reset the dt_price_quantity_touple array to hold nothing.
* \param array Pointer to the dynamic dt_price_quantity_touple array.
*/
void reset_dt_price_quantity_touple_array(dt_price_quantity_touple_array * array)
{
	(*array).size = 0;
}

/** \fn void free_dt_price_quantity_touple_array(dt_price_quantity_touple_array * array)
* \brief Free the memory of a dynamic dt_price_quantity_touple array.
* \param array Pointer to the dynamic dt_price_quantity_touple array.
*/
void free_dt_price_quantity_touple_array(dt_price_quantity_touple_array * array)
{
	int i;
	
	for(i = 0; i < array->size; i++)
	{
		free_dt_price_quantity_touple(&(*array).array[i]);
	}
	
	free((*array).array);
}

void copy_dt_price_quantity_touple_array(dt_price_quantity_touple_array * from, dt_price_quantity_touple_array * to)
{
	int i;

	//to = init_dt_price_quantity_touple_array();

	for(i = 0; i < (*from).size; i++)
	{
		add_dt_price_quantity_touple(to, (*from).array[i].price, (*from).array[i].quantity);
	}
}

/** \fn void add_dt_price_quantity_touple(dt_price_quantity_touple_array * array, double price, double quantity)
* \brief Add an dt_price_quantity_touple to the dynamic dt_price_quantity_touple array.
* \param array Pointer to the dynamic dt_price_quantity_touple array.
* \param new_int The dt_price_quantity_touple to add
*/
void add_dt_price_quantity_touple(dt_price_quantity_touple_array * array,  double price,  double quantity)
{
	if((*array).size == (*array).total_size)
	{
		(*array).total_size = (int)((*array).total_size * ARRAY_GROWTH_RATE);
		(*array).array = (dt_price_quantity_touple *)realloc((*array).array, ((*array).total_size * sizeof(dt_price_quantity_touple)));
	}
	init_dt_price_quantity_touple(&(*array).array[(*array).size]);
	(*array).array[(*array).size].price = price;
	(*array).array[(*array).size].quantity = quantity;

	(*array).size++;
}

/** \fn void remove_dt_price_quantity_touple(dt_price_quantity_touple_array * array, int index)
 * \brief Remove an dt_price_quantity_touple from a dynamic dt_price_quantity_touple array.
 * \param array Pointer to the dynamic dt_price_quantity_touple array.
 * \param index The index of the dt_price_quantity_touple to remove.
 */
void remove_dt_price_quantity_touple(dt_price_quantity_touple_array * array, int index)
{
	int i;

	/* Free element at index index */
	free_dt_price_quantity_touple(&(*array).array[index]);

	/* Copy all elements up by one */
	if(index < (*array).size)
	{
		for(i = index; i < (*array).size - 1; i++)
		{
			copy_dt_price_quantity_touple(&(*array).array[i+1], &(*array).array[i]);
		}
		(*array).size--;
	}
}
/* Functions for the dt_market_size datatype */
/** \fn dt_market_size_array * init_dt_market_size_array()
 * \brief Allocate memory for a dynamic dt_market_size array.
 * \return dt_market_size_array Pointer to the new dynamic dt_market_size array.
 */
void init_dt_market_size_array(dt_market_size_array * array)
{
	(*array).size = 0;
	(*array).total_size = ARRAY_BLOCK_SIZE;
	(*array).array = (dt_market_size *)malloc(ARRAY_BLOCK_SIZE * sizeof(dt_market_size));
	CHECK_POINTER((*array).array);
}

/** \fn void reset_dt_market_size_array(dt_market_size_array* array)
* \brief Reset the dt_market_size array to hold nothing.
* \param array Pointer to the dynamic dt_market_size array.
*/
void reset_dt_market_size_array(dt_market_size_array * array)
{
	(*array).size = 0;
}

/** \fn void free_dt_market_size_array(dt_market_size_array * array)
* \brief Free the memory of a dynamic dt_market_size array.
* \param array Pointer to the dynamic dt_market_size array.
*/
void free_dt_market_size_array(dt_market_size_array * array)
{
	int i;
	
	for(i = 0; i < array->size; i++)
	{
		free_dt_market_size(&(*array).array[i]);
	}
	
	free((*array).array);
}

void copy_dt_market_size_array(dt_market_size_array * from, dt_market_size_array * to)
{
	int i;

	//to = init_dt_market_size_array();

	for(i = 0; i < (*from).size; i++)
	{
		add_dt_market_size(to, (*from).array[i].period, (*from).array[i].market_size);
	}
}

/** \fn void add_dt_market_size(dt_market_size_array * array, int period, double market_size)
* \brief Add an dt_market_size to the dynamic dt_market_size array.
* \param array Pointer to the dynamic dt_market_size array.
* \param new_int The dt_market_size to add
*/
void add_dt_market_size(dt_market_size_array * array,  int period,  double market_size)
{
	if((*array).size == (*array).total_size)
	{
		(*array).total_size = (int)((*array).total_size * ARRAY_GROWTH_RATE);
		(*array).array = (dt_market_size *)realloc((*array).array, ((*array).total_size * sizeof(dt_market_size)));
	}
	init_dt_market_size(&(*array).array[(*array).size]);
	(*array).array[(*array).size].period = period;
	(*array).array[(*array).size].market_size = market_size;

	(*array).size++;
}

/** \fn void remove_dt_market_size(dt_market_size_array * array, int index)
 * \brief Remove an dt_market_size from a dynamic dt_market_size array.
 * \param array Pointer to the dynamic dt_market_size array.
 * \param index The index of the dt_market_size to remove.
 */
void remove_dt_market_size(dt_market_size_array * array, int index)
{
	int i;

	/* Free element at index index */
	free_dt_market_size(&(*array).array[index]);

	/* Copy all elements up by one */
	if(index < (*array).size)
	{
		for(i = index; i < (*array).size - 1; i++)
		{
			copy_dt_market_size(&(*array).array[i+1], &(*array).array[i]);
		}
		(*array).size--;
	}
}
/* Functions for the dt_total_and_regional_market_size datatype */
/** \fn dt_total_and_regional_market_size_array * init_dt_total_and_regional_market_size_array()
 * \brief Allocate memory for a dynamic dt_total_and_regional_market_size array.
 * \return dt_total_and_regional_market_size_array Pointer to the new dynamic dt_total_and_regional_market_size array.
 */
void init_dt_total_and_regional_market_size_array(dt_total_and_regional_market_size_array * array)
{
	(*array).size = 0;
	(*array).total_size = ARRAY_BLOCK_SIZE;
	(*array).array = (dt_total_and_regional_market_size *)malloc(ARRAY_BLOCK_SIZE * sizeof(dt_total_and_regional_market_size));
	CHECK_POINTER((*array).array);
}

/** \fn void reset_dt_total_and_regional_market_size_array(dt_total_and_regional_market_size_array* array)
* \brief Reset the dt_total_and_regional_market_size array to hold nothing.
* \param array Pointer to the dynamic dt_total_and_regional_market_size array.
*/
void reset_dt_total_and_regional_market_size_array(dt_total_and_regional_market_size_array * array)
{
	(*array).size = 0;
}

/** \fn void free_dt_total_and_regional_market_size_array(dt_total_and_regional_market_size_array * array)
* \brief Free the memory of a dynamic dt_total_and_regional_market_size array.
* \param array Pointer to the dynamic dt_total_and_regional_market_size array.
*/
void free_dt_total_and_regional_market_size_array(dt_total_and_regional_market_size_array * array)
{
	int i;
	
	for(i = 0; i < array->size; i++)
	{
		free_dt_total_and_regional_market_size(&(*array).array[i]);
	}
	
	free((*array).array);
}

void copy_dt_total_and_regional_market_size_array(dt_total_and_regional_market_size_array * from, dt_total_and_regional_market_size_array * to)
{
	int i;

	//to = init_dt_total_and_regional_market_size_array();

	for(i = 0; i < (*from).size; i++)
	{
		add_dt_total_and_regional_market_size(to, (*from).array[i].region_id, (*from).array[i].mall_id, &(*from).array[i].market_sizes);
	}
}

/** \fn void add_dt_total_and_regional_market_size(dt_total_and_regional_market_size_array * array, int region_id, int mall_id, dt_market_size_array * market_sizes)
* \brief Add an dt_total_and_regional_market_size to the dynamic dt_total_and_regional_market_size array.
* \param array Pointer to the dynamic dt_total_and_regional_market_size array.
* \param new_int The dt_total_and_regional_market_size to add
*/
void add_dt_total_and_regional_market_size(dt_total_and_regional_market_size_array * array,  int region_id,  int mall_id, /*@out@*/ dt_market_size_array * market_sizes)
{
	if((*array).size == (*array).total_size)
	{
		(*array).total_size = (int)((*array).total_size * ARRAY_GROWTH_RATE);
		(*array).array = (dt_total_and_regional_market_size *)realloc((*array).array, ((*array).total_size * sizeof(dt_total_and_regional_market_size)));
	}
	init_dt_total_and_regional_market_size(&(*array).array[(*array).size]);
	(*array).array[(*array).size].region_id = region_id;
	(*array).array[(*array).size].mall_id = mall_id;
	if(market_sizes != NULL) copy_dt_market_size_array(market_sizes, &(*array).array[(*array).size].market_sizes);

	(*array).size++;
}

/** \fn void remove_dt_total_and_regional_market_size(dt_total_and_regional_market_size_array * array, int index)
 * \brief Remove an dt_total_and_regional_market_size from a dynamic dt_total_and_regional_market_size array.
 * \param array Pointer to the dynamic dt_total_and_regional_market_size array.
 * \param index The index of the dt_total_and_regional_market_size to remove.
 */
void remove_dt_total_and_regional_market_size(dt_total_and_regional_market_size_array * array, int index)
{
	int i;

	/* Free element at index index */
	free_dt_total_and_regional_market_size(&(*array).array[index]);

	/* Copy all elements up by one */
	if(index < (*array).size)
	{
		for(i = index; i < (*array).size - 1; i++)
		{
			copy_dt_total_and_regional_market_size(&(*array).array[i+1], &(*array).array[i]);
		}
		(*array).size--;
	}
}
/* Functions for the dt_value_lattice datatype */
/** \fn dt_value_lattice_array * init_dt_value_lattice_array()
 * \brief Allocate memory for a dynamic dt_value_lattice array.
 * \return dt_value_lattice_array Pointer to the new dynamic dt_value_lattice array.
 */
void init_dt_value_lattice_array(dt_value_lattice_array * array)
{
	(*array).size = 0;
	(*array).total_size = ARRAY_BLOCK_SIZE;
	(*array).array = (dt_value_lattice *)malloc(ARRAY_BLOCK_SIZE * sizeof(dt_value_lattice));
	CHECK_POINTER((*array).array);
}

/** \fn void reset_dt_value_lattice_array(dt_value_lattice_array* array)
* \brief Reset the dt_value_lattice array to hold nothing.
* \param array Pointer to the dynamic dt_value_lattice array.
*/
void reset_dt_value_lattice_array(dt_value_lattice_array * array)
{
	(*array).size = 0;
}

/** \fn void free_dt_value_lattice_array(dt_value_lattice_array * array)
* \brief Free the memory of a dynamic dt_value_lattice array.
* \param array Pointer to the dynamic dt_value_lattice array.
*/
void free_dt_value_lattice_array(dt_value_lattice_array * array)
{
	int i;
	
	for(i = 0; i < array->size; i++)
	{
		free_dt_value_lattice(&(*array).array[i]);
	}
	
	free((*array).array);
}

void copy_dt_value_lattice_array(dt_value_lattice_array * from, dt_value_lattice_array * to)
{
	int i;

	//to = init_dt_value_lattice_array();

	for(i = 0; i < (*from).size; i++)
	{
		add_dt_value_lattice(to, (*from).array[i].intermediate_quality, (*from).array[i].value, (*from).array[i].strategy);
	}
}

/** \fn void add_dt_value_lattice(dt_value_lattice_array * array, double intermediate_quality, double value, int strategy)
* \brief Add an dt_value_lattice to the dynamic dt_value_lattice array.
* \param array Pointer to the dynamic dt_value_lattice array.
* \param new_int The dt_value_lattice to add
*/
void add_dt_value_lattice(dt_value_lattice_array * array,  double intermediate_quality,  double value,  int strategy)
{
	if((*array).size == (*array).total_size)
	{
		(*array).total_size = (int)((*array).total_size * ARRAY_GROWTH_RATE);
		(*array).array = (dt_value_lattice *)realloc((*array).array, ((*array).total_size * sizeof(dt_value_lattice)));
	}
	init_dt_value_lattice(&(*array).array[(*array).size]);
	(*array).array[(*array).size].intermediate_quality = intermediate_quality;
	(*array).array[(*array).size].value = value;
	(*array).array[(*array).size].strategy = strategy;

	(*array).size++;
}

/** \fn void remove_dt_value_lattice(dt_value_lattice_array * array, int index)
 * \brief Remove an dt_value_lattice from a dynamic dt_value_lattice array.
 * \param array Pointer to the dynamic dt_value_lattice array.
 * \param index The index of the dt_value_lattice to remove.
 */
void remove_dt_value_lattice(dt_value_lattice_array * array, int index)
{
	int i;

	/* Free element at index index */
	free_dt_value_lattice(&(*array).array[index]);

	/* Copy all elements up by one */
	if(index < (*array).size)
	{
		for(i = index; i < (*array).size - 1; i++)
		{
			copy_dt_value_lattice(&(*array).array[i+1], &(*array).array[i]);
		}
		(*array).size--;
	}
}
/* Functions for the dt_value_lattice_years datatype */
/** \fn dt_value_lattice_years_array * init_dt_value_lattice_years_array()
 * \brief Allocate memory for a dynamic dt_value_lattice_years array.
 * \return dt_value_lattice_years_array Pointer to the new dynamic dt_value_lattice_years array.
 */
void init_dt_value_lattice_years_array(dt_value_lattice_years_array * array)
{
	(*array).size = 0;
	(*array).total_size = ARRAY_BLOCK_SIZE;
	(*array).array = (dt_value_lattice_years *)malloc(ARRAY_BLOCK_SIZE * sizeof(dt_value_lattice_years));
	CHECK_POINTER((*array).array);
}

/** \fn void reset_dt_value_lattice_years_array(dt_value_lattice_years_array* array)
* \brief Reset the dt_value_lattice_years array to hold nothing.
* \param array Pointer to the dynamic dt_value_lattice_years array.
*/
void reset_dt_value_lattice_years_array(dt_value_lattice_years_array * array)
{
	(*array).size = 0;
}

/** \fn void free_dt_value_lattice_years_array(dt_value_lattice_years_array * array)
* \brief Free the memory of a dynamic dt_value_lattice_years array.
* \param array Pointer to the dynamic dt_value_lattice_years array.
*/
void free_dt_value_lattice_years_array(dt_value_lattice_years_array * array)
{
	int i;
	
	for(i = 0; i < array->size; i++)
	{
		free_dt_value_lattice_years(&(*array).array[i]);
	}
	
	free((*array).array);
}

void copy_dt_value_lattice_years_array(dt_value_lattice_years_array * from, dt_value_lattice_years_array * to)
{
	int i;

	//to = init_dt_value_lattice_years_array();

	for(i = 0; i < (*from).size; i++)
	{
		add_dt_value_lattice_years(to, (*from).array[i].year, &(*from).array[i].values);
	}
}

/** \fn void add_dt_value_lattice_years(dt_value_lattice_years_array * array, int year, dt_value_lattice_array * values)
* \brief Add an dt_value_lattice_years to the dynamic dt_value_lattice_years array.
* \param array Pointer to the dynamic dt_value_lattice_years array.
* \param new_int The dt_value_lattice_years to add
*/
void add_dt_value_lattice_years(dt_value_lattice_years_array * array,  int year, /*@out@*/ dt_value_lattice_array * values)
{
	if((*array).size == (*array).total_size)
	{
		(*array).total_size = (int)((*array).total_size * ARRAY_GROWTH_RATE);
		(*array).array = (dt_value_lattice_years *)realloc((*array).array, ((*array).total_size * sizeof(dt_value_lattice_years)));
	}
	init_dt_value_lattice_years(&(*array).array[(*array).size]);
	(*array).array[(*array).size].year = year;
	if(values != NULL) copy_dt_value_lattice_array(values, &(*array).array[(*array).size].values);

	(*array).size++;
}

/** \fn void remove_dt_value_lattice_years(dt_value_lattice_years_array * array, int index)
 * \brief Remove an dt_value_lattice_years from a dynamic dt_value_lattice_years array.
 * \param array Pointer to the dynamic dt_value_lattice_years array.
 * \param index The index of the dt_value_lattice_years to remove.
 */
void remove_dt_value_lattice_years(dt_value_lattice_years_array * array, int index)
{
	int i;

	/* Free element at index index */
	free_dt_value_lattice_years(&(*array).array[index]);

	/* Copy all elements up by one */
	if(index < (*array).size)
	{
		for(i = index; i < (*array).size - 1; i++)
		{
			copy_dt_value_lattice_years(&(*array).array[i+1], &(*array).array[i]);
		}
		(*array).size--;
	}
}
/* Functions for the dt_monthly_estimations datatype */
/** \fn dt_monthly_estimations_array * init_dt_monthly_estimations_array()
 * \brief Allocate memory for a dynamic dt_monthly_estimations array.
 * \return dt_monthly_estimations_array Pointer to the new dynamic dt_monthly_estimations array.
 */
void init_dt_monthly_estimations_array(dt_monthly_estimations_array * array)
{
	(*array).size = 0;
	(*array).total_size = ARRAY_BLOCK_SIZE;
	(*array).array = (dt_monthly_estimations *)malloc(ARRAY_BLOCK_SIZE * sizeof(dt_monthly_estimations));
	CHECK_POINTER((*array).array);
}

/** \fn void reset_dt_monthly_estimations_array(dt_monthly_estimations_array* array)
* \brief Reset the dt_monthly_estimations array to hold nothing.
* \param array Pointer to the dynamic dt_monthly_estimations array.
*/
void reset_dt_monthly_estimations_array(dt_monthly_estimations_array * array)
{
	(*array).size = 0;
}

/** \fn void free_dt_monthly_estimations_array(dt_monthly_estimations_array * array)
* \brief Free the memory of a dynamic dt_monthly_estimations array.
* \param array Pointer to the dynamic dt_monthly_estimations array.
*/
void free_dt_monthly_estimations_array(dt_monthly_estimations_array * array)
{
	int i;
	
	for(i = 0; i < array->size; i++)
	{
		free_dt_monthly_estimations(&(*array).array[i]);
	}
	
	free((*array).array);
}

void copy_dt_monthly_estimations_array(dt_monthly_estimations_array * from, dt_monthly_estimations_array * to)
{
	int i;

	//to = init_dt_monthly_estimations_array();

	for(i = 0; i < (*from).size; i++)
	{
		add_dt_monthly_estimations(to, (*from).array[i].output, (*from).array[i].earnings, (*from).array[i].sold_quantity, (*from).array[i].labor_costs, (*from).array[i].capital_costs, (*from).array[i].interest_payments, (*from).array[i].wage, (*from).array[i].mean_specific_skills, (*from).array[i].average_productivity, (*from).array[i].investment_nominal);
	}
}

/** \fn void add_dt_monthly_estimations(dt_monthly_estimations_array * array, double output, double earnings, double sold_quantity, double labor_costs, double capital_costs, double interest_payments, double wage, double mean_specific_skills, double average_productivity, double investment_nominal)
* \brief Add an dt_monthly_estimations to the dynamic dt_monthly_estimations array.
* \param array Pointer to the dynamic dt_monthly_estimations array.
* \param new_int The dt_monthly_estimations to add
*/
void add_dt_monthly_estimations(dt_monthly_estimations_array * array,  double output,  double earnings,  double sold_quantity,  double labor_costs,  double capital_costs,  double interest_payments,  double wage,  double mean_specific_skills,  double average_productivity,  double investment_nominal)
{
	if((*array).size == (*array).total_size)
	{
		(*array).total_size = (int)((*array).total_size * ARRAY_GROWTH_RATE);
		(*array).array = (dt_monthly_estimations *)realloc((*array).array, ((*array).total_size * sizeof(dt_monthly_estimations)));
	}
	init_dt_monthly_estimations(&(*array).array[(*array).size]);
	(*array).array[(*array).size].output = output;
	(*array).array[(*array).size].earnings = earnings;
	(*array).array[(*array).size].sold_quantity = sold_quantity;
	(*array).array[(*array).size].labor_costs = labor_costs;
	(*array).array[(*array).size].capital_costs = capital_costs;
	(*array).array[(*array).size].interest_payments = interest_payments;
	(*array).array[(*array).size].wage = wage;
	(*array).array[(*array).size].mean_specific_skills = mean_specific_skills;
	(*array).array[(*array).size].average_productivity = average_productivity;
	(*array).array[(*array).size].investment_nominal = investment_nominal;

	(*array).size++;
}

/** \fn void remove_dt_monthly_estimations(dt_monthly_estimations_array * array, int index)
 * \brief Remove an dt_monthly_estimations from a dynamic dt_monthly_estimations array.
 * \param array Pointer to the dynamic dt_monthly_estimations array.
 * \param index The index of the dt_monthly_estimations to remove.
 */
void remove_dt_monthly_estimations(dt_monthly_estimations_array * array, int index)
{
	int i;

	/* Free element at index index */
	free_dt_monthly_estimations(&(*array).array[index]);

	/* Copy all elements up by one */
	if(index < (*array).size)
	{
		for(i = index; i < (*array).size - 1; i++)
		{
			copy_dt_monthly_estimations(&(*array).array[i+1], &(*array).array[i]);
		}
		(*array).size--;
	}
}

/** \fn int idle()
 * \brief an idle function for use by agents.
 */
int idle()
{
	return 0;
}

int FLAME_get_environment_variable_total_regions()
{
	return FLAME_environment_variable_total_regions;
}
int FLAME_get_environment_variable_id_debug_probe()
{
	return FLAME_environment_variable_id_debug_probe;
}
int FLAME_get_environment_variable_print_log()
{
	return FLAME_environment_variable_print_log;
}
int FLAME_get_environment_variable_print_debug_bankruptcy()
{
	return FLAME_environment_variable_print_debug_bankruptcy;
}
int FLAME_get_environment_variable_print_debug_eurostat()
{
	return FLAME_environment_variable_print_debug_eurostat;
}
int FLAME_get_environment_variable_print_debug_ch()
{
	return FLAME_environment_variable_print_debug_ch;
}
int FLAME_get_environment_variable_print_debug_afm()
{
	return FLAME_environment_variable_print_debug_afm;
}
int FLAME_get_environment_variable_print_debug_afm_ch()
{
	return FLAME_environment_variable_print_debug_afm_ch;
}
int FLAME_get_environment_variable_print_debug_exp1()
{
	return FLAME_environment_variable_print_debug_exp1;
}
int FLAME_get_environment_variable_print_debug_file_exp1()
{
	return FLAME_environment_variable_print_debug_file_exp1;
}
int FLAME_get_environment_variable_print_debug_file_exp2()
{
	return FLAME_environment_variable_print_debug_file_exp2;
}
int FLAME_get_environment_variable_policy_exp1()
{
	return FLAME_environment_variable_policy_exp1;
}
int FLAME_get_environment_variable_print_debug_gov()
{
	return FLAME_environment_variable_print_debug_gov;
}
int FLAME_get_environment_variable_print_debug_household()
{
	return FLAME_environment_variable_print_debug_household;
}
int FLAME_get_environment_variable_print_debug_credit()
{
	return FLAME_environment_variable_print_debug_credit;
}
int FLAME_get_environment_variable_print_debug_consumption()
{
	return FLAME_environment_variable_print_debug_consumption;
}
int FLAME_get_environment_variable_print_debug_finman()
{
	return FLAME_environment_variable_print_debug_finman;
}
int FLAME_get_environment_variable_print_debug_production()
{
	return FLAME_environment_variable_print_debug_production;
}
int FLAME_get_environment_variable_print_debug()
{
	return FLAME_environment_variable_print_debug;
}
int FLAME_get_environment_variable_print_debug_market_research()
{
	return FLAME_environment_variable_print_debug_market_research;
}
int FLAME_get_environment_variable_policy_exp_energy_shock()
{
	return FLAME_environment_variable_policy_exp_energy_shock;
}
int FLAME_get_environment_variable_policy_exp_stabilization_subsidy()
{
	return FLAME_environment_variable_policy_exp_stabilization_subsidy;
}
int FLAME_get_environment_variable_policy_exp_stabilization_tax()
{
	return FLAME_environment_variable_policy_exp_stabilization_tax;
}
int FLAME_get_environment_variable_const_bankruptcy_idle_period()
{
	return FLAME_environment_variable_const_bankruptcy_idle_period;
}
int FLAME_get_environment_variable_days_per_month()
{
	return FLAME_environment_variable_days_per_month;
}
int FLAME_get_environment_variable_xml_cloned()
{
	return FLAME_environment_variable_xml_cloned;
}
int FLAME_get_environment_variable_individual_learning()
{
	return FLAME_environment_variable_individual_learning;
}
double FLAME_get_environment_variable_const_wage_wealth_ratio()
{
	return FLAME_environment_variable_const_wage_wealth_ratio;
}
double FLAME_get_environment_variable_const_income_tax_rate()
{
	return FLAME_environment_variable_const_income_tax_rate;
}
double FLAME_get_environment_variable_gamma_const()
{
	return FLAME_environment_variable_gamma_const;
}
double FLAME_get_environment_variable_gamma_quality()
{
	return FLAME_environment_variable_gamma_quality;
}
double FLAME_get_environment_variable_initial_price()
{
	return FLAME_environment_variable_initial_price;
}
double FLAME_get_environment_variable_depreciation_rate()
{
	return FLAME_environment_variable_depreciation_rate;
}
double FLAME_get_environment_variable_discont_rate()
{
	return FLAME_environment_variable_discont_rate;
}
double FLAME_get_environment_variable_mark_up()
{
	return FLAME_environment_variable_mark_up;
}
double FLAME_get_environment_variable_lambda()
{
	return FLAME_environment_variable_lambda;
}
double FLAME_get_environment_variable_target_savings_rate()
{
	return FLAME_environment_variable_target_savings_rate;
}
double FLAME_get_environment_variable_carrol_consumption_parameter()
{
	return FLAME_environment_variable_carrol_consumption_parameter;
}
double FLAME_get_environment_variable_quantil_normal_distribution()
{
	return FLAME_environment_variable_quantil_normal_distribution;
}
int FLAME_get_environment_variable_firm_planning_horizon()
{
	return FLAME_environment_variable_firm_planning_horizon;
}
double FLAME_get_environment_variable_initial_stock_up()
{
	return FLAME_environment_variable_initial_stock_up;
}
int FLAME_get_environment_variable_initial_price_adjustment()
{
	return FLAME_environment_variable_initial_price_adjustment;
}
double FLAME_get_environment_variable_adaption_delivery_volume()
{
	return FLAME_environment_variable_adaption_delivery_volume;
}
double FLAME_get_environment_variable_inv_inertia()
{
	return FLAME_environment_variable_inv_inertia;
}
int FLAME_get_environment_variable_planning_horizon_vintage_choice()
{
	return FLAME_environment_variable_planning_horizon_vintage_choice;
}
double FLAME_get_environment_variable_gamma_logit_vintage_choice()
{
	return FLAME_environment_variable_gamma_logit_vintage_choice;
}
double FLAME_get_environment_variable_delta_logit_vintage_choice()
{
	return FLAME_environment_variable_delta_logit_vintage_choice;
}
int FLAME_get_environment_variable_number_of_banks_to_apply()
{
	return FLAME_environment_variable_number_of_banks_to_apply;
}
int FLAME_get_environment_variable_const_number_of_banks()
{
	return FLAME_environment_variable_const_number_of_banks;
}
int FLAME_get_environment_variable_const_installment_periods()
{
	return FLAME_environment_variable_const_installment_periods;
}
double FLAME_get_environment_variable_bank_lambda()
{
	return FLAME_environment_variable_bank_lambda;
}
double FLAME_get_environment_variable_ecb_interest_rate()
{
	return FLAME_environment_variable_ecb_interest_rate;
}
double FLAME_get_environment_variable_ecb_interest_rate_markdown()
{
	return FLAME_environment_variable_ecb_interest_rate_markdown;
}
double FLAME_get_environment_variable_alfa()
{
	return FLAME_environment_variable_alfa;
}
double FLAME_get_environment_variable_min_cash_reserve_ratio()
{
	return FLAME_environment_variable_min_cash_reserve_ratio;
}
double FLAME_get_environment_variable_const_firm_leverage()
{
	return FLAME_environment_variable_const_firm_leverage;
}
double FLAME_get_environment_variable_debt_rescaling_factor()
{
	return FLAME_environment_variable_debt_rescaling_factor;
}
double FLAME_get_environment_variable_target_leverage_ratio()
{
	return FLAME_environment_variable_target_leverage_ratio;
}
double FLAME_get_environment_variable_target_liquidity_ratio()
{
	return FLAME_environment_variable_target_liquidity_ratio;
}
double FLAME_get_environment_variable_const_dividend_earnings_ratio()
{
	return FLAME_environment_variable_const_dividend_earnings_ratio;
}
double FLAME_get_environment_variable_const_dividend_treshold_full_payout()
{
	return FLAME_environment_variable_const_dividend_treshold_full_payout;
}
int FLAME_get_environment_variable_igfirm_dividend_payout_stretching_month()
{
	return FLAME_environment_variable_igfirm_dividend_payout_stretching_month;
}
double FLAME_get_environment_variable_index_price_adj()
{
	return FLAME_environment_variable_index_price_adj;
}
double FLAME_get_environment_variable_index_price_adj_max()
{
	return FLAME_environment_variable_index_price_adj_max;
}
double FLAME_get_environment_variable_index_price_adj_min()
{
	return FLAME_environment_variable_index_price_adj_min;
}
int FLAME_get_environment_variable_trading_activity()
{
	return FLAME_environment_variable_trading_activity;
}
int FLAME_get_environment_variable_trading_random()
{
	return FLAME_environment_variable_trading_random;
}
int FLAME_get_environment_variable_igfirm_fin_man_debug()
{
	return FLAME_environment_variable_igfirm_fin_man_debug;
}
double FLAME_get_environment_variable_const_igfirm_dividend_target_pct()
{
	return FLAME_environment_variable_const_igfirm_dividend_target_pct;
}
double FLAME_get_environment_variable_const_igfirm_dividend_adjustment_parameter()
{
	return FLAME_environment_variable_const_igfirm_dividend_adjustment_parameter;
}
int FLAME_get_environment_variable_switch_igfirm_endogenous_innovation_probability()
{
	return FLAME_environment_variable_switch_igfirm_endogenous_innovation_probability;
}
double FLAME_get_environment_variable_igfirm_exogenous_innovation_probability()
{
	return FLAME_environment_variable_igfirm_exogenous_innovation_probability;
}
double FLAME_get_environment_variable_power_of_end_probability_function()
{
	return FLAME_environment_variable_power_of_end_probability_function;
}
int FLAME_get_environment_variable_igfirm_producer_debug()
{
	return FLAME_environment_variable_igfirm_producer_debug;
}
double FLAME_get_environment_variable_igfirm_exogenous_productivity_progress()
{
	return FLAME_environment_variable_igfirm_exogenous_productivity_progress;
}
int FLAME_get_environment_variable_symmetric_shock()
{
	return FLAME_environment_variable_symmetric_shock;
}
int FLAME_get_environment_variable_energy_shock_start()
{
	return FLAME_environment_variable_energy_shock_start;
}
int FLAME_get_environment_variable_energy_shock_end()
{
	return FLAME_environment_variable_energy_shock_end;
}
double FLAME_get_environment_variable_const_energy_shock_intensity()
{
	return FLAME_environment_variable_const_energy_shock_intensity;
}
int FLAME_get_environment_variable_energy_shock_frequency()
{
	return FLAME_environment_variable_energy_shock_frequency;
}
int FLAME_get_environment_variable_transition_phase()
{
	return FLAME_environment_variable_transition_phase;
}
int FLAME_get_environment_variable_innovation_by_random()
{
	return FLAME_environment_variable_innovation_by_random;
}
int FLAME_get_environment_variable_ig_good_limited_offer()
{
	return FLAME_environment_variable_ig_good_limited_offer;
}
int FLAME_get_environment_variable_max_offer_ig_good()
{
	return FLAME_environment_variable_max_offer_ig_good;
}
double FLAME_get_environment_variable_initial_frontier_firm_transition_phase()
{
	return FLAME_environment_variable_initial_frontier_firm_transition_phase;
}
double FLAME_get_environment_variable_initial_productivity_firm()
{
	return FLAME_environment_variable_initial_productivity_firm;
}
double FLAME_get_environment_variable_initial_specific_skills()
{
	return FLAME_environment_variable_initial_specific_skills;
}
int FLAME_get_environment_variable_strenght_of_tech_progress()
{
	return FLAME_environment_variable_strenght_of_tech_progress;
}
double FLAME_get_environment_variable_linear_combination_pricing_ig_good()
{
	return FLAME_environment_variable_linear_combination_pricing_ig_good;
}
double FLAME_get_environment_variable_initial_capital_price_wage_ratio()
{
	return FLAME_environment_variable_initial_capital_price_wage_ratio;
}
double FLAME_get_environment_variable_union_strength()
{
	return FLAME_environment_variable_union_strength;
}
int FLAME_get_environment_variable_reg_diff_union_strength()
{
	return FLAME_environment_variable_reg_diff_union_strength;
}
double FLAME_get_environment_variable_reg2_factor_union_strength()
{
	return FLAME_environment_variable_reg2_factor_union_strength;
}
double FLAME_get_environment_variable_wage_update()
{
	return FLAME_environment_variable_wage_update;
}
int FLAME_get_environment_variable_min_vacancy()
{
	return FLAME_environment_variable_min_vacancy;
}
double FLAME_get_environment_variable_wage_reservation_update()
{
	return FLAME_environment_variable_wage_reservation_update;
}
double FLAME_get_environment_variable_region_cost()
{
	return FLAME_environment_variable_region_cost;
}
double FLAME_get_environment_variable_delivery_prob_if_critical_stock_0()
{
	return FLAME_environment_variable_delivery_prob_if_critical_stock_0;
}
int FLAME_get_environment_variable_labormarket_scenario_reg2()
{
	return FLAME_environment_variable_labormarket_scenario_reg2;
}
int FLAME_get_environment_variable_number_applications()
{
	return FLAME_environment_variable_number_applications;
}
int FLAME_get_environment_variable_applications_per_day()
{
	return FLAME_environment_variable_applications_per_day;
}
int FLAME_get_environment_variable_lower_bound_firing()
{
	return FLAME_environment_variable_lower_bound_firing;
}
int FLAME_get_environment_variable_upper_bound_firing()
{
	return FLAME_environment_variable_upper_bound_firing;
}
double FLAME_get_environment_variable_logit_parameter_specific_skills()
{
	return FLAME_environment_variable_logit_parameter_specific_skills;
}
double FLAME_get_environment_variable_logit_parameter_worker_preselection()
{
	return FLAME_environment_variable_logit_parameter_worker_preselection;
}
double FLAME_get_environment_variable_logit_parameter_general_skills()
{
	return FLAME_environment_variable_logit_parameter_general_skills;
}
int FLAME_get_environment_variable_skill_update_acc_to_formula()
{
	return FLAME_environment_variable_skill_update_acc_to_formula;
}
int FLAME_get_environment_variable_rnd_seed()
{
	return FLAME_environment_variable_rnd_seed;
}
double FLAME_get_environment_variable_gov_policy_unemployment_benefit_pct()
{
	return FLAME_environment_variable_gov_policy_unemployment_benefit_pct;
}
double FLAME_get_environment_variable_gamma_gov()
{
	return FLAME_environment_variable_gamma_gov;
}
int FLAME_get_environment_variable_joe_scenario()
{
	return FLAME_environment_variable_joe_scenario;
}
int FLAME_get_environment_variable_gov_expenditures_and_unemp_benefits_redistributed()
{
	return FLAME_environment_variable_gov_expenditures_and_unemp_benefits_redistributed;
}
double FLAME_get_environment_variable_gov_policy_money_financing_fraction()
{
	return FLAME_environment_variable_gov_policy_money_financing_fraction;
}
int FLAME_get_environment_variable_adaptive_tax_rates()
{
	return FLAME_environment_variable_adaptive_tax_rates;
}
int FLAME_get_environment_variable_gov_2_relaxed_budget_rule()
{
	return FLAME_environment_variable_gov_2_relaxed_budget_rule;
}
double FLAME_get_environment_variable_gov_2_expenditures_covered()
{
	return FLAME_environment_variable_gov_2_expenditures_covered;
}
double FLAME_get_environment_variable_gov_2_consumption_ratio()
{
	return FLAME_environment_variable_gov_2_consumption_ratio;
}
int FLAME_get_environment_variable_gov_regional_consumption_scenario()
{
	return FLAME_environment_variable_gov_regional_consumption_scenario;
}
double FLAME_get_environment_variable_reg2_markup_factor()
{
	return FLAME_environment_variable_reg2_markup_factor;
}
int FLAME_get_environment_variable_migration_region_id()
{
	return FLAME_environment_variable_migration_region_id;
}
double FLAME_get_environment_variable_migration_allocation_quota()
{
	return FLAME_environment_variable_migration_allocation_quota;
}
int FLAME_get_environment_variable_migration_allocation_policy()
{
	return FLAME_environment_variable_migration_allocation_policy;
}
int FLAME_get_environment_variable_migration_experiment()
{
	return FLAME_environment_variable_migration_experiment;
}
int FLAME_get_environment_variable_minimum_wage_policy()
{
	return FLAME_environment_variable_minimum_wage_policy;
}
double FLAME_get_environment_variable_minimum_wage_policy_target_minimum_wage()
{
	return FLAME_environment_variable_minimum_wage_policy_target_minimum_wage;
}
int FLAME_get_environment_variable_policy_migration_top_up_benefits()
{
	return FLAME_environment_variable_policy_migration_top_up_benefits;
}
int FLAME_get_environment_variable_policy_migration_wage_subsidies()
{
	return FLAME_environment_variable_policy_migration_wage_subsidies;
}
int FLAME_get_environment_variable_policy_migration_wage_subsidies_targeted()
{
	return FLAME_environment_variable_policy_migration_wage_subsidies_targeted;
}
double FLAME_get_environment_variable_migration_top_up_benefit()
{
	return FLAME_environment_variable_migration_top_up_benefit;
}
int FLAME_get_environment_variable_migration_date()
{
	return FLAME_environment_variable_migration_date;
}
double FLAME_get_environment_variable_gov_policy_gdp_fraction_consumption()
{
	return FLAME_environment_variable_gov_policy_gdp_fraction_consumption;
}
int FLAME_get_environment_variable_exp_firm_subsidy_scenario()
{
	return FLAME_environment_variable_exp_firm_subsidy_scenario;
}
int FLAME_get_environment_variable_austerity_policy()
{
	return FLAME_environment_variable_austerity_policy;
}
int FLAME_get_environment_variable_austerity_policy_scenario()
{
	return FLAME_environment_variable_austerity_policy_scenario;
}
int FLAME_get_environment_variable_austerity_repay_scenario()
{
	return FLAME_environment_variable_austerity_repay_scenario;
}
double FLAME_get_environment_variable_austerity_consumption_threshold()
{
	return FLAME_environment_variable_austerity_consumption_threshold;
}
double FLAME_get_environment_variable_austerity_debt_threshold()
{
	return FLAME_environment_variable_austerity_debt_threshold;
}
int FLAME_get_environment_variable_austerity_repayment_period()
{
	return FLAME_environment_variable_austerity_repayment_period;
}
double FLAME_get_environment_variable_gov_policy_gdp_fraction_investment()
{
	return FLAME_environment_variable_gov_policy_gdp_fraction_investment;
}
int FLAME_get_environment_variable_no_regions_per_gov()
{
	return FLAME_environment_variable_no_regions_per_gov;
}
int FLAME_get_environment_variable_flexibility_policy()
{
	return FLAME_environment_variable_flexibility_policy;
}
int FLAME_get_environment_variable_gov_budgeting_horizon()
{
	return FLAME_environment_variable_gov_budgeting_horizon;
}
double FLAME_get_environment_variable_subsidy_trigger_on()
{
	return FLAME_environment_variable_subsidy_trigger_on;
}
double FLAME_get_environment_variable_subsidy_trigger_off()
{
	return FLAME_environment_variable_subsidy_trigger_off;
}
int FLAME_get_environment_variable_policy_starting_at_iteration()
{
	return FLAME_environment_variable_policy_starting_at_iteration;
}
int FLAME_get_environment_variable_gov_policy_swith_quantitative_easing()
{
	return FLAME_environment_variable_gov_policy_swith_quantitative_easing;
}
int FLAME_get_environment_variable_gov_policy_switch_human_capital_improvement()
{
	return FLAME_environment_variable_gov_policy_switch_human_capital_improvement;
}
int FLAME_get_environment_variable_subsidy_redistribution()
{
	return FLAME_environment_variable_subsidy_redistribution;
}
int FLAME_get_environment_variable_tech_policy_effectiveness_switch()
{
	return FLAME_environment_variable_tech_policy_effectiveness_switch;
}
double FLAME_get_environment_variable_probability_tech_policy_effectiveness()
{
	return FLAME_environment_variable_probability_tech_policy_effectiveness;
}
int FLAME_get_environment_variable_policy_exp_best_technology_subsidy()
{
	return FLAME_environment_variable_policy_exp_best_technology_subsidy;
}
double FLAME_get_environment_variable_subsidy_redistribution_parameter()
{
	return FLAME_environment_variable_subsidy_redistribution_parameter;
}
int FLAME_get_environment_variable_policy_exp_all_technologies_subsidy()
{
	return FLAME_environment_variable_policy_exp_all_technologies_subsidy;
}
int FLAME_get_environment_variable_regional_policy_technology_subsidy()
{
	return FLAME_environment_variable_regional_policy_technology_subsidy;
}
double FLAME_get_environment_variable_best_technology_subsidy_pct()
{
	return FLAME_environment_variable_best_technology_subsidy_pct;
}
int FLAME_get_environment_variable_innovation_switched_on()
{
	return FLAME_environment_variable_innovation_switched_on;
}
double FLAME_get_environment_variable_mr_start_price()
{
	return FLAME_environment_variable_mr_start_price;
}
double FLAME_get_environment_variable_mr_end_price()
{
	return FLAME_environment_variable_mr_end_price;
}
double FLAME_get_environment_variable_mr_price_increment()
{
	return FLAME_environment_variable_mr_price_increment;
}
int FLAME_get_environment_variable_max_no_employees_product_innovation()
{
	return FLAME_environment_variable_max_no_employees_product_innovation;
}


