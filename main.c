/**
 * \file  main.c
 * \brief Holds main function of the program.
 */
#include <time.h>
#include <gsl/gsl_rng.h>
#include "header.h"

//Global GSL RNG: global constant variable: continues to exist for whole duration of main
gsl_rng * FLAME_GSL_RNG;  /* global GSL random generator */


#define COMPACT_PRINTOUT_P_THRESHOLD 8

/** \fn int main(int argc, char * argv[])
 * \brief Main program loop.
 * \param argc Argument count.
 * \param argv Pointer Pointer to Argument vector.
 */
int main(int argc, char * argv[])
{
	/* Timing variables */
	double start, stop, interval;
	FILE *file;
	char data[100];
	char logfilepath[1000];
	char inputpath[1000];
	char * c;
	int lastd = 0;
	int i;
	int rc;
	int iteration_number = 0;
	int iteration_total;
	int * p_iteration_number = &iteration_number;
	//xmachine_memory_Firm * temp_xmachine_Firm;
	//xmachine_memory_Household * temp_xmachine_Household;
	//xmachine_memory_Mall * temp_xmachine_Mall;
	//xmachine_memory_IGFirm * temp_xmachine_IGFirm;
	//xmachine_memory_Eurostat * temp_xmachine_Eurostat;
	//xmachine_memory_Bank * temp_xmachine_Bank;
	//xmachine_memory_Government * temp_xmachine_Government;
	//xmachine_memory_CentralBank * temp_xmachine_CentralBank;
	//xmachine_memory_ClearingHouse * temp_xmachine_ClearingHouse;

	int FLAME_bank_account_update_message_board_write;
	int FLAME_bank_account_update_message_board_read;
	int FLAME_bank_to_central_bank_account_update_message_board_write;
	int FLAME_bank_to_central_bank_account_update_message_board_read;
	int FLAME_gov_to_central_bank_account_update_message_board_write;
	int FLAME_gov_to_central_bank_account_update_message_board_read;
	int FLAME_wage_payment_message_board_write;
	int FLAME_wage_payment_message_board_read;
	int FLAME_quality_price_info_1_message_board_write;
	int FLAME_quality_price_info_1_message_board_read;
	int FLAME_quality_price_info_2_message_board_write;
	int FLAME_quality_price_info_2_message_board_read;
	int FLAME_update_mall_stock_message_board_write;
	int FLAME_update_mall_stock_message_board_read;
	int FLAME_consumption_request_1_message_board_write;
	int FLAME_consumption_request_1_message_board_read;
	int FLAME_consumption_request_2_message_board_write;
	int FLAME_consumption_request_2_message_board_read;
	int FLAME_accepted_consumption_1_message_board_write;
	int FLAME_accepted_consumption_1_message_board_read;
	int FLAME_accepted_consumption_2_message_board_write;
	int FLAME_accepted_consumption_2_message_board_read;
	int FLAME_sales_message_board_write;
	int FLAME_sales_message_board_read;
	int FLAME_specific_skill_update_message_board_write;
	int FLAME_specific_skill_update_message_board_read;
	int FLAME_policy_rate_message_board_write;
	int FLAME_policy_rate_message_board_read;
	int FLAME_bank_identity_message_board_write;
	int FLAME_bank_identity_message_board_read;
	int FLAME_loan_request_message_board_write;
	int FLAME_loan_request_message_board_read;
	int FLAME_loan_request_ranked_message_board_write;
	int FLAME_loan_request_ranked_message_board_read;
	int FLAME_loan_conditions_message_board_write;
	int FLAME_loan_conditions_message_board_read;
	int FLAME_loan_acceptance_message_board_write;
	int FLAME_loan_acceptance_message_board_read;
	int FLAME_installment_message_board_write;
	int FLAME_installment_message_board_read;
	int FLAME_bankruptcy_message_board_write;
	int FLAME_bankruptcy_message_board_read;
	int FLAME_bank_interest_payment_message_board_write;
	int FLAME_bank_interest_payment_message_board_read;
	int FLAME_account_interest_message_board_write;
	int FLAME_account_interest_message_board_read;
	int FLAME_ecb_dividend_message_board_write;
	int FLAME_ecb_dividend_message_board_read;
	int FLAME_credit_var_update_message_board_write;
	int FLAME_credit_var_update_message_board_read;
	int FLAME_bankruptcy_illiquidity_message_board_write;
	int FLAME_bankruptcy_illiquidity_message_board_read;
	int FLAME_bankruptcy_insolvency_message_board_write;
	int FLAME_bankruptcy_insolvency_message_board_read;
	int FLAME_index_info_message_board_write;
	int FLAME_index_info_message_board_read;
	int FLAME_index_price_message_board_write;
	int FLAME_index_price_message_board_read;
	int FLAME_order_message_board_write;
	int FLAME_order_message_board_read;
	int FLAME_order_status_message_board_write;
	int FLAME_order_status_message_board_read;
	int FLAME_dividend_info_message_board_write;
	int FLAME_dividend_info_message_board_read;
	int FLAME_productivity_message_board_write;
	int FLAME_productivity_message_board_read;
	int FLAME_capital_good_request_message_board_write;
	int FLAME_capital_good_request_message_board_read;
	int FLAME_capital_good_delivery_message_board_write;
	int FLAME_capital_good_delivery_message_board_read;
	int FLAME_pay_capital_goods_message_board_write;
	int FLAME_pay_capital_goods_message_board_read;
	int FLAME_vacancies_message_board_write;
	int FLAME_vacancies_message_board_read;
	int FLAME_vacancies2_message_board_write;
	int FLAME_vacancies2_message_board_read;
	int FLAME_vacancies_r_and_d_employees_message_board_write;
	int FLAME_vacancies_r_and_d_employees_message_board_read;
	int FLAME_vacancies_r_and_d_employees2_message_board_write;
	int FLAME_vacancies_r_and_d_employees2_message_board_read;
	int FLAME_firing_message_board_write;
	int FLAME_firing_message_board_read;
	int FLAME_job_application_message_board_write;
	int FLAME_job_application_message_board_read;
	int FLAME_job_application2_message_board_write;
	int FLAME_job_application2_message_board_read;
	int FLAME_job_offer_message_board_write;
	int FLAME_job_offer_message_board_read;
	int FLAME_job_offer2_message_board_write;
	int FLAME_job_offer2_message_board_read;
	int FLAME_job_acceptance_message_board_write;
	int FLAME_job_acceptance_message_board_read;
	int FLAME_job_acceptance2_message_board_write;
	int FLAME_job_acceptance2_message_board_read;
	int FLAME_quitting_message_board_write;
	int FLAME_quitting_message_board_read;
	int FLAME_quitting2_message_board_write;
	int FLAME_quitting2_message_board_read;
	int FLAME_unemployment_notification_message_board_write;
	int FLAME_unemployment_notification_message_board_read;
	int FLAME_policy_announcement_message_board_write;
	int FLAME_policy_announcement_message_board_read;
	int FLAME_tax_payment_message_board_write;
	int FLAME_tax_payment_message_board_read;
	int FLAME_unemployment_benefit_restitution_message_board_write;
	int FLAME_unemployment_benefit_restitution_message_board_read;
	int FLAME_hh_transfer_notification_message_board_write;
	int FLAME_hh_transfer_notification_message_board_read;
	int FLAME_hh_subsidy_notification_message_board_write;
	int FLAME_hh_subsidy_notification_message_board_read;
	int FLAME_human_capital_policy_announcement_message_board_write;
	int FLAME_human_capital_policy_announcement_message_board_read;
	int FLAME_firm_transfer_notification_message_board_write;
	int FLAME_firm_transfer_notification_message_board_read;
	int FLAME_firm_subsidy_notification_message_board_write;
	int FLAME_firm_subsidy_notification_message_board_read;
	int FLAME_request_fiat_money_message_board_write;
	int FLAME_request_fiat_money_message_board_read;
	int FLAME_human_capital_policy_general_skill_information_message_board_write;
	int FLAME_human_capital_policy_general_skill_information_message_board_read;
	int FLAME_human_capital_policy_new_general_skill_notification_message_board_write;
	int FLAME_human_capital_policy_new_general_skill_notification_message_board_read;
	int FLAME_firm_send_data_message_board_write;
	int FLAME_firm_send_data_message_board_read;
	int FLAME_government_send_data_message_board_write;
	int FLAME_government_send_data_message_board_read;
	int FLAME_household_send_data_message_board_write;
	int FLAME_household_send_data_message_board_read;
	int FLAME_mall_data_message_board_write;
	int FLAME_mall_data_message_board_read;
	int FLAME_eurostat_send_specific_skills_message_board_write;
	int FLAME_eurostat_send_specific_skills_message_board_read;
	int FLAME_data_for_government_message_board_write;
	int FLAME_data_for_government_message_board_read;
	int FLAME_eurostat_send_macrodata_message_board_write;
	int FLAME_eurostat_send_macrodata_message_board_read;
	int FLAME_msg_firm_id_to_malls_message_board_write;
	int FLAME_msg_firm_id_to_malls_message_board_read;
	int FLAME_msg_mall_id_to_firms_message_board_write;
	int FLAME_msg_mall_id_to_firms_message_board_read;
	int FLAME_msg_skills_eurostat_to_igfirm_message_board_write;
	int FLAME_msg_skills_eurostat_to_igfirm_message_board_read;
	int FLAME_msg_market_sizes_message_board_write;
	int FLAME_msg_market_sizes_message_board_read;
	int FLAME_total_subsidies_message_board_write;
	int FLAME_total_subsidies_message_board_read;
	int FLAME_redistributed_subsidies_message_board_write;
	int FLAME_redistributed_subsidies_message_board_read;
	int FLAME_quality_price_message_board_write;
	int FLAME_quality_price_message_board_read;
	int FLAME_interview_request_message_board_write;
	int FLAME_interview_request_message_board_read;
	int FLAME_interview_positive_response_message_board_write;
	int FLAME_interview_positive_response_message_board_read;
	int FLAME_questionnaire_innovation_message_board_write;
	int FLAME_questionnaire_innovation_message_board_read;
	int FLAME_filled_out_questionnaire_product_innovation_message_board_write;
	int FLAME_filled_out_questionnaire_product_innovation_message_board_read;

	/* Particle cloud data */
	double cloud_data[6] = {0.0,0.0,0.0,0.0,0.0,0.0};


/* For partition method. Makes geometric (-g flag) the default but may be overridden with -r for round-robin */
	int partition_method=1;



	/* Output frequency is 1 as default */
	output_frequency = 1;

	/* Set random seed */
/* Overwritten by GSL Random Number Generator, see below */
/*	srand(time(NULL)); */

	

	rc = MB_Env_Init();
	#ifdef ERRCHECK
	if (rc != MB_SUCCESS)
	{
	   fprintf(stderr, "ERROR: Failed to initialise Message Board environment\n");
	   switch(rc) {
	       case MB_ERR_MPI:
	           fprintf(stderr, "\t reason: MPI library not initialised\n");
	           break;
	       case MB_ERR_MEMALLOC:
	           fprintf(stderr, "\t reason: out of memory\n");
	           break;
           default:
               fprintf(stderr, "\t MB_Env_Init returned error code: %d (see libmboard docs for details)\n", rc);
               break;
	   }

	   
       exit(rc);

	}
	#endif
    
	/* For backwards compatabilty allocate current_xmachine */
	current_xmachine = (xmachine *)malloc(sizeof(xmachine));
	if(current_xmachine == NULL) {printf("**** ERROR in Memory check current_xmachine\n");exit(EXIT_FAILURE);}
	/*CHECK_POINTER(current_xmachine);*/

	/* Initialise pointers */
	initialise_pointers();


	printf("FLAME Application: Eurace Model \n");






if(argc < 2)
	{

		printf("Usage: %s <number of iterations> [<states_directory>]/<init_state> <partitions> [-f # | -f #+#]\n",argv[0]);
		printf("\t-f\tOutput frequency, 1st # is frequency, 2nd # is the offset if required\n");



		exit(0);
	}
	iteration_total = atoi(argv[1]);
printf("Iterations: %i\n", iteration_total);

	/* Read initial states of x-machines */
	if(argc < 3)
	{
		printf("Need two parameters\n");
		exit(0);
	}
	strcpy(inputpath, argv[2]);
/*printf("Initial states: %s\n", inputpath);*/

	i = 0;
	lastd = -1;
	while(inputpath[i] != '\0')
	{
		/* For windows directories */
		if(inputpath[i] == '\\') lastd=i;
		/* For unix directories */
		if(inputpath[i] == '/') lastd=i;
		i++;
	}
	strcpy(outputpath, inputpath);
	outputpath[lastd+1] = '\0';

/*printf("Ouput dir: %s\n", outputpath);*/


	/* Read number of space partitions (1 by default) */
	totalnodes = 1;
	if(argc > 3)
	{
		totalnodes = atoi(argv[3]);
	}


	i = 3;
	while(argc > i)
	{
		if(strcmp(argv[i],"-f") == 0)
		{
			if(argc > (i+1))
			{
				output_offset = 0;
				/* Find offset, separated by the char '+' */
				c = strchr(argv[(i+1)], '+');
				if(c == NULL)
				{
					output_frequency = atoi(argv[(i+1)]);
					printf("Using output frequency of: %d\n", output_frequency);
				}
				else
				{
					output_offset = atoi(argv[(i+1)]+(c-argv[(i+1)])+1);
					argv[(i+1)][c-argv[(i+1)]] = '\0';
					output_frequency = atoi(argv[(i+1)]);
					printf("Using output frequency of: %d with offset %d\n", output_frequency, output_offset);
				}

				if(output_frequency == 0)
				{
					printf("Output frequency cannot be zero\n");
					exit(0);
				}

				i++;
			}
			else
			{
				printf("Output frequency number not defined\n");
				exit(0);
			}
		}
		/* Partitioning method: -g = geometric, -r = round-robin */
		if(strcmp(argv[i],"-g") == 0) partition_method = 1;
		if(strcmp(argv[i],"-r") == 0) partition_method = 2;
		i++;
	}


	    /* Read initial data into p_xmachine  */

       //agent_list = p_xmachine;
       readinitialstates(inputpath, outputpath, p_iteration_number, cloud_data, partition_method, 0);
       /* Generate partitions */
       generate_partitions(cloud_data,totalnodes,partition_method);
       save_partition_data();





    /* Partition data */
    /* stc: no partitions in serial */
	//partition_data(totalnodes, agent_list, cloud_data, partition_method);




/******* GSL INIT */
/* Use GSL Random Number Generator */
	const gsl_rng_type * T;

	gsl_rng_env_setup();

	//returns a pointer to a newly-created instance of gsl_rng
	T = gsl_rng_default;
	FLAME_GSL_RNG = gsl_rng_alloc (T);

	//Init on time
	unsigned long int gsl_seed = (unsigned long int)time(NULL);

//30.01.12: Fix seed to XML value in debug
	

	gsl_rng_set(FLAME_GSL_RNG, gsl_seed);

	printf ("[GSL Random Number Generator] generator type: %s\n", gsl_rng_name (FLAME_GSL_RNG));
	printf ("[GSL Random Number Generator] seed = %lu\n", gsl_seed);
	printf ("[GSL Random Number Generator] first value = %lu\n", gsl_rng_get (FLAME_GSL_RNG));
/******* END GSL INIT */

/* Use MB_IndexMap routines from libmboard v0.2 */
/* For each agent constant (that is used in a filter(?))
 * declare an index map handle */



		/*i = 0;
		current_node = *p_node_info;
		while(current_node)
		{
			printf("No of agents on partition %d: %d\n", current_node->node_id, current_node->agent_total);
			i += current_node->agent_total;
			current_node = current_node->next;
		}
		printf("Agent total check: %d\n", i);*/

        /* restore current_node pointer */
		//current_node = *p_node_info;



	/* Start log file (now so that xvisualiser can read straight away) */

	/* Write log file */
	sprintf(logfilepath, "%slog.xml", outputpath);
	if((file = fopen(logfilepath, "w"))==NULL)
	{
		printf("Error: cannot open file '%s' for writing\n", logfilepath);
		exit(0);
	}
	(void)fputs("<model_run>\n", file);
	(void)fputs("<codetype>", file);
	(void)fputs("serial", file);

	(void)fputs("</codetype>\n", file);
	(void)fputs("<nodes>", file);
	sprintf(data, "%i", totalnodes);
	(void)fputs(data, file);
	(void)fputs("</nodes>\n", file);

	/* print timer into */
	(void)fputs("<!-- <time> unit: milliseconds -->\n", file);

	sprintf(data, "unspecified");
	
	(void)fputs("<!-- <time> timer resolution: ", file);
	(void)fputs(data, file);
	(void)fputs(")-->\n", file);

	start = get_time();
	stop = get_time();
	sprintf(data, "%.2e ms", (stop - start) * 1000.0);
	(void)fputs("<!-- <time> timer overhead: ~", file);
	(void)fputs(data, file);
	(void)fputs(")-->\n", file);


	(void)fclose(file);


	/* For each message check if their exists agents that input/output the message */
	FLAME_bank_account_update_message_board_write = 0;
	FLAME_bank_account_update_message_board_read = 0;
	/* Sending agents */
	if(Firm_start_Firm_state->agents != NULL) FLAME_bank_account_update_message_board_write = 1;
	if(Household_start_Household_state->agents != NULL) FLAME_bank_account_update_message_board_write = 1;
	if(IGFirm_IGFirm_start_state->agents != NULL) FLAME_bank_account_update_message_board_write = 1;
	
	/* Reading agents */
	if(Bank_start_Bank_state->agents != NULL) FLAME_bank_account_update_message_board_read = 1;
	
	/* Call message board library with details */
	if(FLAME_bank_account_update_message_board_write == 0 &&
		FLAME_bank_account_update_message_board_read == 0)
			rc = MB_SetAccessMode(b_bank_account_update, MB_MODE_IDLE);
	if(FLAME_bank_account_update_message_board_write == 1 &&
		FLAME_bank_account_update_message_board_read == 0)
			rc = MB_SetAccessMode(b_bank_account_update, MB_MODE_WRITEONLY);
	if(FLAME_bank_account_update_message_board_write == 0 &&
		FLAME_bank_account_update_message_board_read == 1)
			rc = MB_SetAccessMode(b_bank_account_update, MB_MODE_READONLY);
	if(FLAME_bank_account_update_message_board_write == 1 &&
		FLAME_bank_account_update_message_board_read == 1)
			rc = MB_SetAccessMode(b_bank_account_update, MB_MODE_READWRITE);
	#ifdef ERRCHECK
	if (rc != MB_SUCCESS)
	{
	   fprintf(stderr, "ERROR: Could not set access mode of 'bank_account_update' board\n");
	   switch(rc) {
		   case MB_ERR_INVALID:
			   fprintf(stderr, "\t reason: 'bank_account_update' board is invalid\n");
			   break;
		   case MB_ERR_LOCKED:
			   fprintf(stderr, "\t reason: 'bank_account_update' board is locked\n");
			   break;
		   case MB_ERR_MEMALLOC:
			   fprintf(stderr, "\t reason: out of memory\n");
			   break;
		   case MB_ERR_INTERNAL:
			   fprintf(stderr, "\t reason: internal error. Recompile libmoard in debug mode for more info \n");
			   break;
		   default:
			   fprintf(stderr, "\t MB_SyncStart returned error code: %d (see libmboard docs for details)\n", rc);
			   break;
	   }
		   
		   exit(rc);
	}
	#endif
	FLAME_bank_to_central_bank_account_update_message_board_write = 0;
	FLAME_bank_to_central_bank_account_update_message_board_read = 0;
	/* Sending agents */
	if(Bank_start_Bank_state->agents != NULL) FLAME_bank_to_central_bank_account_update_message_board_write = 1;
	
	/* Reading agents */
	if(CentralBank_start_Central_Bank_state->agents != NULL) FLAME_bank_to_central_bank_account_update_message_board_read = 1;
	
	/* Call message board library with details */
	if(FLAME_bank_to_central_bank_account_update_message_board_write == 0 &&
		FLAME_bank_to_central_bank_account_update_message_board_read == 0)
			rc = MB_SetAccessMode(b_bank_to_central_bank_account_update, MB_MODE_IDLE);
	if(FLAME_bank_to_central_bank_account_update_message_board_write == 1 &&
		FLAME_bank_to_central_bank_account_update_message_board_read == 0)
			rc = MB_SetAccessMode(b_bank_to_central_bank_account_update, MB_MODE_WRITEONLY);
	if(FLAME_bank_to_central_bank_account_update_message_board_write == 0 &&
		FLAME_bank_to_central_bank_account_update_message_board_read == 1)
			rc = MB_SetAccessMode(b_bank_to_central_bank_account_update, MB_MODE_READONLY);
	if(FLAME_bank_to_central_bank_account_update_message_board_write == 1 &&
		FLAME_bank_to_central_bank_account_update_message_board_read == 1)
			rc = MB_SetAccessMode(b_bank_to_central_bank_account_update, MB_MODE_READWRITE);
	#ifdef ERRCHECK
	if (rc != MB_SUCCESS)
	{
	   fprintf(stderr, "ERROR: Could not set access mode of 'bank_to_central_bank_account_update' board\n");
	   switch(rc) {
		   case MB_ERR_INVALID:
			   fprintf(stderr, "\t reason: 'bank_to_central_bank_account_update' board is invalid\n");
			   break;
		   case MB_ERR_LOCKED:
			   fprintf(stderr, "\t reason: 'bank_to_central_bank_account_update' board is locked\n");
			   break;
		   case MB_ERR_MEMALLOC:
			   fprintf(stderr, "\t reason: out of memory\n");
			   break;
		   case MB_ERR_INTERNAL:
			   fprintf(stderr, "\t reason: internal error. Recompile libmoard in debug mode for more info \n");
			   break;
		   default:
			   fprintf(stderr, "\t MB_SyncStart returned error code: %d (see libmboard docs for details)\n", rc);
			   break;
	   }
		   
		   exit(rc);
	}
	#endif
	FLAME_gov_to_central_bank_account_update_message_board_write = 0;
	FLAME_gov_to_central_bank_account_update_message_board_read = 0;
	/* Sending agents */
	if(Government_start_Government_state->agents != NULL) FLAME_gov_to_central_bank_account_update_message_board_write = 1;
	
	/* Reading agents */
	if(CentralBank_start_Central_Bank_state->agents != NULL) FLAME_gov_to_central_bank_account_update_message_board_read = 1;
	
	/* Call message board library with details */
	if(FLAME_gov_to_central_bank_account_update_message_board_write == 0 &&
		FLAME_gov_to_central_bank_account_update_message_board_read == 0)
			rc = MB_SetAccessMode(b_gov_to_central_bank_account_update, MB_MODE_IDLE);
	if(FLAME_gov_to_central_bank_account_update_message_board_write == 1 &&
		FLAME_gov_to_central_bank_account_update_message_board_read == 0)
			rc = MB_SetAccessMode(b_gov_to_central_bank_account_update, MB_MODE_WRITEONLY);
	if(FLAME_gov_to_central_bank_account_update_message_board_write == 0 &&
		FLAME_gov_to_central_bank_account_update_message_board_read == 1)
			rc = MB_SetAccessMode(b_gov_to_central_bank_account_update, MB_MODE_READONLY);
	if(FLAME_gov_to_central_bank_account_update_message_board_write == 1 &&
		FLAME_gov_to_central_bank_account_update_message_board_read == 1)
			rc = MB_SetAccessMode(b_gov_to_central_bank_account_update, MB_MODE_READWRITE);
	#ifdef ERRCHECK
	if (rc != MB_SUCCESS)
	{
	   fprintf(stderr, "ERROR: Could not set access mode of 'gov_to_central_bank_account_update' board\n");
	   switch(rc) {
		   case MB_ERR_INVALID:
			   fprintf(stderr, "\t reason: 'gov_to_central_bank_account_update' board is invalid\n");
			   break;
		   case MB_ERR_LOCKED:
			   fprintf(stderr, "\t reason: 'gov_to_central_bank_account_update' board is locked\n");
			   break;
		   case MB_ERR_MEMALLOC:
			   fprintf(stderr, "\t reason: out of memory\n");
			   break;
		   case MB_ERR_INTERNAL:
			   fprintf(stderr, "\t reason: internal error. Recompile libmoard in debug mode for more info \n");
			   break;
		   default:
			   fprintf(stderr, "\t MB_SyncStart returned error code: %d (see libmboard docs for details)\n", rc);
			   break;
	   }
		   
		   exit(rc);
	}
	#endif
	FLAME_wage_payment_message_board_write = 0;
	FLAME_wage_payment_message_board_read = 0;
	/* Sending agents */
	if(Firm_start_Firm_state->agents != NULL) FLAME_wage_payment_message_board_write = 1;
	
	/* Reading agents */
	if(Household_start_Household_state->agents != NULL) FLAME_wage_payment_message_board_read = 1;
	
	/* Call message board library with details */
	if(FLAME_wage_payment_message_board_write == 0 &&
		FLAME_wage_payment_message_board_read == 0)
			rc = MB_SetAccessMode(b_wage_payment, MB_MODE_IDLE);
	if(FLAME_wage_payment_message_board_write == 1 &&
		FLAME_wage_payment_message_board_read == 0)
			rc = MB_SetAccessMode(b_wage_payment, MB_MODE_WRITEONLY);
	if(FLAME_wage_payment_message_board_write == 0 &&
		FLAME_wage_payment_message_board_read == 1)
			rc = MB_SetAccessMode(b_wage_payment, MB_MODE_READONLY);
	if(FLAME_wage_payment_message_board_write == 1 &&
		FLAME_wage_payment_message_board_read == 1)
			rc = MB_SetAccessMode(b_wage_payment, MB_MODE_READWRITE);
	#ifdef ERRCHECK
	if (rc != MB_SUCCESS)
	{
	   fprintf(stderr, "ERROR: Could not set access mode of 'wage_payment' board\n");
	   switch(rc) {
		   case MB_ERR_INVALID:
			   fprintf(stderr, "\t reason: 'wage_payment' board is invalid\n");
			   break;
		   case MB_ERR_LOCKED:
			   fprintf(stderr, "\t reason: 'wage_payment' board is locked\n");
			   break;
		   case MB_ERR_MEMALLOC:
			   fprintf(stderr, "\t reason: out of memory\n");
			   break;
		   case MB_ERR_INTERNAL:
			   fprintf(stderr, "\t reason: internal error. Recompile libmoard in debug mode for more info \n");
			   break;
		   default:
			   fprintf(stderr, "\t MB_SyncStart returned error code: %d (see libmboard docs for details)\n", rc);
			   break;
	   }
		   
		   exit(rc);
	}
	#endif
	FLAME_quality_price_info_1_message_board_write = 0;
	FLAME_quality_price_info_1_message_board_read = 0;
	/* Sending agents */
	if(Mall_start_Mall_state->agents != NULL) FLAME_quality_price_info_1_message_board_write = 1;
	
	/* Reading agents */
	if(Household_start_Household_state->agents != NULL) FLAME_quality_price_info_1_message_board_read = 1;
	if(Government_start_Government_state->agents != NULL) FLAME_quality_price_info_1_message_board_read = 1;
	
	/* Call message board library with details */
	if(FLAME_quality_price_info_1_message_board_write == 0 &&
		FLAME_quality_price_info_1_message_board_read == 0)
			rc = MB_SetAccessMode(b_quality_price_info_1, MB_MODE_IDLE);
	if(FLAME_quality_price_info_1_message_board_write == 1 &&
		FLAME_quality_price_info_1_message_board_read == 0)
			rc = MB_SetAccessMode(b_quality_price_info_1, MB_MODE_WRITEONLY);
	if(FLAME_quality_price_info_1_message_board_write == 0 &&
		FLAME_quality_price_info_1_message_board_read == 1)
			rc = MB_SetAccessMode(b_quality_price_info_1, MB_MODE_READONLY);
	if(FLAME_quality_price_info_1_message_board_write == 1 &&
		FLAME_quality_price_info_1_message_board_read == 1)
			rc = MB_SetAccessMode(b_quality_price_info_1, MB_MODE_READWRITE);
	#ifdef ERRCHECK
	if (rc != MB_SUCCESS)
	{
	   fprintf(stderr, "ERROR: Could not set access mode of 'quality_price_info_1' board\n");
	   switch(rc) {
		   case MB_ERR_INVALID:
			   fprintf(stderr, "\t reason: 'quality_price_info_1' board is invalid\n");
			   break;
		   case MB_ERR_LOCKED:
			   fprintf(stderr, "\t reason: 'quality_price_info_1' board is locked\n");
			   break;
		   case MB_ERR_MEMALLOC:
			   fprintf(stderr, "\t reason: out of memory\n");
			   break;
		   case MB_ERR_INTERNAL:
			   fprintf(stderr, "\t reason: internal error. Recompile libmoard in debug mode for more info \n");
			   break;
		   default:
			   fprintf(stderr, "\t MB_SyncStart returned error code: %d (see libmboard docs for details)\n", rc);
			   break;
	   }
		   
		   exit(rc);
	}
	#endif
	FLAME_quality_price_info_2_message_board_write = 0;
	FLAME_quality_price_info_2_message_board_read = 0;
	/* Sending agents */
	if(Mall_start_Mall_state->agents != NULL) FLAME_quality_price_info_2_message_board_write = 1;
	
	/* Reading agents */
	if(Household_start_Household_state->agents != NULL) FLAME_quality_price_info_2_message_board_read = 1;
	if(Government_start_Government_state->agents != NULL) FLAME_quality_price_info_2_message_board_read = 1;
	
	/* Call message board library with details */
	if(FLAME_quality_price_info_2_message_board_write == 0 &&
		FLAME_quality_price_info_2_message_board_read == 0)
			rc = MB_SetAccessMode(b_quality_price_info_2, MB_MODE_IDLE);
	if(FLAME_quality_price_info_2_message_board_write == 1 &&
		FLAME_quality_price_info_2_message_board_read == 0)
			rc = MB_SetAccessMode(b_quality_price_info_2, MB_MODE_WRITEONLY);
	if(FLAME_quality_price_info_2_message_board_write == 0 &&
		FLAME_quality_price_info_2_message_board_read == 1)
			rc = MB_SetAccessMode(b_quality_price_info_2, MB_MODE_READONLY);
	if(FLAME_quality_price_info_2_message_board_write == 1 &&
		FLAME_quality_price_info_2_message_board_read == 1)
			rc = MB_SetAccessMode(b_quality_price_info_2, MB_MODE_READWRITE);
	#ifdef ERRCHECK
	if (rc != MB_SUCCESS)
	{
	   fprintf(stderr, "ERROR: Could not set access mode of 'quality_price_info_2' board\n");
	   switch(rc) {
		   case MB_ERR_INVALID:
			   fprintf(stderr, "\t reason: 'quality_price_info_2' board is invalid\n");
			   break;
		   case MB_ERR_LOCKED:
			   fprintf(stderr, "\t reason: 'quality_price_info_2' board is locked\n");
			   break;
		   case MB_ERR_MEMALLOC:
			   fprintf(stderr, "\t reason: out of memory\n");
			   break;
		   case MB_ERR_INTERNAL:
			   fprintf(stderr, "\t reason: internal error. Recompile libmoard in debug mode for more info \n");
			   break;
		   default:
			   fprintf(stderr, "\t MB_SyncStart returned error code: %d (see libmboard docs for details)\n", rc);
			   break;
	   }
		   
		   exit(rc);
	}
	#endif
	FLAME_update_mall_stock_message_board_write = 0;
	FLAME_update_mall_stock_message_board_read = 0;
	/* Sending agents */
	if(Firm_start_Firm_state->agents != NULL) FLAME_update_mall_stock_message_board_write = 1;
	
	/* Reading agents */
	if(Mall_start_Mall_state->agents != NULL) FLAME_update_mall_stock_message_board_read = 1;
	
	/* Call message board library with details */
	if(FLAME_update_mall_stock_message_board_write == 0 &&
		FLAME_update_mall_stock_message_board_read == 0)
			rc = MB_SetAccessMode(b_update_mall_stock, MB_MODE_IDLE);
	if(FLAME_update_mall_stock_message_board_write == 1 &&
		FLAME_update_mall_stock_message_board_read == 0)
			rc = MB_SetAccessMode(b_update_mall_stock, MB_MODE_WRITEONLY);
	if(FLAME_update_mall_stock_message_board_write == 0 &&
		FLAME_update_mall_stock_message_board_read == 1)
			rc = MB_SetAccessMode(b_update_mall_stock, MB_MODE_READONLY);
	if(FLAME_update_mall_stock_message_board_write == 1 &&
		FLAME_update_mall_stock_message_board_read == 1)
			rc = MB_SetAccessMode(b_update_mall_stock, MB_MODE_READWRITE);
	#ifdef ERRCHECK
	if (rc != MB_SUCCESS)
	{
	   fprintf(stderr, "ERROR: Could not set access mode of 'update_mall_stock' board\n");
	   switch(rc) {
		   case MB_ERR_INVALID:
			   fprintf(stderr, "\t reason: 'update_mall_stock' board is invalid\n");
			   break;
		   case MB_ERR_LOCKED:
			   fprintf(stderr, "\t reason: 'update_mall_stock' board is locked\n");
			   break;
		   case MB_ERR_MEMALLOC:
			   fprintf(stderr, "\t reason: out of memory\n");
			   break;
		   case MB_ERR_INTERNAL:
			   fprintf(stderr, "\t reason: internal error. Recompile libmoard in debug mode for more info \n");
			   break;
		   default:
			   fprintf(stderr, "\t MB_SyncStart returned error code: %d (see libmboard docs for details)\n", rc);
			   break;
	   }
		   
		   exit(rc);
	}
	#endif
	FLAME_consumption_request_1_message_board_write = 0;
	FLAME_consumption_request_1_message_board_read = 0;
	/* Sending agents */
	if(Household_start_Household_state->agents != NULL) FLAME_consumption_request_1_message_board_write = 1;
	if(Government_start_Government_state->agents != NULL) FLAME_consumption_request_1_message_board_write = 1;
	
	/* Reading agents */
	if(Mall_start_Mall_state->agents != NULL) FLAME_consumption_request_1_message_board_read = 1;
	
	/* Call message board library with details */
	if(FLAME_consumption_request_1_message_board_write == 0 &&
		FLAME_consumption_request_1_message_board_read == 0)
			rc = MB_SetAccessMode(b_consumption_request_1, MB_MODE_IDLE);
	if(FLAME_consumption_request_1_message_board_write == 1 &&
		FLAME_consumption_request_1_message_board_read == 0)
			rc = MB_SetAccessMode(b_consumption_request_1, MB_MODE_WRITEONLY);
	if(FLAME_consumption_request_1_message_board_write == 0 &&
		FLAME_consumption_request_1_message_board_read == 1)
			rc = MB_SetAccessMode(b_consumption_request_1, MB_MODE_READONLY);
	if(FLAME_consumption_request_1_message_board_write == 1 &&
		FLAME_consumption_request_1_message_board_read == 1)
			rc = MB_SetAccessMode(b_consumption_request_1, MB_MODE_READWRITE);
	#ifdef ERRCHECK
	if (rc != MB_SUCCESS)
	{
	   fprintf(stderr, "ERROR: Could not set access mode of 'consumption_request_1' board\n");
	   switch(rc) {
		   case MB_ERR_INVALID:
			   fprintf(stderr, "\t reason: 'consumption_request_1' board is invalid\n");
			   break;
		   case MB_ERR_LOCKED:
			   fprintf(stderr, "\t reason: 'consumption_request_1' board is locked\n");
			   break;
		   case MB_ERR_MEMALLOC:
			   fprintf(stderr, "\t reason: out of memory\n");
			   break;
		   case MB_ERR_INTERNAL:
			   fprintf(stderr, "\t reason: internal error. Recompile libmoard in debug mode for more info \n");
			   break;
		   default:
			   fprintf(stderr, "\t MB_SyncStart returned error code: %d (see libmboard docs for details)\n", rc);
			   break;
	   }
		   
		   exit(rc);
	}
	#endif
	FLAME_consumption_request_2_message_board_write = 0;
	FLAME_consumption_request_2_message_board_read = 0;
	/* Sending agents */
	if(Household_start_Household_state->agents != NULL) FLAME_consumption_request_2_message_board_write = 1;
	if(Government_start_Government_state->agents != NULL) FLAME_consumption_request_2_message_board_write = 1;
	
	/* Reading agents */
	if(Mall_start_Mall_state->agents != NULL) FLAME_consumption_request_2_message_board_read = 1;
	
	/* Call message board library with details */
	if(FLAME_consumption_request_2_message_board_write == 0 &&
		FLAME_consumption_request_2_message_board_read == 0)
			rc = MB_SetAccessMode(b_consumption_request_2, MB_MODE_IDLE);
	if(FLAME_consumption_request_2_message_board_write == 1 &&
		FLAME_consumption_request_2_message_board_read == 0)
			rc = MB_SetAccessMode(b_consumption_request_2, MB_MODE_WRITEONLY);
	if(FLAME_consumption_request_2_message_board_write == 0 &&
		FLAME_consumption_request_2_message_board_read == 1)
			rc = MB_SetAccessMode(b_consumption_request_2, MB_MODE_READONLY);
	if(FLAME_consumption_request_2_message_board_write == 1 &&
		FLAME_consumption_request_2_message_board_read == 1)
			rc = MB_SetAccessMode(b_consumption_request_2, MB_MODE_READWRITE);
	#ifdef ERRCHECK
	if (rc != MB_SUCCESS)
	{
	   fprintf(stderr, "ERROR: Could not set access mode of 'consumption_request_2' board\n");
	   switch(rc) {
		   case MB_ERR_INVALID:
			   fprintf(stderr, "\t reason: 'consumption_request_2' board is invalid\n");
			   break;
		   case MB_ERR_LOCKED:
			   fprintf(stderr, "\t reason: 'consumption_request_2' board is locked\n");
			   break;
		   case MB_ERR_MEMALLOC:
			   fprintf(stderr, "\t reason: out of memory\n");
			   break;
		   case MB_ERR_INTERNAL:
			   fprintf(stderr, "\t reason: internal error. Recompile libmoard in debug mode for more info \n");
			   break;
		   default:
			   fprintf(stderr, "\t MB_SyncStart returned error code: %d (see libmboard docs for details)\n", rc);
			   break;
	   }
		   
		   exit(rc);
	}
	#endif
	FLAME_accepted_consumption_1_message_board_write = 0;
	FLAME_accepted_consumption_1_message_board_read = 0;
	/* Sending agents */
	if(Mall_start_Mall_state->agents != NULL) FLAME_accepted_consumption_1_message_board_write = 1;
	
	/* Reading agents */
	if(Household_start_Household_state->agents != NULL) FLAME_accepted_consumption_1_message_board_read = 1;
	if(Government_start_Government_state->agents != NULL) FLAME_accepted_consumption_1_message_board_read = 1;
	
	/* Call message board library with details */
	if(FLAME_accepted_consumption_1_message_board_write == 0 &&
		FLAME_accepted_consumption_1_message_board_read == 0)
			rc = MB_SetAccessMode(b_accepted_consumption_1, MB_MODE_IDLE);
	if(FLAME_accepted_consumption_1_message_board_write == 1 &&
		FLAME_accepted_consumption_1_message_board_read == 0)
			rc = MB_SetAccessMode(b_accepted_consumption_1, MB_MODE_WRITEONLY);
	if(FLAME_accepted_consumption_1_message_board_write == 0 &&
		FLAME_accepted_consumption_1_message_board_read == 1)
			rc = MB_SetAccessMode(b_accepted_consumption_1, MB_MODE_READONLY);
	if(FLAME_accepted_consumption_1_message_board_write == 1 &&
		FLAME_accepted_consumption_1_message_board_read == 1)
			rc = MB_SetAccessMode(b_accepted_consumption_1, MB_MODE_READWRITE);
	#ifdef ERRCHECK
	if (rc != MB_SUCCESS)
	{
	   fprintf(stderr, "ERROR: Could not set access mode of 'accepted_consumption_1' board\n");
	   switch(rc) {
		   case MB_ERR_INVALID:
			   fprintf(stderr, "\t reason: 'accepted_consumption_1' board is invalid\n");
			   break;
		   case MB_ERR_LOCKED:
			   fprintf(stderr, "\t reason: 'accepted_consumption_1' board is locked\n");
			   break;
		   case MB_ERR_MEMALLOC:
			   fprintf(stderr, "\t reason: out of memory\n");
			   break;
		   case MB_ERR_INTERNAL:
			   fprintf(stderr, "\t reason: internal error. Recompile libmoard in debug mode for more info \n");
			   break;
		   default:
			   fprintf(stderr, "\t MB_SyncStart returned error code: %d (see libmboard docs for details)\n", rc);
			   break;
	   }
		   
		   exit(rc);
	}
	#endif
	FLAME_accepted_consumption_2_message_board_write = 0;
	FLAME_accepted_consumption_2_message_board_read = 0;
	/* Sending agents */
	if(Mall_start_Mall_state->agents != NULL) FLAME_accepted_consumption_2_message_board_write = 1;
	
	/* Reading agents */
	if(Household_start_Household_state->agents != NULL) FLAME_accepted_consumption_2_message_board_read = 1;
	if(Government_start_Government_state->agents != NULL) FLAME_accepted_consumption_2_message_board_read = 1;
	
	/* Call message board library with details */
	if(FLAME_accepted_consumption_2_message_board_write == 0 &&
		FLAME_accepted_consumption_2_message_board_read == 0)
			rc = MB_SetAccessMode(b_accepted_consumption_2, MB_MODE_IDLE);
	if(FLAME_accepted_consumption_2_message_board_write == 1 &&
		FLAME_accepted_consumption_2_message_board_read == 0)
			rc = MB_SetAccessMode(b_accepted_consumption_2, MB_MODE_WRITEONLY);
	if(FLAME_accepted_consumption_2_message_board_write == 0 &&
		FLAME_accepted_consumption_2_message_board_read == 1)
			rc = MB_SetAccessMode(b_accepted_consumption_2, MB_MODE_READONLY);
	if(FLAME_accepted_consumption_2_message_board_write == 1 &&
		FLAME_accepted_consumption_2_message_board_read == 1)
			rc = MB_SetAccessMode(b_accepted_consumption_2, MB_MODE_READWRITE);
	#ifdef ERRCHECK
	if (rc != MB_SUCCESS)
	{
	   fprintf(stderr, "ERROR: Could not set access mode of 'accepted_consumption_2' board\n");
	   switch(rc) {
		   case MB_ERR_INVALID:
			   fprintf(stderr, "\t reason: 'accepted_consumption_2' board is invalid\n");
			   break;
		   case MB_ERR_LOCKED:
			   fprintf(stderr, "\t reason: 'accepted_consumption_2' board is locked\n");
			   break;
		   case MB_ERR_MEMALLOC:
			   fprintf(stderr, "\t reason: out of memory\n");
			   break;
		   case MB_ERR_INTERNAL:
			   fprintf(stderr, "\t reason: internal error. Recompile libmoard in debug mode for more info \n");
			   break;
		   default:
			   fprintf(stderr, "\t MB_SyncStart returned error code: %d (see libmboard docs for details)\n", rc);
			   break;
	   }
		   
		   exit(rc);
	}
	#endif
	FLAME_sales_message_board_write = 0;
	FLAME_sales_message_board_read = 0;
	/* Sending agents */
	if(Mall_start_Mall_state->agents != NULL) FLAME_sales_message_board_write = 1;
	
	/* Reading agents */
	if(Firm_start_Firm_state->agents != NULL) FLAME_sales_message_board_read = 1;
	
	/* Call message board library with details */
	if(FLAME_sales_message_board_write == 0 &&
		FLAME_sales_message_board_read == 0)
			rc = MB_SetAccessMode(b_sales, MB_MODE_IDLE);
	if(FLAME_sales_message_board_write == 1 &&
		FLAME_sales_message_board_read == 0)
			rc = MB_SetAccessMode(b_sales, MB_MODE_WRITEONLY);
	if(FLAME_sales_message_board_write == 0 &&
		FLAME_sales_message_board_read == 1)
			rc = MB_SetAccessMode(b_sales, MB_MODE_READONLY);
	if(FLAME_sales_message_board_write == 1 &&
		FLAME_sales_message_board_read == 1)
			rc = MB_SetAccessMode(b_sales, MB_MODE_READWRITE);
	#ifdef ERRCHECK
	if (rc != MB_SUCCESS)
	{
	   fprintf(stderr, "ERROR: Could not set access mode of 'sales' board\n");
	   switch(rc) {
		   case MB_ERR_INVALID:
			   fprintf(stderr, "\t reason: 'sales' board is invalid\n");
			   break;
		   case MB_ERR_LOCKED:
			   fprintf(stderr, "\t reason: 'sales' board is locked\n");
			   break;
		   case MB_ERR_MEMALLOC:
			   fprintf(stderr, "\t reason: out of memory\n");
			   break;
		   case MB_ERR_INTERNAL:
			   fprintf(stderr, "\t reason: internal error. Recompile libmoard in debug mode for more info \n");
			   break;
		   default:
			   fprintf(stderr, "\t MB_SyncStart returned error code: %d (see libmboard docs for details)\n", rc);
			   break;
	   }
		   
		   exit(rc);
	}
	#endif
	FLAME_specific_skill_update_message_board_write = 0;
	FLAME_specific_skill_update_message_board_read = 0;
	/* Sending agents */
	if(Household_start_Household_state->agents != NULL) FLAME_specific_skill_update_message_board_write = 1;
	
	/* Reading agents */
	if(Firm_start_Firm_state->agents != NULL) FLAME_specific_skill_update_message_board_read = 1;
	
	/* Call message board library with details */
	if(FLAME_specific_skill_update_message_board_write == 0 &&
		FLAME_specific_skill_update_message_board_read == 0)
			rc = MB_SetAccessMode(b_specific_skill_update, MB_MODE_IDLE);
	if(FLAME_specific_skill_update_message_board_write == 1 &&
		FLAME_specific_skill_update_message_board_read == 0)
			rc = MB_SetAccessMode(b_specific_skill_update, MB_MODE_WRITEONLY);
	if(FLAME_specific_skill_update_message_board_write == 0 &&
		FLAME_specific_skill_update_message_board_read == 1)
			rc = MB_SetAccessMode(b_specific_skill_update, MB_MODE_READONLY);
	if(FLAME_specific_skill_update_message_board_write == 1 &&
		FLAME_specific_skill_update_message_board_read == 1)
			rc = MB_SetAccessMode(b_specific_skill_update, MB_MODE_READWRITE);
	#ifdef ERRCHECK
	if (rc != MB_SUCCESS)
	{
	   fprintf(stderr, "ERROR: Could not set access mode of 'specific_skill_update' board\n");
	   switch(rc) {
		   case MB_ERR_INVALID:
			   fprintf(stderr, "\t reason: 'specific_skill_update' board is invalid\n");
			   break;
		   case MB_ERR_LOCKED:
			   fprintf(stderr, "\t reason: 'specific_skill_update' board is locked\n");
			   break;
		   case MB_ERR_MEMALLOC:
			   fprintf(stderr, "\t reason: out of memory\n");
			   break;
		   case MB_ERR_INTERNAL:
			   fprintf(stderr, "\t reason: internal error. Recompile libmoard in debug mode for more info \n");
			   break;
		   default:
			   fprintf(stderr, "\t MB_SyncStart returned error code: %d (see libmboard docs for details)\n", rc);
			   break;
	   }
		   
		   exit(rc);
	}
	#endif
	FLAME_policy_rate_message_board_write = 0;
	FLAME_policy_rate_message_board_read = 0;
	/* Sending agents */
	if(CentralBank_start_Central_Bank_state->agents != NULL) FLAME_policy_rate_message_board_write = 1;
	
	/* Reading agents */
	if(Bank_start_Bank_state->agents != NULL) FLAME_policy_rate_message_board_read = 1;
	
	/* Call message board library with details */
	if(FLAME_policy_rate_message_board_write == 0 &&
		FLAME_policy_rate_message_board_read == 0)
			rc = MB_SetAccessMode(b_policy_rate, MB_MODE_IDLE);
	if(FLAME_policy_rate_message_board_write == 1 &&
		FLAME_policy_rate_message_board_read == 0)
			rc = MB_SetAccessMode(b_policy_rate, MB_MODE_WRITEONLY);
	if(FLAME_policy_rate_message_board_write == 0 &&
		FLAME_policy_rate_message_board_read == 1)
			rc = MB_SetAccessMode(b_policy_rate, MB_MODE_READONLY);
	if(FLAME_policy_rate_message_board_write == 1 &&
		FLAME_policy_rate_message_board_read == 1)
			rc = MB_SetAccessMode(b_policy_rate, MB_MODE_READWRITE);
	#ifdef ERRCHECK
	if (rc != MB_SUCCESS)
	{
	   fprintf(stderr, "ERROR: Could not set access mode of 'policy_rate' board\n");
	   switch(rc) {
		   case MB_ERR_INVALID:
			   fprintf(stderr, "\t reason: 'policy_rate' board is invalid\n");
			   break;
		   case MB_ERR_LOCKED:
			   fprintf(stderr, "\t reason: 'policy_rate' board is locked\n");
			   break;
		   case MB_ERR_MEMALLOC:
			   fprintf(stderr, "\t reason: out of memory\n");
			   break;
		   case MB_ERR_INTERNAL:
			   fprintf(stderr, "\t reason: internal error. Recompile libmoard in debug mode for more info \n");
			   break;
		   default:
			   fprintf(stderr, "\t MB_SyncStart returned error code: %d (see libmboard docs for details)\n", rc);
			   break;
	   }
		   
		   exit(rc);
	}
	#endif
	FLAME_bank_identity_message_board_write = 0;
	FLAME_bank_identity_message_board_read = 0;
	/* Sending agents */
	if(Bank_start_Bank_state->agents != NULL) FLAME_bank_identity_message_board_write = 1;
	
	/* Reading agents */
	if(Firm_start_Firm_state->agents != NULL) FLAME_bank_identity_message_board_read = 1;
	
	/* Call message board library with details */
	if(FLAME_bank_identity_message_board_write == 0 &&
		FLAME_bank_identity_message_board_read == 0)
			rc = MB_SetAccessMode(b_bank_identity, MB_MODE_IDLE);
	if(FLAME_bank_identity_message_board_write == 1 &&
		FLAME_bank_identity_message_board_read == 0)
			rc = MB_SetAccessMode(b_bank_identity, MB_MODE_WRITEONLY);
	if(FLAME_bank_identity_message_board_write == 0 &&
		FLAME_bank_identity_message_board_read == 1)
			rc = MB_SetAccessMode(b_bank_identity, MB_MODE_READONLY);
	if(FLAME_bank_identity_message_board_write == 1 &&
		FLAME_bank_identity_message_board_read == 1)
			rc = MB_SetAccessMode(b_bank_identity, MB_MODE_READWRITE);
	#ifdef ERRCHECK
	if (rc != MB_SUCCESS)
	{
	   fprintf(stderr, "ERROR: Could not set access mode of 'bank_identity' board\n");
	   switch(rc) {
		   case MB_ERR_INVALID:
			   fprintf(stderr, "\t reason: 'bank_identity' board is invalid\n");
			   break;
		   case MB_ERR_LOCKED:
			   fprintf(stderr, "\t reason: 'bank_identity' board is locked\n");
			   break;
		   case MB_ERR_MEMALLOC:
			   fprintf(stderr, "\t reason: out of memory\n");
			   break;
		   case MB_ERR_INTERNAL:
			   fprintf(stderr, "\t reason: internal error. Recompile libmoard in debug mode for more info \n");
			   break;
		   default:
			   fprintf(stderr, "\t MB_SyncStart returned error code: %d (see libmboard docs for details)\n", rc);
			   break;
	   }
		   
		   exit(rc);
	}
	#endif
	FLAME_loan_request_message_board_write = 0;
	FLAME_loan_request_message_board_read = 0;
	/* Sending agents */
	if(Firm_start_Firm_state->agents != NULL) FLAME_loan_request_message_board_write = 1;
	
	/* Reading agents */
	if(Bank_start_Bank_state->agents != NULL) FLAME_loan_request_message_board_read = 1;
	
	/* Call message board library with details */
	if(FLAME_loan_request_message_board_write == 0 &&
		FLAME_loan_request_message_board_read == 0)
			rc = MB_SetAccessMode(b_loan_request, MB_MODE_IDLE);
	if(FLAME_loan_request_message_board_write == 1 &&
		FLAME_loan_request_message_board_read == 0)
			rc = MB_SetAccessMode(b_loan_request, MB_MODE_WRITEONLY);
	if(FLAME_loan_request_message_board_write == 0 &&
		FLAME_loan_request_message_board_read == 1)
			rc = MB_SetAccessMode(b_loan_request, MB_MODE_READONLY);
	if(FLAME_loan_request_message_board_write == 1 &&
		FLAME_loan_request_message_board_read == 1)
			rc = MB_SetAccessMode(b_loan_request, MB_MODE_READWRITE);
	#ifdef ERRCHECK
	if (rc != MB_SUCCESS)
	{
	   fprintf(stderr, "ERROR: Could not set access mode of 'loan_request' board\n");
	   switch(rc) {
		   case MB_ERR_INVALID:
			   fprintf(stderr, "\t reason: 'loan_request' board is invalid\n");
			   break;
		   case MB_ERR_LOCKED:
			   fprintf(stderr, "\t reason: 'loan_request' board is locked\n");
			   break;
		   case MB_ERR_MEMALLOC:
			   fprintf(stderr, "\t reason: out of memory\n");
			   break;
		   case MB_ERR_INTERNAL:
			   fprintf(stderr, "\t reason: internal error. Recompile libmoard in debug mode for more info \n");
			   break;
		   default:
			   fprintf(stderr, "\t MB_SyncStart returned error code: %d (see libmboard docs for details)\n", rc);
			   break;
	   }
		   
		   exit(rc);
	}
	#endif
	FLAME_loan_request_ranked_message_board_write = 0;
	FLAME_loan_request_ranked_message_board_read = 0;
	/* Sending agents */
	if(Bank_start_Bank_state->agents != NULL) FLAME_loan_request_ranked_message_board_write = 1;
	
	/* Reading agents */
	if(Bank_start_Bank_state->agents != NULL) FLAME_loan_request_ranked_message_board_read = 1;
	
	/* Call message board library with details */
	if(FLAME_loan_request_ranked_message_board_write == 0 &&
		FLAME_loan_request_ranked_message_board_read == 0)
			rc = MB_SetAccessMode(b_loan_request_ranked, MB_MODE_IDLE);
	if(FLAME_loan_request_ranked_message_board_write == 1 &&
		FLAME_loan_request_ranked_message_board_read == 0)
			rc = MB_SetAccessMode(b_loan_request_ranked, MB_MODE_WRITEONLY);
	if(FLAME_loan_request_ranked_message_board_write == 0 &&
		FLAME_loan_request_ranked_message_board_read == 1)
			rc = MB_SetAccessMode(b_loan_request_ranked, MB_MODE_READONLY);
	if(FLAME_loan_request_ranked_message_board_write == 1 &&
		FLAME_loan_request_ranked_message_board_read == 1)
			rc = MB_SetAccessMode(b_loan_request_ranked, MB_MODE_READWRITE);
	#ifdef ERRCHECK
	if (rc != MB_SUCCESS)
	{
	   fprintf(stderr, "ERROR: Could not set access mode of 'loan_request_ranked' board\n");
	   switch(rc) {
		   case MB_ERR_INVALID:
			   fprintf(stderr, "\t reason: 'loan_request_ranked' board is invalid\n");
			   break;
		   case MB_ERR_LOCKED:
			   fprintf(stderr, "\t reason: 'loan_request_ranked' board is locked\n");
			   break;
		   case MB_ERR_MEMALLOC:
			   fprintf(stderr, "\t reason: out of memory\n");
			   break;
		   case MB_ERR_INTERNAL:
			   fprintf(stderr, "\t reason: internal error. Recompile libmoard in debug mode for more info \n");
			   break;
		   default:
			   fprintf(stderr, "\t MB_SyncStart returned error code: %d (see libmboard docs for details)\n", rc);
			   break;
	   }
		   
		   exit(rc);
	}
	#endif
	FLAME_loan_conditions_message_board_write = 0;
	FLAME_loan_conditions_message_board_read = 0;
	/* Sending agents */
	if(Bank_start_Bank_state->agents != NULL) FLAME_loan_conditions_message_board_write = 1;
	
	/* Reading agents */
	if(Firm_start_Firm_state->agents != NULL) FLAME_loan_conditions_message_board_read = 1;
	
	/* Call message board library with details */
	if(FLAME_loan_conditions_message_board_write == 0 &&
		FLAME_loan_conditions_message_board_read == 0)
			rc = MB_SetAccessMode(b_loan_conditions, MB_MODE_IDLE);
	if(FLAME_loan_conditions_message_board_write == 1 &&
		FLAME_loan_conditions_message_board_read == 0)
			rc = MB_SetAccessMode(b_loan_conditions, MB_MODE_WRITEONLY);
	if(FLAME_loan_conditions_message_board_write == 0 &&
		FLAME_loan_conditions_message_board_read == 1)
			rc = MB_SetAccessMode(b_loan_conditions, MB_MODE_READONLY);
	if(FLAME_loan_conditions_message_board_write == 1 &&
		FLAME_loan_conditions_message_board_read == 1)
			rc = MB_SetAccessMode(b_loan_conditions, MB_MODE_READWRITE);
	#ifdef ERRCHECK
	if (rc != MB_SUCCESS)
	{
	   fprintf(stderr, "ERROR: Could not set access mode of 'loan_conditions' board\n");
	   switch(rc) {
		   case MB_ERR_INVALID:
			   fprintf(stderr, "\t reason: 'loan_conditions' board is invalid\n");
			   break;
		   case MB_ERR_LOCKED:
			   fprintf(stderr, "\t reason: 'loan_conditions' board is locked\n");
			   break;
		   case MB_ERR_MEMALLOC:
			   fprintf(stderr, "\t reason: out of memory\n");
			   break;
		   case MB_ERR_INTERNAL:
			   fprintf(stderr, "\t reason: internal error. Recompile libmoard in debug mode for more info \n");
			   break;
		   default:
			   fprintf(stderr, "\t MB_SyncStart returned error code: %d (see libmboard docs for details)\n", rc);
			   break;
	   }
		   
		   exit(rc);
	}
	#endif
	FLAME_loan_acceptance_message_board_write = 0;
	FLAME_loan_acceptance_message_board_read = 0;
	/* Sending agents */
	if(Firm_start_Firm_state->agents != NULL) FLAME_loan_acceptance_message_board_write = 1;
	
	/* Reading agents */
	if(Bank_start_Bank_state->agents != NULL) FLAME_loan_acceptance_message_board_read = 1;
	
	/* Call message board library with details */
	if(FLAME_loan_acceptance_message_board_write == 0 &&
		FLAME_loan_acceptance_message_board_read == 0)
			rc = MB_SetAccessMode(b_loan_acceptance, MB_MODE_IDLE);
	if(FLAME_loan_acceptance_message_board_write == 1 &&
		FLAME_loan_acceptance_message_board_read == 0)
			rc = MB_SetAccessMode(b_loan_acceptance, MB_MODE_WRITEONLY);
	if(FLAME_loan_acceptance_message_board_write == 0 &&
		FLAME_loan_acceptance_message_board_read == 1)
			rc = MB_SetAccessMode(b_loan_acceptance, MB_MODE_READONLY);
	if(FLAME_loan_acceptance_message_board_write == 1 &&
		FLAME_loan_acceptance_message_board_read == 1)
			rc = MB_SetAccessMode(b_loan_acceptance, MB_MODE_READWRITE);
	#ifdef ERRCHECK
	if (rc != MB_SUCCESS)
	{
	   fprintf(stderr, "ERROR: Could not set access mode of 'loan_acceptance' board\n");
	   switch(rc) {
		   case MB_ERR_INVALID:
			   fprintf(stderr, "\t reason: 'loan_acceptance' board is invalid\n");
			   break;
		   case MB_ERR_LOCKED:
			   fprintf(stderr, "\t reason: 'loan_acceptance' board is locked\n");
			   break;
		   case MB_ERR_MEMALLOC:
			   fprintf(stderr, "\t reason: out of memory\n");
			   break;
		   case MB_ERR_INTERNAL:
			   fprintf(stderr, "\t reason: internal error. Recompile libmoard in debug mode for more info \n");
			   break;
		   default:
			   fprintf(stderr, "\t MB_SyncStart returned error code: %d (see libmboard docs for details)\n", rc);
			   break;
	   }
		   
		   exit(rc);
	}
	#endif
	FLAME_installment_message_board_write = 0;
	FLAME_installment_message_board_read = 0;
	/* Sending agents */
	if(Firm_start_Firm_state->agents != NULL) FLAME_installment_message_board_write = 1;
	
	/* Reading agents */
	if(Bank_start_Bank_state->agents != NULL) FLAME_installment_message_board_read = 1;
	
	/* Call message board library with details */
	if(FLAME_installment_message_board_write == 0 &&
		FLAME_installment_message_board_read == 0)
			rc = MB_SetAccessMode(b_installment, MB_MODE_IDLE);
	if(FLAME_installment_message_board_write == 1 &&
		FLAME_installment_message_board_read == 0)
			rc = MB_SetAccessMode(b_installment, MB_MODE_WRITEONLY);
	if(FLAME_installment_message_board_write == 0 &&
		FLAME_installment_message_board_read == 1)
			rc = MB_SetAccessMode(b_installment, MB_MODE_READONLY);
	if(FLAME_installment_message_board_write == 1 &&
		FLAME_installment_message_board_read == 1)
			rc = MB_SetAccessMode(b_installment, MB_MODE_READWRITE);
	#ifdef ERRCHECK
	if (rc != MB_SUCCESS)
	{
	   fprintf(stderr, "ERROR: Could not set access mode of 'installment' board\n");
	   switch(rc) {
		   case MB_ERR_INVALID:
			   fprintf(stderr, "\t reason: 'installment' board is invalid\n");
			   break;
		   case MB_ERR_LOCKED:
			   fprintf(stderr, "\t reason: 'installment' board is locked\n");
			   break;
		   case MB_ERR_MEMALLOC:
			   fprintf(stderr, "\t reason: out of memory\n");
			   break;
		   case MB_ERR_INTERNAL:
			   fprintf(stderr, "\t reason: internal error. Recompile libmoard in debug mode for more info \n");
			   break;
		   default:
			   fprintf(stderr, "\t MB_SyncStart returned error code: %d (see libmboard docs for details)\n", rc);
			   break;
	   }
		   
		   exit(rc);
	}
	#endif
	FLAME_bankruptcy_message_board_write = 0;
	FLAME_bankruptcy_message_board_read = 0;
	/* Sending agents */
	if(Firm_start_Firm_state->agents != NULL) FLAME_bankruptcy_message_board_write = 1;
	
	/* Reading agents */
	if(Bank_start_Bank_state->agents != NULL) FLAME_bankruptcy_message_board_read = 1;
	
	/* Call message board library with details */
	if(FLAME_bankruptcy_message_board_write == 0 &&
		FLAME_bankruptcy_message_board_read == 0)
			rc = MB_SetAccessMode(b_bankruptcy, MB_MODE_IDLE);
	if(FLAME_bankruptcy_message_board_write == 1 &&
		FLAME_bankruptcy_message_board_read == 0)
			rc = MB_SetAccessMode(b_bankruptcy, MB_MODE_WRITEONLY);
	if(FLAME_bankruptcy_message_board_write == 0 &&
		FLAME_bankruptcy_message_board_read == 1)
			rc = MB_SetAccessMode(b_bankruptcy, MB_MODE_READONLY);
	if(FLAME_bankruptcy_message_board_write == 1 &&
		FLAME_bankruptcy_message_board_read == 1)
			rc = MB_SetAccessMode(b_bankruptcy, MB_MODE_READWRITE);
	#ifdef ERRCHECK
	if (rc != MB_SUCCESS)
	{
	   fprintf(stderr, "ERROR: Could not set access mode of 'bankruptcy' board\n");
	   switch(rc) {
		   case MB_ERR_INVALID:
			   fprintf(stderr, "\t reason: 'bankruptcy' board is invalid\n");
			   break;
		   case MB_ERR_LOCKED:
			   fprintf(stderr, "\t reason: 'bankruptcy' board is locked\n");
			   break;
		   case MB_ERR_MEMALLOC:
			   fprintf(stderr, "\t reason: out of memory\n");
			   break;
		   case MB_ERR_INTERNAL:
			   fprintf(stderr, "\t reason: internal error. Recompile libmoard in debug mode for more info \n");
			   break;
		   default:
			   fprintf(stderr, "\t MB_SyncStart returned error code: %d (see libmboard docs for details)\n", rc);
			   break;
	   }
		   
		   exit(rc);
	}
	#endif
	FLAME_bank_interest_payment_message_board_write = 0;
	FLAME_bank_interest_payment_message_board_read = 0;
	/* Sending agents */
	if(Bank_start_Bank_state->agents != NULL) FLAME_bank_interest_payment_message_board_write = 1;
	
	/* Reading agents */
	if(CentralBank_start_Central_Bank_state->agents != NULL) FLAME_bank_interest_payment_message_board_read = 1;
	
	/* Call message board library with details */
	if(FLAME_bank_interest_payment_message_board_write == 0 &&
		FLAME_bank_interest_payment_message_board_read == 0)
			rc = MB_SetAccessMode(b_bank_interest_payment, MB_MODE_IDLE);
	if(FLAME_bank_interest_payment_message_board_write == 1 &&
		FLAME_bank_interest_payment_message_board_read == 0)
			rc = MB_SetAccessMode(b_bank_interest_payment, MB_MODE_WRITEONLY);
	if(FLAME_bank_interest_payment_message_board_write == 0 &&
		FLAME_bank_interest_payment_message_board_read == 1)
			rc = MB_SetAccessMode(b_bank_interest_payment, MB_MODE_READONLY);
	if(FLAME_bank_interest_payment_message_board_write == 1 &&
		FLAME_bank_interest_payment_message_board_read == 1)
			rc = MB_SetAccessMode(b_bank_interest_payment, MB_MODE_READWRITE);
	#ifdef ERRCHECK
	if (rc != MB_SUCCESS)
	{
	   fprintf(stderr, "ERROR: Could not set access mode of 'bank_interest_payment' board\n");
	   switch(rc) {
		   case MB_ERR_INVALID:
			   fprintf(stderr, "\t reason: 'bank_interest_payment' board is invalid\n");
			   break;
		   case MB_ERR_LOCKED:
			   fprintf(stderr, "\t reason: 'bank_interest_payment' board is locked\n");
			   break;
		   case MB_ERR_MEMALLOC:
			   fprintf(stderr, "\t reason: out of memory\n");
			   break;
		   case MB_ERR_INTERNAL:
			   fprintf(stderr, "\t reason: internal error. Recompile libmoard in debug mode for more info \n");
			   break;
		   default:
			   fprintf(stderr, "\t MB_SyncStart returned error code: %d (see libmboard docs for details)\n", rc);
			   break;
	   }
		   
		   exit(rc);
	}
	#endif
	FLAME_account_interest_message_board_write = 0;
	FLAME_account_interest_message_board_read = 0;
	/* Sending agents */
	if(Bank_start_Bank_state->agents != NULL) FLAME_account_interest_message_board_write = 1;
	
	/* Reading agents */
	if(Firm_start_Firm_state->agents != NULL) FLAME_account_interest_message_board_read = 1;
	if(Household_start_Household_state->agents != NULL) FLAME_account_interest_message_board_read = 1;
	if(IGFirm_IGFirm_start_state->agents != NULL) FLAME_account_interest_message_board_read = 1;
	
	/* Call message board library with details */
	if(FLAME_account_interest_message_board_write == 0 &&
		FLAME_account_interest_message_board_read == 0)
			rc = MB_SetAccessMode(b_account_interest, MB_MODE_IDLE);
	if(FLAME_account_interest_message_board_write == 1 &&
		FLAME_account_interest_message_board_read == 0)
			rc = MB_SetAccessMode(b_account_interest, MB_MODE_WRITEONLY);
	if(FLAME_account_interest_message_board_write == 0 &&
		FLAME_account_interest_message_board_read == 1)
			rc = MB_SetAccessMode(b_account_interest, MB_MODE_READONLY);
	if(FLAME_account_interest_message_board_write == 1 &&
		FLAME_account_interest_message_board_read == 1)
			rc = MB_SetAccessMode(b_account_interest, MB_MODE_READWRITE);
	#ifdef ERRCHECK
	if (rc != MB_SUCCESS)
	{
	   fprintf(stderr, "ERROR: Could not set access mode of 'account_interest' board\n");
	   switch(rc) {
		   case MB_ERR_INVALID:
			   fprintf(stderr, "\t reason: 'account_interest' board is invalid\n");
			   break;
		   case MB_ERR_LOCKED:
			   fprintf(stderr, "\t reason: 'account_interest' board is locked\n");
			   break;
		   case MB_ERR_MEMALLOC:
			   fprintf(stderr, "\t reason: out of memory\n");
			   break;
		   case MB_ERR_INTERNAL:
			   fprintf(stderr, "\t reason: internal error. Recompile libmoard in debug mode for more info \n");
			   break;
		   default:
			   fprintf(stderr, "\t MB_SyncStart returned error code: %d (see libmboard docs for details)\n", rc);
			   break;
	   }
		   
		   exit(rc);
	}
	#endif
	FLAME_ecb_dividend_message_board_write = 0;
	FLAME_ecb_dividend_message_board_read = 0;
	/* Sending agents */
	if(CentralBank_start_Central_Bank_state->agents != NULL) FLAME_ecb_dividend_message_board_write = 1;
	
	/* Reading agents */
	if(Government_start_Government_state->agents != NULL) FLAME_ecb_dividend_message_board_read = 1;
	
	/* Call message board library with details */
	if(FLAME_ecb_dividend_message_board_write == 0 &&
		FLAME_ecb_dividend_message_board_read == 0)
			rc = MB_SetAccessMode(b_ecb_dividend, MB_MODE_IDLE);
	if(FLAME_ecb_dividend_message_board_write == 1 &&
		FLAME_ecb_dividend_message_board_read == 0)
			rc = MB_SetAccessMode(b_ecb_dividend, MB_MODE_WRITEONLY);
	if(FLAME_ecb_dividend_message_board_write == 0 &&
		FLAME_ecb_dividend_message_board_read == 1)
			rc = MB_SetAccessMode(b_ecb_dividend, MB_MODE_READONLY);
	if(FLAME_ecb_dividend_message_board_write == 1 &&
		FLAME_ecb_dividend_message_board_read == 1)
			rc = MB_SetAccessMode(b_ecb_dividend, MB_MODE_READWRITE);
	#ifdef ERRCHECK
	if (rc != MB_SUCCESS)
	{
	   fprintf(stderr, "ERROR: Could not set access mode of 'ecb_dividend' board\n");
	   switch(rc) {
		   case MB_ERR_INVALID:
			   fprintf(stderr, "\t reason: 'ecb_dividend' board is invalid\n");
			   break;
		   case MB_ERR_LOCKED:
			   fprintf(stderr, "\t reason: 'ecb_dividend' board is locked\n");
			   break;
		   case MB_ERR_MEMALLOC:
			   fprintf(stderr, "\t reason: out of memory\n");
			   break;
		   case MB_ERR_INTERNAL:
			   fprintf(stderr, "\t reason: internal error. Recompile libmoard in debug mode for more info \n");
			   break;
		   default:
			   fprintf(stderr, "\t MB_SyncStart returned error code: %d (see libmboard docs for details)\n", rc);
			   break;
	   }
		   
		   exit(rc);
	}
	#endif
	FLAME_credit_var_update_message_board_write = 0;
	FLAME_credit_var_update_message_board_read = 0;
	/* Sending agents */
	if(Firm_start_Firm_state->agents != NULL) FLAME_credit_var_update_message_board_write = 1;
	
	/* Reading agents */
	if(Bank_start_Bank_state->agents != NULL) FLAME_credit_var_update_message_board_read = 1;
	
	/* Call message board library with details */
	if(FLAME_credit_var_update_message_board_write == 0 &&
		FLAME_credit_var_update_message_board_read == 0)
			rc = MB_SetAccessMode(b_credit_var_update, MB_MODE_IDLE);
	if(FLAME_credit_var_update_message_board_write == 1 &&
		FLAME_credit_var_update_message_board_read == 0)
			rc = MB_SetAccessMode(b_credit_var_update, MB_MODE_WRITEONLY);
	if(FLAME_credit_var_update_message_board_write == 0 &&
		FLAME_credit_var_update_message_board_read == 1)
			rc = MB_SetAccessMode(b_credit_var_update, MB_MODE_READONLY);
	if(FLAME_credit_var_update_message_board_write == 1 &&
		FLAME_credit_var_update_message_board_read == 1)
			rc = MB_SetAccessMode(b_credit_var_update, MB_MODE_READWRITE);
	#ifdef ERRCHECK
	if (rc != MB_SUCCESS)
	{
	   fprintf(stderr, "ERROR: Could not set access mode of 'credit_var_update' board\n");
	   switch(rc) {
		   case MB_ERR_INVALID:
			   fprintf(stderr, "\t reason: 'credit_var_update' board is invalid\n");
			   break;
		   case MB_ERR_LOCKED:
			   fprintf(stderr, "\t reason: 'credit_var_update' board is locked\n");
			   break;
		   case MB_ERR_MEMALLOC:
			   fprintf(stderr, "\t reason: out of memory\n");
			   break;
		   case MB_ERR_INTERNAL:
			   fprintf(stderr, "\t reason: internal error. Recompile libmoard in debug mode for more info \n");
			   break;
		   default:
			   fprintf(stderr, "\t MB_SyncStart returned error code: %d (see libmboard docs for details)\n", rc);
			   break;
	   }
		   
		   exit(rc);
	}
	#endif
	FLAME_bankruptcy_illiquidity_message_board_write = 0;
	FLAME_bankruptcy_illiquidity_message_board_read = 0;
	/* Sending agents */
	if(Firm_start_Firm_state->agents != NULL) FLAME_bankruptcy_illiquidity_message_board_write = 1;
	
	/* Reading agents */
	if(Mall_start_Mall_state->agents != NULL) FLAME_bankruptcy_illiquidity_message_board_read = 1;
	if(Eurostat_start_Eurostat_state->agents != NULL) FLAME_bankruptcy_illiquidity_message_board_read = 1;
	
	/* Call message board library with details */
	if(FLAME_bankruptcy_illiquidity_message_board_write == 0 &&
		FLAME_bankruptcy_illiquidity_message_board_read == 0)
			rc = MB_SetAccessMode(b_bankruptcy_illiquidity, MB_MODE_IDLE);
	if(FLAME_bankruptcy_illiquidity_message_board_write == 1 &&
		FLAME_bankruptcy_illiquidity_message_board_read == 0)
			rc = MB_SetAccessMode(b_bankruptcy_illiquidity, MB_MODE_WRITEONLY);
	if(FLAME_bankruptcy_illiquidity_message_board_write == 0 &&
		FLAME_bankruptcy_illiquidity_message_board_read == 1)
			rc = MB_SetAccessMode(b_bankruptcy_illiquidity, MB_MODE_READONLY);
	if(FLAME_bankruptcy_illiquidity_message_board_write == 1 &&
		FLAME_bankruptcy_illiquidity_message_board_read == 1)
			rc = MB_SetAccessMode(b_bankruptcy_illiquidity, MB_MODE_READWRITE);
	#ifdef ERRCHECK
	if (rc != MB_SUCCESS)
	{
	   fprintf(stderr, "ERROR: Could not set access mode of 'bankruptcy_illiquidity' board\n");
	   switch(rc) {
		   case MB_ERR_INVALID:
			   fprintf(stderr, "\t reason: 'bankruptcy_illiquidity' board is invalid\n");
			   break;
		   case MB_ERR_LOCKED:
			   fprintf(stderr, "\t reason: 'bankruptcy_illiquidity' board is locked\n");
			   break;
		   case MB_ERR_MEMALLOC:
			   fprintf(stderr, "\t reason: out of memory\n");
			   break;
		   case MB_ERR_INTERNAL:
			   fprintf(stderr, "\t reason: internal error. Recompile libmoard in debug mode for more info \n");
			   break;
		   default:
			   fprintf(stderr, "\t MB_SyncStart returned error code: %d (see libmboard docs for details)\n", rc);
			   break;
	   }
		   
		   exit(rc);
	}
	#endif
	FLAME_bankruptcy_insolvency_message_board_write = 0;
	FLAME_bankruptcy_insolvency_message_board_read = 0;
	/* Sending agents */
	if(Firm_start_Firm_state->agents != NULL) FLAME_bankruptcy_insolvency_message_board_write = 1;
	
	/* Reading agents */
	if(Mall_start_Mall_state->agents != NULL) FLAME_bankruptcy_insolvency_message_board_read = 1;
	if(Eurostat_start_Eurostat_state->agents != NULL) FLAME_bankruptcy_insolvency_message_board_read = 1;
	
	/* Call message board library with details */
	if(FLAME_bankruptcy_insolvency_message_board_write == 0 &&
		FLAME_bankruptcy_insolvency_message_board_read == 0)
			rc = MB_SetAccessMode(b_bankruptcy_insolvency, MB_MODE_IDLE);
	if(FLAME_bankruptcy_insolvency_message_board_write == 1 &&
		FLAME_bankruptcy_insolvency_message_board_read == 0)
			rc = MB_SetAccessMode(b_bankruptcy_insolvency, MB_MODE_WRITEONLY);
	if(FLAME_bankruptcy_insolvency_message_board_write == 0 &&
		FLAME_bankruptcy_insolvency_message_board_read == 1)
			rc = MB_SetAccessMode(b_bankruptcy_insolvency, MB_MODE_READONLY);
	if(FLAME_bankruptcy_insolvency_message_board_write == 1 &&
		FLAME_bankruptcy_insolvency_message_board_read == 1)
			rc = MB_SetAccessMode(b_bankruptcy_insolvency, MB_MODE_READWRITE);
	#ifdef ERRCHECK
	if (rc != MB_SUCCESS)
	{
	   fprintf(stderr, "ERROR: Could not set access mode of 'bankruptcy_insolvency' board\n");
	   switch(rc) {
		   case MB_ERR_INVALID:
			   fprintf(stderr, "\t reason: 'bankruptcy_insolvency' board is invalid\n");
			   break;
		   case MB_ERR_LOCKED:
			   fprintf(stderr, "\t reason: 'bankruptcy_insolvency' board is locked\n");
			   break;
		   case MB_ERR_MEMALLOC:
			   fprintf(stderr, "\t reason: out of memory\n");
			   break;
		   case MB_ERR_INTERNAL:
			   fprintf(stderr, "\t reason: internal error. Recompile libmoard in debug mode for more info \n");
			   break;
		   default:
			   fprintf(stderr, "\t MB_SyncStart returned error code: %d (see libmboard docs for details)\n", rc);
			   break;
	   }
		   
		   exit(rc);
	}
	#endif
	FLAME_index_info_message_board_write = 0;
	FLAME_index_info_message_board_read = 0;
	/* Sending agents */
	if(ClearingHouse_start_Clearinghouse_state->agents != NULL) FLAME_index_info_message_board_write = 1;
	
	/* Reading agents */
	if(Household_start_Household_state->agents != NULL) FLAME_index_info_message_board_read = 1;
	
	/* Call message board library with details */
	if(FLAME_index_info_message_board_write == 0 &&
		FLAME_index_info_message_board_read == 0)
			rc = MB_SetAccessMode(b_index_info, MB_MODE_IDLE);
	if(FLAME_index_info_message_board_write == 1 &&
		FLAME_index_info_message_board_read == 0)
			rc = MB_SetAccessMode(b_index_info, MB_MODE_WRITEONLY);
	if(FLAME_index_info_message_board_write == 0 &&
		FLAME_index_info_message_board_read == 1)
			rc = MB_SetAccessMode(b_index_info, MB_MODE_READONLY);
	if(FLAME_index_info_message_board_write == 1 &&
		FLAME_index_info_message_board_read == 1)
			rc = MB_SetAccessMode(b_index_info, MB_MODE_READWRITE);
	#ifdef ERRCHECK
	if (rc != MB_SUCCESS)
	{
	   fprintf(stderr, "ERROR: Could not set access mode of 'index_info' board\n");
	   switch(rc) {
		   case MB_ERR_INVALID:
			   fprintf(stderr, "\t reason: 'index_info' board is invalid\n");
			   break;
		   case MB_ERR_LOCKED:
			   fprintf(stderr, "\t reason: 'index_info' board is locked\n");
			   break;
		   case MB_ERR_MEMALLOC:
			   fprintf(stderr, "\t reason: out of memory\n");
			   break;
		   case MB_ERR_INTERNAL:
			   fprintf(stderr, "\t reason: internal error. Recompile libmoard in debug mode for more info \n");
			   break;
		   default:
			   fprintf(stderr, "\t MB_SyncStart returned error code: %d (see libmboard docs for details)\n", rc);
			   break;
	   }
		   
		   exit(rc);
	}
	#endif
	FLAME_index_price_message_board_write = 0;
	FLAME_index_price_message_board_read = 0;
	/* Sending agents */
	if(ClearingHouse_start_Clearinghouse_state->agents != NULL) FLAME_index_price_message_board_write = 1;
	
	/* Reading agents */
	if(Household_start_Household_state->agents != NULL) FLAME_index_price_message_board_read = 1;
	
	/* Call message board library with details */
	if(FLAME_index_price_message_board_write == 0 &&
		FLAME_index_price_message_board_read == 0)
			rc = MB_SetAccessMode(b_index_price, MB_MODE_IDLE);
	if(FLAME_index_price_message_board_write == 1 &&
		FLAME_index_price_message_board_read == 0)
			rc = MB_SetAccessMode(b_index_price, MB_MODE_WRITEONLY);
	if(FLAME_index_price_message_board_write == 0 &&
		FLAME_index_price_message_board_read == 1)
			rc = MB_SetAccessMode(b_index_price, MB_MODE_READONLY);
	if(FLAME_index_price_message_board_write == 1 &&
		FLAME_index_price_message_board_read == 1)
			rc = MB_SetAccessMode(b_index_price, MB_MODE_READWRITE);
	#ifdef ERRCHECK
	if (rc != MB_SUCCESS)
	{
	   fprintf(stderr, "ERROR: Could not set access mode of 'index_price' board\n");
	   switch(rc) {
		   case MB_ERR_INVALID:
			   fprintf(stderr, "\t reason: 'index_price' board is invalid\n");
			   break;
		   case MB_ERR_LOCKED:
			   fprintf(stderr, "\t reason: 'index_price' board is locked\n");
			   break;
		   case MB_ERR_MEMALLOC:
			   fprintf(stderr, "\t reason: out of memory\n");
			   break;
		   case MB_ERR_INTERNAL:
			   fprintf(stderr, "\t reason: internal error. Recompile libmoard in debug mode for more info \n");
			   break;
		   default:
			   fprintf(stderr, "\t MB_SyncStart returned error code: %d (see libmboard docs for details)\n", rc);
			   break;
	   }
		   
		   exit(rc);
	}
	#endif
	FLAME_order_message_board_write = 0;
	FLAME_order_message_board_read = 0;
	/* Sending agents */
	if(Household_start_Household_state->agents != NULL) FLAME_order_message_board_write = 1;
	
	/* Reading agents */
	if(ClearingHouse_start_Clearinghouse_state->agents != NULL) FLAME_order_message_board_read = 1;
	
	/* Call message board library with details */
	if(FLAME_order_message_board_write == 0 &&
		FLAME_order_message_board_read == 0)
			rc = MB_SetAccessMode(b_order, MB_MODE_IDLE);
	if(FLAME_order_message_board_write == 1 &&
		FLAME_order_message_board_read == 0)
			rc = MB_SetAccessMode(b_order, MB_MODE_WRITEONLY);
	if(FLAME_order_message_board_write == 0 &&
		FLAME_order_message_board_read == 1)
			rc = MB_SetAccessMode(b_order, MB_MODE_READONLY);
	if(FLAME_order_message_board_write == 1 &&
		FLAME_order_message_board_read == 1)
			rc = MB_SetAccessMode(b_order, MB_MODE_READWRITE);
	#ifdef ERRCHECK
	if (rc != MB_SUCCESS)
	{
	   fprintf(stderr, "ERROR: Could not set access mode of 'order' board\n");
	   switch(rc) {
		   case MB_ERR_INVALID:
			   fprintf(stderr, "\t reason: 'order' board is invalid\n");
			   break;
		   case MB_ERR_LOCKED:
			   fprintf(stderr, "\t reason: 'order' board is locked\n");
			   break;
		   case MB_ERR_MEMALLOC:
			   fprintf(stderr, "\t reason: out of memory\n");
			   break;
		   case MB_ERR_INTERNAL:
			   fprintf(stderr, "\t reason: internal error. Recompile libmoard in debug mode for more info \n");
			   break;
		   default:
			   fprintf(stderr, "\t MB_SyncStart returned error code: %d (see libmboard docs for details)\n", rc);
			   break;
	   }
		   
		   exit(rc);
	}
	#endif
	FLAME_order_status_message_board_write = 0;
	FLAME_order_status_message_board_read = 0;
	/* Sending agents */
	if(ClearingHouse_start_Clearinghouse_state->agents != NULL) FLAME_order_status_message_board_write = 1;
	
	/* Reading agents */
	if(Household_start_Household_state->agents != NULL) FLAME_order_status_message_board_read = 1;
	
	/* Call message board library with details */
	if(FLAME_order_status_message_board_write == 0 &&
		FLAME_order_status_message_board_read == 0)
			rc = MB_SetAccessMode(b_order_status, MB_MODE_IDLE);
	if(FLAME_order_status_message_board_write == 1 &&
		FLAME_order_status_message_board_read == 0)
			rc = MB_SetAccessMode(b_order_status, MB_MODE_WRITEONLY);
	if(FLAME_order_status_message_board_write == 0 &&
		FLAME_order_status_message_board_read == 1)
			rc = MB_SetAccessMode(b_order_status, MB_MODE_READONLY);
	if(FLAME_order_status_message_board_write == 1 &&
		FLAME_order_status_message_board_read == 1)
			rc = MB_SetAccessMode(b_order_status, MB_MODE_READWRITE);
	#ifdef ERRCHECK
	if (rc != MB_SUCCESS)
	{
	   fprintf(stderr, "ERROR: Could not set access mode of 'order_status' board\n");
	   switch(rc) {
		   case MB_ERR_INVALID:
			   fprintf(stderr, "\t reason: 'order_status' board is invalid\n");
			   break;
		   case MB_ERR_LOCKED:
			   fprintf(stderr, "\t reason: 'order_status' board is locked\n");
			   break;
		   case MB_ERR_MEMALLOC:
			   fprintf(stderr, "\t reason: out of memory\n");
			   break;
		   case MB_ERR_INTERNAL:
			   fprintf(stderr, "\t reason: internal error. Recompile libmoard in debug mode for more info \n");
			   break;
		   default:
			   fprintf(stderr, "\t MB_SyncStart returned error code: %d (see libmboard docs for details)\n", rc);
			   break;
	   }
		   
		   exit(rc);
	}
	#endif
	FLAME_dividend_info_message_board_write = 0;
	FLAME_dividend_info_message_board_read = 0;
	/* Sending agents */
	if(Firm_start_Firm_state->agents != NULL) FLAME_dividend_info_message_board_write = 1;
	if(IGFirm_IGFirm_start_state->agents != NULL) FLAME_dividend_info_message_board_write = 1;
	if(Bank_start_Bank_state->agents != NULL) FLAME_dividend_info_message_board_write = 1;
	
	/* Reading agents */
	if(ClearingHouse_start_Clearinghouse_state->agents != NULL) FLAME_dividend_info_message_board_read = 1;
	
	/* Call message board library with details */
	if(FLAME_dividend_info_message_board_write == 0 &&
		FLAME_dividend_info_message_board_read == 0)
			rc = MB_SetAccessMode(b_dividend_info, MB_MODE_IDLE);
	if(FLAME_dividend_info_message_board_write == 1 &&
		FLAME_dividend_info_message_board_read == 0)
			rc = MB_SetAccessMode(b_dividend_info, MB_MODE_WRITEONLY);
	if(FLAME_dividend_info_message_board_write == 0 &&
		FLAME_dividend_info_message_board_read == 1)
			rc = MB_SetAccessMode(b_dividend_info, MB_MODE_READONLY);
	if(FLAME_dividend_info_message_board_write == 1 &&
		FLAME_dividend_info_message_board_read == 1)
			rc = MB_SetAccessMode(b_dividend_info, MB_MODE_READWRITE);
	#ifdef ERRCHECK
	if (rc != MB_SUCCESS)
	{
	   fprintf(stderr, "ERROR: Could not set access mode of 'dividend_info' board\n");
	   switch(rc) {
		   case MB_ERR_INVALID:
			   fprintf(stderr, "\t reason: 'dividend_info' board is invalid\n");
			   break;
		   case MB_ERR_LOCKED:
			   fprintf(stderr, "\t reason: 'dividend_info' board is locked\n");
			   break;
		   case MB_ERR_MEMALLOC:
			   fprintf(stderr, "\t reason: out of memory\n");
			   break;
		   case MB_ERR_INTERNAL:
			   fprintf(stderr, "\t reason: internal error. Recompile libmoard in debug mode for more info \n");
			   break;
		   default:
			   fprintf(stderr, "\t MB_SyncStart returned error code: %d (see libmboard docs for details)\n", rc);
			   break;
	   }
		   
		   exit(rc);
	}
	#endif
	FLAME_productivity_message_board_write = 0;
	FLAME_productivity_message_board_read = 0;
	/* Sending agents */
	if(IGFirm_IGFirm_start_state->agents != NULL) FLAME_productivity_message_board_write = 1;
	
	/* Reading agents */
	if(Firm_start_Firm_state->agents != NULL) FLAME_productivity_message_board_read = 1;
	
	/* Call message board library with details */
	if(FLAME_productivity_message_board_write == 0 &&
		FLAME_productivity_message_board_read == 0)
			rc = MB_SetAccessMode(b_productivity, MB_MODE_IDLE);
	if(FLAME_productivity_message_board_write == 1 &&
		FLAME_productivity_message_board_read == 0)
			rc = MB_SetAccessMode(b_productivity, MB_MODE_WRITEONLY);
	if(FLAME_productivity_message_board_write == 0 &&
		FLAME_productivity_message_board_read == 1)
			rc = MB_SetAccessMode(b_productivity, MB_MODE_READONLY);
	if(FLAME_productivity_message_board_write == 1 &&
		FLAME_productivity_message_board_read == 1)
			rc = MB_SetAccessMode(b_productivity, MB_MODE_READWRITE);
	#ifdef ERRCHECK
	if (rc != MB_SUCCESS)
	{
	   fprintf(stderr, "ERROR: Could not set access mode of 'productivity' board\n");
	   switch(rc) {
		   case MB_ERR_INVALID:
			   fprintf(stderr, "\t reason: 'productivity' board is invalid\n");
			   break;
		   case MB_ERR_LOCKED:
			   fprintf(stderr, "\t reason: 'productivity' board is locked\n");
			   break;
		   case MB_ERR_MEMALLOC:
			   fprintf(stderr, "\t reason: out of memory\n");
			   break;
		   case MB_ERR_INTERNAL:
			   fprintf(stderr, "\t reason: internal error. Recompile libmoard in debug mode for more info \n");
			   break;
		   default:
			   fprintf(stderr, "\t MB_SyncStart returned error code: %d (see libmboard docs for details)\n", rc);
			   break;
	   }
		   
		   exit(rc);
	}
	#endif
	FLAME_capital_good_request_message_board_write = 0;
	FLAME_capital_good_request_message_board_read = 0;
	/* Sending agents */
	if(Firm_start_Firm_state->agents != NULL) FLAME_capital_good_request_message_board_write = 1;
	
	/* Reading agents */
	if(IGFirm_IGFirm_start_state->agents != NULL) FLAME_capital_good_request_message_board_read = 1;
	
	/* Call message board library with details */
	if(FLAME_capital_good_request_message_board_write == 0 &&
		FLAME_capital_good_request_message_board_read == 0)
			rc = MB_SetAccessMode(b_capital_good_request, MB_MODE_IDLE);
	if(FLAME_capital_good_request_message_board_write == 1 &&
		FLAME_capital_good_request_message_board_read == 0)
			rc = MB_SetAccessMode(b_capital_good_request, MB_MODE_WRITEONLY);
	if(FLAME_capital_good_request_message_board_write == 0 &&
		FLAME_capital_good_request_message_board_read == 1)
			rc = MB_SetAccessMode(b_capital_good_request, MB_MODE_READONLY);
	if(FLAME_capital_good_request_message_board_write == 1 &&
		FLAME_capital_good_request_message_board_read == 1)
			rc = MB_SetAccessMode(b_capital_good_request, MB_MODE_READWRITE);
	#ifdef ERRCHECK
	if (rc != MB_SUCCESS)
	{
	   fprintf(stderr, "ERROR: Could not set access mode of 'capital_good_request' board\n");
	   switch(rc) {
		   case MB_ERR_INVALID:
			   fprintf(stderr, "\t reason: 'capital_good_request' board is invalid\n");
			   break;
		   case MB_ERR_LOCKED:
			   fprintf(stderr, "\t reason: 'capital_good_request' board is locked\n");
			   break;
		   case MB_ERR_MEMALLOC:
			   fprintf(stderr, "\t reason: out of memory\n");
			   break;
		   case MB_ERR_INTERNAL:
			   fprintf(stderr, "\t reason: internal error. Recompile libmoard in debug mode for more info \n");
			   break;
		   default:
			   fprintf(stderr, "\t MB_SyncStart returned error code: %d (see libmboard docs for details)\n", rc);
			   break;
	   }
		   
		   exit(rc);
	}
	#endif
	FLAME_capital_good_delivery_message_board_write = 0;
	FLAME_capital_good_delivery_message_board_read = 0;
	/* Sending agents */
	if(IGFirm_IGFirm_start_state->agents != NULL) FLAME_capital_good_delivery_message_board_write = 1;
	
	/* Reading agents */
	if(Firm_start_Firm_state->agents != NULL) FLAME_capital_good_delivery_message_board_read = 1;
	
	/* Call message board library with details */
	if(FLAME_capital_good_delivery_message_board_write == 0 &&
		FLAME_capital_good_delivery_message_board_read == 0)
			rc = MB_SetAccessMode(b_capital_good_delivery, MB_MODE_IDLE);
	if(FLAME_capital_good_delivery_message_board_write == 1 &&
		FLAME_capital_good_delivery_message_board_read == 0)
			rc = MB_SetAccessMode(b_capital_good_delivery, MB_MODE_WRITEONLY);
	if(FLAME_capital_good_delivery_message_board_write == 0 &&
		FLAME_capital_good_delivery_message_board_read == 1)
			rc = MB_SetAccessMode(b_capital_good_delivery, MB_MODE_READONLY);
	if(FLAME_capital_good_delivery_message_board_write == 1 &&
		FLAME_capital_good_delivery_message_board_read == 1)
			rc = MB_SetAccessMode(b_capital_good_delivery, MB_MODE_READWRITE);
	#ifdef ERRCHECK
	if (rc != MB_SUCCESS)
	{
	   fprintf(stderr, "ERROR: Could not set access mode of 'capital_good_delivery' board\n");
	   switch(rc) {
		   case MB_ERR_INVALID:
			   fprintf(stderr, "\t reason: 'capital_good_delivery' board is invalid\n");
			   break;
		   case MB_ERR_LOCKED:
			   fprintf(stderr, "\t reason: 'capital_good_delivery' board is locked\n");
			   break;
		   case MB_ERR_MEMALLOC:
			   fprintf(stderr, "\t reason: out of memory\n");
			   break;
		   case MB_ERR_INTERNAL:
			   fprintf(stderr, "\t reason: internal error. Recompile libmoard in debug mode for more info \n");
			   break;
		   default:
			   fprintf(stderr, "\t MB_SyncStart returned error code: %d (see libmboard docs for details)\n", rc);
			   break;
	   }
		   
		   exit(rc);
	}
	#endif
	FLAME_pay_capital_goods_message_board_write = 0;
	FLAME_pay_capital_goods_message_board_read = 0;
	/* Sending agents */
	if(Firm_start_Firm_state->agents != NULL) FLAME_pay_capital_goods_message_board_write = 1;
	
	/* Reading agents */
	if(IGFirm_IGFirm_start_state->agents != NULL) FLAME_pay_capital_goods_message_board_read = 1;
	
	/* Call message board library with details */
	if(FLAME_pay_capital_goods_message_board_write == 0 &&
		FLAME_pay_capital_goods_message_board_read == 0)
			rc = MB_SetAccessMode(b_pay_capital_goods, MB_MODE_IDLE);
	if(FLAME_pay_capital_goods_message_board_write == 1 &&
		FLAME_pay_capital_goods_message_board_read == 0)
			rc = MB_SetAccessMode(b_pay_capital_goods, MB_MODE_WRITEONLY);
	if(FLAME_pay_capital_goods_message_board_write == 0 &&
		FLAME_pay_capital_goods_message_board_read == 1)
			rc = MB_SetAccessMode(b_pay_capital_goods, MB_MODE_READONLY);
	if(FLAME_pay_capital_goods_message_board_write == 1 &&
		FLAME_pay_capital_goods_message_board_read == 1)
			rc = MB_SetAccessMode(b_pay_capital_goods, MB_MODE_READWRITE);
	#ifdef ERRCHECK
	if (rc != MB_SUCCESS)
	{
	   fprintf(stderr, "ERROR: Could not set access mode of 'pay_capital_goods' board\n");
	   switch(rc) {
		   case MB_ERR_INVALID:
			   fprintf(stderr, "\t reason: 'pay_capital_goods' board is invalid\n");
			   break;
		   case MB_ERR_LOCKED:
			   fprintf(stderr, "\t reason: 'pay_capital_goods' board is locked\n");
			   break;
		   case MB_ERR_MEMALLOC:
			   fprintf(stderr, "\t reason: out of memory\n");
			   break;
		   case MB_ERR_INTERNAL:
			   fprintf(stderr, "\t reason: internal error. Recompile libmoard in debug mode for more info \n");
			   break;
		   default:
			   fprintf(stderr, "\t MB_SyncStart returned error code: %d (see libmboard docs for details)\n", rc);
			   break;
	   }
		   
		   exit(rc);
	}
	#endif
	FLAME_vacancies_message_board_write = 0;
	FLAME_vacancies_message_board_read = 0;
	/* Sending agents */
	if(Firm_start_Firm_state->agents != NULL) FLAME_vacancies_message_board_write = 1;
	
	/* Reading agents */
	if(Household_start_Household_state->agents != NULL) FLAME_vacancies_message_board_read = 1;
	
	/* Call message board library with details */
	if(FLAME_vacancies_message_board_write == 0 &&
		FLAME_vacancies_message_board_read == 0)
			rc = MB_SetAccessMode(b_vacancies, MB_MODE_IDLE);
	if(FLAME_vacancies_message_board_write == 1 &&
		FLAME_vacancies_message_board_read == 0)
			rc = MB_SetAccessMode(b_vacancies, MB_MODE_WRITEONLY);
	if(FLAME_vacancies_message_board_write == 0 &&
		FLAME_vacancies_message_board_read == 1)
			rc = MB_SetAccessMode(b_vacancies, MB_MODE_READONLY);
	if(FLAME_vacancies_message_board_write == 1 &&
		FLAME_vacancies_message_board_read == 1)
			rc = MB_SetAccessMode(b_vacancies, MB_MODE_READWRITE);
	#ifdef ERRCHECK
	if (rc != MB_SUCCESS)
	{
	   fprintf(stderr, "ERROR: Could not set access mode of 'vacancies' board\n");
	   switch(rc) {
		   case MB_ERR_INVALID:
			   fprintf(stderr, "\t reason: 'vacancies' board is invalid\n");
			   break;
		   case MB_ERR_LOCKED:
			   fprintf(stderr, "\t reason: 'vacancies' board is locked\n");
			   break;
		   case MB_ERR_MEMALLOC:
			   fprintf(stderr, "\t reason: out of memory\n");
			   break;
		   case MB_ERR_INTERNAL:
			   fprintf(stderr, "\t reason: internal error. Recompile libmoard in debug mode for more info \n");
			   break;
		   default:
			   fprintf(stderr, "\t MB_SyncStart returned error code: %d (see libmboard docs for details)\n", rc);
			   break;
	   }
		   
		   exit(rc);
	}
	#endif
	FLAME_vacancies2_message_board_write = 0;
	FLAME_vacancies2_message_board_read = 0;
	/* Sending agents */
	if(Firm_start_Firm_state->agents != NULL) FLAME_vacancies2_message_board_write = 1;
	
	/* Reading agents */
	if(Household_start_Household_state->agents != NULL) FLAME_vacancies2_message_board_read = 1;
	
	/* Call message board library with details */
	if(FLAME_vacancies2_message_board_write == 0 &&
		FLAME_vacancies2_message_board_read == 0)
			rc = MB_SetAccessMode(b_vacancies2, MB_MODE_IDLE);
	if(FLAME_vacancies2_message_board_write == 1 &&
		FLAME_vacancies2_message_board_read == 0)
			rc = MB_SetAccessMode(b_vacancies2, MB_MODE_WRITEONLY);
	if(FLAME_vacancies2_message_board_write == 0 &&
		FLAME_vacancies2_message_board_read == 1)
			rc = MB_SetAccessMode(b_vacancies2, MB_MODE_READONLY);
	if(FLAME_vacancies2_message_board_write == 1 &&
		FLAME_vacancies2_message_board_read == 1)
			rc = MB_SetAccessMode(b_vacancies2, MB_MODE_READWRITE);
	#ifdef ERRCHECK
	if (rc != MB_SUCCESS)
	{
	   fprintf(stderr, "ERROR: Could not set access mode of 'vacancies2' board\n");
	   switch(rc) {
		   case MB_ERR_INVALID:
			   fprintf(stderr, "\t reason: 'vacancies2' board is invalid\n");
			   break;
		   case MB_ERR_LOCKED:
			   fprintf(stderr, "\t reason: 'vacancies2' board is locked\n");
			   break;
		   case MB_ERR_MEMALLOC:
			   fprintf(stderr, "\t reason: out of memory\n");
			   break;
		   case MB_ERR_INTERNAL:
			   fprintf(stderr, "\t reason: internal error. Recompile libmoard in debug mode for more info \n");
			   break;
		   default:
			   fprintf(stderr, "\t MB_SyncStart returned error code: %d (see libmboard docs for details)\n", rc);
			   break;
	   }
		   
		   exit(rc);
	}
	#endif
	FLAME_vacancies_r_and_d_employees_message_board_write = 0;
	FLAME_vacancies_r_and_d_employees_message_board_read = 0;
	/* Sending agents */
	if(Firm_start_Firm_state->agents != NULL) FLAME_vacancies_r_and_d_employees_message_board_write = 1;
	
	/* Reading agents */
	if(Household_start_Household_state->agents != NULL) FLAME_vacancies_r_and_d_employees_message_board_read = 1;
	
	/* Call message board library with details */
	if(FLAME_vacancies_r_and_d_employees_message_board_write == 0 &&
		FLAME_vacancies_r_and_d_employees_message_board_read == 0)
			rc = MB_SetAccessMode(b_vacancies_r_and_d_employees, MB_MODE_IDLE);
	if(FLAME_vacancies_r_and_d_employees_message_board_write == 1 &&
		FLAME_vacancies_r_and_d_employees_message_board_read == 0)
			rc = MB_SetAccessMode(b_vacancies_r_and_d_employees, MB_MODE_WRITEONLY);
	if(FLAME_vacancies_r_and_d_employees_message_board_write == 0 &&
		FLAME_vacancies_r_and_d_employees_message_board_read == 1)
			rc = MB_SetAccessMode(b_vacancies_r_and_d_employees, MB_MODE_READONLY);
	if(FLAME_vacancies_r_and_d_employees_message_board_write == 1 &&
		FLAME_vacancies_r_and_d_employees_message_board_read == 1)
			rc = MB_SetAccessMode(b_vacancies_r_and_d_employees, MB_MODE_READWRITE);
	#ifdef ERRCHECK
	if (rc != MB_SUCCESS)
	{
	   fprintf(stderr, "ERROR: Could not set access mode of 'vacancies_r_and_d_employees' board\n");
	   switch(rc) {
		   case MB_ERR_INVALID:
			   fprintf(stderr, "\t reason: 'vacancies_r_and_d_employees' board is invalid\n");
			   break;
		   case MB_ERR_LOCKED:
			   fprintf(stderr, "\t reason: 'vacancies_r_and_d_employees' board is locked\n");
			   break;
		   case MB_ERR_MEMALLOC:
			   fprintf(stderr, "\t reason: out of memory\n");
			   break;
		   case MB_ERR_INTERNAL:
			   fprintf(stderr, "\t reason: internal error. Recompile libmoard in debug mode for more info \n");
			   break;
		   default:
			   fprintf(stderr, "\t MB_SyncStart returned error code: %d (see libmboard docs for details)\n", rc);
			   break;
	   }
		   
		   exit(rc);
	}
	#endif
	FLAME_vacancies_r_and_d_employees2_message_board_write = 0;
	FLAME_vacancies_r_and_d_employees2_message_board_read = 0;
	/* Sending agents */
	if(Firm_start_Firm_state->agents != NULL) FLAME_vacancies_r_and_d_employees2_message_board_write = 1;
	
	/* Reading agents */
	if(Household_start_Household_state->agents != NULL) FLAME_vacancies_r_and_d_employees2_message_board_read = 1;
	
	/* Call message board library with details */
	if(FLAME_vacancies_r_and_d_employees2_message_board_write == 0 &&
		FLAME_vacancies_r_and_d_employees2_message_board_read == 0)
			rc = MB_SetAccessMode(b_vacancies_r_and_d_employees2, MB_MODE_IDLE);
	if(FLAME_vacancies_r_and_d_employees2_message_board_write == 1 &&
		FLAME_vacancies_r_and_d_employees2_message_board_read == 0)
			rc = MB_SetAccessMode(b_vacancies_r_and_d_employees2, MB_MODE_WRITEONLY);
	if(FLAME_vacancies_r_and_d_employees2_message_board_write == 0 &&
		FLAME_vacancies_r_and_d_employees2_message_board_read == 1)
			rc = MB_SetAccessMode(b_vacancies_r_and_d_employees2, MB_MODE_READONLY);
	if(FLAME_vacancies_r_and_d_employees2_message_board_write == 1 &&
		FLAME_vacancies_r_and_d_employees2_message_board_read == 1)
			rc = MB_SetAccessMode(b_vacancies_r_and_d_employees2, MB_MODE_READWRITE);
	#ifdef ERRCHECK
	if (rc != MB_SUCCESS)
	{
	   fprintf(stderr, "ERROR: Could not set access mode of 'vacancies_r_and_d_employees2' board\n");
	   switch(rc) {
		   case MB_ERR_INVALID:
			   fprintf(stderr, "\t reason: 'vacancies_r_and_d_employees2' board is invalid\n");
			   break;
		   case MB_ERR_LOCKED:
			   fprintf(stderr, "\t reason: 'vacancies_r_and_d_employees2' board is locked\n");
			   break;
		   case MB_ERR_MEMALLOC:
			   fprintf(stderr, "\t reason: out of memory\n");
			   break;
		   case MB_ERR_INTERNAL:
			   fprintf(stderr, "\t reason: internal error. Recompile libmoard in debug mode for more info \n");
			   break;
		   default:
			   fprintf(stderr, "\t MB_SyncStart returned error code: %d (see libmboard docs for details)\n", rc);
			   break;
	   }
		   
		   exit(rc);
	}
	#endif
	FLAME_firing_message_board_write = 0;
	FLAME_firing_message_board_read = 0;
	/* Sending agents */
	if(Firm_start_Firm_state->agents != NULL) FLAME_firing_message_board_write = 1;
	
	/* Reading agents */
	if(Household_start_Household_state->agents != NULL) FLAME_firing_message_board_read = 1;
	
	/* Call message board library with details */
	if(FLAME_firing_message_board_write == 0 &&
		FLAME_firing_message_board_read == 0)
			rc = MB_SetAccessMode(b_firing, MB_MODE_IDLE);
	if(FLAME_firing_message_board_write == 1 &&
		FLAME_firing_message_board_read == 0)
			rc = MB_SetAccessMode(b_firing, MB_MODE_WRITEONLY);
	if(FLAME_firing_message_board_write == 0 &&
		FLAME_firing_message_board_read == 1)
			rc = MB_SetAccessMode(b_firing, MB_MODE_READONLY);
	if(FLAME_firing_message_board_write == 1 &&
		FLAME_firing_message_board_read == 1)
			rc = MB_SetAccessMode(b_firing, MB_MODE_READWRITE);
	#ifdef ERRCHECK
	if (rc != MB_SUCCESS)
	{
	   fprintf(stderr, "ERROR: Could not set access mode of 'firing' board\n");
	   switch(rc) {
		   case MB_ERR_INVALID:
			   fprintf(stderr, "\t reason: 'firing' board is invalid\n");
			   break;
		   case MB_ERR_LOCKED:
			   fprintf(stderr, "\t reason: 'firing' board is locked\n");
			   break;
		   case MB_ERR_MEMALLOC:
			   fprintf(stderr, "\t reason: out of memory\n");
			   break;
		   case MB_ERR_INTERNAL:
			   fprintf(stderr, "\t reason: internal error. Recompile libmoard in debug mode for more info \n");
			   break;
		   default:
			   fprintf(stderr, "\t MB_SyncStart returned error code: %d (see libmboard docs for details)\n", rc);
			   break;
	   }
		   
		   exit(rc);
	}
	#endif
	FLAME_job_application_message_board_write = 0;
	FLAME_job_application_message_board_read = 0;
	/* Sending agents */
	if(Household_start_Household_state->agents != NULL) FLAME_job_application_message_board_write = 1;
	
	/* Reading agents */
	if(Firm_start_Firm_state->agents != NULL) FLAME_job_application_message_board_read = 1;
	
	/* Call message board library with details */
	if(FLAME_job_application_message_board_write == 0 &&
		FLAME_job_application_message_board_read == 0)
			rc = MB_SetAccessMode(b_job_application, MB_MODE_IDLE);
	if(FLAME_job_application_message_board_write == 1 &&
		FLAME_job_application_message_board_read == 0)
			rc = MB_SetAccessMode(b_job_application, MB_MODE_WRITEONLY);
	if(FLAME_job_application_message_board_write == 0 &&
		FLAME_job_application_message_board_read == 1)
			rc = MB_SetAccessMode(b_job_application, MB_MODE_READONLY);
	if(FLAME_job_application_message_board_write == 1 &&
		FLAME_job_application_message_board_read == 1)
			rc = MB_SetAccessMode(b_job_application, MB_MODE_READWRITE);
	#ifdef ERRCHECK
	if (rc != MB_SUCCESS)
	{
	   fprintf(stderr, "ERROR: Could not set access mode of 'job_application' board\n");
	   switch(rc) {
		   case MB_ERR_INVALID:
			   fprintf(stderr, "\t reason: 'job_application' board is invalid\n");
			   break;
		   case MB_ERR_LOCKED:
			   fprintf(stderr, "\t reason: 'job_application' board is locked\n");
			   break;
		   case MB_ERR_MEMALLOC:
			   fprintf(stderr, "\t reason: out of memory\n");
			   break;
		   case MB_ERR_INTERNAL:
			   fprintf(stderr, "\t reason: internal error. Recompile libmoard in debug mode for more info \n");
			   break;
		   default:
			   fprintf(stderr, "\t MB_SyncStart returned error code: %d (see libmboard docs for details)\n", rc);
			   break;
	   }
		   
		   exit(rc);
	}
	#endif
	FLAME_job_application2_message_board_write = 0;
	FLAME_job_application2_message_board_read = 0;
	/* Sending agents */
	if(Household_start_Household_state->agents != NULL) FLAME_job_application2_message_board_write = 1;
	
	/* Reading agents */
	if(Firm_start_Firm_state->agents != NULL) FLAME_job_application2_message_board_read = 1;
	
	/* Call message board library with details */
	if(FLAME_job_application2_message_board_write == 0 &&
		FLAME_job_application2_message_board_read == 0)
			rc = MB_SetAccessMode(b_job_application2, MB_MODE_IDLE);
	if(FLAME_job_application2_message_board_write == 1 &&
		FLAME_job_application2_message_board_read == 0)
			rc = MB_SetAccessMode(b_job_application2, MB_MODE_WRITEONLY);
	if(FLAME_job_application2_message_board_write == 0 &&
		FLAME_job_application2_message_board_read == 1)
			rc = MB_SetAccessMode(b_job_application2, MB_MODE_READONLY);
	if(FLAME_job_application2_message_board_write == 1 &&
		FLAME_job_application2_message_board_read == 1)
			rc = MB_SetAccessMode(b_job_application2, MB_MODE_READWRITE);
	#ifdef ERRCHECK
	if (rc != MB_SUCCESS)
	{
	   fprintf(stderr, "ERROR: Could not set access mode of 'job_application2' board\n");
	   switch(rc) {
		   case MB_ERR_INVALID:
			   fprintf(stderr, "\t reason: 'job_application2' board is invalid\n");
			   break;
		   case MB_ERR_LOCKED:
			   fprintf(stderr, "\t reason: 'job_application2' board is locked\n");
			   break;
		   case MB_ERR_MEMALLOC:
			   fprintf(stderr, "\t reason: out of memory\n");
			   break;
		   case MB_ERR_INTERNAL:
			   fprintf(stderr, "\t reason: internal error. Recompile libmoard in debug mode for more info \n");
			   break;
		   default:
			   fprintf(stderr, "\t MB_SyncStart returned error code: %d (see libmboard docs for details)\n", rc);
			   break;
	   }
		   
		   exit(rc);
	}
	#endif
	FLAME_job_offer_message_board_write = 0;
	FLAME_job_offer_message_board_read = 0;
	/* Sending agents */
	if(Firm_start_Firm_state->agents != NULL) FLAME_job_offer_message_board_write = 1;
	
	/* Reading agents */
	if(Household_start_Household_state->agents != NULL) FLAME_job_offer_message_board_read = 1;
	
	/* Call message board library with details */
	if(FLAME_job_offer_message_board_write == 0 &&
		FLAME_job_offer_message_board_read == 0)
			rc = MB_SetAccessMode(b_job_offer, MB_MODE_IDLE);
	if(FLAME_job_offer_message_board_write == 1 &&
		FLAME_job_offer_message_board_read == 0)
			rc = MB_SetAccessMode(b_job_offer, MB_MODE_WRITEONLY);
	if(FLAME_job_offer_message_board_write == 0 &&
		FLAME_job_offer_message_board_read == 1)
			rc = MB_SetAccessMode(b_job_offer, MB_MODE_READONLY);
	if(FLAME_job_offer_message_board_write == 1 &&
		FLAME_job_offer_message_board_read == 1)
			rc = MB_SetAccessMode(b_job_offer, MB_MODE_READWRITE);
	#ifdef ERRCHECK
	if (rc != MB_SUCCESS)
	{
	   fprintf(stderr, "ERROR: Could not set access mode of 'job_offer' board\n");
	   switch(rc) {
		   case MB_ERR_INVALID:
			   fprintf(stderr, "\t reason: 'job_offer' board is invalid\n");
			   break;
		   case MB_ERR_LOCKED:
			   fprintf(stderr, "\t reason: 'job_offer' board is locked\n");
			   break;
		   case MB_ERR_MEMALLOC:
			   fprintf(stderr, "\t reason: out of memory\n");
			   break;
		   case MB_ERR_INTERNAL:
			   fprintf(stderr, "\t reason: internal error. Recompile libmoard in debug mode for more info \n");
			   break;
		   default:
			   fprintf(stderr, "\t MB_SyncStart returned error code: %d (see libmboard docs for details)\n", rc);
			   break;
	   }
		   
		   exit(rc);
	}
	#endif
	FLAME_job_offer2_message_board_write = 0;
	FLAME_job_offer2_message_board_read = 0;
	/* Sending agents */
	if(Firm_start_Firm_state->agents != NULL) FLAME_job_offer2_message_board_write = 1;
	
	/* Reading agents */
	if(Household_start_Household_state->agents != NULL) FLAME_job_offer2_message_board_read = 1;
	
	/* Call message board library with details */
	if(FLAME_job_offer2_message_board_write == 0 &&
		FLAME_job_offer2_message_board_read == 0)
			rc = MB_SetAccessMode(b_job_offer2, MB_MODE_IDLE);
	if(FLAME_job_offer2_message_board_write == 1 &&
		FLAME_job_offer2_message_board_read == 0)
			rc = MB_SetAccessMode(b_job_offer2, MB_MODE_WRITEONLY);
	if(FLAME_job_offer2_message_board_write == 0 &&
		FLAME_job_offer2_message_board_read == 1)
			rc = MB_SetAccessMode(b_job_offer2, MB_MODE_READONLY);
	if(FLAME_job_offer2_message_board_write == 1 &&
		FLAME_job_offer2_message_board_read == 1)
			rc = MB_SetAccessMode(b_job_offer2, MB_MODE_READWRITE);
	#ifdef ERRCHECK
	if (rc != MB_SUCCESS)
	{
	   fprintf(stderr, "ERROR: Could not set access mode of 'job_offer2' board\n");
	   switch(rc) {
		   case MB_ERR_INVALID:
			   fprintf(stderr, "\t reason: 'job_offer2' board is invalid\n");
			   break;
		   case MB_ERR_LOCKED:
			   fprintf(stderr, "\t reason: 'job_offer2' board is locked\n");
			   break;
		   case MB_ERR_MEMALLOC:
			   fprintf(stderr, "\t reason: out of memory\n");
			   break;
		   case MB_ERR_INTERNAL:
			   fprintf(stderr, "\t reason: internal error. Recompile libmoard in debug mode for more info \n");
			   break;
		   default:
			   fprintf(stderr, "\t MB_SyncStart returned error code: %d (see libmboard docs for details)\n", rc);
			   break;
	   }
		   
		   exit(rc);
	}
	#endif
	FLAME_job_acceptance_message_board_write = 0;
	FLAME_job_acceptance_message_board_read = 0;
	/* Sending agents */
	if(Household_start_Household_state->agents != NULL) FLAME_job_acceptance_message_board_write = 1;
	
	/* Reading agents */
	if(Firm_start_Firm_state->agents != NULL) FLAME_job_acceptance_message_board_read = 1;
	
	/* Call message board library with details */
	if(FLAME_job_acceptance_message_board_write == 0 &&
		FLAME_job_acceptance_message_board_read == 0)
			rc = MB_SetAccessMode(b_job_acceptance, MB_MODE_IDLE);
	if(FLAME_job_acceptance_message_board_write == 1 &&
		FLAME_job_acceptance_message_board_read == 0)
			rc = MB_SetAccessMode(b_job_acceptance, MB_MODE_WRITEONLY);
	if(FLAME_job_acceptance_message_board_write == 0 &&
		FLAME_job_acceptance_message_board_read == 1)
			rc = MB_SetAccessMode(b_job_acceptance, MB_MODE_READONLY);
	if(FLAME_job_acceptance_message_board_write == 1 &&
		FLAME_job_acceptance_message_board_read == 1)
			rc = MB_SetAccessMode(b_job_acceptance, MB_MODE_READWRITE);
	#ifdef ERRCHECK
	if (rc != MB_SUCCESS)
	{
	   fprintf(stderr, "ERROR: Could not set access mode of 'job_acceptance' board\n");
	   switch(rc) {
		   case MB_ERR_INVALID:
			   fprintf(stderr, "\t reason: 'job_acceptance' board is invalid\n");
			   break;
		   case MB_ERR_LOCKED:
			   fprintf(stderr, "\t reason: 'job_acceptance' board is locked\n");
			   break;
		   case MB_ERR_MEMALLOC:
			   fprintf(stderr, "\t reason: out of memory\n");
			   break;
		   case MB_ERR_INTERNAL:
			   fprintf(stderr, "\t reason: internal error. Recompile libmoard in debug mode for more info \n");
			   break;
		   default:
			   fprintf(stderr, "\t MB_SyncStart returned error code: %d (see libmboard docs for details)\n", rc);
			   break;
	   }
		   
		   exit(rc);
	}
	#endif
	FLAME_job_acceptance2_message_board_write = 0;
	FLAME_job_acceptance2_message_board_read = 0;
	/* Sending agents */
	if(Household_start_Household_state->agents != NULL) FLAME_job_acceptance2_message_board_write = 1;
	
	/* Reading agents */
	if(Firm_start_Firm_state->agents != NULL) FLAME_job_acceptance2_message_board_read = 1;
	
	/* Call message board library with details */
	if(FLAME_job_acceptance2_message_board_write == 0 &&
		FLAME_job_acceptance2_message_board_read == 0)
			rc = MB_SetAccessMode(b_job_acceptance2, MB_MODE_IDLE);
	if(FLAME_job_acceptance2_message_board_write == 1 &&
		FLAME_job_acceptance2_message_board_read == 0)
			rc = MB_SetAccessMode(b_job_acceptance2, MB_MODE_WRITEONLY);
	if(FLAME_job_acceptance2_message_board_write == 0 &&
		FLAME_job_acceptance2_message_board_read == 1)
			rc = MB_SetAccessMode(b_job_acceptance2, MB_MODE_READONLY);
	if(FLAME_job_acceptance2_message_board_write == 1 &&
		FLAME_job_acceptance2_message_board_read == 1)
			rc = MB_SetAccessMode(b_job_acceptance2, MB_MODE_READWRITE);
	#ifdef ERRCHECK
	if (rc != MB_SUCCESS)
	{
	   fprintf(stderr, "ERROR: Could not set access mode of 'job_acceptance2' board\n");
	   switch(rc) {
		   case MB_ERR_INVALID:
			   fprintf(stderr, "\t reason: 'job_acceptance2' board is invalid\n");
			   break;
		   case MB_ERR_LOCKED:
			   fprintf(stderr, "\t reason: 'job_acceptance2' board is locked\n");
			   break;
		   case MB_ERR_MEMALLOC:
			   fprintf(stderr, "\t reason: out of memory\n");
			   break;
		   case MB_ERR_INTERNAL:
			   fprintf(stderr, "\t reason: internal error. Recompile libmoard in debug mode for more info \n");
			   break;
		   default:
			   fprintf(stderr, "\t MB_SyncStart returned error code: %d (see libmboard docs for details)\n", rc);
			   break;
	   }
		   
		   exit(rc);
	}
	#endif
	FLAME_quitting_message_board_write = 0;
	FLAME_quitting_message_board_read = 0;
	/* Sending agents */
	if(Household_start_Household_state->agents != NULL) FLAME_quitting_message_board_write = 1;
	
	/* Reading agents */
	if(Firm_start_Firm_state->agents != NULL) FLAME_quitting_message_board_read = 1;
	
	/* Call message board library with details */
	if(FLAME_quitting_message_board_write == 0 &&
		FLAME_quitting_message_board_read == 0)
			rc = MB_SetAccessMode(b_quitting, MB_MODE_IDLE);
	if(FLAME_quitting_message_board_write == 1 &&
		FLAME_quitting_message_board_read == 0)
			rc = MB_SetAccessMode(b_quitting, MB_MODE_WRITEONLY);
	if(FLAME_quitting_message_board_write == 0 &&
		FLAME_quitting_message_board_read == 1)
			rc = MB_SetAccessMode(b_quitting, MB_MODE_READONLY);
	if(FLAME_quitting_message_board_write == 1 &&
		FLAME_quitting_message_board_read == 1)
			rc = MB_SetAccessMode(b_quitting, MB_MODE_READWRITE);
	#ifdef ERRCHECK
	if (rc != MB_SUCCESS)
	{
	   fprintf(stderr, "ERROR: Could not set access mode of 'quitting' board\n");
	   switch(rc) {
		   case MB_ERR_INVALID:
			   fprintf(stderr, "\t reason: 'quitting' board is invalid\n");
			   break;
		   case MB_ERR_LOCKED:
			   fprintf(stderr, "\t reason: 'quitting' board is locked\n");
			   break;
		   case MB_ERR_MEMALLOC:
			   fprintf(stderr, "\t reason: out of memory\n");
			   break;
		   case MB_ERR_INTERNAL:
			   fprintf(stderr, "\t reason: internal error. Recompile libmoard in debug mode for more info \n");
			   break;
		   default:
			   fprintf(stderr, "\t MB_SyncStart returned error code: %d (see libmboard docs for details)\n", rc);
			   break;
	   }
		   
		   exit(rc);
	}
	#endif
	FLAME_quitting2_message_board_write = 0;
	FLAME_quitting2_message_board_read = 0;
	/* Sending agents */
	if(Household_start_Household_state->agents != NULL) FLAME_quitting2_message_board_write = 1;
	
	/* Reading agents */
	if(Firm_start_Firm_state->agents != NULL) FLAME_quitting2_message_board_read = 1;
	
	/* Call message board library with details */
	if(FLAME_quitting2_message_board_write == 0 &&
		FLAME_quitting2_message_board_read == 0)
			rc = MB_SetAccessMode(b_quitting2, MB_MODE_IDLE);
	if(FLAME_quitting2_message_board_write == 1 &&
		FLAME_quitting2_message_board_read == 0)
			rc = MB_SetAccessMode(b_quitting2, MB_MODE_WRITEONLY);
	if(FLAME_quitting2_message_board_write == 0 &&
		FLAME_quitting2_message_board_read == 1)
			rc = MB_SetAccessMode(b_quitting2, MB_MODE_READONLY);
	if(FLAME_quitting2_message_board_write == 1 &&
		FLAME_quitting2_message_board_read == 1)
			rc = MB_SetAccessMode(b_quitting2, MB_MODE_READWRITE);
	#ifdef ERRCHECK
	if (rc != MB_SUCCESS)
	{
	   fprintf(stderr, "ERROR: Could not set access mode of 'quitting2' board\n");
	   switch(rc) {
		   case MB_ERR_INVALID:
			   fprintf(stderr, "\t reason: 'quitting2' board is invalid\n");
			   break;
		   case MB_ERR_LOCKED:
			   fprintf(stderr, "\t reason: 'quitting2' board is locked\n");
			   break;
		   case MB_ERR_MEMALLOC:
			   fprintf(stderr, "\t reason: out of memory\n");
			   break;
		   case MB_ERR_INTERNAL:
			   fprintf(stderr, "\t reason: internal error. Recompile libmoard in debug mode for more info \n");
			   break;
		   default:
			   fprintf(stderr, "\t MB_SyncStart returned error code: %d (see libmboard docs for details)\n", rc);
			   break;
	   }
		   
		   exit(rc);
	}
	#endif
	FLAME_unemployment_notification_message_board_write = 0;
	FLAME_unemployment_notification_message_board_read = 0;
	/* Sending agents */
	if(Household_start_Household_state->agents != NULL) FLAME_unemployment_notification_message_board_write = 1;
	
	/* Reading agents */
	if(Government_start_Government_state->agents != NULL) FLAME_unemployment_notification_message_board_read = 1;
	
	/* Call message board library with details */
	if(FLAME_unemployment_notification_message_board_write == 0 &&
		FLAME_unemployment_notification_message_board_read == 0)
			rc = MB_SetAccessMode(b_unemployment_notification, MB_MODE_IDLE);
	if(FLAME_unemployment_notification_message_board_write == 1 &&
		FLAME_unemployment_notification_message_board_read == 0)
			rc = MB_SetAccessMode(b_unemployment_notification, MB_MODE_WRITEONLY);
	if(FLAME_unemployment_notification_message_board_write == 0 &&
		FLAME_unemployment_notification_message_board_read == 1)
			rc = MB_SetAccessMode(b_unemployment_notification, MB_MODE_READONLY);
	if(FLAME_unemployment_notification_message_board_write == 1 &&
		FLAME_unemployment_notification_message_board_read == 1)
			rc = MB_SetAccessMode(b_unemployment_notification, MB_MODE_READWRITE);
	#ifdef ERRCHECK
	if (rc != MB_SUCCESS)
	{
	   fprintf(stderr, "ERROR: Could not set access mode of 'unemployment_notification' board\n");
	   switch(rc) {
		   case MB_ERR_INVALID:
			   fprintf(stderr, "\t reason: 'unemployment_notification' board is invalid\n");
			   break;
		   case MB_ERR_LOCKED:
			   fprintf(stderr, "\t reason: 'unemployment_notification' board is locked\n");
			   break;
		   case MB_ERR_MEMALLOC:
			   fprintf(stderr, "\t reason: out of memory\n");
			   break;
		   case MB_ERR_INTERNAL:
			   fprintf(stderr, "\t reason: internal error. Recompile libmoard in debug mode for more info \n");
			   break;
		   default:
			   fprintf(stderr, "\t MB_SyncStart returned error code: %d (see libmboard docs for details)\n", rc);
			   break;
	   }
		   
		   exit(rc);
	}
	#endif
	FLAME_policy_announcement_message_board_write = 0;
	FLAME_policy_announcement_message_board_read = 0;
	/* Sending agents */
	if(Government_start_Government_state->agents != NULL) FLAME_policy_announcement_message_board_write = 1;
	
	/* Reading agents */
	if(Firm_start_Firm_state->agents != NULL) FLAME_policy_announcement_message_board_read = 1;
	if(Household_start_Household_state->agents != NULL) FLAME_policy_announcement_message_board_read = 1;
	if(IGFirm_IGFirm_start_state->agents != NULL) FLAME_policy_announcement_message_board_read = 1;
	if(Bank_start_Bank_state->agents != NULL) FLAME_policy_announcement_message_board_read = 1;
	
	/* Call message board library with details */
	if(FLAME_policy_announcement_message_board_write == 0 &&
		FLAME_policy_announcement_message_board_read == 0)
			rc = MB_SetAccessMode(b_policy_announcement, MB_MODE_IDLE);
	if(FLAME_policy_announcement_message_board_write == 1 &&
		FLAME_policy_announcement_message_board_read == 0)
			rc = MB_SetAccessMode(b_policy_announcement, MB_MODE_WRITEONLY);
	if(FLAME_policy_announcement_message_board_write == 0 &&
		FLAME_policy_announcement_message_board_read == 1)
			rc = MB_SetAccessMode(b_policy_announcement, MB_MODE_READONLY);
	if(FLAME_policy_announcement_message_board_write == 1 &&
		FLAME_policy_announcement_message_board_read == 1)
			rc = MB_SetAccessMode(b_policy_announcement, MB_MODE_READWRITE);
	#ifdef ERRCHECK
	if (rc != MB_SUCCESS)
	{
	   fprintf(stderr, "ERROR: Could not set access mode of 'policy_announcement' board\n");
	   switch(rc) {
		   case MB_ERR_INVALID:
			   fprintf(stderr, "\t reason: 'policy_announcement' board is invalid\n");
			   break;
		   case MB_ERR_LOCKED:
			   fprintf(stderr, "\t reason: 'policy_announcement' board is locked\n");
			   break;
		   case MB_ERR_MEMALLOC:
			   fprintf(stderr, "\t reason: out of memory\n");
			   break;
		   case MB_ERR_INTERNAL:
			   fprintf(stderr, "\t reason: internal error. Recompile libmoard in debug mode for more info \n");
			   break;
		   default:
			   fprintf(stderr, "\t MB_SyncStart returned error code: %d (see libmboard docs for details)\n", rc);
			   break;
	   }
		   
		   exit(rc);
	}
	#endif
	FLAME_tax_payment_message_board_write = 0;
	FLAME_tax_payment_message_board_read = 0;
	/* Sending agents */
	if(Firm_start_Firm_state->agents != NULL) FLAME_tax_payment_message_board_write = 1;
	if(Household_start_Household_state->agents != NULL) FLAME_tax_payment_message_board_write = 1;
	if(IGFirm_IGFirm_start_state->agents != NULL) FLAME_tax_payment_message_board_write = 1;
	if(Bank_start_Bank_state->agents != NULL) FLAME_tax_payment_message_board_write = 1;
	
	/* Reading agents */
	if(Government_start_Government_state->agents != NULL) FLAME_tax_payment_message_board_read = 1;
	
	/* Call message board library with details */
	if(FLAME_tax_payment_message_board_write == 0 &&
		FLAME_tax_payment_message_board_read == 0)
			rc = MB_SetAccessMode(b_tax_payment, MB_MODE_IDLE);
	if(FLAME_tax_payment_message_board_write == 1 &&
		FLAME_tax_payment_message_board_read == 0)
			rc = MB_SetAccessMode(b_tax_payment, MB_MODE_WRITEONLY);
	if(FLAME_tax_payment_message_board_write == 0 &&
		FLAME_tax_payment_message_board_read == 1)
			rc = MB_SetAccessMode(b_tax_payment, MB_MODE_READONLY);
	if(FLAME_tax_payment_message_board_write == 1 &&
		FLAME_tax_payment_message_board_read == 1)
			rc = MB_SetAccessMode(b_tax_payment, MB_MODE_READWRITE);
	#ifdef ERRCHECK
	if (rc != MB_SUCCESS)
	{
	   fprintf(stderr, "ERROR: Could not set access mode of 'tax_payment' board\n");
	   switch(rc) {
		   case MB_ERR_INVALID:
			   fprintf(stderr, "\t reason: 'tax_payment' board is invalid\n");
			   break;
		   case MB_ERR_LOCKED:
			   fprintf(stderr, "\t reason: 'tax_payment' board is locked\n");
			   break;
		   case MB_ERR_MEMALLOC:
			   fprintf(stderr, "\t reason: out of memory\n");
			   break;
		   case MB_ERR_INTERNAL:
			   fprintf(stderr, "\t reason: internal error. Recompile libmoard in debug mode for more info \n");
			   break;
		   default:
			   fprintf(stderr, "\t MB_SyncStart returned error code: %d (see libmboard docs for details)\n", rc);
			   break;
	   }
		   
		   exit(rc);
	}
	#endif
	FLAME_unemployment_benefit_restitution_message_board_write = 0;
	FLAME_unemployment_benefit_restitution_message_board_read = 0;
	/* Sending agents */
	if(Household_start_Household_state->agents != NULL) FLAME_unemployment_benefit_restitution_message_board_write = 1;
	
	/* Reading agents */
	if(Government_start_Government_state->agents != NULL) FLAME_unemployment_benefit_restitution_message_board_read = 1;
	
	/* Call message board library with details */
	if(FLAME_unemployment_benefit_restitution_message_board_write == 0 &&
		FLAME_unemployment_benefit_restitution_message_board_read == 0)
			rc = MB_SetAccessMode(b_unemployment_benefit_restitution, MB_MODE_IDLE);
	if(FLAME_unemployment_benefit_restitution_message_board_write == 1 &&
		FLAME_unemployment_benefit_restitution_message_board_read == 0)
			rc = MB_SetAccessMode(b_unemployment_benefit_restitution, MB_MODE_WRITEONLY);
	if(FLAME_unemployment_benefit_restitution_message_board_write == 0 &&
		FLAME_unemployment_benefit_restitution_message_board_read == 1)
			rc = MB_SetAccessMode(b_unemployment_benefit_restitution, MB_MODE_READONLY);
	if(FLAME_unemployment_benefit_restitution_message_board_write == 1 &&
		FLAME_unemployment_benefit_restitution_message_board_read == 1)
			rc = MB_SetAccessMode(b_unemployment_benefit_restitution, MB_MODE_READWRITE);
	#ifdef ERRCHECK
	if (rc != MB_SUCCESS)
	{
	   fprintf(stderr, "ERROR: Could not set access mode of 'unemployment_benefit_restitution' board\n");
	   switch(rc) {
		   case MB_ERR_INVALID:
			   fprintf(stderr, "\t reason: 'unemployment_benefit_restitution' board is invalid\n");
			   break;
		   case MB_ERR_LOCKED:
			   fprintf(stderr, "\t reason: 'unemployment_benefit_restitution' board is locked\n");
			   break;
		   case MB_ERR_MEMALLOC:
			   fprintf(stderr, "\t reason: out of memory\n");
			   break;
		   case MB_ERR_INTERNAL:
			   fprintf(stderr, "\t reason: internal error. Recompile libmoard in debug mode for more info \n");
			   break;
		   default:
			   fprintf(stderr, "\t MB_SyncStart returned error code: %d (see libmboard docs for details)\n", rc);
			   break;
	   }
		   
		   exit(rc);
	}
	#endif
	FLAME_hh_transfer_notification_message_board_write = 0;
	FLAME_hh_transfer_notification_message_board_read = 0;
	/* Sending agents */
	if(Household_start_Household_state->agents != NULL) FLAME_hh_transfer_notification_message_board_write = 1;
	
	/* Reading agents */
	if(Government_start_Government_state->agents != NULL) FLAME_hh_transfer_notification_message_board_read = 1;
	
	/* Call message board library with details */
	if(FLAME_hh_transfer_notification_message_board_write == 0 &&
		FLAME_hh_transfer_notification_message_board_read == 0)
			rc = MB_SetAccessMode(b_hh_transfer_notification, MB_MODE_IDLE);
	if(FLAME_hh_transfer_notification_message_board_write == 1 &&
		FLAME_hh_transfer_notification_message_board_read == 0)
			rc = MB_SetAccessMode(b_hh_transfer_notification, MB_MODE_WRITEONLY);
	if(FLAME_hh_transfer_notification_message_board_write == 0 &&
		FLAME_hh_transfer_notification_message_board_read == 1)
			rc = MB_SetAccessMode(b_hh_transfer_notification, MB_MODE_READONLY);
	if(FLAME_hh_transfer_notification_message_board_write == 1 &&
		FLAME_hh_transfer_notification_message_board_read == 1)
			rc = MB_SetAccessMode(b_hh_transfer_notification, MB_MODE_READWRITE);
	#ifdef ERRCHECK
	if (rc != MB_SUCCESS)
	{
	   fprintf(stderr, "ERROR: Could not set access mode of 'hh_transfer_notification' board\n");
	   switch(rc) {
		   case MB_ERR_INVALID:
			   fprintf(stderr, "\t reason: 'hh_transfer_notification' board is invalid\n");
			   break;
		   case MB_ERR_LOCKED:
			   fprintf(stderr, "\t reason: 'hh_transfer_notification' board is locked\n");
			   break;
		   case MB_ERR_MEMALLOC:
			   fprintf(stderr, "\t reason: out of memory\n");
			   break;
		   case MB_ERR_INTERNAL:
			   fprintf(stderr, "\t reason: internal error. Recompile libmoard in debug mode for more info \n");
			   break;
		   default:
			   fprintf(stderr, "\t MB_SyncStart returned error code: %d (see libmboard docs for details)\n", rc);
			   break;
	   }
		   
		   exit(rc);
	}
	#endif
	FLAME_hh_subsidy_notification_message_board_write = 0;
	FLAME_hh_subsidy_notification_message_board_read = 0;
	/* Sending agents */
	if(Household_start_Household_state->agents != NULL) FLAME_hh_subsidy_notification_message_board_write = 1;
	
	/* Reading agents */
	if(Government_start_Government_state->agents != NULL) FLAME_hh_subsidy_notification_message_board_read = 1;
	
	/* Call message board library with details */
	if(FLAME_hh_subsidy_notification_message_board_write == 0 &&
		FLAME_hh_subsidy_notification_message_board_read == 0)
			rc = MB_SetAccessMode(b_hh_subsidy_notification, MB_MODE_IDLE);
	if(FLAME_hh_subsidy_notification_message_board_write == 1 &&
		FLAME_hh_subsidy_notification_message_board_read == 0)
			rc = MB_SetAccessMode(b_hh_subsidy_notification, MB_MODE_WRITEONLY);
	if(FLAME_hh_subsidy_notification_message_board_write == 0 &&
		FLAME_hh_subsidy_notification_message_board_read == 1)
			rc = MB_SetAccessMode(b_hh_subsidy_notification, MB_MODE_READONLY);
	if(FLAME_hh_subsidy_notification_message_board_write == 1 &&
		FLAME_hh_subsidy_notification_message_board_read == 1)
			rc = MB_SetAccessMode(b_hh_subsidy_notification, MB_MODE_READWRITE);
	#ifdef ERRCHECK
	if (rc != MB_SUCCESS)
	{
	   fprintf(stderr, "ERROR: Could not set access mode of 'hh_subsidy_notification' board\n");
	   switch(rc) {
		   case MB_ERR_INVALID:
			   fprintf(stderr, "\t reason: 'hh_subsidy_notification' board is invalid\n");
			   break;
		   case MB_ERR_LOCKED:
			   fprintf(stderr, "\t reason: 'hh_subsidy_notification' board is locked\n");
			   break;
		   case MB_ERR_MEMALLOC:
			   fprintf(stderr, "\t reason: out of memory\n");
			   break;
		   case MB_ERR_INTERNAL:
			   fprintf(stderr, "\t reason: internal error. Recompile libmoard in debug mode for more info \n");
			   break;
		   default:
			   fprintf(stderr, "\t MB_SyncStart returned error code: %d (see libmboard docs for details)\n", rc);
			   break;
	   }
		   
		   exit(rc);
	}
	#endif
	FLAME_human_capital_policy_announcement_message_board_write = 0;
	FLAME_human_capital_policy_announcement_message_board_read = 0;
	/* Sending agents */
	if(Government_start_Government_state->agents != NULL) FLAME_human_capital_policy_announcement_message_board_write = 1;
	
	/* Reading agents */
	if(Household_start_Household_state->agents != NULL) FLAME_human_capital_policy_announcement_message_board_read = 1;
	
	/* Call message board library with details */
	if(FLAME_human_capital_policy_announcement_message_board_write == 0 &&
		FLAME_human_capital_policy_announcement_message_board_read == 0)
			rc = MB_SetAccessMode(b_human_capital_policy_announcement, MB_MODE_IDLE);
	if(FLAME_human_capital_policy_announcement_message_board_write == 1 &&
		FLAME_human_capital_policy_announcement_message_board_read == 0)
			rc = MB_SetAccessMode(b_human_capital_policy_announcement, MB_MODE_WRITEONLY);
	if(FLAME_human_capital_policy_announcement_message_board_write == 0 &&
		FLAME_human_capital_policy_announcement_message_board_read == 1)
			rc = MB_SetAccessMode(b_human_capital_policy_announcement, MB_MODE_READONLY);
	if(FLAME_human_capital_policy_announcement_message_board_write == 1 &&
		FLAME_human_capital_policy_announcement_message_board_read == 1)
			rc = MB_SetAccessMode(b_human_capital_policy_announcement, MB_MODE_READWRITE);
	#ifdef ERRCHECK
	if (rc != MB_SUCCESS)
	{
	   fprintf(stderr, "ERROR: Could not set access mode of 'human_capital_policy_announcement' board\n");
	   switch(rc) {
		   case MB_ERR_INVALID:
			   fprintf(stderr, "\t reason: 'human_capital_policy_announcement' board is invalid\n");
			   break;
		   case MB_ERR_LOCKED:
			   fprintf(stderr, "\t reason: 'human_capital_policy_announcement' board is locked\n");
			   break;
		   case MB_ERR_MEMALLOC:
			   fprintf(stderr, "\t reason: out of memory\n");
			   break;
		   case MB_ERR_INTERNAL:
			   fprintf(stderr, "\t reason: internal error. Recompile libmoard in debug mode for more info \n");
			   break;
		   default:
			   fprintf(stderr, "\t MB_SyncStart returned error code: %d (see libmboard docs for details)\n", rc);
			   break;
	   }
		   
		   exit(rc);
	}
	#endif
	FLAME_firm_transfer_notification_message_board_write = 0;
	FLAME_firm_transfer_notification_message_board_read = 0;
	/* Sending agents */
	if(Firm_start_Firm_state->agents != NULL) FLAME_firm_transfer_notification_message_board_write = 1;
	if(IGFirm_IGFirm_start_state->agents != NULL) FLAME_firm_transfer_notification_message_board_write = 1;
	
	/* Reading agents */
	if(Government_start_Government_state->agents != NULL) FLAME_firm_transfer_notification_message_board_read = 1;
	
	/* Call message board library with details */
	if(FLAME_firm_transfer_notification_message_board_write == 0 &&
		FLAME_firm_transfer_notification_message_board_read == 0)
			rc = MB_SetAccessMode(b_firm_transfer_notification, MB_MODE_IDLE);
	if(FLAME_firm_transfer_notification_message_board_write == 1 &&
		FLAME_firm_transfer_notification_message_board_read == 0)
			rc = MB_SetAccessMode(b_firm_transfer_notification, MB_MODE_WRITEONLY);
	if(FLAME_firm_transfer_notification_message_board_write == 0 &&
		FLAME_firm_transfer_notification_message_board_read == 1)
			rc = MB_SetAccessMode(b_firm_transfer_notification, MB_MODE_READONLY);
	if(FLAME_firm_transfer_notification_message_board_write == 1 &&
		FLAME_firm_transfer_notification_message_board_read == 1)
			rc = MB_SetAccessMode(b_firm_transfer_notification, MB_MODE_READWRITE);
	#ifdef ERRCHECK
	if (rc != MB_SUCCESS)
	{
	   fprintf(stderr, "ERROR: Could not set access mode of 'firm_transfer_notification' board\n");
	   switch(rc) {
		   case MB_ERR_INVALID:
			   fprintf(stderr, "\t reason: 'firm_transfer_notification' board is invalid\n");
			   break;
		   case MB_ERR_LOCKED:
			   fprintf(stderr, "\t reason: 'firm_transfer_notification' board is locked\n");
			   break;
		   case MB_ERR_MEMALLOC:
			   fprintf(stderr, "\t reason: out of memory\n");
			   break;
		   case MB_ERR_INTERNAL:
			   fprintf(stderr, "\t reason: internal error. Recompile libmoard in debug mode for more info \n");
			   break;
		   default:
			   fprintf(stderr, "\t MB_SyncStart returned error code: %d (see libmboard docs for details)\n", rc);
			   break;
	   }
		   
		   exit(rc);
	}
	#endif
	FLAME_firm_subsidy_notification_message_board_write = 0;
	FLAME_firm_subsidy_notification_message_board_read = 0;
	/* Sending agents */
	if(Firm_start_Firm_state->agents != NULL) FLAME_firm_subsidy_notification_message_board_write = 1;
	if(IGFirm_IGFirm_start_state->agents != NULL) FLAME_firm_subsidy_notification_message_board_write = 1;
	
	/* Reading agents */
	if(Government_start_Government_state->agents != NULL) FLAME_firm_subsidy_notification_message_board_read = 1;
	
	/* Call message board library with details */
	if(FLAME_firm_subsidy_notification_message_board_write == 0 &&
		FLAME_firm_subsidy_notification_message_board_read == 0)
			rc = MB_SetAccessMode(b_firm_subsidy_notification, MB_MODE_IDLE);
	if(FLAME_firm_subsidy_notification_message_board_write == 1 &&
		FLAME_firm_subsidy_notification_message_board_read == 0)
			rc = MB_SetAccessMode(b_firm_subsidy_notification, MB_MODE_WRITEONLY);
	if(FLAME_firm_subsidy_notification_message_board_write == 0 &&
		FLAME_firm_subsidy_notification_message_board_read == 1)
			rc = MB_SetAccessMode(b_firm_subsidy_notification, MB_MODE_READONLY);
	if(FLAME_firm_subsidy_notification_message_board_write == 1 &&
		FLAME_firm_subsidy_notification_message_board_read == 1)
			rc = MB_SetAccessMode(b_firm_subsidy_notification, MB_MODE_READWRITE);
	#ifdef ERRCHECK
	if (rc != MB_SUCCESS)
	{
	   fprintf(stderr, "ERROR: Could not set access mode of 'firm_subsidy_notification' board\n");
	   switch(rc) {
		   case MB_ERR_INVALID:
			   fprintf(stderr, "\t reason: 'firm_subsidy_notification' board is invalid\n");
			   break;
		   case MB_ERR_LOCKED:
			   fprintf(stderr, "\t reason: 'firm_subsidy_notification' board is locked\n");
			   break;
		   case MB_ERR_MEMALLOC:
			   fprintf(stderr, "\t reason: out of memory\n");
			   break;
		   case MB_ERR_INTERNAL:
			   fprintf(stderr, "\t reason: internal error. Recompile libmoard in debug mode for more info \n");
			   break;
		   default:
			   fprintf(stderr, "\t MB_SyncStart returned error code: %d (see libmboard docs for details)\n", rc);
			   break;
	   }
		   
		   exit(rc);
	}
	#endif
	FLAME_request_fiat_money_message_board_write = 0;
	FLAME_request_fiat_money_message_board_read = 0;
	/* Sending agents */
	if(Government_start_Government_state->agents != NULL) FLAME_request_fiat_money_message_board_write = 1;
	
	/* Reading agents */
	if(CentralBank_start_Central_Bank_state->agents != NULL) FLAME_request_fiat_money_message_board_read = 1;
	
	/* Call message board library with details */
	if(FLAME_request_fiat_money_message_board_write == 0 &&
		FLAME_request_fiat_money_message_board_read == 0)
			rc = MB_SetAccessMode(b_request_fiat_money, MB_MODE_IDLE);
	if(FLAME_request_fiat_money_message_board_write == 1 &&
		FLAME_request_fiat_money_message_board_read == 0)
			rc = MB_SetAccessMode(b_request_fiat_money, MB_MODE_WRITEONLY);
	if(FLAME_request_fiat_money_message_board_write == 0 &&
		FLAME_request_fiat_money_message_board_read == 1)
			rc = MB_SetAccessMode(b_request_fiat_money, MB_MODE_READONLY);
	if(FLAME_request_fiat_money_message_board_write == 1 &&
		FLAME_request_fiat_money_message_board_read == 1)
			rc = MB_SetAccessMode(b_request_fiat_money, MB_MODE_READWRITE);
	#ifdef ERRCHECK
	if (rc != MB_SUCCESS)
	{
	   fprintf(stderr, "ERROR: Could not set access mode of 'request_fiat_money' board\n");
	   switch(rc) {
		   case MB_ERR_INVALID:
			   fprintf(stderr, "\t reason: 'request_fiat_money' board is invalid\n");
			   break;
		   case MB_ERR_LOCKED:
			   fprintf(stderr, "\t reason: 'request_fiat_money' board is locked\n");
			   break;
		   case MB_ERR_MEMALLOC:
			   fprintf(stderr, "\t reason: out of memory\n");
			   break;
		   case MB_ERR_INTERNAL:
			   fprintf(stderr, "\t reason: internal error. Recompile libmoard in debug mode for more info \n");
			   break;
		   default:
			   fprintf(stderr, "\t MB_SyncStart returned error code: %d (see libmboard docs for details)\n", rc);
			   break;
	   }
		   
		   exit(rc);
	}
	#endif
	FLAME_human_capital_policy_general_skill_information_message_board_write = 0;
	FLAME_human_capital_policy_general_skill_information_message_board_read = 0;
	/* Sending agents */
	if(Household_start_Household_state->agents != NULL) FLAME_human_capital_policy_general_skill_information_message_board_write = 1;
	
	/* Reading agents */
	if(Government_start_Government_state->agents != NULL) FLAME_human_capital_policy_general_skill_information_message_board_read = 1;
	
	/* Call message board library with details */
	if(FLAME_human_capital_policy_general_skill_information_message_board_write == 0 &&
		FLAME_human_capital_policy_general_skill_information_message_board_read == 0)
			rc = MB_SetAccessMode(b_human_capital_policy_general_skill_information, MB_MODE_IDLE);
	if(FLAME_human_capital_policy_general_skill_information_message_board_write == 1 &&
		FLAME_human_capital_policy_general_skill_information_message_board_read == 0)
			rc = MB_SetAccessMode(b_human_capital_policy_general_skill_information, MB_MODE_WRITEONLY);
	if(FLAME_human_capital_policy_general_skill_information_message_board_write == 0 &&
		FLAME_human_capital_policy_general_skill_information_message_board_read == 1)
			rc = MB_SetAccessMode(b_human_capital_policy_general_skill_information, MB_MODE_READONLY);
	if(FLAME_human_capital_policy_general_skill_information_message_board_write == 1 &&
		FLAME_human_capital_policy_general_skill_information_message_board_read == 1)
			rc = MB_SetAccessMode(b_human_capital_policy_general_skill_information, MB_MODE_READWRITE);
	#ifdef ERRCHECK
	if (rc != MB_SUCCESS)
	{
	   fprintf(stderr, "ERROR: Could not set access mode of 'human_capital_policy_general_skill_information' board\n");
	   switch(rc) {
		   case MB_ERR_INVALID:
			   fprintf(stderr, "\t reason: 'human_capital_policy_general_skill_information' board is invalid\n");
			   break;
		   case MB_ERR_LOCKED:
			   fprintf(stderr, "\t reason: 'human_capital_policy_general_skill_information' board is locked\n");
			   break;
		   case MB_ERR_MEMALLOC:
			   fprintf(stderr, "\t reason: out of memory\n");
			   break;
		   case MB_ERR_INTERNAL:
			   fprintf(stderr, "\t reason: internal error. Recompile libmoard in debug mode for more info \n");
			   break;
		   default:
			   fprintf(stderr, "\t MB_SyncStart returned error code: %d (see libmboard docs for details)\n", rc);
			   break;
	   }
		   
		   exit(rc);
	}
	#endif
	FLAME_human_capital_policy_new_general_skill_notification_message_board_write = 0;
	FLAME_human_capital_policy_new_general_skill_notification_message_board_read = 0;
	/* Sending agents */
	if(Government_start_Government_state->agents != NULL) FLAME_human_capital_policy_new_general_skill_notification_message_board_write = 1;
	
	/* Reading agents */
	if(Household_start_Household_state->agents != NULL) FLAME_human_capital_policy_new_general_skill_notification_message_board_read = 1;
	
	/* Call message board library with details */
	if(FLAME_human_capital_policy_new_general_skill_notification_message_board_write == 0 &&
		FLAME_human_capital_policy_new_general_skill_notification_message_board_read == 0)
			rc = MB_SetAccessMode(b_human_capital_policy_new_general_skill_notification, MB_MODE_IDLE);
	if(FLAME_human_capital_policy_new_general_skill_notification_message_board_write == 1 &&
		FLAME_human_capital_policy_new_general_skill_notification_message_board_read == 0)
			rc = MB_SetAccessMode(b_human_capital_policy_new_general_skill_notification, MB_MODE_WRITEONLY);
	if(FLAME_human_capital_policy_new_general_skill_notification_message_board_write == 0 &&
		FLAME_human_capital_policy_new_general_skill_notification_message_board_read == 1)
			rc = MB_SetAccessMode(b_human_capital_policy_new_general_skill_notification, MB_MODE_READONLY);
	if(FLAME_human_capital_policy_new_general_skill_notification_message_board_write == 1 &&
		FLAME_human_capital_policy_new_general_skill_notification_message_board_read == 1)
			rc = MB_SetAccessMode(b_human_capital_policy_new_general_skill_notification, MB_MODE_READWRITE);
	#ifdef ERRCHECK
	if (rc != MB_SUCCESS)
	{
	   fprintf(stderr, "ERROR: Could not set access mode of 'human_capital_policy_new_general_skill_notification' board\n");
	   switch(rc) {
		   case MB_ERR_INVALID:
			   fprintf(stderr, "\t reason: 'human_capital_policy_new_general_skill_notification' board is invalid\n");
			   break;
		   case MB_ERR_LOCKED:
			   fprintf(stderr, "\t reason: 'human_capital_policy_new_general_skill_notification' board is locked\n");
			   break;
		   case MB_ERR_MEMALLOC:
			   fprintf(stderr, "\t reason: out of memory\n");
			   break;
		   case MB_ERR_INTERNAL:
			   fprintf(stderr, "\t reason: internal error. Recompile libmoard in debug mode for more info \n");
			   break;
		   default:
			   fprintf(stderr, "\t MB_SyncStart returned error code: %d (see libmboard docs for details)\n", rc);
			   break;
	   }
		   
		   exit(rc);
	}
	#endif
	FLAME_firm_send_data_message_board_write = 0;
	FLAME_firm_send_data_message_board_read = 0;
	/* Sending agents */
	if(Firm_start_Firm_state->agents != NULL) FLAME_firm_send_data_message_board_write = 1;
	if(IGFirm_IGFirm_start_state->agents != NULL) FLAME_firm_send_data_message_board_write = 1;
	
	/* Reading agents */
	if(Eurostat_start_Eurostat_state->agents != NULL) FLAME_firm_send_data_message_board_read = 1;
	
	/* Call message board library with details */
	if(FLAME_firm_send_data_message_board_write == 0 &&
		FLAME_firm_send_data_message_board_read == 0)
			rc = MB_SetAccessMode(b_firm_send_data, MB_MODE_IDLE);
	if(FLAME_firm_send_data_message_board_write == 1 &&
		FLAME_firm_send_data_message_board_read == 0)
			rc = MB_SetAccessMode(b_firm_send_data, MB_MODE_WRITEONLY);
	if(FLAME_firm_send_data_message_board_write == 0 &&
		FLAME_firm_send_data_message_board_read == 1)
			rc = MB_SetAccessMode(b_firm_send_data, MB_MODE_READONLY);
	if(FLAME_firm_send_data_message_board_write == 1 &&
		FLAME_firm_send_data_message_board_read == 1)
			rc = MB_SetAccessMode(b_firm_send_data, MB_MODE_READWRITE);
	#ifdef ERRCHECK
	if (rc != MB_SUCCESS)
	{
	   fprintf(stderr, "ERROR: Could not set access mode of 'firm_send_data' board\n");
	   switch(rc) {
		   case MB_ERR_INVALID:
			   fprintf(stderr, "\t reason: 'firm_send_data' board is invalid\n");
			   break;
		   case MB_ERR_LOCKED:
			   fprintf(stderr, "\t reason: 'firm_send_data' board is locked\n");
			   break;
		   case MB_ERR_MEMALLOC:
			   fprintf(stderr, "\t reason: out of memory\n");
			   break;
		   case MB_ERR_INTERNAL:
			   fprintf(stderr, "\t reason: internal error. Recompile libmoard in debug mode for more info \n");
			   break;
		   default:
			   fprintf(stderr, "\t MB_SyncStart returned error code: %d (see libmboard docs for details)\n", rc);
			   break;
	   }
		   
		   exit(rc);
	}
	#endif
	FLAME_government_send_data_message_board_write = 0;
	FLAME_government_send_data_message_board_read = 0;
	/* Sending agents */
	if(Government_start_Government_state->agents != NULL) FLAME_government_send_data_message_board_write = 1;
	
	/* Reading agents */
	if(Eurostat_start_Eurostat_state->agents != NULL) FLAME_government_send_data_message_board_read = 1;
	
	/* Call message board library with details */
	if(FLAME_government_send_data_message_board_write == 0 &&
		FLAME_government_send_data_message_board_read == 0)
			rc = MB_SetAccessMode(b_government_send_data, MB_MODE_IDLE);
	if(FLAME_government_send_data_message_board_write == 1 &&
		FLAME_government_send_data_message_board_read == 0)
			rc = MB_SetAccessMode(b_government_send_data, MB_MODE_WRITEONLY);
	if(FLAME_government_send_data_message_board_write == 0 &&
		FLAME_government_send_data_message_board_read == 1)
			rc = MB_SetAccessMode(b_government_send_data, MB_MODE_READONLY);
	if(FLAME_government_send_data_message_board_write == 1 &&
		FLAME_government_send_data_message_board_read == 1)
			rc = MB_SetAccessMode(b_government_send_data, MB_MODE_READWRITE);
	#ifdef ERRCHECK
	if (rc != MB_SUCCESS)
	{
	   fprintf(stderr, "ERROR: Could not set access mode of 'government_send_data' board\n");
	   switch(rc) {
		   case MB_ERR_INVALID:
			   fprintf(stderr, "\t reason: 'government_send_data' board is invalid\n");
			   break;
		   case MB_ERR_LOCKED:
			   fprintf(stderr, "\t reason: 'government_send_data' board is locked\n");
			   break;
		   case MB_ERR_MEMALLOC:
			   fprintf(stderr, "\t reason: out of memory\n");
			   break;
		   case MB_ERR_INTERNAL:
			   fprintf(stderr, "\t reason: internal error. Recompile libmoard in debug mode for more info \n");
			   break;
		   default:
			   fprintf(stderr, "\t MB_SyncStart returned error code: %d (see libmboard docs for details)\n", rc);
			   break;
	   }
		   
		   exit(rc);
	}
	#endif
	FLAME_household_send_data_message_board_write = 0;
	FLAME_household_send_data_message_board_read = 0;
	/* Sending agents */
	if(Household_start_Household_state->agents != NULL) FLAME_household_send_data_message_board_write = 1;
	
	/* Reading agents */
	if(Eurostat_start_Eurostat_state->agents != NULL) FLAME_household_send_data_message_board_read = 1;
	
	/* Call message board library with details */
	if(FLAME_household_send_data_message_board_write == 0 &&
		FLAME_household_send_data_message_board_read == 0)
			rc = MB_SetAccessMode(b_household_send_data, MB_MODE_IDLE);
	if(FLAME_household_send_data_message_board_write == 1 &&
		FLAME_household_send_data_message_board_read == 0)
			rc = MB_SetAccessMode(b_household_send_data, MB_MODE_WRITEONLY);
	if(FLAME_household_send_data_message_board_write == 0 &&
		FLAME_household_send_data_message_board_read == 1)
			rc = MB_SetAccessMode(b_household_send_data, MB_MODE_READONLY);
	if(FLAME_household_send_data_message_board_write == 1 &&
		FLAME_household_send_data_message_board_read == 1)
			rc = MB_SetAccessMode(b_household_send_data, MB_MODE_READWRITE);
	#ifdef ERRCHECK
	if (rc != MB_SUCCESS)
	{
	   fprintf(stderr, "ERROR: Could not set access mode of 'household_send_data' board\n");
	   switch(rc) {
		   case MB_ERR_INVALID:
			   fprintf(stderr, "\t reason: 'household_send_data' board is invalid\n");
			   break;
		   case MB_ERR_LOCKED:
			   fprintf(stderr, "\t reason: 'household_send_data' board is locked\n");
			   break;
		   case MB_ERR_MEMALLOC:
			   fprintf(stderr, "\t reason: out of memory\n");
			   break;
		   case MB_ERR_INTERNAL:
			   fprintf(stderr, "\t reason: internal error. Recompile libmoard in debug mode for more info \n");
			   break;
		   default:
			   fprintf(stderr, "\t MB_SyncStart returned error code: %d (see libmboard docs for details)\n", rc);
			   break;
	   }
		   
		   exit(rc);
	}
	#endif
	FLAME_mall_data_message_board_write = 0;
	FLAME_mall_data_message_board_read = 0;
	/* Sending agents */
	if(Mall_start_Mall_state->agents != NULL) FLAME_mall_data_message_board_write = 1;
	
	/* Reading agents */
	if(Eurostat_start_Eurostat_state->agents != NULL) FLAME_mall_data_message_board_read = 1;
	
	/* Call message board library with details */
	if(FLAME_mall_data_message_board_write == 0 &&
		FLAME_mall_data_message_board_read == 0)
			rc = MB_SetAccessMode(b_mall_data, MB_MODE_IDLE);
	if(FLAME_mall_data_message_board_write == 1 &&
		FLAME_mall_data_message_board_read == 0)
			rc = MB_SetAccessMode(b_mall_data, MB_MODE_WRITEONLY);
	if(FLAME_mall_data_message_board_write == 0 &&
		FLAME_mall_data_message_board_read == 1)
			rc = MB_SetAccessMode(b_mall_data, MB_MODE_READONLY);
	if(FLAME_mall_data_message_board_write == 1 &&
		FLAME_mall_data_message_board_read == 1)
			rc = MB_SetAccessMode(b_mall_data, MB_MODE_READWRITE);
	#ifdef ERRCHECK
	if (rc != MB_SUCCESS)
	{
	   fprintf(stderr, "ERROR: Could not set access mode of 'mall_data' board\n");
	   switch(rc) {
		   case MB_ERR_INVALID:
			   fprintf(stderr, "\t reason: 'mall_data' board is invalid\n");
			   break;
		   case MB_ERR_LOCKED:
			   fprintf(stderr, "\t reason: 'mall_data' board is locked\n");
			   break;
		   case MB_ERR_MEMALLOC:
			   fprintf(stderr, "\t reason: out of memory\n");
			   break;
		   case MB_ERR_INTERNAL:
			   fprintf(stderr, "\t reason: internal error. Recompile libmoard in debug mode for more info \n");
			   break;
		   default:
			   fprintf(stderr, "\t MB_SyncStart returned error code: %d (see libmboard docs for details)\n", rc);
			   break;
	   }
		   
		   exit(rc);
	}
	#endif
	FLAME_eurostat_send_specific_skills_message_board_write = 0;
	FLAME_eurostat_send_specific_skills_message_board_read = 0;
	/* Sending agents */
	if(Eurostat_start_Eurostat_state->agents != NULL) FLAME_eurostat_send_specific_skills_message_board_write = 1;
	
	/* Reading agents */
	if(Firm_start_Firm_state->agents != NULL) FLAME_eurostat_send_specific_skills_message_board_read = 1;
	if(IGFirm_IGFirm_start_state->agents != NULL) FLAME_eurostat_send_specific_skills_message_board_read = 1;
	
	/* Call message board library with details */
	if(FLAME_eurostat_send_specific_skills_message_board_write == 0 &&
		FLAME_eurostat_send_specific_skills_message_board_read == 0)
			rc = MB_SetAccessMode(b_eurostat_send_specific_skills, MB_MODE_IDLE);
	if(FLAME_eurostat_send_specific_skills_message_board_write == 1 &&
		FLAME_eurostat_send_specific_skills_message_board_read == 0)
			rc = MB_SetAccessMode(b_eurostat_send_specific_skills, MB_MODE_WRITEONLY);
	if(FLAME_eurostat_send_specific_skills_message_board_write == 0 &&
		FLAME_eurostat_send_specific_skills_message_board_read == 1)
			rc = MB_SetAccessMode(b_eurostat_send_specific_skills, MB_MODE_READONLY);
	if(FLAME_eurostat_send_specific_skills_message_board_write == 1 &&
		FLAME_eurostat_send_specific_skills_message_board_read == 1)
			rc = MB_SetAccessMode(b_eurostat_send_specific_skills, MB_MODE_READWRITE);
	#ifdef ERRCHECK
	if (rc != MB_SUCCESS)
	{
	   fprintf(stderr, "ERROR: Could not set access mode of 'eurostat_send_specific_skills' board\n");
	   switch(rc) {
		   case MB_ERR_INVALID:
			   fprintf(stderr, "\t reason: 'eurostat_send_specific_skills' board is invalid\n");
			   break;
		   case MB_ERR_LOCKED:
			   fprintf(stderr, "\t reason: 'eurostat_send_specific_skills' board is locked\n");
			   break;
		   case MB_ERR_MEMALLOC:
			   fprintf(stderr, "\t reason: out of memory\n");
			   break;
		   case MB_ERR_INTERNAL:
			   fprintf(stderr, "\t reason: internal error. Recompile libmoard in debug mode for more info \n");
			   break;
		   default:
			   fprintf(stderr, "\t MB_SyncStart returned error code: %d (see libmboard docs for details)\n", rc);
			   break;
	   }
		   
		   exit(rc);
	}
	#endif
	FLAME_data_for_government_message_board_write = 0;
	FLAME_data_for_government_message_board_read = 0;
	/* Sending agents */
	if(Eurostat_start_Eurostat_state->agents != NULL) FLAME_data_for_government_message_board_write = 1;
	
	/* Reading agents */
	if(Household_start_Household_state->agents != NULL) FLAME_data_for_government_message_board_read = 1;
	if(Government_start_Government_state->agents != NULL) FLAME_data_for_government_message_board_read = 1;
	
	/* Call message board library with details */
	if(FLAME_data_for_government_message_board_write == 0 &&
		FLAME_data_for_government_message_board_read == 0)
			rc = MB_SetAccessMode(b_data_for_government, MB_MODE_IDLE);
	if(FLAME_data_for_government_message_board_write == 1 &&
		FLAME_data_for_government_message_board_read == 0)
			rc = MB_SetAccessMode(b_data_for_government, MB_MODE_WRITEONLY);
	if(FLAME_data_for_government_message_board_write == 0 &&
		FLAME_data_for_government_message_board_read == 1)
			rc = MB_SetAccessMode(b_data_for_government, MB_MODE_READONLY);
	if(FLAME_data_for_government_message_board_write == 1 &&
		FLAME_data_for_government_message_board_read == 1)
			rc = MB_SetAccessMode(b_data_for_government, MB_MODE_READWRITE);
	#ifdef ERRCHECK
	if (rc != MB_SUCCESS)
	{
	   fprintf(stderr, "ERROR: Could not set access mode of 'data_for_government' board\n");
	   switch(rc) {
		   case MB_ERR_INVALID:
			   fprintf(stderr, "\t reason: 'data_for_government' board is invalid\n");
			   break;
		   case MB_ERR_LOCKED:
			   fprintf(stderr, "\t reason: 'data_for_government' board is locked\n");
			   break;
		   case MB_ERR_MEMALLOC:
			   fprintf(stderr, "\t reason: out of memory\n");
			   break;
		   case MB_ERR_INTERNAL:
			   fprintf(stderr, "\t reason: internal error. Recompile libmoard in debug mode for more info \n");
			   break;
		   default:
			   fprintf(stderr, "\t MB_SyncStart returned error code: %d (see libmboard docs for details)\n", rc);
			   break;
	   }
		   
		   exit(rc);
	}
	#endif
	FLAME_eurostat_send_macrodata_message_board_write = 0;
	FLAME_eurostat_send_macrodata_message_board_read = 0;
	/* Sending agents */
	if(Eurostat_start_Eurostat_state->agents != NULL) FLAME_eurostat_send_macrodata_message_board_write = 1;
	
	/* Reading agents */
	if(Government_start_Government_state->agents != NULL) FLAME_eurostat_send_macrodata_message_board_read = 1;
	if(CentralBank_start_Central_Bank_state->agents != NULL) FLAME_eurostat_send_macrodata_message_board_read = 1;
	
	/* Call message board library with details */
	if(FLAME_eurostat_send_macrodata_message_board_write == 0 &&
		FLAME_eurostat_send_macrodata_message_board_read == 0)
			rc = MB_SetAccessMode(b_eurostat_send_macrodata, MB_MODE_IDLE);
	if(FLAME_eurostat_send_macrodata_message_board_write == 1 &&
		FLAME_eurostat_send_macrodata_message_board_read == 0)
			rc = MB_SetAccessMode(b_eurostat_send_macrodata, MB_MODE_WRITEONLY);
	if(FLAME_eurostat_send_macrodata_message_board_write == 0 &&
		FLAME_eurostat_send_macrodata_message_board_read == 1)
			rc = MB_SetAccessMode(b_eurostat_send_macrodata, MB_MODE_READONLY);
	if(FLAME_eurostat_send_macrodata_message_board_write == 1 &&
		FLAME_eurostat_send_macrodata_message_board_read == 1)
			rc = MB_SetAccessMode(b_eurostat_send_macrodata, MB_MODE_READWRITE);
	#ifdef ERRCHECK
	if (rc != MB_SUCCESS)
	{
	   fprintf(stderr, "ERROR: Could not set access mode of 'eurostat_send_macrodata' board\n");
	   switch(rc) {
		   case MB_ERR_INVALID:
			   fprintf(stderr, "\t reason: 'eurostat_send_macrodata' board is invalid\n");
			   break;
		   case MB_ERR_LOCKED:
			   fprintf(stderr, "\t reason: 'eurostat_send_macrodata' board is locked\n");
			   break;
		   case MB_ERR_MEMALLOC:
			   fprintf(stderr, "\t reason: out of memory\n");
			   break;
		   case MB_ERR_INTERNAL:
			   fprintf(stderr, "\t reason: internal error. Recompile libmoard in debug mode for more info \n");
			   break;
		   default:
			   fprintf(stderr, "\t MB_SyncStart returned error code: %d (see libmboard docs for details)\n", rc);
			   break;
	   }
		   
		   exit(rc);
	}
	#endif
	FLAME_msg_firm_id_to_malls_message_board_write = 0;
	FLAME_msg_firm_id_to_malls_message_board_read = 0;
	/* Sending agents */
	if(Firm_start_Firm_state->agents != NULL) FLAME_msg_firm_id_to_malls_message_board_write = 1;
	
	/* Reading agents */
	if(Mall_start_Mall_state->agents != NULL) FLAME_msg_firm_id_to_malls_message_board_read = 1;
	
	/* Call message board library with details */
	if(FLAME_msg_firm_id_to_malls_message_board_write == 0 &&
		FLAME_msg_firm_id_to_malls_message_board_read == 0)
			rc = MB_SetAccessMode(b_msg_firm_id_to_malls, MB_MODE_IDLE);
	if(FLAME_msg_firm_id_to_malls_message_board_write == 1 &&
		FLAME_msg_firm_id_to_malls_message_board_read == 0)
			rc = MB_SetAccessMode(b_msg_firm_id_to_malls, MB_MODE_WRITEONLY);
	if(FLAME_msg_firm_id_to_malls_message_board_write == 0 &&
		FLAME_msg_firm_id_to_malls_message_board_read == 1)
			rc = MB_SetAccessMode(b_msg_firm_id_to_malls, MB_MODE_READONLY);
	if(FLAME_msg_firm_id_to_malls_message_board_write == 1 &&
		FLAME_msg_firm_id_to_malls_message_board_read == 1)
			rc = MB_SetAccessMode(b_msg_firm_id_to_malls, MB_MODE_READWRITE);
	#ifdef ERRCHECK
	if (rc != MB_SUCCESS)
	{
	   fprintf(stderr, "ERROR: Could not set access mode of 'msg_firm_id_to_malls' board\n");
	   switch(rc) {
		   case MB_ERR_INVALID:
			   fprintf(stderr, "\t reason: 'msg_firm_id_to_malls' board is invalid\n");
			   break;
		   case MB_ERR_LOCKED:
			   fprintf(stderr, "\t reason: 'msg_firm_id_to_malls' board is locked\n");
			   break;
		   case MB_ERR_MEMALLOC:
			   fprintf(stderr, "\t reason: out of memory\n");
			   break;
		   case MB_ERR_INTERNAL:
			   fprintf(stderr, "\t reason: internal error. Recompile libmoard in debug mode for more info \n");
			   break;
		   default:
			   fprintf(stderr, "\t MB_SyncStart returned error code: %d (see libmboard docs for details)\n", rc);
			   break;
	   }
		   
		   exit(rc);
	}
	#endif
	FLAME_msg_mall_id_to_firms_message_board_write = 0;
	FLAME_msg_mall_id_to_firms_message_board_read = 0;
	/* Sending agents */
	if(Mall_start_Mall_state->agents != NULL) FLAME_msg_mall_id_to_firms_message_board_write = 1;
	
	/* Reading agents */
	if(Firm_start_Firm_state->agents != NULL) FLAME_msg_mall_id_to_firms_message_board_read = 1;
	
	/* Call message board library with details */
	if(FLAME_msg_mall_id_to_firms_message_board_write == 0 &&
		FLAME_msg_mall_id_to_firms_message_board_read == 0)
			rc = MB_SetAccessMode(b_msg_mall_id_to_firms, MB_MODE_IDLE);
	if(FLAME_msg_mall_id_to_firms_message_board_write == 1 &&
		FLAME_msg_mall_id_to_firms_message_board_read == 0)
			rc = MB_SetAccessMode(b_msg_mall_id_to_firms, MB_MODE_WRITEONLY);
	if(FLAME_msg_mall_id_to_firms_message_board_write == 0 &&
		FLAME_msg_mall_id_to_firms_message_board_read == 1)
			rc = MB_SetAccessMode(b_msg_mall_id_to_firms, MB_MODE_READONLY);
	if(FLAME_msg_mall_id_to_firms_message_board_write == 1 &&
		FLAME_msg_mall_id_to_firms_message_board_read == 1)
			rc = MB_SetAccessMode(b_msg_mall_id_to_firms, MB_MODE_READWRITE);
	#ifdef ERRCHECK
	if (rc != MB_SUCCESS)
	{
	   fprintf(stderr, "ERROR: Could not set access mode of 'msg_mall_id_to_firms' board\n");
	   switch(rc) {
		   case MB_ERR_INVALID:
			   fprintf(stderr, "\t reason: 'msg_mall_id_to_firms' board is invalid\n");
			   break;
		   case MB_ERR_LOCKED:
			   fprintf(stderr, "\t reason: 'msg_mall_id_to_firms' board is locked\n");
			   break;
		   case MB_ERR_MEMALLOC:
			   fprintf(stderr, "\t reason: out of memory\n");
			   break;
		   case MB_ERR_INTERNAL:
			   fprintf(stderr, "\t reason: internal error. Recompile libmoard in debug mode for more info \n");
			   break;
		   default:
			   fprintf(stderr, "\t MB_SyncStart returned error code: %d (see libmboard docs for details)\n", rc);
			   break;
	   }
		   
		   exit(rc);
	}
	#endif
	FLAME_msg_skills_eurostat_to_igfirm_message_board_write = 0;
	FLAME_msg_skills_eurostat_to_igfirm_message_board_read = 0;
	/* Sending agents */
	if(Eurostat_start_Eurostat_state->agents != NULL) FLAME_msg_skills_eurostat_to_igfirm_message_board_write = 1;
	
	/* Reading agents */
	if(IGFirm_IGFirm_start_state->agents != NULL) FLAME_msg_skills_eurostat_to_igfirm_message_board_read = 1;
	
	/* Call message board library with details */
	if(FLAME_msg_skills_eurostat_to_igfirm_message_board_write == 0 &&
		FLAME_msg_skills_eurostat_to_igfirm_message_board_read == 0)
			rc = MB_SetAccessMode(b_msg_skills_eurostat_to_igfirm, MB_MODE_IDLE);
	if(FLAME_msg_skills_eurostat_to_igfirm_message_board_write == 1 &&
		FLAME_msg_skills_eurostat_to_igfirm_message_board_read == 0)
			rc = MB_SetAccessMode(b_msg_skills_eurostat_to_igfirm, MB_MODE_WRITEONLY);
	if(FLAME_msg_skills_eurostat_to_igfirm_message_board_write == 0 &&
		FLAME_msg_skills_eurostat_to_igfirm_message_board_read == 1)
			rc = MB_SetAccessMode(b_msg_skills_eurostat_to_igfirm, MB_MODE_READONLY);
	if(FLAME_msg_skills_eurostat_to_igfirm_message_board_write == 1 &&
		FLAME_msg_skills_eurostat_to_igfirm_message_board_read == 1)
			rc = MB_SetAccessMode(b_msg_skills_eurostat_to_igfirm, MB_MODE_READWRITE);
	#ifdef ERRCHECK
	if (rc != MB_SUCCESS)
	{
	   fprintf(stderr, "ERROR: Could not set access mode of 'msg_skills_eurostat_to_igfirm' board\n");
	   switch(rc) {
		   case MB_ERR_INVALID:
			   fprintf(stderr, "\t reason: 'msg_skills_eurostat_to_igfirm' board is invalid\n");
			   break;
		   case MB_ERR_LOCKED:
			   fprintf(stderr, "\t reason: 'msg_skills_eurostat_to_igfirm' board is locked\n");
			   break;
		   case MB_ERR_MEMALLOC:
			   fprintf(stderr, "\t reason: out of memory\n");
			   break;
		   case MB_ERR_INTERNAL:
			   fprintf(stderr, "\t reason: internal error. Recompile libmoard in debug mode for more info \n");
			   break;
		   default:
			   fprintf(stderr, "\t MB_SyncStart returned error code: %d (see libmboard docs for details)\n", rc);
			   break;
	   }
		   
		   exit(rc);
	}
	#endif
	FLAME_msg_market_sizes_message_board_write = 0;
	FLAME_msg_market_sizes_message_board_read = 0;
	/* Sending agents */
	if(Eurostat_start_Eurostat_state->agents != NULL) FLAME_msg_market_sizes_message_board_write = 1;
	
	/* Reading agents */
	if(Firm_start_Firm_state->agents != NULL) FLAME_msg_market_sizes_message_board_read = 1;
	
	/* Call message board library with details */
	if(FLAME_msg_market_sizes_message_board_write == 0 &&
		FLAME_msg_market_sizes_message_board_read == 0)
			rc = MB_SetAccessMode(b_msg_market_sizes, MB_MODE_IDLE);
	if(FLAME_msg_market_sizes_message_board_write == 1 &&
		FLAME_msg_market_sizes_message_board_read == 0)
			rc = MB_SetAccessMode(b_msg_market_sizes, MB_MODE_WRITEONLY);
	if(FLAME_msg_market_sizes_message_board_write == 0 &&
		FLAME_msg_market_sizes_message_board_read == 1)
			rc = MB_SetAccessMode(b_msg_market_sizes, MB_MODE_READONLY);
	if(FLAME_msg_market_sizes_message_board_write == 1 &&
		FLAME_msg_market_sizes_message_board_read == 1)
			rc = MB_SetAccessMode(b_msg_market_sizes, MB_MODE_READWRITE);
	#ifdef ERRCHECK
	if (rc != MB_SUCCESS)
	{
	   fprintf(stderr, "ERROR: Could not set access mode of 'msg_market_sizes' board\n");
	   switch(rc) {
		   case MB_ERR_INVALID:
			   fprintf(stderr, "\t reason: 'msg_market_sizes' board is invalid\n");
			   break;
		   case MB_ERR_LOCKED:
			   fprintf(stderr, "\t reason: 'msg_market_sizes' board is locked\n");
			   break;
		   case MB_ERR_MEMALLOC:
			   fprintf(stderr, "\t reason: out of memory\n");
			   break;
		   case MB_ERR_INTERNAL:
			   fprintf(stderr, "\t reason: internal error. Recompile libmoard in debug mode for more info \n");
			   break;
		   default:
			   fprintf(stderr, "\t MB_SyncStart returned error code: %d (see libmboard docs for details)\n", rc);
			   break;
	   }
		   
		   exit(rc);
	}
	#endif
	FLAME_total_subsidies_message_board_write = 0;
	FLAME_total_subsidies_message_board_read = 0;
	/* Sending agents */
	if(Government_start_Government_state->agents != NULL) FLAME_total_subsidies_message_board_write = 1;
	
	/* Reading agents */
	if(Eurostat_start_Eurostat_state->agents != NULL) FLAME_total_subsidies_message_board_read = 1;
	
	/* Call message board library with details */
	if(FLAME_total_subsidies_message_board_write == 0 &&
		FLAME_total_subsidies_message_board_read == 0)
			rc = MB_SetAccessMode(b_total_subsidies, MB_MODE_IDLE);
	if(FLAME_total_subsidies_message_board_write == 1 &&
		FLAME_total_subsidies_message_board_read == 0)
			rc = MB_SetAccessMode(b_total_subsidies, MB_MODE_WRITEONLY);
	if(FLAME_total_subsidies_message_board_write == 0 &&
		FLAME_total_subsidies_message_board_read == 1)
			rc = MB_SetAccessMode(b_total_subsidies, MB_MODE_READONLY);
	if(FLAME_total_subsidies_message_board_write == 1 &&
		FLAME_total_subsidies_message_board_read == 1)
			rc = MB_SetAccessMode(b_total_subsidies, MB_MODE_READWRITE);
	#ifdef ERRCHECK
	if (rc != MB_SUCCESS)
	{
	   fprintf(stderr, "ERROR: Could not set access mode of 'total_subsidies' board\n");
	   switch(rc) {
		   case MB_ERR_INVALID:
			   fprintf(stderr, "\t reason: 'total_subsidies' board is invalid\n");
			   break;
		   case MB_ERR_LOCKED:
			   fprintf(stderr, "\t reason: 'total_subsidies' board is locked\n");
			   break;
		   case MB_ERR_MEMALLOC:
			   fprintf(stderr, "\t reason: out of memory\n");
			   break;
		   case MB_ERR_INTERNAL:
			   fprintf(stderr, "\t reason: internal error. Recompile libmoard in debug mode for more info \n");
			   break;
		   default:
			   fprintf(stderr, "\t MB_SyncStart returned error code: %d (see libmboard docs for details)\n", rc);
			   break;
	   }
		   
		   exit(rc);
	}
	#endif
	FLAME_redistributed_subsidies_message_board_write = 0;
	FLAME_redistributed_subsidies_message_board_read = 0;
	/* Sending agents */
	if(Eurostat_start_Eurostat_state->agents != NULL) FLAME_redistributed_subsidies_message_board_write = 1;
	
	/* Reading agents */
	if(Government_start_Government_state->agents != NULL) FLAME_redistributed_subsidies_message_board_read = 1;
	
	/* Call message board library with details */
	if(FLAME_redistributed_subsidies_message_board_write == 0 &&
		FLAME_redistributed_subsidies_message_board_read == 0)
			rc = MB_SetAccessMode(b_redistributed_subsidies, MB_MODE_IDLE);
	if(FLAME_redistributed_subsidies_message_board_write == 1 &&
		FLAME_redistributed_subsidies_message_board_read == 0)
			rc = MB_SetAccessMode(b_redistributed_subsidies, MB_MODE_WRITEONLY);
	if(FLAME_redistributed_subsidies_message_board_write == 0 &&
		FLAME_redistributed_subsidies_message_board_read == 1)
			rc = MB_SetAccessMode(b_redistributed_subsidies, MB_MODE_READONLY);
	if(FLAME_redistributed_subsidies_message_board_write == 1 &&
		FLAME_redistributed_subsidies_message_board_read == 1)
			rc = MB_SetAccessMode(b_redistributed_subsidies, MB_MODE_READWRITE);
	#ifdef ERRCHECK
	if (rc != MB_SUCCESS)
	{
	   fprintf(stderr, "ERROR: Could not set access mode of 'redistributed_subsidies' board\n");
	   switch(rc) {
		   case MB_ERR_INVALID:
			   fprintf(stderr, "\t reason: 'redistributed_subsidies' board is invalid\n");
			   break;
		   case MB_ERR_LOCKED:
			   fprintf(stderr, "\t reason: 'redistributed_subsidies' board is locked\n");
			   break;
		   case MB_ERR_MEMALLOC:
			   fprintf(stderr, "\t reason: out of memory\n");
			   break;
		   case MB_ERR_INTERNAL:
			   fprintf(stderr, "\t reason: internal error. Recompile libmoard in debug mode for more info \n");
			   break;
		   default:
			   fprintf(stderr, "\t MB_SyncStart returned error code: %d (see libmboard docs for details)\n", rc);
			   break;
	   }
		   
		   exit(rc);
	}
	#endif
	FLAME_quality_price_message_board_write = 0;
	FLAME_quality_price_message_board_read = 0;
	/* Sending agents */
	if(Eurostat_start_Eurostat_state->agents != NULL) FLAME_quality_price_message_board_write = 1;
	
	/* Reading agents */
	if(Firm_start_Firm_state->agents != NULL) FLAME_quality_price_message_board_read = 1;
	
	/* Call message board library with details */
	if(FLAME_quality_price_message_board_write == 0 &&
		FLAME_quality_price_message_board_read == 0)
			rc = MB_SetAccessMode(b_quality_price, MB_MODE_IDLE);
	if(FLAME_quality_price_message_board_write == 1 &&
		FLAME_quality_price_message_board_read == 0)
			rc = MB_SetAccessMode(b_quality_price, MB_MODE_WRITEONLY);
	if(FLAME_quality_price_message_board_write == 0 &&
		FLAME_quality_price_message_board_read == 1)
			rc = MB_SetAccessMode(b_quality_price, MB_MODE_READONLY);
	if(FLAME_quality_price_message_board_write == 1 &&
		FLAME_quality_price_message_board_read == 1)
			rc = MB_SetAccessMode(b_quality_price, MB_MODE_READWRITE);
	#ifdef ERRCHECK
	if (rc != MB_SUCCESS)
	{
	   fprintf(stderr, "ERROR: Could not set access mode of 'quality_price' board\n");
	   switch(rc) {
		   case MB_ERR_INVALID:
			   fprintf(stderr, "\t reason: 'quality_price' board is invalid\n");
			   break;
		   case MB_ERR_LOCKED:
			   fprintf(stderr, "\t reason: 'quality_price' board is locked\n");
			   break;
		   case MB_ERR_MEMALLOC:
			   fprintf(stderr, "\t reason: out of memory\n");
			   break;
		   case MB_ERR_INTERNAL:
			   fprintf(stderr, "\t reason: internal error. Recompile libmoard in debug mode for more info \n");
			   break;
		   default:
			   fprintf(stderr, "\t MB_SyncStart returned error code: %d (see libmboard docs for details)\n", rc);
			   break;
	   }
		   
		   exit(rc);
	}
	#endif
	FLAME_interview_request_message_board_write = 0;
	FLAME_interview_request_message_board_read = 0;
	/* Sending agents */
	if(Firm_start_Firm_state->agents != NULL) FLAME_interview_request_message_board_write = 1;
	
	/* Reading agents */
	if(Household_start_Household_state->agents != NULL) FLAME_interview_request_message_board_read = 1;
	
	/* Call message board library with details */
	if(FLAME_interview_request_message_board_write == 0 &&
		FLAME_interview_request_message_board_read == 0)
			rc = MB_SetAccessMode(b_interview_request, MB_MODE_IDLE);
	if(FLAME_interview_request_message_board_write == 1 &&
		FLAME_interview_request_message_board_read == 0)
			rc = MB_SetAccessMode(b_interview_request, MB_MODE_WRITEONLY);
	if(FLAME_interview_request_message_board_write == 0 &&
		FLAME_interview_request_message_board_read == 1)
			rc = MB_SetAccessMode(b_interview_request, MB_MODE_READONLY);
	if(FLAME_interview_request_message_board_write == 1 &&
		FLAME_interview_request_message_board_read == 1)
			rc = MB_SetAccessMode(b_interview_request, MB_MODE_READWRITE);
	#ifdef ERRCHECK
	if (rc != MB_SUCCESS)
	{
	   fprintf(stderr, "ERROR: Could not set access mode of 'interview_request' board\n");
	   switch(rc) {
		   case MB_ERR_INVALID:
			   fprintf(stderr, "\t reason: 'interview_request' board is invalid\n");
			   break;
		   case MB_ERR_LOCKED:
			   fprintf(stderr, "\t reason: 'interview_request' board is locked\n");
			   break;
		   case MB_ERR_MEMALLOC:
			   fprintf(stderr, "\t reason: out of memory\n");
			   break;
		   case MB_ERR_INTERNAL:
			   fprintf(stderr, "\t reason: internal error. Recompile libmoard in debug mode for more info \n");
			   break;
		   default:
			   fprintf(stderr, "\t MB_SyncStart returned error code: %d (see libmboard docs for details)\n", rc);
			   break;
	   }
		   
		   exit(rc);
	}
	#endif
	FLAME_interview_positive_response_message_board_write = 0;
	FLAME_interview_positive_response_message_board_read = 0;
	/* Sending agents */
	if(Household_start_Household_state->agents != NULL) FLAME_interview_positive_response_message_board_write = 1;
	
	/* Reading agents */
	if(Firm_start_Firm_state->agents != NULL) FLAME_interview_positive_response_message_board_read = 1;
	
	/* Call message board library with details */
	if(FLAME_interview_positive_response_message_board_write == 0 &&
		FLAME_interview_positive_response_message_board_read == 0)
			rc = MB_SetAccessMode(b_interview_positive_response, MB_MODE_IDLE);
	if(FLAME_interview_positive_response_message_board_write == 1 &&
		FLAME_interview_positive_response_message_board_read == 0)
			rc = MB_SetAccessMode(b_interview_positive_response, MB_MODE_WRITEONLY);
	if(FLAME_interview_positive_response_message_board_write == 0 &&
		FLAME_interview_positive_response_message_board_read == 1)
			rc = MB_SetAccessMode(b_interview_positive_response, MB_MODE_READONLY);
	if(FLAME_interview_positive_response_message_board_write == 1 &&
		FLAME_interview_positive_response_message_board_read == 1)
			rc = MB_SetAccessMode(b_interview_positive_response, MB_MODE_READWRITE);
	#ifdef ERRCHECK
	if (rc != MB_SUCCESS)
	{
	   fprintf(stderr, "ERROR: Could not set access mode of 'interview_positive_response' board\n");
	   switch(rc) {
		   case MB_ERR_INVALID:
			   fprintf(stderr, "\t reason: 'interview_positive_response' board is invalid\n");
			   break;
		   case MB_ERR_LOCKED:
			   fprintf(stderr, "\t reason: 'interview_positive_response' board is locked\n");
			   break;
		   case MB_ERR_MEMALLOC:
			   fprintf(stderr, "\t reason: out of memory\n");
			   break;
		   case MB_ERR_INTERNAL:
			   fprintf(stderr, "\t reason: internal error. Recompile libmoard in debug mode for more info \n");
			   break;
		   default:
			   fprintf(stderr, "\t MB_SyncStart returned error code: %d (see libmboard docs for details)\n", rc);
			   break;
	   }
		   
		   exit(rc);
	}
	#endif
	FLAME_questionnaire_innovation_message_board_write = 0;
	FLAME_questionnaire_innovation_message_board_read = 0;
	/* Sending agents */
	if(Firm_start_Firm_state->agents != NULL) FLAME_questionnaire_innovation_message_board_write = 1;
	
	/* Reading agents */
	if(Household_start_Household_state->agents != NULL) FLAME_questionnaire_innovation_message_board_read = 1;
	
	/* Call message board library with details */
	if(FLAME_questionnaire_innovation_message_board_write == 0 &&
		FLAME_questionnaire_innovation_message_board_read == 0)
			rc = MB_SetAccessMode(b_questionnaire_innovation, MB_MODE_IDLE);
	if(FLAME_questionnaire_innovation_message_board_write == 1 &&
		FLAME_questionnaire_innovation_message_board_read == 0)
			rc = MB_SetAccessMode(b_questionnaire_innovation, MB_MODE_WRITEONLY);
	if(FLAME_questionnaire_innovation_message_board_write == 0 &&
		FLAME_questionnaire_innovation_message_board_read == 1)
			rc = MB_SetAccessMode(b_questionnaire_innovation, MB_MODE_READONLY);
	if(FLAME_questionnaire_innovation_message_board_write == 1 &&
		FLAME_questionnaire_innovation_message_board_read == 1)
			rc = MB_SetAccessMode(b_questionnaire_innovation, MB_MODE_READWRITE);
	#ifdef ERRCHECK
	if (rc != MB_SUCCESS)
	{
	   fprintf(stderr, "ERROR: Could not set access mode of 'questionnaire_innovation' board\n");
	   switch(rc) {
		   case MB_ERR_INVALID:
			   fprintf(stderr, "\t reason: 'questionnaire_innovation' board is invalid\n");
			   break;
		   case MB_ERR_LOCKED:
			   fprintf(stderr, "\t reason: 'questionnaire_innovation' board is locked\n");
			   break;
		   case MB_ERR_MEMALLOC:
			   fprintf(stderr, "\t reason: out of memory\n");
			   break;
		   case MB_ERR_INTERNAL:
			   fprintf(stderr, "\t reason: internal error. Recompile libmoard in debug mode for more info \n");
			   break;
		   default:
			   fprintf(stderr, "\t MB_SyncStart returned error code: %d (see libmboard docs for details)\n", rc);
			   break;
	   }
		   
		   exit(rc);
	}
	#endif
	FLAME_filled_out_questionnaire_product_innovation_message_board_write = 0;
	FLAME_filled_out_questionnaire_product_innovation_message_board_read = 0;
	/* Sending agents */
	if(Household_start_Household_state->agents != NULL) FLAME_filled_out_questionnaire_product_innovation_message_board_write = 1;
	
	/* Reading agents */
	if(Firm_start_Firm_state->agents != NULL) FLAME_filled_out_questionnaire_product_innovation_message_board_read = 1;
	
	/* Call message board library with details */
	if(FLAME_filled_out_questionnaire_product_innovation_message_board_write == 0 &&
		FLAME_filled_out_questionnaire_product_innovation_message_board_read == 0)
			rc = MB_SetAccessMode(b_filled_out_questionnaire_product_innovation, MB_MODE_IDLE);
	if(FLAME_filled_out_questionnaire_product_innovation_message_board_write == 1 &&
		FLAME_filled_out_questionnaire_product_innovation_message_board_read == 0)
			rc = MB_SetAccessMode(b_filled_out_questionnaire_product_innovation, MB_MODE_WRITEONLY);
	if(FLAME_filled_out_questionnaire_product_innovation_message_board_write == 0 &&
		FLAME_filled_out_questionnaire_product_innovation_message_board_read == 1)
			rc = MB_SetAccessMode(b_filled_out_questionnaire_product_innovation, MB_MODE_READONLY);
	if(FLAME_filled_out_questionnaire_product_innovation_message_board_write == 1 &&
		FLAME_filled_out_questionnaire_product_innovation_message_board_read == 1)
			rc = MB_SetAccessMode(b_filled_out_questionnaire_product_innovation, MB_MODE_READWRITE);
	#ifdef ERRCHECK
	if (rc != MB_SUCCESS)
	{
	   fprintf(stderr, "ERROR: Could not set access mode of 'filled_out_questionnaire_product_innovation' board\n");
	   switch(rc) {
		   case MB_ERR_INVALID:
			   fprintf(stderr, "\t reason: 'filled_out_questionnaire_product_innovation' board is invalid\n");
			   break;
		   case MB_ERR_LOCKED:
			   fprintf(stderr, "\t reason: 'filled_out_questionnaire_product_innovation' board is locked\n");
			   break;
		   case MB_ERR_MEMALLOC:
			   fprintf(stderr, "\t reason: out of memory\n");
			   break;
		   case MB_ERR_INTERNAL:
			   fprintf(stderr, "\t reason: internal error. Recompile libmoard in debug mode for more info \n");
			   break;
		   default:
			   fprintf(stderr, "\t MB_SyncStart returned error code: %d (see libmboard docs for details)\n", rc);
			   break;
	   }
		   
		   exit(rc);
	}
	#endif
	
	
	/* Start timing */
	start = get_time();

	for(iteration_loop=iteration_number+1; iteration_loop < iteration_number+iteration_total+1; iteration_loop++)
	{
		interval = get_time();

		/* Print out iteration number */
		
		fprintf(stdout, "Iteration - %d\n", iteration_loop);
		(void)fflush(stdout);
        
		/* START OF ITERATION */
		
		/* Start sync message boards that don't write */
		if(FLAME_bank_account_update_message_board_write == 0)
		{
			/*printf("%d> bank_account_update message board sync start early as no agents sending any messages of this type\n", node_number);*/
			
			/* ********** sync message board here **********  */
			if(FLAME_TEST_PRINT_START_AND_END_OF_LIBMBOARD_CALLS) printf("start MB_SyncStart(b_bank_account_update)\n");
			rc = MB_SyncStart(b_bank_account_update);
			if(FLAME_TEST_PRINT_START_AND_END_OF_LIBMBOARD_CALLS) printf("finish MB_SyncStart(b_bank_account_update)\n");
			#ifdef ERRCHECK
			if (rc != MB_SUCCESS)
			{
			   fprintf(stderr, "ERROR: Could not start sync of 'bank_account_update' board\n");
			   switch(rc) {
				   case MB_ERR_INVALID:
					   fprintf(stderr, "\t reason: 'bank_account_update' board is invalid\n");
					   break;
				   case MB_ERR_LOCKED:
					   fprintf(stderr, "\t reason: 'bank_account_update' board is locked\n");
					   break;
				   case MB_ERR_MEMALLOC:
					   fprintf(stderr, "\t reason: out of memory\n");
					   break;
				   case MB_ERR_INTERNAL:
					   fprintf(stderr, "\t reason: internal error. Recompile libmoard in debug mode for more info \n");
					   break;
				   default:
					   fprintf(stderr, "\t MB_SyncStart returned error code: %d (see libmboard docs for details)\n", rc);
					   break;
			   }
			   
					   
					   exit(rc);
			   }
			   #endif
		}
		
		/* Start sync message boards that don't write */
		if(FLAME_bank_to_central_bank_account_update_message_board_write == 0)
		{
			/*printf("%d> bank_to_central_bank_account_update message board sync start early as no agents sending any messages of this type\n", node_number);*/
			
			/* ********** sync message board here **********  */
			if(FLAME_TEST_PRINT_START_AND_END_OF_LIBMBOARD_CALLS) printf("start MB_SyncStart(b_bank_to_central_bank_account_update)\n");
			rc = MB_SyncStart(b_bank_to_central_bank_account_update);
			if(FLAME_TEST_PRINT_START_AND_END_OF_LIBMBOARD_CALLS) printf("finish MB_SyncStart(b_bank_to_central_bank_account_update)\n");
			#ifdef ERRCHECK
			if (rc != MB_SUCCESS)
			{
			   fprintf(stderr, "ERROR: Could not start sync of 'bank_to_central_bank_account_update' board\n");
			   switch(rc) {
				   case MB_ERR_INVALID:
					   fprintf(stderr, "\t reason: 'bank_to_central_bank_account_update' board is invalid\n");
					   break;
				   case MB_ERR_LOCKED:
					   fprintf(stderr, "\t reason: 'bank_to_central_bank_account_update' board is locked\n");
					   break;
				   case MB_ERR_MEMALLOC:
					   fprintf(stderr, "\t reason: out of memory\n");
					   break;
				   case MB_ERR_INTERNAL:
					   fprintf(stderr, "\t reason: internal error. Recompile libmoard in debug mode for more info \n");
					   break;
				   default:
					   fprintf(stderr, "\t MB_SyncStart returned error code: %d (see libmboard docs for details)\n", rc);
					   break;
			   }
			   
					   
					   exit(rc);
			   }
			   #endif
		}
		
		/* Start sync message boards that don't write */
		if(FLAME_gov_to_central_bank_account_update_message_board_write == 0)
		{
			/*printf("%d> gov_to_central_bank_account_update message board sync start early as no agents sending any messages of this type\n", node_number);*/
			
			/* ********** sync message board here **********  */
			if(FLAME_TEST_PRINT_START_AND_END_OF_LIBMBOARD_CALLS) printf("start MB_SyncStart(b_gov_to_central_bank_account_update)\n");
			rc = MB_SyncStart(b_gov_to_central_bank_account_update);
			if(FLAME_TEST_PRINT_START_AND_END_OF_LIBMBOARD_CALLS) printf("finish MB_SyncStart(b_gov_to_central_bank_account_update)\n");
			#ifdef ERRCHECK
			if (rc != MB_SUCCESS)
			{
			   fprintf(stderr, "ERROR: Could not start sync of 'gov_to_central_bank_account_update' board\n");
			   switch(rc) {
				   case MB_ERR_INVALID:
					   fprintf(stderr, "\t reason: 'gov_to_central_bank_account_update' board is invalid\n");
					   break;
				   case MB_ERR_LOCKED:
					   fprintf(stderr, "\t reason: 'gov_to_central_bank_account_update' board is locked\n");
					   break;
				   case MB_ERR_MEMALLOC:
					   fprintf(stderr, "\t reason: out of memory\n");
					   break;
				   case MB_ERR_INTERNAL:
					   fprintf(stderr, "\t reason: internal error. Recompile libmoard in debug mode for more info \n");
					   break;
				   default:
					   fprintf(stderr, "\t MB_SyncStart returned error code: %d (see libmboard docs for details)\n", rc);
					   break;
			   }
			   
					   
					   exit(rc);
			   }
			   #endif
		}
		
		/* Start sync message boards that don't write */
		if(FLAME_wage_payment_message_board_write == 0)
		{
			/*printf("%d> wage_payment message board sync start early as no agents sending any messages of this type\n", node_number);*/
			
			/* ********** sync message board here **********  */
			if(FLAME_TEST_PRINT_START_AND_END_OF_LIBMBOARD_CALLS) printf("start MB_SyncStart(b_wage_payment)\n");
			rc = MB_SyncStart(b_wage_payment);
			if(FLAME_TEST_PRINT_START_AND_END_OF_LIBMBOARD_CALLS) printf("finish MB_SyncStart(b_wage_payment)\n");
			#ifdef ERRCHECK
			if (rc != MB_SUCCESS)
			{
			   fprintf(stderr, "ERROR: Could not start sync of 'wage_payment' board\n");
			   switch(rc) {
				   case MB_ERR_INVALID:
					   fprintf(stderr, "\t reason: 'wage_payment' board is invalid\n");
					   break;
				   case MB_ERR_LOCKED:
					   fprintf(stderr, "\t reason: 'wage_payment' board is locked\n");
					   break;
				   case MB_ERR_MEMALLOC:
					   fprintf(stderr, "\t reason: out of memory\n");
					   break;
				   case MB_ERR_INTERNAL:
					   fprintf(stderr, "\t reason: internal error. Recompile libmoard in debug mode for more info \n");
					   break;
				   default:
					   fprintf(stderr, "\t MB_SyncStart returned error code: %d (see libmboard docs for details)\n", rc);
					   break;
			   }
			   
					   
					   exit(rc);
			   }
			   #endif
		}
		
		/* Start sync message boards that don't write */
		if(FLAME_quality_price_info_1_message_board_write == 0)
		{
			/*printf("%d> quality_price_info_1 message board sync start early as no agents sending any messages of this type\n", node_number);*/
			
			/* ********** sync message board here **********  */
			if(FLAME_TEST_PRINT_START_AND_END_OF_LIBMBOARD_CALLS) printf("start MB_SyncStart(b_quality_price_info_1)\n");
			rc = MB_SyncStart(b_quality_price_info_1);
			if(FLAME_TEST_PRINT_START_AND_END_OF_LIBMBOARD_CALLS) printf("finish MB_SyncStart(b_quality_price_info_1)\n");
			#ifdef ERRCHECK
			if (rc != MB_SUCCESS)
			{
			   fprintf(stderr, "ERROR: Could not start sync of 'quality_price_info_1' board\n");
			   switch(rc) {
				   case MB_ERR_INVALID:
					   fprintf(stderr, "\t reason: 'quality_price_info_1' board is invalid\n");
					   break;
				   case MB_ERR_LOCKED:
					   fprintf(stderr, "\t reason: 'quality_price_info_1' board is locked\n");
					   break;
				   case MB_ERR_MEMALLOC:
					   fprintf(stderr, "\t reason: out of memory\n");
					   break;
				   case MB_ERR_INTERNAL:
					   fprintf(stderr, "\t reason: internal error. Recompile libmoard in debug mode for more info \n");
					   break;
				   default:
					   fprintf(stderr, "\t MB_SyncStart returned error code: %d (see libmboard docs for details)\n", rc);
					   break;
			   }
			   
					   
					   exit(rc);
			   }
			   #endif
		}
		
		/* Start sync message boards that don't write */
		if(FLAME_quality_price_info_2_message_board_write == 0)
		{
			/*printf("%d> quality_price_info_2 message board sync start early as no agents sending any messages of this type\n", node_number);*/
			
			/* ********** sync message board here **********  */
			if(FLAME_TEST_PRINT_START_AND_END_OF_LIBMBOARD_CALLS) printf("start MB_SyncStart(b_quality_price_info_2)\n");
			rc = MB_SyncStart(b_quality_price_info_2);
			if(FLAME_TEST_PRINT_START_AND_END_OF_LIBMBOARD_CALLS) printf("finish MB_SyncStart(b_quality_price_info_2)\n");
			#ifdef ERRCHECK
			if (rc != MB_SUCCESS)
			{
			   fprintf(stderr, "ERROR: Could not start sync of 'quality_price_info_2' board\n");
			   switch(rc) {
				   case MB_ERR_INVALID:
					   fprintf(stderr, "\t reason: 'quality_price_info_2' board is invalid\n");
					   break;
				   case MB_ERR_LOCKED:
					   fprintf(stderr, "\t reason: 'quality_price_info_2' board is locked\n");
					   break;
				   case MB_ERR_MEMALLOC:
					   fprintf(stderr, "\t reason: out of memory\n");
					   break;
				   case MB_ERR_INTERNAL:
					   fprintf(stderr, "\t reason: internal error. Recompile libmoard in debug mode for more info \n");
					   break;
				   default:
					   fprintf(stderr, "\t MB_SyncStart returned error code: %d (see libmboard docs for details)\n", rc);
					   break;
			   }
			   
					   
					   exit(rc);
			   }
			   #endif
		}
		
		/* Start sync message boards that don't write */
		if(FLAME_update_mall_stock_message_board_write == 0)
		{
			/*printf("%d> update_mall_stock message board sync start early as no agents sending any messages of this type\n", node_number);*/
			
			/* ********** sync message board here **********  */
			if(FLAME_TEST_PRINT_START_AND_END_OF_LIBMBOARD_CALLS) printf("start MB_SyncStart(b_update_mall_stock)\n");
			rc = MB_SyncStart(b_update_mall_stock);
			if(FLAME_TEST_PRINT_START_AND_END_OF_LIBMBOARD_CALLS) printf("finish MB_SyncStart(b_update_mall_stock)\n");
			#ifdef ERRCHECK
			if (rc != MB_SUCCESS)
			{
			   fprintf(stderr, "ERROR: Could not start sync of 'update_mall_stock' board\n");
			   switch(rc) {
				   case MB_ERR_INVALID:
					   fprintf(stderr, "\t reason: 'update_mall_stock' board is invalid\n");
					   break;
				   case MB_ERR_LOCKED:
					   fprintf(stderr, "\t reason: 'update_mall_stock' board is locked\n");
					   break;
				   case MB_ERR_MEMALLOC:
					   fprintf(stderr, "\t reason: out of memory\n");
					   break;
				   case MB_ERR_INTERNAL:
					   fprintf(stderr, "\t reason: internal error. Recompile libmoard in debug mode for more info \n");
					   break;
				   default:
					   fprintf(stderr, "\t MB_SyncStart returned error code: %d (see libmboard docs for details)\n", rc);
					   break;
			   }
			   
					   
					   exit(rc);
			   }
			   #endif
		}
		
		/* Start sync message boards that don't write */
		if(FLAME_consumption_request_1_message_board_write == 0)
		{
			/*printf("%d> consumption_request_1 message board sync start early as no agents sending any messages of this type\n", node_number);*/
			
			/* ********** sync message board here **********  */
			if(FLAME_TEST_PRINT_START_AND_END_OF_LIBMBOARD_CALLS) printf("start MB_SyncStart(b_consumption_request_1)\n");
			rc = MB_SyncStart(b_consumption_request_1);
			if(FLAME_TEST_PRINT_START_AND_END_OF_LIBMBOARD_CALLS) printf("finish MB_SyncStart(b_consumption_request_1)\n");
			#ifdef ERRCHECK
			if (rc != MB_SUCCESS)
			{
			   fprintf(stderr, "ERROR: Could not start sync of 'consumption_request_1' board\n");
			   switch(rc) {
				   case MB_ERR_INVALID:
					   fprintf(stderr, "\t reason: 'consumption_request_1' board is invalid\n");
					   break;
				   case MB_ERR_LOCKED:
					   fprintf(stderr, "\t reason: 'consumption_request_1' board is locked\n");
					   break;
				   case MB_ERR_MEMALLOC:
					   fprintf(stderr, "\t reason: out of memory\n");
					   break;
				   case MB_ERR_INTERNAL:
					   fprintf(stderr, "\t reason: internal error. Recompile libmoard in debug mode for more info \n");
					   break;
				   default:
					   fprintf(stderr, "\t MB_SyncStart returned error code: %d (see libmboard docs for details)\n", rc);
					   break;
			   }
			   
					   
					   exit(rc);
			   }
			   #endif
		}
		
		/* Start sync message boards that don't write */
		if(FLAME_consumption_request_2_message_board_write == 0)
		{
			/*printf("%d> consumption_request_2 message board sync start early as no agents sending any messages of this type\n", node_number);*/
			
			/* ********** sync message board here **********  */
			if(FLAME_TEST_PRINT_START_AND_END_OF_LIBMBOARD_CALLS) printf("start MB_SyncStart(b_consumption_request_2)\n");
			rc = MB_SyncStart(b_consumption_request_2);
			if(FLAME_TEST_PRINT_START_AND_END_OF_LIBMBOARD_CALLS) printf("finish MB_SyncStart(b_consumption_request_2)\n");
			#ifdef ERRCHECK
			if (rc != MB_SUCCESS)
			{
			   fprintf(stderr, "ERROR: Could not start sync of 'consumption_request_2' board\n");
			   switch(rc) {
				   case MB_ERR_INVALID:
					   fprintf(stderr, "\t reason: 'consumption_request_2' board is invalid\n");
					   break;
				   case MB_ERR_LOCKED:
					   fprintf(stderr, "\t reason: 'consumption_request_2' board is locked\n");
					   break;
				   case MB_ERR_MEMALLOC:
					   fprintf(stderr, "\t reason: out of memory\n");
					   break;
				   case MB_ERR_INTERNAL:
					   fprintf(stderr, "\t reason: internal error. Recompile libmoard in debug mode for more info \n");
					   break;
				   default:
					   fprintf(stderr, "\t MB_SyncStart returned error code: %d (see libmboard docs for details)\n", rc);
					   break;
			   }
			   
					   
					   exit(rc);
			   }
			   #endif
		}
		
		/* Start sync message boards that don't write */
		if(FLAME_accepted_consumption_1_message_board_write == 0)
		{
			/*printf("%d> accepted_consumption_1 message board sync start early as no agents sending any messages of this type\n", node_number);*/
			
			/* ********** sync message board here **********  */
			if(FLAME_TEST_PRINT_START_AND_END_OF_LIBMBOARD_CALLS) printf("start MB_SyncStart(b_accepted_consumption_1)\n");
			rc = MB_SyncStart(b_accepted_consumption_1);
			if(FLAME_TEST_PRINT_START_AND_END_OF_LIBMBOARD_CALLS) printf("finish MB_SyncStart(b_accepted_consumption_1)\n");
			#ifdef ERRCHECK
			if (rc != MB_SUCCESS)
			{
			   fprintf(stderr, "ERROR: Could not start sync of 'accepted_consumption_1' board\n");
			   switch(rc) {
				   case MB_ERR_INVALID:
					   fprintf(stderr, "\t reason: 'accepted_consumption_1' board is invalid\n");
					   break;
				   case MB_ERR_LOCKED:
					   fprintf(stderr, "\t reason: 'accepted_consumption_1' board is locked\n");
					   break;
				   case MB_ERR_MEMALLOC:
					   fprintf(stderr, "\t reason: out of memory\n");
					   break;
				   case MB_ERR_INTERNAL:
					   fprintf(stderr, "\t reason: internal error. Recompile libmoard in debug mode for more info \n");
					   break;
				   default:
					   fprintf(stderr, "\t MB_SyncStart returned error code: %d (see libmboard docs for details)\n", rc);
					   break;
			   }
			   
					   
					   exit(rc);
			   }
			   #endif
		}
		
		/* Start sync message boards that don't write */
		if(FLAME_accepted_consumption_2_message_board_write == 0)
		{
			/*printf("%d> accepted_consumption_2 message board sync start early as no agents sending any messages of this type\n", node_number);*/
			
			/* ********** sync message board here **********  */
			if(FLAME_TEST_PRINT_START_AND_END_OF_LIBMBOARD_CALLS) printf("start MB_SyncStart(b_accepted_consumption_2)\n");
			rc = MB_SyncStart(b_accepted_consumption_2);
			if(FLAME_TEST_PRINT_START_AND_END_OF_LIBMBOARD_CALLS) printf("finish MB_SyncStart(b_accepted_consumption_2)\n");
			#ifdef ERRCHECK
			if (rc != MB_SUCCESS)
			{
			   fprintf(stderr, "ERROR: Could not start sync of 'accepted_consumption_2' board\n");
			   switch(rc) {
				   case MB_ERR_INVALID:
					   fprintf(stderr, "\t reason: 'accepted_consumption_2' board is invalid\n");
					   break;
				   case MB_ERR_LOCKED:
					   fprintf(stderr, "\t reason: 'accepted_consumption_2' board is locked\n");
					   break;
				   case MB_ERR_MEMALLOC:
					   fprintf(stderr, "\t reason: out of memory\n");
					   break;
				   case MB_ERR_INTERNAL:
					   fprintf(stderr, "\t reason: internal error. Recompile libmoard in debug mode for more info \n");
					   break;
				   default:
					   fprintf(stderr, "\t MB_SyncStart returned error code: %d (see libmboard docs for details)\n", rc);
					   break;
			   }
			   
					   
					   exit(rc);
			   }
			   #endif
		}
		
		/* Start sync message boards that don't write */
		if(FLAME_sales_message_board_write == 0)
		{
			/*printf("%d> sales message board sync start early as no agents sending any messages of this type\n", node_number);*/
			
			/* ********** sync message board here **********  */
			if(FLAME_TEST_PRINT_START_AND_END_OF_LIBMBOARD_CALLS) printf("start MB_SyncStart(b_sales)\n");
			rc = MB_SyncStart(b_sales);
			if(FLAME_TEST_PRINT_START_AND_END_OF_LIBMBOARD_CALLS) printf("finish MB_SyncStart(b_sales)\n");
			#ifdef ERRCHECK
			if (rc != MB_SUCCESS)
			{
			   fprintf(stderr, "ERROR: Could not start sync of 'sales' board\n");
			   switch(rc) {
				   case MB_ERR_INVALID:
					   fprintf(stderr, "\t reason: 'sales' board is invalid\n");
					   break;
				   case MB_ERR_LOCKED:
					   fprintf(stderr, "\t reason: 'sales' board is locked\n");
					   break;
				   case MB_ERR_MEMALLOC:
					   fprintf(stderr, "\t reason: out of memory\n");
					   break;
				   case MB_ERR_INTERNAL:
					   fprintf(stderr, "\t reason: internal error. Recompile libmoard in debug mode for more info \n");
					   break;
				   default:
					   fprintf(stderr, "\t MB_SyncStart returned error code: %d (see libmboard docs for details)\n", rc);
					   break;
			   }
			   
					   
					   exit(rc);
			   }
			   #endif
		}
		
		/* Start sync message boards that don't write */
		if(FLAME_specific_skill_update_message_board_write == 0)
		{
			/*printf("%d> specific_skill_update message board sync start early as no agents sending any messages of this type\n", node_number);*/
			
			/* ********** sync message board here **********  */
			if(FLAME_TEST_PRINT_START_AND_END_OF_LIBMBOARD_CALLS) printf("start MB_SyncStart(b_specific_skill_update)\n");
			rc = MB_SyncStart(b_specific_skill_update);
			if(FLAME_TEST_PRINT_START_AND_END_OF_LIBMBOARD_CALLS) printf("finish MB_SyncStart(b_specific_skill_update)\n");
			#ifdef ERRCHECK
			if (rc != MB_SUCCESS)
			{
			   fprintf(stderr, "ERROR: Could not start sync of 'specific_skill_update' board\n");
			   switch(rc) {
				   case MB_ERR_INVALID:
					   fprintf(stderr, "\t reason: 'specific_skill_update' board is invalid\n");
					   break;
				   case MB_ERR_LOCKED:
					   fprintf(stderr, "\t reason: 'specific_skill_update' board is locked\n");
					   break;
				   case MB_ERR_MEMALLOC:
					   fprintf(stderr, "\t reason: out of memory\n");
					   break;
				   case MB_ERR_INTERNAL:
					   fprintf(stderr, "\t reason: internal error. Recompile libmoard in debug mode for more info \n");
					   break;
				   default:
					   fprintf(stderr, "\t MB_SyncStart returned error code: %d (see libmboard docs for details)\n", rc);
					   break;
			   }
			   
					   
					   exit(rc);
			   }
			   #endif
		}
		
		/* Start sync message boards that don't write */
		if(FLAME_policy_rate_message_board_write == 0)
		{
			/*printf("%d> policy_rate message board sync start early as no agents sending any messages of this type\n", node_number);*/
			
			/* ********** sync message board here **********  */
			if(FLAME_TEST_PRINT_START_AND_END_OF_LIBMBOARD_CALLS) printf("start MB_SyncStart(b_policy_rate)\n");
			rc = MB_SyncStart(b_policy_rate);
			if(FLAME_TEST_PRINT_START_AND_END_OF_LIBMBOARD_CALLS) printf("finish MB_SyncStart(b_policy_rate)\n");
			#ifdef ERRCHECK
			if (rc != MB_SUCCESS)
			{
			   fprintf(stderr, "ERROR: Could not start sync of 'policy_rate' board\n");
			   switch(rc) {
				   case MB_ERR_INVALID:
					   fprintf(stderr, "\t reason: 'policy_rate' board is invalid\n");
					   break;
				   case MB_ERR_LOCKED:
					   fprintf(stderr, "\t reason: 'policy_rate' board is locked\n");
					   break;
				   case MB_ERR_MEMALLOC:
					   fprintf(stderr, "\t reason: out of memory\n");
					   break;
				   case MB_ERR_INTERNAL:
					   fprintf(stderr, "\t reason: internal error. Recompile libmoard in debug mode for more info \n");
					   break;
				   default:
					   fprintf(stderr, "\t MB_SyncStart returned error code: %d (see libmboard docs for details)\n", rc);
					   break;
			   }
			   
					   
					   exit(rc);
			   }
			   #endif
		}
		
		/* Start sync message boards that don't write */
		if(FLAME_bank_identity_message_board_write == 0)
		{
			/*printf("%d> bank_identity message board sync start early as no agents sending any messages of this type\n", node_number);*/
			
			/* ********** sync message board here **********  */
			if(FLAME_TEST_PRINT_START_AND_END_OF_LIBMBOARD_CALLS) printf("start MB_SyncStart(b_bank_identity)\n");
			rc = MB_SyncStart(b_bank_identity);
			if(FLAME_TEST_PRINT_START_AND_END_OF_LIBMBOARD_CALLS) printf("finish MB_SyncStart(b_bank_identity)\n");
			#ifdef ERRCHECK
			if (rc != MB_SUCCESS)
			{
			   fprintf(stderr, "ERROR: Could not start sync of 'bank_identity' board\n");
			   switch(rc) {
				   case MB_ERR_INVALID:
					   fprintf(stderr, "\t reason: 'bank_identity' board is invalid\n");
					   break;
				   case MB_ERR_LOCKED:
					   fprintf(stderr, "\t reason: 'bank_identity' board is locked\n");
					   break;
				   case MB_ERR_MEMALLOC:
					   fprintf(stderr, "\t reason: out of memory\n");
					   break;
				   case MB_ERR_INTERNAL:
					   fprintf(stderr, "\t reason: internal error. Recompile libmoard in debug mode for more info \n");
					   break;
				   default:
					   fprintf(stderr, "\t MB_SyncStart returned error code: %d (see libmboard docs for details)\n", rc);
					   break;
			   }
			   
					   
					   exit(rc);
			   }
			   #endif
		}
		
		/* Start sync message boards that don't write */
		if(FLAME_loan_request_message_board_write == 0)
		{
			/*printf("%d> loan_request message board sync start early as no agents sending any messages of this type\n", node_number);*/
			
			/* ********** sync message board here **********  */
			if(FLAME_TEST_PRINT_START_AND_END_OF_LIBMBOARD_CALLS) printf("start MB_SyncStart(b_loan_request)\n");
			rc = MB_SyncStart(b_loan_request);
			if(FLAME_TEST_PRINT_START_AND_END_OF_LIBMBOARD_CALLS) printf("finish MB_SyncStart(b_loan_request)\n");
			#ifdef ERRCHECK
			if (rc != MB_SUCCESS)
			{
			   fprintf(stderr, "ERROR: Could not start sync of 'loan_request' board\n");
			   switch(rc) {
				   case MB_ERR_INVALID:
					   fprintf(stderr, "\t reason: 'loan_request' board is invalid\n");
					   break;
				   case MB_ERR_LOCKED:
					   fprintf(stderr, "\t reason: 'loan_request' board is locked\n");
					   break;
				   case MB_ERR_MEMALLOC:
					   fprintf(stderr, "\t reason: out of memory\n");
					   break;
				   case MB_ERR_INTERNAL:
					   fprintf(stderr, "\t reason: internal error. Recompile libmoard in debug mode for more info \n");
					   break;
				   default:
					   fprintf(stderr, "\t MB_SyncStart returned error code: %d (see libmboard docs for details)\n", rc);
					   break;
			   }
			   
					   
					   exit(rc);
			   }
			   #endif
		}
		
		/* Start sync message boards that don't write */
		if(FLAME_loan_request_ranked_message_board_write == 0)
		{
			/*printf("%d> loan_request_ranked message board sync start early as no agents sending any messages of this type\n", node_number);*/
			
			/* ********** sync message board here **********  */
			if(FLAME_TEST_PRINT_START_AND_END_OF_LIBMBOARD_CALLS) printf("start MB_SyncStart(b_loan_request_ranked)\n");
			rc = MB_SyncStart(b_loan_request_ranked);
			if(FLAME_TEST_PRINT_START_AND_END_OF_LIBMBOARD_CALLS) printf("finish MB_SyncStart(b_loan_request_ranked)\n");
			#ifdef ERRCHECK
			if (rc != MB_SUCCESS)
			{
			   fprintf(stderr, "ERROR: Could not start sync of 'loan_request_ranked' board\n");
			   switch(rc) {
				   case MB_ERR_INVALID:
					   fprintf(stderr, "\t reason: 'loan_request_ranked' board is invalid\n");
					   break;
				   case MB_ERR_LOCKED:
					   fprintf(stderr, "\t reason: 'loan_request_ranked' board is locked\n");
					   break;
				   case MB_ERR_MEMALLOC:
					   fprintf(stderr, "\t reason: out of memory\n");
					   break;
				   case MB_ERR_INTERNAL:
					   fprintf(stderr, "\t reason: internal error. Recompile libmoard in debug mode for more info \n");
					   break;
				   default:
					   fprintf(stderr, "\t MB_SyncStart returned error code: %d (see libmboard docs for details)\n", rc);
					   break;
			   }
			   
					   
					   exit(rc);
			   }
			   #endif
		}
		
		/* Start sync message boards that don't write */
		if(FLAME_loan_conditions_message_board_write == 0)
		{
			/*printf("%d> loan_conditions message board sync start early as no agents sending any messages of this type\n", node_number);*/
			
			/* ********** sync message board here **********  */
			if(FLAME_TEST_PRINT_START_AND_END_OF_LIBMBOARD_CALLS) printf("start MB_SyncStart(b_loan_conditions)\n");
			rc = MB_SyncStart(b_loan_conditions);
			if(FLAME_TEST_PRINT_START_AND_END_OF_LIBMBOARD_CALLS) printf("finish MB_SyncStart(b_loan_conditions)\n");
			#ifdef ERRCHECK
			if (rc != MB_SUCCESS)
			{
			   fprintf(stderr, "ERROR: Could not start sync of 'loan_conditions' board\n");
			   switch(rc) {
				   case MB_ERR_INVALID:
					   fprintf(stderr, "\t reason: 'loan_conditions' board is invalid\n");
					   break;
				   case MB_ERR_LOCKED:
					   fprintf(stderr, "\t reason: 'loan_conditions' board is locked\n");
					   break;
				   case MB_ERR_MEMALLOC:
					   fprintf(stderr, "\t reason: out of memory\n");
					   break;
				   case MB_ERR_INTERNAL:
					   fprintf(stderr, "\t reason: internal error. Recompile libmoard in debug mode for more info \n");
					   break;
				   default:
					   fprintf(stderr, "\t MB_SyncStart returned error code: %d (see libmboard docs for details)\n", rc);
					   break;
			   }
			   
					   
					   exit(rc);
			   }
			   #endif
		}
		
		/* Start sync message boards that don't write */
		if(FLAME_loan_acceptance_message_board_write == 0)
		{
			/*printf("%d> loan_acceptance message board sync start early as no agents sending any messages of this type\n", node_number);*/
			
			/* ********** sync message board here **********  */
			if(FLAME_TEST_PRINT_START_AND_END_OF_LIBMBOARD_CALLS) printf("start MB_SyncStart(b_loan_acceptance)\n");
			rc = MB_SyncStart(b_loan_acceptance);
			if(FLAME_TEST_PRINT_START_AND_END_OF_LIBMBOARD_CALLS) printf("finish MB_SyncStart(b_loan_acceptance)\n");
			#ifdef ERRCHECK
			if (rc != MB_SUCCESS)
			{
			   fprintf(stderr, "ERROR: Could not start sync of 'loan_acceptance' board\n");
			   switch(rc) {
				   case MB_ERR_INVALID:
					   fprintf(stderr, "\t reason: 'loan_acceptance' board is invalid\n");
					   break;
				   case MB_ERR_LOCKED:
					   fprintf(stderr, "\t reason: 'loan_acceptance' board is locked\n");
					   break;
				   case MB_ERR_MEMALLOC:
					   fprintf(stderr, "\t reason: out of memory\n");
					   break;
				   case MB_ERR_INTERNAL:
					   fprintf(stderr, "\t reason: internal error. Recompile libmoard in debug mode for more info \n");
					   break;
				   default:
					   fprintf(stderr, "\t MB_SyncStart returned error code: %d (see libmboard docs for details)\n", rc);
					   break;
			   }
			   
					   
					   exit(rc);
			   }
			   #endif
		}
		
		/* Start sync message boards that don't write */
		if(FLAME_installment_message_board_write == 0)
		{
			/*printf("%d> installment message board sync start early as no agents sending any messages of this type\n", node_number);*/
			
			/* ********** sync message board here **********  */
			if(FLAME_TEST_PRINT_START_AND_END_OF_LIBMBOARD_CALLS) printf("start MB_SyncStart(b_installment)\n");
			rc = MB_SyncStart(b_installment);
			if(FLAME_TEST_PRINT_START_AND_END_OF_LIBMBOARD_CALLS) printf("finish MB_SyncStart(b_installment)\n");
			#ifdef ERRCHECK
			if (rc != MB_SUCCESS)
			{
			   fprintf(stderr, "ERROR: Could not start sync of 'installment' board\n");
			   switch(rc) {
				   case MB_ERR_INVALID:
					   fprintf(stderr, "\t reason: 'installment' board is invalid\n");
					   break;
				   case MB_ERR_LOCKED:
					   fprintf(stderr, "\t reason: 'installment' board is locked\n");
					   break;
				   case MB_ERR_MEMALLOC:
					   fprintf(stderr, "\t reason: out of memory\n");
					   break;
				   case MB_ERR_INTERNAL:
					   fprintf(stderr, "\t reason: internal error. Recompile libmoard in debug mode for more info \n");
					   break;
				   default:
					   fprintf(stderr, "\t MB_SyncStart returned error code: %d (see libmboard docs for details)\n", rc);
					   break;
			   }
			   
					   
					   exit(rc);
			   }
			   #endif
		}
		
		/* Start sync message boards that don't write */
		if(FLAME_bankruptcy_message_board_write == 0)
		{
			/*printf("%d> bankruptcy message board sync start early as no agents sending any messages of this type\n", node_number);*/
			
			/* ********** sync message board here **********  */
			if(FLAME_TEST_PRINT_START_AND_END_OF_LIBMBOARD_CALLS) printf("start MB_SyncStart(b_bankruptcy)\n");
			rc = MB_SyncStart(b_bankruptcy);
			if(FLAME_TEST_PRINT_START_AND_END_OF_LIBMBOARD_CALLS) printf("finish MB_SyncStart(b_bankruptcy)\n");
			#ifdef ERRCHECK
			if (rc != MB_SUCCESS)
			{
			   fprintf(stderr, "ERROR: Could not start sync of 'bankruptcy' board\n");
			   switch(rc) {
				   case MB_ERR_INVALID:
					   fprintf(stderr, "\t reason: 'bankruptcy' board is invalid\n");
					   break;
				   case MB_ERR_LOCKED:
					   fprintf(stderr, "\t reason: 'bankruptcy' board is locked\n");
					   break;
				   case MB_ERR_MEMALLOC:
					   fprintf(stderr, "\t reason: out of memory\n");
					   break;
				   case MB_ERR_INTERNAL:
					   fprintf(stderr, "\t reason: internal error. Recompile libmoard in debug mode for more info \n");
					   break;
				   default:
					   fprintf(stderr, "\t MB_SyncStart returned error code: %d (see libmboard docs for details)\n", rc);
					   break;
			   }
			   
					   
					   exit(rc);
			   }
			   #endif
		}
		
		/* Start sync message boards that don't write */
		if(FLAME_bank_interest_payment_message_board_write == 0)
		{
			/*printf("%d> bank_interest_payment message board sync start early as no agents sending any messages of this type\n", node_number);*/
			
			/* ********** sync message board here **********  */
			if(FLAME_TEST_PRINT_START_AND_END_OF_LIBMBOARD_CALLS) printf("start MB_SyncStart(b_bank_interest_payment)\n");
			rc = MB_SyncStart(b_bank_interest_payment);
			if(FLAME_TEST_PRINT_START_AND_END_OF_LIBMBOARD_CALLS) printf("finish MB_SyncStart(b_bank_interest_payment)\n");
			#ifdef ERRCHECK
			if (rc != MB_SUCCESS)
			{
			   fprintf(stderr, "ERROR: Could not start sync of 'bank_interest_payment' board\n");
			   switch(rc) {
				   case MB_ERR_INVALID:
					   fprintf(stderr, "\t reason: 'bank_interest_payment' board is invalid\n");
					   break;
				   case MB_ERR_LOCKED:
					   fprintf(stderr, "\t reason: 'bank_interest_payment' board is locked\n");
					   break;
				   case MB_ERR_MEMALLOC:
					   fprintf(stderr, "\t reason: out of memory\n");
					   break;
				   case MB_ERR_INTERNAL:
					   fprintf(stderr, "\t reason: internal error. Recompile libmoard in debug mode for more info \n");
					   break;
				   default:
					   fprintf(stderr, "\t MB_SyncStart returned error code: %d (see libmboard docs for details)\n", rc);
					   break;
			   }
			   
					   
					   exit(rc);
			   }
			   #endif
		}
		
		/* Start sync message boards that don't write */
		if(FLAME_account_interest_message_board_write == 0)
		{
			/*printf("%d> account_interest message board sync start early as no agents sending any messages of this type\n", node_number);*/
			
			/* ********** sync message board here **********  */
			if(FLAME_TEST_PRINT_START_AND_END_OF_LIBMBOARD_CALLS) printf("start MB_SyncStart(b_account_interest)\n");
			rc = MB_SyncStart(b_account_interest);
			if(FLAME_TEST_PRINT_START_AND_END_OF_LIBMBOARD_CALLS) printf("finish MB_SyncStart(b_account_interest)\n");
			#ifdef ERRCHECK
			if (rc != MB_SUCCESS)
			{
			   fprintf(stderr, "ERROR: Could not start sync of 'account_interest' board\n");
			   switch(rc) {
				   case MB_ERR_INVALID:
					   fprintf(stderr, "\t reason: 'account_interest' board is invalid\n");
					   break;
				   case MB_ERR_LOCKED:
					   fprintf(stderr, "\t reason: 'account_interest' board is locked\n");
					   break;
				   case MB_ERR_MEMALLOC:
					   fprintf(stderr, "\t reason: out of memory\n");
					   break;
				   case MB_ERR_INTERNAL:
					   fprintf(stderr, "\t reason: internal error. Recompile libmoard in debug mode for more info \n");
					   break;
				   default:
					   fprintf(stderr, "\t MB_SyncStart returned error code: %d (see libmboard docs for details)\n", rc);
					   break;
			   }
			   
					   
					   exit(rc);
			   }
			   #endif
		}
		
		/* Start sync message boards that don't write */
		if(FLAME_ecb_dividend_message_board_write == 0)
		{
			/*printf("%d> ecb_dividend message board sync start early as no agents sending any messages of this type\n", node_number);*/
			
			/* ********** sync message board here **********  */
			if(FLAME_TEST_PRINT_START_AND_END_OF_LIBMBOARD_CALLS) printf("start MB_SyncStart(b_ecb_dividend)\n");
			rc = MB_SyncStart(b_ecb_dividend);
			if(FLAME_TEST_PRINT_START_AND_END_OF_LIBMBOARD_CALLS) printf("finish MB_SyncStart(b_ecb_dividend)\n");
			#ifdef ERRCHECK
			if (rc != MB_SUCCESS)
			{
			   fprintf(stderr, "ERROR: Could not start sync of 'ecb_dividend' board\n");
			   switch(rc) {
				   case MB_ERR_INVALID:
					   fprintf(stderr, "\t reason: 'ecb_dividend' board is invalid\n");
					   break;
				   case MB_ERR_LOCKED:
					   fprintf(stderr, "\t reason: 'ecb_dividend' board is locked\n");
					   break;
				   case MB_ERR_MEMALLOC:
					   fprintf(stderr, "\t reason: out of memory\n");
					   break;
				   case MB_ERR_INTERNAL:
					   fprintf(stderr, "\t reason: internal error. Recompile libmoard in debug mode for more info \n");
					   break;
				   default:
					   fprintf(stderr, "\t MB_SyncStart returned error code: %d (see libmboard docs for details)\n", rc);
					   break;
			   }
			   
					   
					   exit(rc);
			   }
			   #endif
		}
		
		/* Start sync message boards that don't write */
		if(FLAME_credit_var_update_message_board_write == 0)
		{
			/*printf("%d> credit_var_update message board sync start early as no agents sending any messages of this type\n", node_number);*/
			
			/* ********** sync message board here **********  */
			if(FLAME_TEST_PRINT_START_AND_END_OF_LIBMBOARD_CALLS) printf("start MB_SyncStart(b_credit_var_update)\n");
			rc = MB_SyncStart(b_credit_var_update);
			if(FLAME_TEST_PRINT_START_AND_END_OF_LIBMBOARD_CALLS) printf("finish MB_SyncStart(b_credit_var_update)\n");
			#ifdef ERRCHECK
			if (rc != MB_SUCCESS)
			{
			   fprintf(stderr, "ERROR: Could not start sync of 'credit_var_update' board\n");
			   switch(rc) {
				   case MB_ERR_INVALID:
					   fprintf(stderr, "\t reason: 'credit_var_update' board is invalid\n");
					   break;
				   case MB_ERR_LOCKED:
					   fprintf(stderr, "\t reason: 'credit_var_update' board is locked\n");
					   break;
				   case MB_ERR_MEMALLOC:
					   fprintf(stderr, "\t reason: out of memory\n");
					   break;
				   case MB_ERR_INTERNAL:
					   fprintf(stderr, "\t reason: internal error. Recompile libmoard in debug mode for more info \n");
					   break;
				   default:
					   fprintf(stderr, "\t MB_SyncStart returned error code: %d (see libmboard docs for details)\n", rc);
					   break;
			   }
			   
					   
					   exit(rc);
			   }
			   #endif
		}
		
		/* Start sync message boards that don't write */
		if(FLAME_bankruptcy_illiquidity_message_board_write == 0)
		{
			/*printf("%d> bankruptcy_illiquidity message board sync start early as no agents sending any messages of this type\n", node_number);*/
			
			/* ********** sync message board here **********  */
			if(FLAME_TEST_PRINT_START_AND_END_OF_LIBMBOARD_CALLS) printf("start MB_SyncStart(b_bankruptcy_illiquidity)\n");
			rc = MB_SyncStart(b_bankruptcy_illiquidity);
			if(FLAME_TEST_PRINT_START_AND_END_OF_LIBMBOARD_CALLS) printf("finish MB_SyncStart(b_bankruptcy_illiquidity)\n");
			#ifdef ERRCHECK
			if (rc != MB_SUCCESS)
			{
			   fprintf(stderr, "ERROR: Could not start sync of 'bankruptcy_illiquidity' board\n");
			   switch(rc) {
				   case MB_ERR_INVALID:
					   fprintf(stderr, "\t reason: 'bankruptcy_illiquidity' board is invalid\n");
					   break;
				   case MB_ERR_LOCKED:
					   fprintf(stderr, "\t reason: 'bankruptcy_illiquidity' board is locked\n");
					   break;
				   case MB_ERR_MEMALLOC:
					   fprintf(stderr, "\t reason: out of memory\n");
					   break;
				   case MB_ERR_INTERNAL:
					   fprintf(stderr, "\t reason: internal error. Recompile libmoard in debug mode for more info \n");
					   break;
				   default:
					   fprintf(stderr, "\t MB_SyncStart returned error code: %d (see libmboard docs for details)\n", rc);
					   break;
			   }
			   
					   
					   exit(rc);
			   }
			   #endif
		}
		
		/* Start sync message boards that don't write */
		if(FLAME_bankruptcy_insolvency_message_board_write == 0)
		{
			/*printf("%d> bankruptcy_insolvency message board sync start early as no agents sending any messages of this type\n", node_number);*/
			
			/* ********** sync message board here **********  */
			if(FLAME_TEST_PRINT_START_AND_END_OF_LIBMBOARD_CALLS) printf("start MB_SyncStart(b_bankruptcy_insolvency)\n");
			rc = MB_SyncStart(b_bankruptcy_insolvency);
			if(FLAME_TEST_PRINT_START_AND_END_OF_LIBMBOARD_CALLS) printf("finish MB_SyncStart(b_bankruptcy_insolvency)\n");
			#ifdef ERRCHECK
			if (rc != MB_SUCCESS)
			{
			   fprintf(stderr, "ERROR: Could not start sync of 'bankruptcy_insolvency' board\n");
			   switch(rc) {
				   case MB_ERR_INVALID:
					   fprintf(stderr, "\t reason: 'bankruptcy_insolvency' board is invalid\n");
					   break;
				   case MB_ERR_LOCKED:
					   fprintf(stderr, "\t reason: 'bankruptcy_insolvency' board is locked\n");
					   break;
				   case MB_ERR_MEMALLOC:
					   fprintf(stderr, "\t reason: out of memory\n");
					   break;
				   case MB_ERR_INTERNAL:
					   fprintf(stderr, "\t reason: internal error. Recompile libmoard in debug mode for more info \n");
					   break;
				   default:
					   fprintf(stderr, "\t MB_SyncStart returned error code: %d (see libmboard docs for details)\n", rc);
					   break;
			   }
			   
					   
					   exit(rc);
			   }
			   #endif
		}
		
		/* Start sync message boards that don't write */
		if(FLAME_index_info_message_board_write == 0)
		{
			/*printf("%d> index_info message board sync start early as no agents sending any messages of this type\n", node_number);*/
			
			/* ********** sync message board here **********  */
			if(FLAME_TEST_PRINT_START_AND_END_OF_LIBMBOARD_CALLS) printf("start MB_SyncStart(b_index_info)\n");
			rc = MB_SyncStart(b_index_info);
			if(FLAME_TEST_PRINT_START_AND_END_OF_LIBMBOARD_CALLS) printf("finish MB_SyncStart(b_index_info)\n");
			#ifdef ERRCHECK
			if (rc != MB_SUCCESS)
			{
			   fprintf(stderr, "ERROR: Could not start sync of 'index_info' board\n");
			   switch(rc) {
				   case MB_ERR_INVALID:
					   fprintf(stderr, "\t reason: 'index_info' board is invalid\n");
					   break;
				   case MB_ERR_LOCKED:
					   fprintf(stderr, "\t reason: 'index_info' board is locked\n");
					   break;
				   case MB_ERR_MEMALLOC:
					   fprintf(stderr, "\t reason: out of memory\n");
					   break;
				   case MB_ERR_INTERNAL:
					   fprintf(stderr, "\t reason: internal error. Recompile libmoard in debug mode for more info \n");
					   break;
				   default:
					   fprintf(stderr, "\t MB_SyncStart returned error code: %d (see libmboard docs for details)\n", rc);
					   break;
			   }
			   
					   
					   exit(rc);
			   }
			   #endif
		}
		
		/* Start sync message boards that don't write */
		if(FLAME_index_price_message_board_write == 0)
		{
			/*printf("%d> index_price message board sync start early as no agents sending any messages of this type\n", node_number);*/
			
			/* ********** sync message board here **********  */
			if(FLAME_TEST_PRINT_START_AND_END_OF_LIBMBOARD_CALLS) printf("start MB_SyncStart(b_index_price)\n");
			rc = MB_SyncStart(b_index_price);
			if(FLAME_TEST_PRINT_START_AND_END_OF_LIBMBOARD_CALLS) printf("finish MB_SyncStart(b_index_price)\n");
			#ifdef ERRCHECK
			if (rc != MB_SUCCESS)
			{
			   fprintf(stderr, "ERROR: Could not start sync of 'index_price' board\n");
			   switch(rc) {
				   case MB_ERR_INVALID:
					   fprintf(stderr, "\t reason: 'index_price' board is invalid\n");
					   break;
				   case MB_ERR_LOCKED:
					   fprintf(stderr, "\t reason: 'index_price' board is locked\n");
					   break;
				   case MB_ERR_MEMALLOC:
					   fprintf(stderr, "\t reason: out of memory\n");
					   break;
				   case MB_ERR_INTERNAL:
					   fprintf(stderr, "\t reason: internal error. Recompile libmoard in debug mode for more info \n");
					   break;
				   default:
					   fprintf(stderr, "\t MB_SyncStart returned error code: %d (see libmboard docs for details)\n", rc);
					   break;
			   }
			   
					   
					   exit(rc);
			   }
			   #endif
		}
		
		/* Start sync message boards that don't write */
		if(FLAME_order_message_board_write == 0)
		{
			/*printf("%d> order message board sync start early as no agents sending any messages of this type\n", node_number);*/
			
			/* ********** sync message board here **********  */
			if(FLAME_TEST_PRINT_START_AND_END_OF_LIBMBOARD_CALLS) printf("start MB_SyncStart(b_order)\n");
			rc = MB_SyncStart(b_order);
			if(FLAME_TEST_PRINT_START_AND_END_OF_LIBMBOARD_CALLS) printf("finish MB_SyncStart(b_order)\n");
			#ifdef ERRCHECK
			if (rc != MB_SUCCESS)
			{
			   fprintf(stderr, "ERROR: Could not start sync of 'order' board\n");
			   switch(rc) {
				   case MB_ERR_INVALID:
					   fprintf(stderr, "\t reason: 'order' board is invalid\n");
					   break;
				   case MB_ERR_LOCKED:
					   fprintf(stderr, "\t reason: 'order' board is locked\n");
					   break;
				   case MB_ERR_MEMALLOC:
					   fprintf(stderr, "\t reason: out of memory\n");
					   break;
				   case MB_ERR_INTERNAL:
					   fprintf(stderr, "\t reason: internal error. Recompile libmoard in debug mode for more info \n");
					   break;
				   default:
					   fprintf(stderr, "\t MB_SyncStart returned error code: %d (see libmboard docs for details)\n", rc);
					   break;
			   }
			   
					   
					   exit(rc);
			   }
			   #endif
		}
		
		/* Start sync message boards that don't write */
		if(FLAME_order_status_message_board_write == 0)
		{
			/*printf("%d> order_status message board sync start early as no agents sending any messages of this type\n", node_number);*/
			
			/* ********** sync message board here **********  */
			if(FLAME_TEST_PRINT_START_AND_END_OF_LIBMBOARD_CALLS) printf("start MB_SyncStart(b_order_status)\n");
			rc = MB_SyncStart(b_order_status);
			if(FLAME_TEST_PRINT_START_AND_END_OF_LIBMBOARD_CALLS) printf("finish MB_SyncStart(b_order_status)\n");
			#ifdef ERRCHECK
			if (rc != MB_SUCCESS)
			{
			   fprintf(stderr, "ERROR: Could not start sync of 'order_status' board\n");
			   switch(rc) {
				   case MB_ERR_INVALID:
					   fprintf(stderr, "\t reason: 'order_status' board is invalid\n");
					   break;
				   case MB_ERR_LOCKED:
					   fprintf(stderr, "\t reason: 'order_status' board is locked\n");
					   break;
				   case MB_ERR_MEMALLOC:
					   fprintf(stderr, "\t reason: out of memory\n");
					   break;
				   case MB_ERR_INTERNAL:
					   fprintf(stderr, "\t reason: internal error. Recompile libmoard in debug mode for more info \n");
					   break;
				   default:
					   fprintf(stderr, "\t MB_SyncStart returned error code: %d (see libmboard docs for details)\n", rc);
					   break;
			   }
			   
					   
					   exit(rc);
			   }
			   #endif
		}
		
		/* Start sync message boards that don't write */
		if(FLAME_dividend_info_message_board_write == 0)
		{
			/*printf("%d> dividend_info message board sync start early as no agents sending any messages of this type\n", node_number);*/
			
			/* ********** sync message board here **********  */
			if(FLAME_TEST_PRINT_START_AND_END_OF_LIBMBOARD_CALLS) printf("start MB_SyncStart(b_dividend_info)\n");
			rc = MB_SyncStart(b_dividend_info);
			if(FLAME_TEST_PRINT_START_AND_END_OF_LIBMBOARD_CALLS) printf("finish MB_SyncStart(b_dividend_info)\n");
			#ifdef ERRCHECK
			if (rc != MB_SUCCESS)
			{
			   fprintf(stderr, "ERROR: Could not start sync of 'dividend_info' board\n");
			   switch(rc) {
				   case MB_ERR_INVALID:
					   fprintf(stderr, "\t reason: 'dividend_info' board is invalid\n");
					   break;
				   case MB_ERR_LOCKED:
					   fprintf(stderr, "\t reason: 'dividend_info' board is locked\n");
					   break;
				   case MB_ERR_MEMALLOC:
					   fprintf(stderr, "\t reason: out of memory\n");
					   break;
				   case MB_ERR_INTERNAL:
					   fprintf(stderr, "\t reason: internal error. Recompile libmoard in debug mode for more info \n");
					   break;
				   default:
					   fprintf(stderr, "\t MB_SyncStart returned error code: %d (see libmboard docs for details)\n", rc);
					   break;
			   }
			   
					   
					   exit(rc);
			   }
			   #endif
		}
		
		/* Start sync message boards that don't write */
		if(FLAME_productivity_message_board_write == 0)
		{
			/*printf("%d> productivity message board sync start early as no agents sending any messages of this type\n", node_number);*/
			
			/* ********** sync message board here **********  */
			if(FLAME_TEST_PRINT_START_AND_END_OF_LIBMBOARD_CALLS) printf("start MB_SyncStart(b_productivity)\n");
			rc = MB_SyncStart(b_productivity);
			if(FLAME_TEST_PRINT_START_AND_END_OF_LIBMBOARD_CALLS) printf("finish MB_SyncStart(b_productivity)\n");
			#ifdef ERRCHECK
			if (rc != MB_SUCCESS)
			{
			   fprintf(stderr, "ERROR: Could not start sync of 'productivity' board\n");
			   switch(rc) {
				   case MB_ERR_INVALID:
					   fprintf(stderr, "\t reason: 'productivity' board is invalid\n");
					   break;
				   case MB_ERR_LOCKED:
					   fprintf(stderr, "\t reason: 'productivity' board is locked\n");
					   break;
				   case MB_ERR_MEMALLOC:
					   fprintf(stderr, "\t reason: out of memory\n");
					   break;
				   case MB_ERR_INTERNAL:
					   fprintf(stderr, "\t reason: internal error. Recompile libmoard in debug mode for more info \n");
					   break;
				   default:
					   fprintf(stderr, "\t MB_SyncStart returned error code: %d (see libmboard docs for details)\n", rc);
					   break;
			   }
			   
					   
					   exit(rc);
			   }
			   #endif
		}
		
		/* Start sync message boards that don't write */
		if(FLAME_capital_good_request_message_board_write == 0)
		{
			/*printf("%d> capital_good_request message board sync start early as no agents sending any messages of this type\n", node_number);*/
			
			/* ********** sync message board here **********  */
			if(FLAME_TEST_PRINT_START_AND_END_OF_LIBMBOARD_CALLS) printf("start MB_SyncStart(b_capital_good_request)\n");
			rc = MB_SyncStart(b_capital_good_request);
			if(FLAME_TEST_PRINT_START_AND_END_OF_LIBMBOARD_CALLS) printf("finish MB_SyncStart(b_capital_good_request)\n");
			#ifdef ERRCHECK
			if (rc != MB_SUCCESS)
			{
			   fprintf(stderr, "ERROR: Could not start sync of 'capital_good_request' board\n");
			   switch(rc) {
				   case MB_ERR_INVALID:
					   fprintf(stderr, "\t reason: 'capital_good_request' board is invalid\n");
					   break;
				   case MB_ERR_LOCKED:
					   fprintf(stderr, "\t reason: 'capital_good_request' board is locked\n");
					   break;
				   case MB_ERR_MEMALLOC:
					   fprintf(stderr, "\t reason: out of memory\n");
					   break;
				   case MB_ERR_INTERNAL:
					   fprintf(stderr, "\t reason: internal error. Recompile libmoard in debug mode for more info \n");
					   break;
				   default:
					   fprintf(stderr, "\t MB_SyncStart returned error code: %d (see libmboard docs for details)\n", rc);
					   break;
			   }
			   
					   
					   exit(rc);
			   }
			   #endif
		}
		
		/* Start sync message boards that don't write */
		if(FLAME_capital_good_delivery_message_board_write == 0)
		{
			/*printf("%d> capital_good_delivery message board sync start early as no agents sending any messages of this type\n", node_number);*/
			
			/* ********** sync message board here **********  */
			if(FLAME_TEST_PRINT_START_AND_END_OF_LIBMBOARD_CALLS) printf("start MB_SyncStart(b_capital_good_delivery)\n");
			rc = MB_SyncStart(b_capital_good_delivery);
			if(FLAME_TEST_PRINT_START_AND_END_OF_LIBMBOARD_CALLS) printf("finish MB_SyncStart(b_capital_good_delivery)\n");
			#ifdef ERRCHECK
			if (rc != MB_SUCCESS)
			{
			   fprintf(stderr, "ERROR: Could not start sync of 'capital_good_delivery' board\n");
			   switch(rc) {
				   case MB_ERR_INVALID:
					   fprintf(stderr, "\t reason: 'capital_good_delivery' board is invalid\n");
					   break;
				   case MB_ERR_LOCKED:
					   fprintf(stderr, "\t reason: 'capital_good_delivery' board is locked\n");
					   break;
				   case MB_ERR_MEMALLOC:
					   fprintf(stderr, "\t reason: out of memory\n");
					   break;
				   case MB_ERR_INTERNAL:
					   fprintf(stderr, "\t reason: internal error. Recompile libmoard in debug mode for more info \n");
					   break;
				   default:
					   fprintf(stderr, "\t MB_SyncStart returned error code: %d (see libmboard docs for details)\n", rc);
					   break;
			   }
			   
					   
					   exit(rc);
			   }
			   #endif
		}
		
		/* Start sync message boards that don't write */
		if(FLAME_pay_capital_goods_message_board_write == 0)
		{
			/*printf("%d> pay_capital_goods message board sync start early as no agents sending any messages of this type\n", node_number);*/
			
			/* ********** sync message board here **********  */
			if(FLAME_TEST_PRINT_START_AND_END_OF_LIBMBOARD_CALLS) printf("start MB_SyncStart(b_pay_capital_goods)\n");
			rc = MB_SyncStart(b_pay_capital_goods);
			if(FLAME_TEST_PRINT_START_AND_END_OF_LIBMBOARD_CALLS) printf("finish MB_SyncStart(b_pay_capital_goods)\n");
			#ifdef ERRCHECK
			if (rc != MB_SUCCESS)
			{
			   fprintf(stderr, "ERROR: Could not start sync of 'pay_capital_goods' board\n");
			   switch(rc) {
				   case MB_ERR_INVALID:
					   fprintf(stderr, "\t reason: 'pay_capital_goods' board is invalid\n");
					   break;
				   case MB_ERR_LOCKED:
					   fprintf(stderr, "\t reason: 'pay_capital_goods' board is locked\n");
					   break;
				   case MB_ERR_MEMALLOC:
					   fprintf(stderr, "\t reason: out of memory\n");
					   break;
				   case MB_ERR_INTERNAL:
					   fprintf(stderr, "\t reason: internal error. Recompile libmoard in debug mode for more info \n");
					   break;
				   default:
					   fprintf(stderr, "\t MB_SyncStart returned error code: %d (see libmboard docs for details)\n", rc);
					   break;
			   }
			   
					   
					   exit(rc);
			   }
			   #endif
		}
		
		/* Start sync message boards that don't write */
		if(FLAME_vacancies_message_board_write == 0)
		{
			/*printf("%d> vacancies message board sync start early as no agents sending any messages of this type\n", node_number);*/
			
			/* ********** sync message board here **********  */
			if(FLAME_TEST_PRINT_START_AND_END_OF_LIBMBOARD_CALLS) printf("start MB_SyncStart(b_vacancies)\n");
			rc = MB_SyncStart(b_vacancies);
			if(FLAME_TEST_PRINT_START_AND_END_OF_LIBMBOARD_CALLS) printf("finish MB_SyncStart(b_vacancies)\n");
			#ifdef ERRCHECK
			if (rc != MB_SUCCESS)
			{
			   fprintf(stderr, "ERROR: Could not start sync of 'vacancies' board\n");
			   switch(rc) {
				   case MB_ERR_INVALID:
					   fprintf(stderr, "\t reason: 'vacancies' board is invalid\n");
					   break;
				   case MB_ERR_LOCKED:
					   fprintf(stderr, "\t reason: 'vacancies' board is locked\n");
					   break;
				   case MB_ERR_MEMALLOC:
					   fprintf(stderr, "\t reason: out of memory\n");
					   break;
				   case MB_ERR_INTERNAL:
					   fprintf(stderr, "\t reason: internal error. Recompile libmoard in debug mode for more info \n");
					   break;
				   default:
					   fprintf(stderr, "\t MB_SyncStart returned error code: %d (see libmboard docs for details)\n", rc);
					   break;
			   }
			   
					   
					   exit(rc);
			   }
			   #endif
		}
		
		/* Start sync message boards that don't write */
		if(FLAME_vacancies2_message_board_write == 0)
		{
			/*printf("%d> vacancies2 message board sync start early as no agents sending any messages of this type\n", node_number);*/
			
			/* ********** sync message board here **********  */
			if(FLAME_TEST_PRINT_START_AND_END_OF_LIBMBOARD_CALLS) printf("start MB_SyncStart(b_vacancies2)\n");
			rc = MB_SyncStart(b_vacancies2);
			if(FLAME_TEST_PRINT_START_AND_END_OF_LIBMBOARD_CALLS) printf("finish MB_SyncStart(b_vacancies2)\n");
			#ifdef ERRCHECK
			if (rc != MB_SUCCESS)
			{
			   fprintf(stderr, "ERROR: Could not start sync of 'vacancies2' board\n");
			   switch(rc) {
				   case MB_ERR_INVALID:
					   fprintf(stderr, "\t reason: 'vacancies2' board is invalid\n");
					   break;
				   case MB_ERR_LOCKED:
					   fprintf(stderr, "\t reason: 'vacancies2' board is locked\n");
					   break;
				   case MB_ERR_MEMALLOC:
					   fprintf(stderr, "\t reason: out of memory\n");
					   break;
				   case MB_ERR_INTERNAL:
					   fprintf(stderr, "\t reason: internal error. Recompile libmoard in debug mode for more info \n");
					   break;
				   default:
					   fprintf(stderr, "\t MB_SyncStart returned error code: %d (see libmboard docs for details)\n", rc);
					   break;
			   }
			   
					   
					   exit(rc);
			   }
			   #endif
		}
		
		/* Start sync message boards that don't write */
		if(FLAME_vacancies_r_and_d_employees_message_board_write == 0)
		{
			/*printf("%d> vacancies_r_and_d_employees message board sync start early as no agents sending any messages of this type\n", node_number);*/
			
			/* ********** sync message board here **********  */
			if(FLAME_TEST_PRINT_START_AND_END_OF_LIBMBOARD_CALLS) printf("start MB_SyncStart(b_vacancies_r_and_d_employees)\n");
			rc = MB_SyncStart(b_vacancies_r_and_d_employees);
			if(FLAME_TEST_PRINT_START_AND_END_OF_LIBMBOARD_CALLS) printf("finish MB_SyncStart(b_vacancies_r_and_d_employees)\n");
			#ifdef ERRCHECK
			if (rc != MB_SUCCESS)
			{
			   fprintf(stderr, "ERROR: Could not start sync of 'vacancies_r_and_d_employees' board\n");
			   switch(rc) {
				   case MB_ERR_INVALID:
					   fprintf(stderr, "\t reason: 'vacancies_r_and_d_employees' board is invalid\n");
					   break;
				   case MB_ERR_LOCKED:
					   fprintf(stderr, "\t reason: 'vacancies_r_and_d_employees' board is locked\n");
					   break;
				   case MB_ERR_MEMALLOC:
					   fprintf(stderr, "\t reason: out of memory\n");
					   break;
				   case MB_ERR_INTERNAL:
					   fprintf(stderr, "\t reason: internal error. Recompile libmoard in debug mode for more info \n");
					   break;
				   default:
					   fprintf(stderr, "\t MB_SyncStart returned error code: %d (see libmboard docs for details)\n", rc);
					   break;
			   }
			   
					   
					   exit(rc);
			   }
			   #endif
		}
		
		/* Start sync message boards that don't write */
		if(FLAME_vacancies_r_and_d_employees2_message_board_write == 0)
		{
			/*printf("%d> vacancies_r_and_d_employees2 message board sync start early as no agents sending any messages of this type\n", node_number);*/
			
			/* ********** sync message board here **********  */
			if(FLAME_TEST_PRINT_START_AND_END_OF_LIBMBOARD_CALLS) printf("start MB_SyncStart(b_vacancies_r_and_d_employees2)\n");
			rc = MB_SyncStart(b_vacancies_r_and_d_employees2);
			if(FLAME_TEST_PRINT_START_AND_END_OF_LIBMBOARD_CALLS) printf("finish MB_SyncStart(b_vacancies_r_and_d_employees2)\n");
			#ifdef ERRCHECK
			if (rc != MB_SUCCESS)
			{
			   fprintf(stderr, "ERROR: Could not start sync of 'vacancies_r_and_d_employees2' board\n");
			   switch(rc) {
				   case MB_ERR_INVALID:
					   fprintf(stderr, "\t reason: 'vacancies_r_and_d_employees2' board is invalid\n");
					   break;
				   case MB_ERR_LOCKED:
					   fprintf(stderr, "\t reason: 'vacancies_r_and_d_employees2' board is locked\n");
					   break;
				   case MB_ERR_MEMALLOC:
					   fprintf(stderr, "\t reason: out of memory\n");
					   break;
				   case MB_ERR_INTERNAL:
					   fprintf(stderr, "\t reason: internal error. Recompile libmoard in debug mode for more info \n");
					   break;
				   default:
					   fprintf(stderr, "\t MB_SyncStart returned error code: %d (see libmboard docs for details)\n", rc);
					   break;
			   }
			   
					   
					   exit(rc);
			   }
			   #endif
		}
		
		/* Start sync message boards that don't write */
		if(FLAME_firing_message_board_write == 0)
		{
			/*printf("%d> firing message board sync start early as no agents sending any messages of this type\n", node_number);*/
			
			/* ********** sync message board here **********  */
			if(FLAME_TEST_PRINT_START_AND_END_OF_LIBMBOARD_CALLS) printf("start MB_SyncStart(b_firing)\n");
			rc = MB_SyncStart(b_firing);
			if(FLAME_TEST_PRINT_START_AND_END_OF_LIBMBOARD_CALLS) printf("finish MB_SyncStart(b_firing)\n");
			#ifdef ERRCHECK
			if (rc != MB_SUCCESS)
			{
			   fprintf(stderr, "ERROR: Could not start sync of 'firing' board\n");
			   switch(rc) {
				   case MB_ERR_INVALID:
					   fprintf(stderr, "\t reason: 'firing' board is invalid\n");
					   break;
				   case MB_ERR_LOCKED:
					   fprintf(stderr, "\t reason: 'firing' board is locked\n");
					   break;
				   case MB_ERR_MEMALLOC:
					   fprintf(stderr, "\t reason: out of memory\n");
					   break;
				   case MB_ERR_INTERNAL:
					   fprintf(stderr, "\t reason: internal error. Recompile libmoard in debug mode for more info \n");
					   break;
				   default:
					   fprintf(stderr, "\t MB_SyncStart returned error code: %d (see libmboard docs for details)\n", rc);
					   break;
			   }
			   
					   
					   exit(rc);
			   }
			   #endif
		}
		
		/* Start sync message boards that don't write */
		if(FLAME_job_application_message_board_write == 0)
		{
			/*printf("%d> job_application message board sync start early as no agents sending any messages of this type\n", node_number);*/
			
			/* ********** sync message board here **********  */
			if(FLAME_TEST_PRINT_START_AND_END_OF_LIBMBOARD_CALLS) printf("start MB_SyncStart(b_job_application)\n");
			rc = MB_SyncStart(b_job_application);
			if(FLAME_TEST_PRINT_START_AND_END_OF_LIBMBOARD_CALLS) printf("finish MB_SyncStart(b_job_application)\n");
			#ifdef ERRCHECK
			if (rc != MB_SUCCESS)
			{
			   fprintf(stderr, "ERROR: Could not start sync of 'job_application' board\n");
			   switch(rc) {
				   case MB_ERR_INVALID:
					   fprintf(stderr, "\t reason: 'job_application' board is invalid\n");
					   break;
				   case MB_ERR_LOCKED:
					   fprintf(stderr, "\t reason: 'job_application' board is locked\n");
					   break;
				   case MB_ERR_MEMALLOC:
					   fprintf(stderr, "\t reason: out of memory\n");
					   break;
				   case MB_ERR_INTERNAL:
					   fprintf(stderr, "\t reason: internal error. Recompile libmoard in debug mode for more info \n");
					   break;
				   default:
					   fprintf(stderr, "\t MB_SyncStart returned error code: %d (see libmboard docs for details)\n", rc);
					   break;
			   }
			   
					   
					   exit(rc);
			   }
			   #endif
		}
		
		/* Start sync message boards that don't write */
		if(FLAME_job_application2_message_board_write == 0)
		{
			/*printf("%d> job_application2 message board sync start early as no agents sending any messages of this type\n", node_number);*/
			
			/* ********** sync message board here **********  */
			if(FLAME_TEST_PRINT_START_AND_END_OF_LIBMBOARD_CALLS) printf("start MB_SyncStart(b_job_application2)\n");
			rc = MB_SyncStart(b_job_application2);
			if(FLAME_TEST_PRINT_START_AND_END_OF_LIBMBOARD_CALLS) printf("finish MB_SyncStart(b_job_application2)\n");
			#ifdef ERRCHECK
			if (rc != MB_SUCCESS)
			{
			   fprintf(stderr, "ERROR: Could not start sync of 'job_application2' board\n");
			   switch(rc) {
				   case MB_ERR_INVALID:
					   fprintf(stderr, "\t reason: 'job_application2' board is invalid\n");
					   break;
				   case MB_ERR_LOCKED:
					   fprintf(stderr, "\t reason: 'job_application2' board is locked\n");
					   break;
				   case MB_ERR_MEMALLOC:
					   fprintf(stderr, "\t reason: out of memory\n");
					   break;
				   case MB_ERR_INTERNAL:
					   fprintf(stderr, "\t reason: internal error. Recompile libmoard in debug mode for more info \n");
					   break;
				   default:
					   fprintf(stderr, "\t MB_SyncStart returned error code: %d (see libmboard docs for details)\n", rc);
					   break;
			   }
			   
					   
					   exit(rc);
			   }
			   #endif
		}
		
		/* Start sync message boards that don't write */
		if(FLAME_job_offer_message_board_write == 0)
		{
			/*printf("%d> job_offer message board sync start early as no agents sending any messages of this type\n", node_number);*/
			
			/* ********** sync message board here **********  */
			if(FLAME_TEST_PRINT_START_AND_END_OF_LIBMBOARD_CALLS) printf("start MB_SyncStart(b_job_offer)\n");
			rc = MB_SyncStart(b_job_offer);
			if(FLAME_TEST_PRINT_START_AND_END_OF_LIBMBOARD_CALLS) printf("finish MB_SyncStart(b_job_offer)\n");
			#ifdef ERRCHECK
			if (rc != MB_SUCCESS)
			{
			   fprintf(stderr, "ERROR: Could not start sync of 'job_offer' board\n");
			   switch(rc) {
				   case MB_ERR_INVALID:
					   fprintf(stderr, "\t reason: 'job_offer' board is invalid\n");
					   break;
				   case MB_ERR_LOCKED:
					   fprintf(stderr, "\t reason: 'job_offer' board is locked\n");
					   break;
				   case MB_ERR_MEMALLOC:
					   fprintf(stderr, "\t reason: out of memory\n");
					   break;
				   case MB_ERR_INTERNAL:
					   fprintf(stderr, "\t reason: internal error. Recompile libmoard in debug mode for more info \n");
					   break;
				   default:
					   fprintf(stderr, "\t MB_SyncStart returned error code: %d (see libmboard docs for details)\n", rc);
					   break;
			   }
			   
					   
					   exit(rc);
			   }
			   #endif
		}
		
		/* Start sync message boards that don't write */
		if(FLAME_job_offer2_message_board_write == 0)
		{
			/*printf("%d> job_offer2 message board sync start early as no agents sending any messages of this type\n", node_number);*/
			
			/* ********** sync message board here **********  */
			if(FLAME_TEST_PRINT_START_AND_END_OF_LIBMBOARD_CALLS) printf("start MB_SyncStart(b_job_offer2)\n");
			rc = MB_SyncStart(b_job_offer2);
			if(FLAME_TEST_PRINT_START_AND_END_OF_LIBMBOARD_CALLS) printf("finish MB_SyncStart(b_job_offer2)\n");
			#ifdef ERRCHECK
			if (rc != MB_SUCCESS)
			{
			   fprintf(stderr, "ERROR: Could not start sync of 'job_offer2' board\n");
			   switch(rc) {
				   case MB_ERR_INVALID:
					   fprintf(stderr, "\t reason: 'job_offer2' board is invalid\n");
					   break;
				   case MB_ERR_LOCKED:
					   fprintf(stderr, "\t reason: 'job_offer2' board is locked\n");
					   break;
				   case MB_ERR_MEMALLOC:
					   fprintf(stderr, "\t reason: out of memory\n");
					   break;
				   case MB_ERR_INTERNAL:
					   fprintf(stderr, "\t reason: internal error. Recompile libmoard in debug mode for more info \n");
					   break;
				   default:
					   fprintf(stderr, "\t MB_SyncStart returned error code: %d (see libmboard docs for details)\n", rc);
					   break;
			   }
			   
					   
					   exit(rc);
			   }
			   #endif
		}
		
		/* Start sync message boards that don't write */
		if(FLAME_job_acceptance_message_board_write == 0)
		{
			/*printf("%d> job_acceptance message board sync start early as no agents sending any messages of this type\n", node_number);*/
			
			/* ********** sync message board here **********  */
			if(FLAME_TEST_PRINT_START_AND_END_OF_LIBMBOARD_CALLS) printf("start MB_SyncStart(b_job_acceptance)\n");
			rc = MB_SyncStart(b_job_acceptance);
			if(FLAME_TEST_PRINT_START_AND_END_OF_LIBMBOARD_CALLS) printf("finish MB_SyncStart(b_job_acceptance)\n");
			#ifdef ERRCHECK
			if (rc != MB_SUCCESS)
			{
			   fprintf(stderr, "ERROR: Could not start sync of 'job_acceptance' board\n");
			   switch(rc) {
				   case MB_ERR_INVALID:
					   fprintf(stderr, "\t reason: 'job_acceptance' board is invalid\n");
					   break;
				   case MB_ERR_LOCKED:
					   fprintf(stderr, "\t reason: 'job_acceptance' board is locked\n");
					   break;
				   case MB_ERR_MEMALLOC:
					   fprintf(stderr, "\t reason: out of memory\n");
					   break;
				   case MB_ERR_INTERNAL:
					   fprintf(stderr, "\t reason: internal error. Recompile libmoard in debug mode for more info \n");
					   break;
				   default:
					   fprintf(stderr, "\t MB_SyncStart returned error code: %d (see libmboard docs for details)\n", rc);
					   break;
			   }
			   
					   
					   exit(rc);
			   }
			   #endif
		}
		
		/* Start sync message boards that don't write */
		if(FLAME_job_acceptance2_message_board_write == 0)
		{
			/*printf("%d> job_acceptance2 message board sync start early as no agents sending any messages of this type\n", node_number);*/
			
			/* ********** sync message board here **********  */
			if(FLAME_TEST_PRINT_START_AND_END_OF_LIBMBOARD_CALLS) printf("start MB_SyncStart(b_job_acceptance2)\n");
			rc = MB_SyncStart(b_job_acceptance2);
			if(FLAME_TEST_PRINT_START_AND_END_OF_LIBMBOARD_CALLS) printf("finish MB_SyncStart(b_job_acceptance2)\n");
			#ifdef ERRCHECK
			if (rc != MB_SUCCESS)
			{
			   fprintf(stderr, "ERROR: Could not start sync of 'job_acceptance2' board\n");
			   switch(rc) {
				   case MB_ERR_INVALID:
					   fprintf(stderr, "\t reason: 'job_acceptance2' board is invalid\n");
					   break;
				   case MB_ERR_LOCKED:
					   fprintf(stderr, "\t reason: 'job_acceptance2' board is locked\n");
					   break;
				   case MB_ERR_MEMALLOC:
					   fprintf(stderr, "\t reason: out of memory\n");
					   break;
				   case MB_ERR_INTERNAL:
					   fprintf(stderr, "\t reason: internal error. Recompile libmoard in debug mode for more info \n");
					   break;
				   default:
					   fprintf(stderr, "\t MB_SyncStart returned error code: %d (see libmboard docs for details)\n", rc);
					   break;
			   }
			   
					   
					   exit(rc);
			   }
			   #endif
		}
		
		/* Start sync message boards that don't write */
		if(FLAME_quitting_message_board_write == 0)
		{
			/*printf("%d> quitting message board sync start early as no agents sending any messages of this type\n", node_number);*/
			
			/* ********** sync message board here **********  */
			if(FLAME_TEST_PRINT_START_AND_END_OF_LIBMBOARD_CALLS) printf("start MB_SyncStart(b_quitting)\n");
			rc = MB_SyncStart(b_quitting);
			if(FLAME_TEST_PRINT_START_AND_END_OF_LIBMBOARD_CALLS) printf("finish MB_SyncStart(b_quitting)\n");
			#ifdef ERRCHECK
			if (rc != MB_SUCCESS)
			{
			   fprintf(stderr, "ERROR: Could not start sync of 'quitting' board\n");
			   switch(rc) {
				   case MB_ERR_INVALID:
					   fprintf(stderr, "\t reason: 'quitting' board is invalid\n");
					   break;
				   case MB_ERR_LOCKED:
					   fprintf(stderr, "\t reason: 'quitting' board is locked\n");
					   break;
				   case MB_ERR_MEMALLOC:
					   fprintf(stderr, "\t reason: out of memory\n");
					   break;
				   case MB_ERR_INTERNAL:
					   fprintf(stderr, "\t reason: internal error. Recompile libmoard in debug mode for more info \n");
					   break;
				   default:
					   fprintf(stderr, "\t MB_SyncStart returned error code: %d (see libmboard docs for details)\n", rc);
					   break;
			   }
			   
					   
					   exit(rc);
			   }
			   #endif
		}
		
		/* Start sync message boards that don't write */
		if(FLAME_quitting2_message_board_write == 0)
		{
			/*printf("%d> quitting2 message board sync start early as no agents sending any messages of this type\n", node_number);*/
			
			/* ********** sync message board here **********  */
			if(FLAME_TEST_PRINT_START_AND_END_OF_LIBMBOARD_CALLS) printf("start MB_SyncStart(b_quitting2)\n");
			rc = MB_SyncStart(b_quitting2);
			if(FLAME_TEST_PRINT_START_AND_END_OF_LIBMBOARD_CALLS) printf("finish MB_SyncStart(b_quitting2)\n");
			#ifdef ERRCHECK
			if (rc != MB_SUCCESS)
			{
			   fprintf(stderr, "ERROR: Could not start sync of 'quitting2' board\n");
			   switch(rc) {
				   case MB_ERR_INVALID:
					   fprintf(stderr, "\t reason: 'quitting2' board is invalid\n");
					   break;
				   case MB_ERR_LOCKED:
					   fprintf(stderr, "\t reason: 'quitting2' board is locked\n");
					   break;
				   case MB_ERR_MEMALLOC:
					   fprintf(stderr, "\t reason: out of memory\n");
					   break;
				   case MB_ERR_INTERNAL:
					   fprintf(stderr, "\t reason: internal error. Recompile libmoard in debug mode for more info \n");
					   break;
				   default:
					   fprintf(stderr, "\t MB_SyncStart returned error code: %d (see libmboard docs for details)\n", rc);
					   break;
			   }
			   
					   
					   exit(rc);
			   }
			   #endif
		}
		
		/* Start sync message boards that don't write */
		if(FLAME_unemployment_notification_message_board_write == 0)
		{
			/*printf("%d> unemployment_notification message board sync start early as no agents sending any messages of this type\n", node_number);*/
			
			/* ********** sync message board here **********  */
			if(FLAME_TEST_PRINT_START_AND_END_OF_LIBMBOARD_CALLS) printf("start MB_SyncStart(b_unemployment_notification)\n");
			rc = MB_SyncStart(b_unemployment_notification);
			if(FLAME_TEST_PRINT_START_AND_END_OF_LIBMBOARD_CALLS) printf("finish MB_SyncStart(b_unemployment_notification)\n");
			#ifdef ERRCHECK
			if (rc != MB_SUCCESS)
			{
			   fprintf(stderr, "ERROR: Could not start sync of 'unemployment_notification' board\n");
			   switch(rc) {
				   case MB_ERR_INVALID:
					   fprintf(stderr, "\t reason: 'unemployment_notification' board is invalid\n");
					   break;
				   case MB_ERR_LOCKED:
					   fprintf(stderr, "\t reason: 'unemployment_notification' board is locked\n");
					   break;
				   case MB_ERR_MEMALLOC:
					   fprintf(stderr, "\t reason: out of memory\n");
					   break;
				   case MB_ERR_INTERNAL:
					   fprintf(stderr, "\t reason: internal error. Recompile libmoard in debug mode for more info \n");
					   break;
				   default:
					   fprintf(stderr, "\t MB_SyncStart returned error code: %d (see libmboard docs for details)\n", rc);
					   break;
			   }
			   
					   
					   exit(rc);
			   }
			   #endif
		}
		
		/* Start sync message boards that don't write */
		if(FLAME_policy_announcement_message_board_write == 0)
		{
			/*printf("%d> policy_announcement message board sync start early as no agents sending any messages of this type\n", node_number);*/
			
			/* ********** sync message board here **********  */
			if(FLAME_TEST_PRINT_START_AND_END_OF_LIBMBOARD_CALLS) printf("start MB_SyncStart(b_policy_announcement)\n");
			rc = MB_SyncStart(b_policy_announcement);
			if(FLAME_TEST_PRINT_START_AND_END_OF_LIBMBOARD_CALLS) printf("finish MB_SyncStart(b_policy_announcement)\n");
			#ifdef ERRCHECK
			if (rc != MB_SUCCESS)
			{
			   fprintf(stderr, "ERROR: Could not start sync of 'policy_announcement' board\n");
			   switch(rc) {
				   case MB_ERR_INVALID:
					   fprintf(stderr, "\t reason: 'policy_announcement' board is invalid\n");
					   break;
				   case MB_ERR_LOCKED:
					   fprintf(stderr, "\t reason: 'policy_announcement' board is locked\n");
					   break;
				   case MB_ERR_MEMALLOC:
					   fprintf(stderr, "\t reason: out of memory\n");
					   break;
				   case MB_ERR_INTERNAL:
					   fprintf(stderr, "\t reason: internal error. Recompile libmoard in debug mode for more info \n");
					   break;
				   default:
					   fprintf(stderr, "\t MB_SyncStart returned error code: %d (see libmboard docs for details)\n", rc);
					   break;
			   }
			   
					   
					   exit(rc);
			   }
			   #endif
		}
		
		/* Start sync message boards that don't write */
		if(FLAME_tax_payment_message_board_write == 0)
		{
			/*printf("%d> tax_payment message board sync start early as no agents sending any messages of this type\n", node_number);*/
			
			/* ********** sync message board here **********  */
			if(FLAME_TEST_PRINT_START_AND_END_OF_LIBMBOARD_CALLS) printf("start MB_SyncStart(b_tax_payment)\n");
			rc = MB_SyncStart(b_tax_payment);
			if(FLAME_TEST_PRINT_START_AND_END_OF_LIBMBOARD_CALLS) printf("finish MB_SyncStart(b_tax_payment)\n");
			#ifdef ERRCHECK
			if (rc != MB_SUCCESS)
			{
			   fprintf(stderr, "ERROR: Could not start sync of 'tax_payment' board\n");
			   switch(rc) {
				   case MB_ERR_INVALID:
					   fprintf(stderr, "\t reason: 'tax_payment' board is invalid\n");
					   break;
				   case MB_ERR_LOCKED:
					   fprintf(stderr, "\t reason: 'tax_payment' board is locked\n");
					   break;
				   case MB_ERR_MEMALLOC:
					   fprintf(stderr, "\t reason: out of memory\n");
					   break;
				   case MB_ERR_INTERNAL:
					   fprintf(stderr, "\t reason: internal error. Recompile libmoard in debug mode for more info \n");
					   break;
				   default:
					   fprintf(stderr, "\t MB_SyncStart returned error code: %d (see libmboard docs for details)\n", rc);
					   break;
			   }
			   
					   
					   exit(rc);
			   }
			   #endif
		}
		
		/* Start sync message boards that don't write */
		if(FLAME_unemployment_benefit_restitution_message_board_write == 0)
		{
			/*printf("%d> unemployment_benefit_restitution message board sync start early as no agents sending any messages of this type\n", node_number);*/
			
			/* ********** sync message board here **********  */
			if(FLAME_TEST_PRINT_START_AND_END_OF_LIBMBOARD_CALLS) printf("start MB_SyncStart(b_unemployment_benefit_restitution)\n");
			rc = MB_SyncStart(b_unemployment_benefit_restitution);
			if(FLAME_TEST_PRINT_START_AND_END_OF_LIBMBOARD_CALLS) printf("finish MB_SyncStart(b_unemployment_benefit_restitution)\n");
			#ifdef ERRCHECK
			if (rc != MB_SUCCESS)
			{
			   fprintf(stderr, "ERROR: Could not start sync of 'unemployment_benefit_restitution' board\n");
			   switch(rc) {
				   case MB_ERR_INVALID:
					   fprintf(stderr, "\t reason: 'unemployment_benefit_restitution' board is invalid\n");
					   break;
				   case MB_ERR_LOCKED:
					   fprintf(stderr, "\t reason: 'unemployment_benefit_restitution' board is locked\n");
					   break;
				   case MB_ERR_MEMALLOC:
					   fprintf(stderr, "\t reason: out of memory\n");
					   break;
				   case MB_ERR_INTERNAL:
					   fprintf(stderr, "\t reason: internal error. Recompile libmoard in debug mode for more info \n");
					   break;
				   default:
					   fprintf(stderr, "\t MB_SyncStart returned error code: %d (see libmboard docs for details)\n", rc);
					   break;
			   }
			   
					   
					   exit(rc);
			   }
			   #endif
		}
		
		/* Start sync message boards that don't write */
		if(FLAME_hh_transfer_notification_message_board_write == 0)
		{
			/*printf("%d> hh_transfer_notification message board sync start early as no agents sending any messages of this type\n", node_number);*/
			
			/* ********** sync message board here **********  */
			if(FLAME_TEST_PRINT_START_AND_END_OF_LIBMBOARD_CALLS) printf("start MB_SyncStart(b_hh_transfer_notification)\n");
			rc = MB_SyncStart(b_hh_transfer_notification);
			if(FLAME_TEST_PRINT_START_AND_END_OF_LIBMBOARD_CALLS) printf("finish MB_SyncStart(b_hh_transfer_notification)\n");
			#ifdef ERRCHECK
			if (rc != MB_SUCCESS)
			{
			   fprintf(stderr, "ERROR: Could not start sync of 'hh_transfer_notification' board\n");
			   switch(rc) {
				   case MB_ERR_INVALID:
					   fprintf(stderr, "\t reason: 'hh_transfer_notification' board is invalid\n");
					   break;
				   case MB_ERR_LOCKED:
					   fprintf(stderr, "\t reason: 'hh_transfer_notification' board is locked\n");
					   break;
				   case MB_ERR_MEMALLOC:
					   fprintf(stderr, "\t reason: out of memory\n");
					   break;
				   case MB_ERR_INTERNAL:
					   fprintf(stderr, "\t reason: internal error. Recompile libmoard in debug mode for more info \n");
					   break;
				   default:
					   fprintf(stderr, "\t MB_SyncStart returned error code: %d (see libmboard docs for details)\n", rc);
					   break;
			   }
			   
					   
					   exit(rc);
			   }
			   #endif
		}
		
		/* Start sync message boards that don't write */
		if(FLAME_hh_subsidy_notification_message_board_write == 0)
		{
			/*printf("%d> hh_subsidy_notification message board sync start early as no agents sending any messages of this type\n", node_number);*/
			
			/* ********** sync message board here **********  */
			if(FLAME_TEST_PRINT_START_AND_END_OF_LIBMBOARD_CALLS) printf("start MB_SyncStart(b_hh_subsidy_notification)\n");
			rc = MB_SyncStart(b_hh_subsidy_notification);
			if(FLAME_TEST_PRINT_START_AND_END_OF_LIBMBOARD_CALLS) printf("finish MB_SyncStart(b_hh_subsidy_notification)\n");
			#ifdef ERRCHECK
			if (rc != MB_SUCCESS)
			{
			   fprintf(stderr, "ERROR: Could not start sync of 'hh_subsidy_notification' board\n");
			   switch(rc) {
				   case MB_ERR_INVALID:
					   fprintf(stderr, "\t reason: 'hh_subsidy_notification' board is invalid\n");
					   break;
				   case MB_ERR_LOCKED:
					   fprintf(stderr, "\t reason: 'hh_subsidy_notification' board is locked\n");
					   break;
				   case MB_ERR_MEMALLOC:
					   fprintf(stderr, "\t reason: out of memory\n");
					   break;
				   case MB_ERR_INTERNAL:
					   fprintf(stderr, "\t reason: internal error. Recompile libmoard in debug mode for more info \n");
					   break;
				   default:
					   fprintf(stderr, "\t MB_SyncStart returned error code: %d (see libmboard docs for details)\n", rc);
					   break;
			   }
			   
					   
					   exit(rc);
			   }
			   #endif
		}
		
		/* Start sync message boards that don't write */
		if(FLAME_human_capital_policy_announcement_message_board_write == 0)
		{
			/*printf("%d> human_capital_policy_announcement message board sync start early as no agents sending any messages of this type\n", node_number);*/
			
			/* ********** sync message board here **********  */
			if(FLAME_TEST_PRINT_START_AND_END_OF_LIBMBOARD_CALLS) printf("start MB_SyncStart(b_human_capital_policy_announcement)\n");
			rc = MB_SyncStart(b_human_capital_policy_announcement);
			if(FLAME_TEST_PRINT_START_AND_END_OF_LIBMBOARD_CALLS) printf("finish MB_SyncStart(b_human_capital_policy_announcement)\n");
			#ifdef ERRCHECK
			if (rc != MB_SUCCESS)
			{
			   fprintf(stderr, "ERROR: Could not start sync of 'human_capital_policy_announcement' board\n");
			   switch(rc) {
				   case MB_ERR_INVALID:
					   fprintf(stderr, "\t reason: 'human_capital_policy_announcement' board is invalid\n");
					   break;
				   case MB_ERR_LOCKED:
					   fprintf(stderr, "\t reason: 'human_capital_policy_announcement' board is locked\n");
					   break;
				   case MB_ERR_MEMALLOC:
					   fprintf(stderr, "\t reason: out of memory\n");
					   break;
				   case MB_ERR_INTERNAL:
					   fprintf(stderr, "\t reason: internal error. Recompile libmoard in debug mode for more info \n");
					   break;
				   default:
					   fprintf(stderr, "\t MB_SyncStart returned error code: %d (see libmboard docs for details)\n", rc);
					   break;
			   }
			   
					   
					   exit(rc);
			   }
			   #endif
		}
		
		/* Start sync message boards that don't write */
		if(FLAME_firm_transfer_notification_message_board_write == 0)
		{
			/*printf("%d> firm_transfer_notification message board sync start early as no agents sending any messages of this type\n", node_number);*/
			
			/* ********** sync message board here **********  */
			if(FLAME_TEST_PRINT_START_AND_END_OF_LIBMBOARD_CALLS) printf("start MB_SyncStart(b_firm_transfer_notification)\n");
			rc = MB_SyncStart(b_firm_transfer_notification);
			if(FLAME_TEST_PRINT_START_AND_END_OF_LIBMBOARD_CALLS) printf("finish MB_SyncStart(b_firm_transfer_notification)\n");
			#ifdef ERRCHECK
			if (rc != MB_SUCCESS)
			{
			   fprintf(stderr, "ERROR: Could not start sync of 'firm_transfer_notification' board\n");
			   switch(rc) {
				   case MB_ERR_INVALID:
					   fprintf(stderr, "\t reason: 'firm_transfer_notification' board is invalid\n");
					   break;
				   case MB_ERR_LOCKED:
					   fprintf(stderr, "\t reason: 'firm_transfer_notification' board is locked\n");
					   break;
				   case MB_ERR_MEMALLOC:
					   fprintf(stderr, "\t reason: out of memory\n");
					   break;
				   case MB_ERR_INTERNAL:
					   fprintf(stderr, "\t reason: internal error. Recompile libmoard in debug mode for more info \n");
					   break;
				   default:
					   fprintf(stderr, "\t MB_SyncStart returned error code: %d (see libmboard docs for details)\n", rc);
					   break;
			   }
			   
					   
					   exit(rc);
			   }
			   #endif
		}
		
		/* Start sync message boards that don't write */
		if(FLAME_firm_subsidy_notification_message_board_write == 0)
		{
			/*printf("%d> firm_subsidy_notification message board sync start early as no agents sending any messages of this type\n", node_number);*/
			
			/* ********** sync message board here **********  */
			if(FLAME_TEST_PRINT_START_AND_END_OF_LIBMBOARD_CALLS) printf("start MB_SyncStart(b_firm_subsidy_notification)\n");
			rc = MB_SyncStart(b_firm_subsidy_notification);
			if(FLAME_TEST_PRINT_START_AND_END_OF_LIBMBOARD_CALLS) printf("finish MB_SyncStart(b_firm_subsidy_notification)\n");
			#ifdef ERRCHECK
			if (rc != MB_SUCCESS)
			{
			   fprintf(stderr, "ERROR: Could not start sync of 'firm_subsidy_notification' board\n");
			   switch(rc) {
				   case MB_ERR_INVALID:
					   fprintf(stderr, "\t reason: 'firm_subsidy_notification' board is invalid\n");
					   break;
				   case MB_ERR_LOCKED:
					   fprintf(stderr, "\t reason: 'firm_subsidy_notification' board is locked\n");
					   break;
				   case MB_ERR_MEMALLOC:
					   fprintf(stderr, "\t reason: out of memory\n");
					   break;
				   case MB_ERR_INTERNAL:
					   fprintf(stderr, "\t reason: internal error. Recompile libmoard in debug mode for more info \n");
					   break;
				   default:
					   fprintf(stderr, "\t MB_SyncStart returned error code: %d (see libmboard docs for details)\n", rc);
					   break;
			   }
			   
					   
					   exit(rc);
			   }
			   #endif
		}
		
		/* Start sync message boards that don't write */
		if(FLAME_request_fiat_money_message_board_write == 0)
		{
			/*printf("%d> request_fiat_money message board sync start early as no agents sending any messages of this type\n", node_number);*/
			
			/* ********** sync message board here **********  */
			if(FLAME_TEST_PRINT_START_AND_END_OF_LIBMBOARD_CALLS) printf("start MB_SyncStart(b_request_fiat_money)\n");
			rc = MB_SyncStart(b_request_fiat_money);
			if(FLAME_TEST_PRINT_START_AND_END_OF_LIBMBOARD_CALLS) printf("finish MB_SyncStart(b_request_fiat_money)\n");
			#ifdef ERRCHECK
			if (rc != MB_SUCCESS)
			{
			   fprintf(stderr, "ERROR: Could not start sync of 'request_fiat_money' board\n");
			   switch(rc) {
				   case MB_ERR_INVALID:
					   fprintf(stderr, "\t reason: 'request_fiat_money' board is invalid\n");
					   break;
				   case MB_ERR_LOCKED:
					   fprintf(stderr, "\t reason: 'request_fiat_money' board is locked\n");
					   break;
				   case MB_ERR_MEMALLOC:
					   fprintf(stderr, "\t reason: out of memory\n");
					   break;
				   case MB_ERR_INTERNAL:
					   fprintf(stderr, "\t reason: internal error. Recompile libmoard in debug mode for more info \n");
					   break;
				   default:
					   fprintf(stderr, "\t MB_SyncStart returned error code: %d (see libmboard docs for details)\n", rc);
					   break;
			   }
			   
					   
					   exit(rc);
			   }
			   #endif
		}
		
		/* Start sync message boards that don't write */
		if(FLAME_human_capital_policy_general_skill_information_message_board_write == 0)
		{
			/*printf("%d> human_capital_policy_general_skill_information message board sync start early as no agents sending any messages of this type\n", node_number);*/
			
			/* ********** sync message board here **********  */
			if(FLAME_TEST_PRINT_START_AND_END_OF_LIBMBOARD_CALLS) printf("start MB_SyncStart(b_human_capital_policy_general_skill_information)\n");
			rc = MB_SyncStart(b_human_capital_policy_general_skill_information);
			if(FLAME_TEST_PRINT_START_AND_END_OF_LIBMBOARD_CALLS) printf("finish MB_SyncStart(b_human_capital_policy_general_skill_information)\n");
			#ifdef ERRCHECK
			if (rc != MB_SUCCESS)
			{
			   fprintf(stderr, "ERROR: Could not start sync of 'human_capital_policy_general_skill_information' board\n");
			   switch(rc) {
				   case MB_ERR_INVALID:
					   fprintf(stderr, "\t reason: 'human_capital_policy_general_skill_information' board is invalid\n");
					   break;
				   case MB_ERR_LOCKED:
					   fprintf(stderr, "\t reason: 'human_capital_policy_general_skill_information' board is locked\n");
					   break;
				   case MB_ERR_MEMALLOC:
					   fprintf(stderr, "\t reason: out of memory\n");
					   break;
				   case MB_ERR_INTERNAL:
					   fprintf(stderr, "\t reason: internal error. Recompile libmoard in debug mode for more info \n");
					   break;
				   default:
					   fprintf(stderr, "\t MB_SyncStart returned error code: %d (see libmboard docs for details)\n", rc);
					   break;
			   }
			   
					   
					   exit(rc);
			   }
			   #endif
		}
		
		/* Start sync message boards that don't write */
		if(FLAME_human_capital_policy_new_general_skill_notification_message_board_write == 0)
		{
			/*printf("%d> human_capital_policy_new_general_skill_notification message board sync start early as no agents sending any messages of this type\n", node_number);*/
			
			/* ********** sync message board here **********  */
			if(FLAME_TEST_PRINT_START_AND_END_OF_LIBMBOARD_CALLS) printf("start MB_SyncStart(b_human_capital_policy_new_general_skill_notification)\n");
			rc = MB_SyncStart(b_human_capital_policy_new_general_skill_notification);
			if(FLAME_TEST_PRINT_START_AND_END_OF_LIBMBOARD_CALLS) printf("finish MB_SyncStart(b_human_capital_policy_new_general_skill_notification)\n");
			#ifdef ERRCHECK
			if (rc != MB_SUCCESS)
			{
			   fprintf(stderr, "ERROR: Could not start sync of 'human_capital_policy_new_general_skill_notification' board\n");
			   switch(rc) {
				   case MB_ERR_INVALID:
					   fprintf(stderr, "\t reason: 'human_capital_policy_new_general_skill_notification' board is invalid\n");
					   break;
				   case MB_ERR_LOCKED:
					   fprintf(stderr, "\t reason: 'human_capital_policy_new_general_skill_notification' board is locked\n");
					   break;
				   case MB_ERR_MEMALLOC:
					   fprintf(stderr, "\t reason: out of memory\n");
					   break;
				   case MB_ERR_INTERNAL:
					   fprintf(stderr, "\t reason: internal error. Recompile libmoard in debug mode for more info \n");
					   break;
				   default:
					   fprintf(stderr, "\t MB_SyncStart returned error code: %d (see libmboard docs for details)\n", rc);
					   break;
			   }
			   
					   
					   exit(rc);
			   }
			   #endif
		}
		
		/* Start sync message boards that don't write */
		if(FLAME_firm_send_data_message_board_write == 0)
		{
			/*printf("%d> firm_send_data message board sync start early as no agents sending any messages of this type\n", node_number);*/
			
			/* ********** sync message board here **********  */
			if(FLAME_TEST_PRINT_START_AND_END_OF_LIBMBOARD_CALLS) printf("start MB_SyncStart(b_firm_send_data)\n");
			rc = MB_SyncStart(b_firm_send_data);
			if(FLAME_TEST_PRINT_START_AND_END_OF_LIBMBOARD_CALLS) printf("finish MB_SyncStart(b_firm_send_data)\n");
			#ifdef ERRCHECK
			if (rc != MB_SUCCESS)
			{
			   fprintf(stderr, "ERROR: Could not start sync of 'firm_send_data' board\n");
			   switch(rc) {
				   case MB_ERR_INVALID:
					   fprintf(stderr, "\t reason: 'firm_send_data' board is invalid\n");
					   break;
				   case MB_ERR_LOCKED:
					   fprintf(stderr, "\t reason: 'firm_send_data' board is locked\n");
					   break;
				   case MB_ERR_MEMALLOC:
					   fprintf(stderr, "\t reason: out of memory\n");
					   break;
				   case MB_ERR_INTERNAL:
					   fprintf(stderr, "\t reason: internal error. Recompile libmoard in debug mode for more info \n");
					   break;
				   default:
					   fprintf(stderr, "\t MB_SyncStart returned error code: %d (see libmboard docs for details)\n", rc);
					   break;
			   }
			   
					   
					   exit(rc);
			   }
			   #endif
		}
		
		/* Start sync message boards that don't write */
		if(FLAME_government_send_data_message_board_write == 0)
		{
			/*printf("%d> government_send_data message board sync start early as no agents sending any messages of this type\n", node_number);*/
			
			/* ********** sync message board here **********  */
			if(FLAME_TEST_PRINT_START_AND_END_OF_LIBMBOARD_CALLS) printf("start MB_SyncStart(b_government_send_data)\n");
			rc = MB_SyncStart(b_government_send_data);
			if(FLAME_TEST_PRINT_START_AND_END_OF_LIBMBOARD_CALLS) printf("finish MB_SyncStart(b_government_send_data)\n");
			#ifdef ERRCHECK
			if (rc != MB_SUCCESS)
			{
			   fprintf(stderr, "ERROR: Could not start sync of 'government_send_data' board\n");
			   switch(rc) {
				   case MB_ERR_INVALID:
					   fprintf(stderr, "\t reason: 'government_send_data' board is invalid\n");
					   break;
				   case MB_ERR_LOCKED:
					   fprintf(stderr, "\t reason: 'government_send_data' board is locked\n");
					   break;
				   case MB_ERR_MEMALLOC:
					   fprintf(stderr, "\t reason: out of memory\n");
					   break;
				   case MB_ERR_INTERNAL:
					   fprintf(stderr, "\t reason: internal error. Recompile libmoard in debug mode for more info \n");
					   break;
				   default:
					   fprintf(stderr, "\t MB_SyncStart returned error code: %d (see libmboard docs for details)\n", rc);
					   break;
			   }
			   
					   
					   exit(rc);
			   }
			   #endif
		}
		
		/* Start sync message boards that don't write */
		if(FLAME_household_send_data_message_board_write == 0)
		{
			/*printf("%d> household_send_data message board sync start early as no agents sending any messages of this type\n", node_number);*/
			
			/* ********** sync message board here **********  */
			if(FLAME_TEST_PRINT_START_AND_END_OF_LIBMBOARD_CALLS) printf("start MB_SyncStart(b_household_send_data)\n");
			rc = MB_SyncStart(b_household_send_data);
			if(FLAME_TEST_PRINT_START_AND_END_OF_LIBMBOARD_CALLS) printf("finish MB_SyncStart(b_household_send_data)\n");
			#ifdef ERRCHECK
			if (rc != MB_SUCCESS)
			{
			   fprintf(stderr, "ERROR: Could not start sync of 'household_send_data' board\n");
			   switch(rc) {
				   case MB_ERR_INVALID:
					   fprintf(stderr, "\t reason: 'household_send_data' board is invalid\n");
					   break;
				   case MB_ERR_LOCKED:
					   fprintf(stderr, "\t reason: 'household_send_data' board is locked\n");
					   break;
				   case MB_ERR_MEMALLOC:
					   fprintf(stderr, "\t reason: out of memory\n");
					   break;
				   case MB_ERR_INTERNAL:
					   fprintf(stderr, "\t reason: internal error. Recompile libmoard in debug mode for more info \n");
					   break;
				   default:
					   fprintf(stderr, "\t MB_SyncStart returned error code: %d (see libmboard docs for details)\n", rc);
					   break;
			   }
			   
					   
					   exit(rc);
			   }
			   #endif
		}
		
		/* Start sync message boards that don't write */
		if(FLAME_mall_data_message_board_write == 0)
		{
			/*printf("%d> mall_data message board sync start early as no agents sending any messages of this type\n", node_number);*/
			
			/* ********** sync message board here **********  */
			if(FLAME_TEST_PRINT_START_AND_END_OF_LIBMBOARD_CALLS) printf("start MB_SyncStart(b_mall_data)\n");
			rc = MB_SyncStart(b_mall_data);
			if(FLAME_TEST_PRINT_START_AND_END_OF_LIBMBOARD_CALLS) printf("finish MB_SyncStart(b_mall_data)\n");
			#ifdef ERRCHECK
			if (rc != MB_SUCCESS)
			{
			   fprintf(stderr, "ERROR: Could not start sync of 'mall_data' board\n");
			   switch(rc) {
				   case MB_ERR_INVALID:
					   fprintf(stderr, "\t reason: 'mall_data' board is invalid\n");
					   break;
				   case MB_ERR_LOCKED:
					   fprintf(stderr, "\t reason: 'mall_data' board is locked\n");
					   break;
				   case MB_ERR_MEMALLOC:
					   fprintf(stderr, "\t reason: out of memory\n");
					   break;
				   case MB_ERR_INTERNAL:
					   fprintf(stderr, "\t reason: internal error. Recompile libmoard in debug mode for more info \n");
					   break;
				   default:
					   fprintf(stderr, "\t MB_SyncStart returned error code: %d (see libmboard docs for details)\n", rc);
					   break;
			   }
			   
					   
					   exit(rc);
			   }
			   #endif
		}
		
		/* Start sync message boards that don't write */
		if(FLAME_eurostat_send_specific_skills_message_board_write == 0)
		{
			/*printf("%d> eurostat_send_specific_skills message board sync start early as no agents sending any messages of this type\n", node_number);*/
			
			/* ********** sync message board here **********  */
			if(FLAME_TEST_PRINT_START_AND_END_OF_LIBMBOARD_CALLS) printf("start MB_SyncStart(b_eurostat_send_specific_skills)\n");
			rc = MB_SyncStart(b_eurostat_send_specific_skills);
			if(FLAME_TEST_PRINT_START_AND_END_OF_LIBMBOARD_CALLS) printf("finish MB_SyncStart(b_eurostat_send_specific_skills)\n");
			#ifdef ERRCHECK
			if (rc != MB_SUCCESS)
			{
			   fprintf(stderr, "ERROR: Could not start sync of 'eurostat_send_specific_skills' board\n");
			   switch(rc) {
				   case MB_ERR_INVALID:
					   fprintf(stderr, "\t reason: 'eurostat_send_specific_skills' board is invalid\n");
					   break;
				   case MB_ERR_LOCKED:
					   fprintf(stderr, "\t reason: 'eurostat_send_specific_skills' board is locked\n");
					   break;
				   case MB_ERR_MEMALLOC:
					   fprintf(stderr, "\t reason: out of memory\n");
					   break;
				   case MB_ERR_INTERNAL:
					   fprintf(stderr, "\t reason: internal error. Recompile libmoard in debug mode for more info \n");
					   break;
				   default:
					   fprintf(stderr, "\t MB_SyncStart returned error code: %d (see libmboard docs for details)\n", rc);
					   break;
			   }
			   
					   
					   exit(rc);
			   }
			   #endif
		}
		
		/* Start sync message boards that don't write */
		if(FLAME_data_for_government_message_board_write == 0)
		{
			/*printf("%d> data_for_government message board sync start early as no agents sending any messages of this type\n", node_number);*/
			
			/* ********** sync message board here **********  */
			if(FLAME_TEST_PRINT_START_AND_END_OF_LIBMBOARD_CALLS) printf("start MB_SyncStart(b_data_for_government)\n");
			rc = MB_SyncStart(b_data_for_government);
			if(FLAME_TEST_PRINT_START_AND_END_OF_LIBMBOARD_CALLS) printf("finish MB_SyncStart(b_data_for_government)\n");
			#ifdef ERRCHECK
			if (rc != MB_SUCCESS)
			{
			   fprintf(stderr, "ERROR: Could not start sync of 'data_for_government' board\n");
			   switch(rc) {
				   case MB_ERR_INVALID:
					   fprintf(stderr, "\t reason: 'data_for_government' board is invalid\n");
					   break;
				   case MB_ERR_LOCKED:
					   fprintf(stderr, "\t reason: 'data_for_government' board is locked\n");
					   break;
				   case MB_ERR_MEMALLOC:
					   fprintf(stderr, "\t reason: out of memory\n");
					   break;
				   case MB_ERR_INTERNAL:
					   fprintf(stderr, "\t reason: internal error. Recompile libmoard in debug mode for more info \n");
					   break;
				   default:
					   fprintf(stderr, "\t MB_SyncStart returned error code: %d (see libmboard docs for details)\n", rc);
					   break;
			   }
			   
					   
					   exit(rc);
			   }
			   #endif
		}
		
		/* Start sync message boards that don't write */
		if(FLAME_eurostat_send_macrodata_message_board_write == 0)
		{
			/*printf("%d> eurostat_send_macrodata message board sync start early as no agents sending any messages of this type\n", node_number);*/
			
			/* ********** sync message board here **********  */
			if(FLAME_TEST_PRINT_START_AND_END_OF_LIBMBOARD_CALLS) printf("start MB_SyncStart(b_eurostat_send_macrodata)\n");
			rc = MB_SyncStart(b_eurostat_send_macrodata);
			if(FLAME_TEST_PRINT_START_AND_END_OF_LIBMBOARD_CALLS) printf("finish MB_SyncStart(b_eurostat_send_macrodata)\n");
			#ifdef ERRCHECK
			if (rc != MB_SUCCESS)
			{
			   fprintf(stderr, "ERROR: Could not start sync of 'eurostat_send_macrodata' board\n");
			   switch(rc) {
				   case MB_ERR_INVALID:
					   fprintf(stderr, "\t reason: 'eurostat_send_macrodata' board is invalid\n");
					   break;
				   case MB_ERR_LOCKED:
					   fprintf(stderr, "\t reason: 'eurostat_send_macrodata' board is locked\n");
					   break;
				   case MB_ERR_MEMALLOC:
					   fprintf(stderr, "\t reason: out of memory\n");
					   break;
				   case MB_ERR_INTERNAL:
					   fprintf(stderr, "\t reason: internal error. Recompile libmoard in debug mode for more info \n");
					   break;
				   default:
					   fprintf(stderr, "\t MB_SyncStart returned error code: %d (see libmboard docs for details)\n", rc);
					   break;
			   }
			   
					   
					   exit(rc);
			   }
			   #endif
		}
		
		/* Start sync message boards that don't write */
		if(FLAME_msg_firm_id_to_malls_message_board_write == 0)
		{
			/*printf("%d> msg_firm_id_to_malls message board sync start early as no agents sending any messages of this type\n", node_number);*/
			
			/* ********** sync message board here **********  */
			if(FLAME_TEST_PRINT_START_AND_END_OF_LIBMBOARD_CALLS) printf("start MB_SyncStart(b_msg_firm_id_to_malls)\n");
			rc = MB_SyncStart(b_msg_firm_id_to_malls);
			if(FLAME_TEST_PRINT_START_AND_END_OF_LIBMBOARD_CALLS) printf("finish MB_SyncStart(b_msg_firm_id_to_malls)\n");
			#ifdef ERRCHECK
			if (rc != MB_SUCCESS)
			{
			   fprintf(stderr, "ERROR: Could not start sync of 'msg_firm_id_to_malls' board\n");
			   switch(rc) {
				   case MB_ERR_INVALID:
					   fprintf(stderr, "\t reason: 'msg_firm_id_to_malls' board is invalid\n");
					   break;
				   case MB_ERR_LOCKED:
					   fprintf(stderr, "\t reason: 'msg_firm_id_to_malls' board is locked\n");
					   break;
				   case MB_ERR_MEMALLOC:
					   fprintf(stderr, "\t reason: out of memory\n");
					   break;
				   case MB_ERR_INTERNAL:
					   fprintf(stderr, "\t reason: internal error. Recompile libmoard in debug mode for more info \n");
					   break;
				   default:
					   fprintf(stderr, "\t MB_SyncStart returned error code: %d (see libmboard docs for details)\n", rc);
					   break;
			   }
			   
					   
					   exit(rc);
			   }
			   #endif
		}
		
		/* Start sync message boards that don't write */
		if(FLAME_msg_mall_id_to_firms_message_board_write == 0)
		{
			/*printf("%d> msg_mall_id_to_firms message board sync start early as no agents sending any messages of this type\n", node_number);*/
			
			/* ********** sync message board here **********  */
			if(FLAME_TEST_PRINT_START_AND_END_OF_LIBMBOARD_CALLS) printf("start MB_SyncStart(b_msg_mall_id_to_firms)\n");
			rc = MB_SyncStart(b_msg_mall_id_to_firms);
			if(FLAME_TEST_PRINT_START_AND_END_OF_LIBMBOARD_CALLS) printf("finish MB_SyncStart(b_msg_mall_id_to_firms)\n");
			#ifdef ERRCHECK
			if (rc != MB_SUCCESS)
			{
			   fprintf(stderr, "ERROR: Could not start sync of 'msg_mall_id_to_firms' board\n");
			   switch(rc) {
				   case MB_ERR_INVALID:
					   fprintf(stderr, "\t reason: 'msg_mall_id_to_firms' board is invalid\n");
					   break;
				   case MB_ERR_LOCKED:
					   fprintf(stderr, "\t reason: 'msg_mall_id_to_firms' board is locked\n");
					   break;
				   case MB_ERR_MEMALLOC:
					   fprintf(stderr, "\t reason: out of memory\n");
					   break;
				   case MB_ERR_INTERNAL:
					   fprintf(stderr, "\t reason: internal error. Recompile libmoard in debug mode for more info \n");
					   break;
				   default:
					   fprintf(stderr, "\t MB_SyncStart returned error code: %d (see libmboard docs for details)\n", rc);
					   break;
			   }
			   
					   
					   exit(rc);
			   }
			   #endif
		}
		
		/* Start sync message boards that don't write */
		if(FLAME_msg_skills_eurostat_to_igfirm_message_board_write == 0)
		{
			/*printf("%d> msg_skills_eurostat_to_igfirm message board sync start early as no agents sending any messages of this type\n", node_number);*/
			
			/* ********** sync message board here **********  */
			if(FLAME_TEST_PRINT_START_AND_END_OF_LIBMBOARD_CALLS) printf("start MB_SyncStart(b_msg_skills_eurostat_to_igfirm)\n");
			rc = MB_SyncStart(b_msg_skills_eurostat_to_igfirm);
			if(FLAME_TEST_PRINT_START_AND_END_OF_LIBMBOARD_CALLS) printf("finish MB_SyncStart(b_msg_skills_eurostat_to_igfirm)\n");
			#ifdef ERRCHECK
			if (rc != MB_SUCCESS)
			{
			   fprintf(stderr, "ERROR: Could not start sync of 'msg_skills_eurostat_to_igfirm' board\n");
			   switch(rc) {
				   case MB_ERR_INVALID:
					   fprintf(stderr, "\t reason: 'msg_skills_eurostat_to_igfirm' board is invalid\n");
					   break;
				   case MB_ERR_LOCKED:
					   fprintf(stderr, "\t reason: 'msg_skills_eurostat_to_igfirm' board is locked\n");
					   break;
				   case MB_ERR_MEMALLOC:
					   fprintf(stderr, "\t reason: out of memory\n");
					   break;
				   case MB_ERR_INTERNAL:
					   fprintf(stderr, "\t reason: internal error. Recompile libmoard in debug mode for more info \n");
					   break;
				   default:
					   fprintf(stderr, "\t MB_SyncStart returned error code: %d (see libmboard docs for details)\n", rc);
					   break;
			   }
			   
					   
					   exit(rc);
			   }
			   #endif
		}
		
		/* Start sync message boards that don't write */
		if(FLAME_msg_market_sizes_message_board_write == 0)
		{
			/*printf("%d> msg_market_sizes message board sync start early as no agents sending any messages of this type\n", node_number);*/
			
			/* ********** sync message board here **********  */
			if(FLAME_TEST_PRINT_START_AND_END_OF_LIBMBOARD_CALLS) printf("start MB_SyncStart(b_msg_market_sizes)\n");
			rc = MB_SyncStart(b_msg_market_sizes);
			if(FLAME_TEST_PRINT_START_AND_END_OF_LIBMBOARD_CALLS) printf("finish MB_SyncStart(b_msg_market_sizes)\n");
			#ifdef ERRCHECK
			if (rc != MB_SUCCESS)
			{
			   fprintf(stderr, "ERROR: Could not start sync of 'msg_market_sizes' board\n");
			   switch(rc) {
				   case MB_ERR_INVALID:
					   fprintf(stderr, "\t reason: 'msg_market_sizes' board is invalid\n");
					   break;
				   case MB_ERR_LOCKED:
					   fprintf(stderr, "\t reason: 'msg_market_sizes' board is locked\n");
					   break;
				   case MB_ERR_MEMALLOC:
					   fprintf(stderr, "\t reason: out of memory\n");
					   break;
				   case MB_ERR_INTERNAL:
					   fprintf(stderr, "\t reason: internal error. Recompile libmoard in debug mode for more info \n");
					   break;
				   default:
					   fprintf(stderr, "\t MB_SyncStart returned error code: %d (see libmboard docs for details)\n", rc);
					   break;
			   }
			   
					   
					   exit(rc);
			   }
			   #endif
		}
		
		/* Start sync message boards that don't write */
		if(FLAME_total_subsidies_message_board_write == 0)
		{
			/*printf("%d> total_subsidies message board sync start early as no agents sending any messages of this type\n", node_number);*/
			
			/* ********** sync message board here **********  */
			if(FLAME_TEST_PRINT_START_AND_END_OF_LIBMBOARD_CALLS) printf("start MB_SyncStart(b_total_subsidies)\n");
			rc = MB_SyncStart(b_total_subsidies);
			if(FLAME_TEST_PRINT_START_AND_END_OF_LIBMBOARD_CALLS) printf("finish MB_SyncStart(b_total_subsidies)\n");
			#ifdef ERRCHECK
			if (rc != MB_SUCCESS)
			{
			   fprintf(stderr, "ERROR: Could not start sync of 'total_subsidies' board\n");
			   switch(rc) {
				   case MB_ERR_INVALID:
					   fprintf(stderr, "\t reason: 'total_subsidies' board is invalid\n");
					   break;
				   case MB_ERR_LOCKED:
					   fprintf(stderr, "\t reason: 'total_subsidies' board is locked\n");
					   break;
				   case MB_ERR_MEMALLOC:
					   fprintf(stderr, "\t reason: out of memory\n");
					   break;
				   case MB_ERR_INTERNAL:
					   fprintf(stderr, "\t reason: internal error. Recompile libmoard in debug mode for more info \n");
					   break;
				   default:
					   fprintf(stderr, "\t MB_SyncStart returned error code: %d (see libmboard docs for details)\n", rc);
					   break;
			   }
			   
					   
					   exit(rc);
			   }
			   #endif
		}
		
		/* Start sync message boards that don't write */
		if(FLAME_redistributed_subsidies_message_board_write == 0)
		{
			/*printf("%d> redistributed_subsidies message board sync start early as no agents sending any messages of this type\n", node_number);*/
			
			/* ********** sync message board here **********  */
			if(FLAME_TEST_PRINT_START_AND_END_OF_LIBMBOARD_CALLS) printf("start MB_SyncStart(b_redistributed_subsidies)\n");
			rc = MB_SyncStart(b_redistributed_subsidies);
			if(FLAME_TEST_PRINT_START_AND_END_OF_LIBMBOARD_CALLS) printf("finish MB_SyncStart(b_redistributed_subsidies)\n");
			#ifdef ERRCHECK
			if (rc != MB_SUCCESS)
			{
			   fprintf(stderr, "ERROR: Could not start sync of 'redistributed_subsidies' board\n");
			   switch(rc) {
				   case MB_ERR_INVALID:
					   fprintf(stderr, "\t reason: 'redistributed_subsidies' board is invalid\n");
					   break;
				   case MB_ERR_LOCKED:
					   fprintf(stderr, "\t reason: 'redistributed_subsidies' board is locked\n");
					   break;
				   case MB_ERR_MEMALLOC:
					   fprintf(stderr, "\t reason: out of memory\n");
					   break;
				   case MB_ERR_INTERNAL:
					   fprintf(stderr, "\t reason: internal error. Recompile libmoard in debug mode for more info \n");
					   break;
				   default:
					   fprintf(stderr, "\t MB_SyncStart returned error code: %d (see libmboard docs for details)\n", rc);
					   break;
			   }
			   
					   
					   exit(rc);
			   }
			   #endif
		}
		
		/* Start sync message boards that don't write */
		if(FLAME_quality_price_message_board_write == 0)
		{
			/*printf("%d> quality_price message board sync start early as no agents sending any messages of this type\n", node_number);*/
			
			/* ********** sync message board here **********  */
			if(FLAME_TEST_PRINT_START_AND_END_OF_LIBMBOARD_CALLS) printf("start MB_SyncStart(b_quality_price)\n");
			rc = MB_SyncStart(b_quality_price);
			if(FLAME_TEST_PRINT_START_AND_END_OF_LIBMBOARD_CALLS) printf("finish MB_SyncStart(b_quality_price)\n");
			#ifdef ERRCHECK
			if (rc != MB_SUCCESS)
			{
			   fprintf(stderr, "ERROR: Could not start sync of 'quality_price' board\n");
			   switch(rc) {
				   case MB_ERR_INVALID:
					   fprintf(stderr, "\t reason: 'quality_price' board is invalid\n");
					   break;
				   case MB_ERR_LOCKED:
					   fprintf(stderr, "\t reason: 'quality_price' board is locked\n");
					   break;
				   case MB_ERR_MEMALLOC:
					   fprintf(stderr, "\t reason: out of memory\n");
					   break;
				   case MB_ERR_INTERNAL:
					   fprintf(stderr, "\t reason: internal error. Recompile libmoard in debug mode for more info \n");
					   break;
				   default:
					   fprintf(stderr, "\t MB_SyncStart returned error code: %d (see libmboard docs for details)\n", rc);
					   break;
			   }
			   
					   
					   exit(rc);
			   }
			   #endif
		}
		
		/* Start sync message boards that don't write */
		if(FLAME_interview_request_message_board_write == 0)
		{
			/*printf("%d> interview_request message board sync start early as no agents sending any messages of this type\n", node_number);*/
			
			/* ********** sync message board here **********  */
			if(FLAME_TEST_PRINT_START_AND_END_OF_LIBMBOARD_CALLS) printf("start MB_SyncStart(b_interview_request)\n");
			rc = MB_SyncStart(b_interview_request);
			if(FLAME_TEST_PRINT_START_AND_END_OF_LIBMBOARD_CALLS) printf("finish MB_SyncStart(b_interview_request)\n");
			#ifdef ERRCHECK
			if (rc != MB_SUCCESS)
			{
			   fprintf(stderr, "ERROR: Could not start sync of 'interview_request' board\n");
			   switch(rc) {
				   case MB_ERR_INVALID:
					   fprintf(stderr, "\t reason: 'interview_request' board is invalid\n");
					   break;
				   case MB_ERR_LOCKED:
					   fprintf(stderr, "\t reason: 'interview_request' board is locked\n");
					   break;
				   case MB_ERR_MEMALLOC:
					   fprintf(stderr, "\t reason: out of memory\n");
					   break;
				   case MB_ERR_INTERNAL:
					   fprintf(stderr, "\t reason: internal error. Recompile libmoard in debug mode for more info \n");
					   break;
				   default:
					   fprintf(stderr, "\t MB_SyncStart returned error code: %d (see libmboard docs for details)\n", rc);
					   break;
			   }
			   
					   
					   exit(rc);
			   }
			   #endif
		}
		
		/* Start sync message boards that don't write */
		if(FLAME_interview_positive_response_message_board_write == 0)
		{
			/*printf("%d> interview_positive_response message board sync start early as no agents sending any messages of this type\n", node_number);*/
			
			/* ********** sync message board here **********  */
			if(FLAME_TEST_PRINT_START_AND_END_OF_LIBMBOARD_CALLS) printf("start MB_SyncStart(b_interview_positive_response)\n");
			rc = MB_SyncStart(b_interview_positive_response);
			if(FLAME_TEST_PRINT_START_AND_END_OF_LIBMBOARD_CALLS) printf("finish MB_SyncStart(b_interview_positive_response)\n");
			#ifdef ERRCHECK
			if (rc != MB_SUCCESS)
			{
			   fprintf(stderr, "ERROR: Could not start sync of 'interview_positive_response' board\n");
			   switch(rc) {
				   case MB_ERR_INVALID:
					   fprintf(stderr, "\t reason: 'interview_positive_response' board is invalid\n");
					   break;
				   case MB_ERR_LOCKED:
					   fprintf(stderr, "\t reason: 'interview_positive_response' board is locked\n");
					   break;
				   case MB_ERR_MEMALLOC:
					   fprintf(stderr, "\t reason: out of memory\n");
					   break;
				   case MB_ERR_INTERNAL:
					   fprintf(stderr, "\t reason: internal error. Recompile libmoard in debug mode for more info \n");
					   break;
				   default:
					   fprintf(stderr, "\t MB_SyncStart returned error code: %d (see libmboard docs for details)\n", rc);
					   break;
			   }
			   
					   
					   exit(rc);
			   }
			   #endif
		}
		
		/* Start sync message boards that don't write */
		if(FLAME_questionnaire_innovation_message_board_write == 0)
		{
			/*printf("%d> questionnaire_innovation message board sync start early as no agents sending any messages of this type\n", node_number);*/
			
			/* ********** sync message board here **********  */
			if(FLAME_TEST_PRINT_START_AND_END_OF_LIBMBOARD_CALLS) printf("start MB_SyncStart(b_questionnaire_innovation)\n");
			rc = MB_SyncStart(b_questionnaire_innovation);
			if(FLAME_TEST_PRINT_START_AND_END_OF_LIBMBOARD_CALLS) printf("finish MB_SyncStart(b_questionnaire_innovation)\n");
			#ifdef ERRCHECK
			if (rc != MB_SUCCESS)
			{
			   fprintf(stderr, "ERROR: Could not start sync of 'questionnaire_innovation' board\n");
			   switch(rc) {
				   case MB_ERR_INVALID:
					   fprintf(stderr, "\t reason: 'questionnaire_innovation' board is invalid\n");
					   break;
				   case MB_ERR_LOCKED:
					   fprintf(stderr, "\t reason: 'questionnaire_innovation' board is locked\n");
					   break;
				   case MB_ERR_MEMALLOC:
					   fprintf(stderr, "\t reason: out of memory\n");
					   break;
				   case MB_ERR_INTERNAL:
					   fprintf(stderr, "\t reason: internal error. Recompile libmoard in debug mode for more info \n");
					   break;
				   default:
					   fprintf(stderr, "\t MB_SyncStart returned error code: %d (see libmboard docs for details)\n", rc);
					   break;
			   }
			   
					   
					   exit(rc);
			   }
			   #endif
		}
		
		/* Start sync message boards that don't write */
		if(FLAME_filled_out_questionnaire_product_innovation_message_board_write == 0)
		{
			/*printf("%d> filled_out_questionnaire_product_innovation message board sync start early as no agents sending any messages of this type\n", node_number);*/
			
			/* ********** sync message board here **********  */
			if(FLAME_TEST_PRINT_START_AND_END_OF_LIBMBOARD_CALLS) printf("start MB_SyncStart(b_filled_out_questionnaire_product_innovation)\n");
			rc = MB_SyncStart(b_filled_out_questionnaire_product_innovation);
			if(FLAME_TEST_PRINT_START_AND_END_OF_LIBMBOARD_CALLS) printf("finish MB_SyncStart(b_filled_out_questionnaire_product_innovation)\n");
			#ifdef ERRCHECK
			if (rc != MB_SUCCESS)
			{
			   fprintf(stderr, "ERROR: Could not start sync of 'filled_out_questionnaire_product_innovation' board\n");
			   switch(rc) {
				   case MB_ERR_INVALID:
					   fprintf(stderr, "\t reason: 'filled_out_questionnaire_product_innovation' board is invalid\n");
					   break;
				   case MB_ERR_LOCKED:
					   fprintf(stderr, "\t reason: 'filled_out_questionnaire_product_innovation' board is locked\n");
					   break;
				   case MB_ERR_MEMALLOC:
					   fprintf(stderr, "\t reason: out of memory\n");
					   break;
				   case MB_ERR_INTERNAL:
					   fprintf(stderr, "\t reason: internal error. Recompile libmoard in debug mode for more info \n");
					   break;
				   default:
					   fprintf(stderr, "\t MB_SyncStart returned error code: %d (see libmboard docs for details)\n", rc);
					   break;
			   }
			   
					   
					   exit(rc);
			   }
			   #endif
		}
		
		

	if(FLAME_TEST_PRINT_START_AND_END_OF_MODEL_FUNCTIONS) printf("start Firm_send_id_to_malls\n");
	current_xmachine_Firm_holder = Firm_start_Firm_state->agents;
	while(current_xmachine_Firm_holder)
	{
		temp_xmachine_Firm_holder = current_xmachine_Firm_holder->next;
		current_xmachine_Firm = current_xmachine_Firm_holder->agent;
		current_xmachine_Firm_next_state = Firm_Firm_initialize_state;
		/* For backwards compatibility set current_xmachine */
		current_xmachine->xmachine_Firm = NULL;
		current_xmachine->xmachine_Household = NULL;
		current_xmachine->xmachine_Mall = NULL;
		current_xmachine->xmachine_IGFirm = NULL;
		current_xmachine->xmachine_Eurostat = NULL;
		current_xmachine->xmachine_Bank = NULL;
		current_xmachine->xmachine_Government = NULL;
		current_xmachine->xmachine_CentralBank = NULL;
		current_xmachine->xmachine_ClearingHouse = NULL;
		current_xmachine->xmachine_Firm = current_xmachine_Firm;

		if(FLAME_condition_Firm_Firm_send_id_to_malls_start_Firm_Firm_initialize(current_xmachine_Firm)==1)
		{

		

			i = Firm_send_id_to_malls();

		

			if(i == 1)
			{
				free_Firm_agent(current_xmachine_Firm_holder, Firm_start_Firm_state);
			}
			else
			{
				transition_Firm_agent(current_xmachine_Firm_holder, Firm_start_Firm_state, Firm_Firm_initialize_state);
			}
		}

		current_xmachine_Firm = NULL;

		current_xmachine_Firm_holder = temp_xmachine_Firm_holder;
	}
	if(FLAME_TEST_PRINT_START_AND_END_OF_MODEL_FUNCTIONS) printf("finish Firm_send_id_to_malls\n");

	if(FLAME_msg_firm_id_to_malls_message_board_write == 1)
	{

		if(FLAME_TEST_PRINT_START_AND_END_OF_LIBMBOARD_CALLS) printf("start MB_SyncStart(b_msg_firm_id_to_malls)\n");
		rc = MB_SyncStart(b_msg_firm_id_to_malls);
		if(FLAME_TEST_PRINT_START_AND_END_OF_LIBMBOARD_CALLS) printf("finish MB_SyncStart(b_msg_firm_id_to_malls)\n");
		#ifdef ERRCHECK
		if (rc != MB_SUCCESS)
		{
		   fprintf(stderr, "ERROR: Could not start sync of 'msg_firm_id_to_malls' board\n");
		   switch(rc) {
			   case MB_ERR_INVALID:
				   fprintf(stderr, "\t reason: 'msg_firm_id_to_malls' board is invalid\n");
				   break;
			   case MB_ERR_LOCKED:
				   fprintf(stderr, "\t reason: 'msg_firm_id_to_malls' board is locked\n");
				   break;
			   case MB_ERR_MEMALLOC:
				   fprintf(stderr, "\t reason: out of memory\n");
				   break;
			   case MB_ERR_INTERNAL:
				   fprintf(stderr, "\t reason: internal error. Recompile libmoard in debug mode for more info \n");
				   break;
			   default:
				   fprintf(stderr, "\t MB_SyncStart returned error code: %d (see libmboard docs for details)\n", rc);
				   break;
		   }

			
			exit(rc);
		}
		#endif
    }
    


	if(FLAME_TEST_PRINT_START_AND_END_OF_MODEL_FUNCTIONS) printf("start Mall_send_id_to_firms\n");
	current_xmachine_Mall_holder = Mall_start_Mall_state->agents;
	while(current_xmachine_Mall_holder)
	{
		temp_xmachine_Mall_holder = current_xmachine_Mall_holder->next;
		current_xmachine_Mall = current_xmachine_Mall_holder->agent;
		current_xmachine_Mall_next_state = Mall_Mall_initialize_state;
		/* For backwards compatibility set current_xmachine */
		current_xmachine->xmachine_Firm = NULL;
		current_xmachine->xmachine_Household = NULL;
		current_xmachine->xmachine_Mall = NULL;
		current_xmachine->xmachine_IGFirm = NULL;
		current_xmachine->xmachine_Eurostat = NULL;
		current_xmachine->xmachine_Bank = NULL;
		current_xmachine->xmachine_Government = NULL;
		current_xmachine->xmachine_CentralBank = NULL;
		current_xmachine->xmachine_ClearingHouse = NULL;
		current_xmachine->xmachine_Mall = current_xmachine_Mall;

		if(FLAME_condition_Mall_Mall_send_id_to_firms_start_Mall_Mall_initialize(current_xmachine_Mall)==1)
		{

		

			i = Mall_send_id_to_firms();

		

			if(i == 1)
			{
				free_Mall_agent(current_xmachine_Mall_holder, Mall_start_Mall_state);
			}
			else
			{
				transition_Mall_agent(current_xmachine_Mall_holder, Mall_start_Mall_state, Mall_Mall_initialize_state);
			}
		}

		current_xmachine_Mall = NULL;

		current_xmachine_Mall_holder = temp_xmachine_Mall_holder;
	}
	if(FLAME_TEST_PRINT_START_AND_END_OF_MODEL_FUNCTIONS) printf("finish Mall_send_id_to_firms\n");

	if(FLAME_msg_mall_id_to_firms_message_board_write == 1)
	{

		if(FLAME_TEST_PRINT_START_AND_END_OF_LIBMBOARD_CALLS) printf("start MB_SyncStart(b_msg_mall_id_to_firms)\n");
		rc = MB_SyncStart(b_msg_mall_id_to_firms);
		if(FLAME_TEST_PRINT_START_AND_END_OF_LIBMBOARD_CALLS) printf("finish MB_SyncStart(b_msg_mall_id_to_firms)\n");
		#ifdef ERRCHECK
		if (rc != MB_SUCCESS)
		{
		   fprintf(stderr, "ERROR: Could not start sync of 'msg_mall_id_to_firms' board\n");
		   switch(rc) {
			   case MB_ERR_INVALID:
				   fprintf(stderr, "\t reason: 'msg_mall_id_to_firms' board is invalid\n");
				   break;
			   case MB_ERR_LOCKED:
				   fprintf(stderr, "\t reason: 'msg_mall_id_to_firms' board is locked\n");
				   break;
			   case MB_ERR_MEMALLOC:
				   fprintf(stderr, "\t reason: out of memory\n");
				   break;
			   case MB_ERR_INTERNAL:
				   fprintf(stderr, "\t reason: internal error. Recompile libmoard in debug mode for more info \n");
				   break;
			   default:
				   fprintf(stderr, "\t MB_SyncStart returned error code: %d (see libmboard docs for details)\n", rc);
				   break;
		   }

			
			exit(rc);
		}
		#endif
    }
    


	if(FLAME_TEST_PRINT_START_AND_END_OF_MODEL_FUNCTIONS) printf("start ClearingHouse_send_index_info\n");
	current_xmachine_ClearingHouse_holder = ClearingHouse_start_Clearinghouse_state->agents;
	while(current_xmachine_ClearingHouse_holder)
	{
		temp_xmachine_ClearingHouse_holder = current_xmachine_ClearingHouse_holder->next;
		current_xmachine_ClearingHouse = current_xmachine_ClearingHouse_holder->agent;
		current_xmachine_ClearingHouse_next_state = ClearingHouse_AFM_00_state;
		/* For backwards compatibility set current_xmachine */
		current_xmachine->xmachine_Firm = NULL;
		current_xmachine->xmachine_Household = NULL;
		current_xmachine->xmachine_Mall = NULL;
		current_xmachine->xmachine_IGFirm = NULL;
		current_xmachine->xmachine_Eurostat = NULL;
		current_xmachine->xmachine_Bank = NULL;
		current_xmachine->xmachine_Government = NULL;
		current_xmachine->xmachine_CentralBank = NULL;
		current_xmachine->xmachine_ClearingHouse = NULL;
		current_xmachine->xmachine_ClearingHouse = current_xmachine_ClearingHouse;

		if(FLAME_condition_ClearingHouse_ClearingHouse_send_index_info_start_Clearinghouse_AFM_00(current_xmachine_ClearingHouse)==1)
		{

		

			i = ClearingHouse_send_index_info();

		

			if(i == 1)
			{
				free_ClearingHouse_agent(current_xmachine_ClearingHouse_holder, ClearingHouse_start_Clearinghouse_state);
			}
			else
			{
				transition_ClearingHouse_agent(current_xmachine_ClearingHouse_holder, ClearingHouse_start_Clearinghouse_state, ClearingHouse_AFM_00_state);
			}
		}

		current_xmachine_ClearingHouse = NULL;

		current_xmachine_ClearingHouse_holder = temp_xmachine_ClearingHouse_holder;
	}
	if(FLAME_TEST_PRINT_START_AND_END_OF_MODEL_FUNCTIONS) printf("finish ClearingHouse_send_index_info\n");

	if(FLAME_index_info_message_board_write == 1)
	{

		if(FLAME_TEST_PRINT_START_AND_END_OF_LIBMBOARD_CALLS) printf("start MB_SyncStart(b_index_info)\n");
		rc = MB_SyncStart(b_index_info);
		if(FLAME_TEST_PRINT_START_AND_END_OF_LIBMBOARD_CALLS) printf("finish MB_SyncStart(b_index_info)\n");
		#ifdef ERRCHECK
		if (rc != MB_SUCCESS)
		{
		   fprintf(stderr, "ERROR: Could not start sync of 'index_info' board\n");
		   switch(rc) {
			   case MB_ERR_INVALID:
				   fprintf(stderr, "\t reason: 'index_info' board is invalid\n");
				   break;
			   case MB_ERR_LOCKED:
				   fprintf(stderr, "\t reason: 'index_info' board is locked\n");
				   break;
			   case MB_ERR_MEMALLOC:
				   fprintf(stderr, "\t reason: out of memory\n");
				   break;
			   case MB_ERR_INTERNAL:
				   fprintf(stderr, "\t reason: internal error. Recompile libmoard in debug mode for more info \n");
				   break;
			   default:
				   fprintf(stderr, "\t MB_SyncStart returned error code: %d (see libmboard docs for details)\n", rc);
				   break;
		   }

			
			exit(rc);
		}
		#endif
    }
    


	if(FLAME_TEST_PRINT_START_AND_END_OF_MODEL_FUNCTIONS) printf("start idle\n");
	current_xmachine_ClearingHouse_holder = ClearingHouse_start_Clearinghouse_state->agents;
	while(current_xmachine_ClearingHouse_holder)
	{
		temp_xmachine_ClearingHouse_holder = current_xmachine_ClearingHouse_holder->next;
		current_xmachine_ClearingHouse = current_xmachine_ClearingHouse_holder->agent;
		current_xmachine_ClearingHouse_next_state = ClearingHouse_AFM_00_state;
		/* For backwards compatibility set current_xmachine */
		current_xmachine->xmachine_Firm = NULL;
		current_xmachine->xmachine_Household = NULL;
		current_xmachine->xmachine_Mall = NULL;
		current_xmachine->xmachine_IGFirm = NULL;
		current_xmachine->xmachine_Eurostat = NULL;
		current_xmachine->xmachine_Bank = NULL;
		current_xmachine->xmachine_Government = NULL;
		current_xmachine->xmachine_CentralBank = NULL;
		current_xmachine->xmachine_ClearingHouse = NULL;
		current_xmachine->xmachine_ClearingHouse = current_xmachine_ClearingHouse;

		if(FLAME_condition_ClearingHouse_idle_start_Clearinghouse_AFM_00(current_xmachine_ClearingHouse)==1)
		{

		

			i = idle();

		

			if(i == 1)
			{
				free_ClearingHouse_agent(current_xmachine_ClearingHouse_holder, ClearingHouse_start_Clearinghouse_state);
			}
			else
			{
				transition_ClearingHouse_agent(current_xmachine_ClearingHouse_holder, ClearingHouse_start_Clearinghouse_state, ClearingHouse_AFM_00_state);
			}
		}

		current_xmachine_ClearingHouse = NULL;

		current_xmachine_ClearingHouse_holder = temp_xmachine_ClearingHouse_holder;
	}
	if(FLAME_TEST_PRINT_START_AND_END_OF_MODEL_FUNCTIONS) printf("finish idle\n");


	if(FLAME_TEST_PRINT_START_AND_END_OF_MODEL_FUNCTIONS) printf("start idle\n");
	current_xmachine_CentralBank_holder = CentralBank_start_Central_Bank_state->agents;
	while(current_xmachine_CentralBank_holder)
	{
		temp_xmachine_CentralBank_holder = current_xmachine_CentralBank_holder->next;
		current_xmachine_CentralBank = current_xmachine_CentralBank_holder->agent;
		current_xmachine_CentralBank_next_state = CentralBank_CB_market_operations_state;
		/* For backwards compatibility set current_xmachine */
		current_xmachine->xmachine_Firm = NULL;
		current_xmachine->xmachine_Household = NULL;
		current_xmachine->xmachine_Mall = NULL;
		current_xmachine->xmachine_IGFirm = NULL;
		current_xmachine->xmachine_Eurostat = NULL;
		current_xmachine->xmachine_Bank = NULL;
		current_xmachine->xmachine_Government = NULL;
		current_xmachine->xmachine_CentralBank = NULL;
		current_xmachine->xmachine_ClearingHouse = NULL;
		current_xmachine->xmachine_CentralBank = current_xmachine_CentralBank;

		if(FLAME_condition_CentralBank_idle_start_Central_Bank_CB_market_operations(current_xmachine_CentralBank)==1)
		{

		

			i = idle();

		

			if(i == 1)
			{
				free_CentralBank_agent(current_xmachine_CentralBank_holder, CentralBank_start_Central_Bank_state);
			}
			else
			{
				transition_CentralBank_agent(current_xmachine_CentralBank_holder, CentralBank_start_Central_Bank_state, CentralBank_CB_market_operations_state);
			}
		}

		current_xmachine_CentralBank = NULL;

		current_xmachine_CentralBank_holder = temp_xmachine_CentralBank_holder;
	}
	if(FLAME_TEST_PRINT_START_AND_END_OF_MODEL_FUNCTIONS) printf("finish idle\n");


	if(FLAME_TEST_PRINT_START_AND_END_OF_MODEL_FUNCTIONS) printf("start Central_Bank_reset_variables\n");
	current_xmachine_CentralBank_holder = CentralBank_start_Central_Bank_state->agents;
	while(current_xmachine_CentralBank_holder)
	{
		temp_xmachine_CentralBank_holder = current_xmachine_CentralBank_holder->next;
		current_xmachine_CentralBank = current_xmachine_CentralBank_holder->agent;
		current_xmachine_CentralBank_next_state = CentralBank_CB_reset_state;
		/* For backwards compatibility set current_xmachine */
		current_xmachine->xmachine_Firm = NULL;
		current_xmachine->xmachine_Household = NULL;
		current_xmachine->xmachine_Mall = NULL;
		current_xmachine->xmachine_IGFirm = NULL;
		current_xmachine->xmachine_Eurostat = NULL;
		current_xmachine->xmachine_Bank = NULL;
		current_xmachine->xmachine_Government = NULL;
		current_xmachine->xmachine_CentralBank = NULL;
		current_xmachine->xmachine_ClearingHouse = NULL;
		current_xmachine->xmachine_CentralBank = current_xmachine_CentralBank;

		if(FLAME_condition_CentralBank_Central_Bank_reset_variables_start_Central_Bank_CB_reset(current_xmachine_CentralBank)==1)
		{

		

			i = Central_Bank_reset_variables();

		

			if(i == 1)
			{
				free_CentralBank_agent(current_xmachine_CentralBank_holder, CentralBank_start_Central_Bank_state);
			}
			else
			{
				transition_CentralBank_agent(current_xmachine_CentralBank_holder, CentralBank_start_Central_Bank_state, CentralBank_CB_reset_state);
			}
		}

		current_xmachine_CentralBank = NULL;

		current_xmachine_CentralBank_holder = temp_xmachine_CentralBank_holder;
	}
	if(FLAME_TEST_PRINT_START_AND_END_OF_MODEL_FUNCTIONS) printf("finish Central_Bank_reset_variables\n");


	if(FLAME_TEST_PRINT_START_AND_END_OF_MODEL_FUNCTIONS) printf("start idle\n");
	current_xmachine_Government_holder = Government_start_Government_state->agents;
	while(current_xmachine_Government_holder)
	{
		temp_xmachine_Government_holder = current_xmachine_Government_holder->next;
		current_xmachine_Government = current_xmachine_Government_holder->agent;
		current_xmachine_Government_next_state = Government_Government_Start_Monthly_Loop_Top_state;
		/* For backwards compatibility set current_xmachine */
		current_xmachine->xmachine_Firm = NULL;
		current_xmachine->xmachine_Household = NULL;
		current_xmachine->xmachine_Mall = NULL;
		current_xmachine->xmachine_IGFirm = NULL;
		current_xmachine->xmachine_Eurostat = NULL;
		current_xmachine->xmachine_Bank = NULL;
		current_xmachine->xmachine_Government = NULL;
		current_xmachine->xmachine_CentralBank = NULL;
		current_xmachine->xmachine_ClearingHouse = NULL;
		current_xmachine->xmachine_Government = current_xmachine_Government;

		if(FLAME_condition_Government_idle_start_Government_Government_Start_Monthly_Loop_Top(current_xmachine_Government)==1)
		{

		

			i = idle();

		

			if(i == 1)
			{
				free_Government_agent(current_xmachine_Government_holder, Government_start_Government_state);
			}
			else
			{
				transition_Government_agent(current_xmachine_Government_holder, Government_start_Government_state, Government_Government_Start_Monthly_Loop_Top_state);
			}
		}

		current_xmachine_Government = NULL;

		current_xmachine_Government_holder = temp_xmachine_Government_holder;
	}
	if(FLAME_TEST_PRINT_START_AND_END_OF_MODEL_FUNCTIONS) printf("finish idle\n");


	if(FLAME_TEST_PRINT_START_AND_END_OF_MODEL_FUNCTIONS) printf("start Government_initialization\n");
	current_xmachine_Government_holder = Government_start_Government_state->agents;
	while(current_xmachine_Government_holder)
	{
		temp_xmachine_Government_holder = current_xmachine_Government_holder->next;
		current_xmachine_Government = current_xmachine_Government_holder->agent;
		current_xmachine_Government_next_state = Government_Government_Start_Monthly_Loop_Top_state;
		/* For backwards compatibility set current_xmachine */
		current_xmachine->xmachine_Firm = NULL;
		current_xmachine->xmachine_Household = NULL;
		current_xmachine->xmachine_Mall = NULL;
		current_xmachine->xmachine_IGFirm = NULL;
		current_xmachine->xmachine_Eurostat = NULL;
		current_xmachine->xmachine_Bank = NULL;
		current_xmachine->xmachine_Government = NULL;
		current_xmachine->xmachine_CentralBank = NULL;
		current_xmachine->xmachine_ClearingHouse = NULL;
		current_xmachine->xmachine_Government = current_xmachine_Government;

		if(FLAME_condition_Government_Government_initialization_start_Government_Government_Start_Monthly_Loop_Top(current_xmachine_Government)==1)
		{

		

			i = Government_initialization();

		

			if(i == 1)
			{
				free_Government_agent(current_xmachine_Government_holder, Government_start_Government_state);
			}
			else
			{
				transition_Government_agent(current_xmachine_Government_holder, Government_start_Government_state, Government_Government_Start_Monthly_Loop_Top_state);
			}
		}

		current_xmachine_Government = NULL;

		current_xmachine_Government_holder = temp_xmachine_Government_holder;
	}
	if(FLAME_TEST_PRINT_START_AND_END_OF_MODEL_FUNCTIONS) printf("finish Government_initialization\n");


	if(FLAME_TEST_PRINT_START_AND_END_OF_MODEL_FUNCTIONS) printf("start idle\n");
	current_xmachine_Bank_holder = Bank_start_Bank_state->agents;
	while(current_xmachine_Bank_holder)
	{
		temp_xmachine_Bank_holder = current_xmachine_Bank_holder->next;
		current_xmachine_Bank = current_xmachine_Bank_holder->agent;
		current_xmachine_Bank_next_state = Bank_Bank_update_policy_rate_state;
		/* For backwards compatibility set current_xmachine */
		current_xmachine->xmachine_Firm = NULL;
		current_xmachine->xmachine_Household = NULL;
		current_xmachine->xmachine_Mall = NULL;
		current_xmachine->xmachine_IGFirm = NULL;
		current_xmachine->xmachine_Eurostat = NULL;
		current_xmachine->xmachine_Bank = NULL;
		current_xmachine->xmachine_Government = NULL;
		current_xmachine->xmachine_CentralBank = NULL;
		current_xmachine->xmachine_ClearingHouse = NULL;
		current_xmachine->xmachine_Bank = current_xmachine_Bank;

		if(FLAME_condition_Bank_idle_start_Bank_Bank_update_policy_rate(current_xmachine_Bank)==1)
		{

		

			i = idle();

		

			if(i == 1)
			{
				free_Bank_agent(current_xmachine_Bank_holder, Bank_start_Bank_state);
			}
			else
			{
				transition_Bank_agent(current_xmachine_Bank_holder, Bank_start_Bank_state, Bank_Bank_update_policy_rate_state);
			}
		}

		current_xmachine_Bank = NULL;

		current_xmachine_Bank_holder = temp_xmachine_Bank_holder;
	}
	if(FLAME_TEST_PRINT_START_AND_END_OF_MODEL_FUNCTIONS) printf("finish idle\n");


	if(FLAME_TEST_PRINT_START_AND_END_OF_MODEL_FUNCTIONS) printf("start idle\n");
	current_xmachine_Eurostat_holder = Eurostat_start_Eurostat_state->agents;
	while(current_xmachine_Eurostat_holder)
	{
		temp_xmachine_Eurostat_holder = current_xmachine_Eurostat_holder->next;
		current_xmachine_Eurostat = current_xmachine_Eurostat_holder->agent;
		current_xmachine_Eurostat_next_state = Eurostat_00_state;
		/* For backwards compatibility set current_xmachine */
		current_xmachine->xmachine_Firm = NULL;
		current_xmachine->xmachine_Household = NULL;
		current_xmachine->xmachine_Mall = NULL;
		current_xmachine->xmachine_IGFirm = NULL;
		current_xmachine->xmachine_Eurostat = NULL;
		current_xmachine->xmachine_Bank = NULL;
		current_xmachine->xmachine_Government = NULL;
		current_xmachine->xmachine_CentralBank = NULL;
		current_xmachine->xmachine_ClearingHouse = NULL;
		current_xmachine->xmachine_Eurostat = current_xmachine_Eurostat;

		if(FLAME_condition_Eurostat_idle_start_Eurostat_00(current_xmachine_Eurostat)==1)
		{

		

			i = idle();

		

			if(i == 1)
			{
				free_Eurostat_agent(current_xmachine_Eurostat_holder, Eurostat_start_Eurostat_state);
			}
			else
			{
				transition_Eurostat_agent(current_xmachine_Eurostat_holder, Eurostat_start_Eurostat_state, Eurostat_00_state);
			}
		}

		current_xmachine_Eurostat = NULL;

		current_xmachine_Eurostat_holder = temp_xmachine_Eurostat_holder;
	}
	if(FLAME_TEST_PRINT_START_AND_END_OF_MODEL_FUNCTIONS) printf("finish idle\n");


	if(FLAME_TEST_PRINT_START_AND_END_OF_MODEL_FUNCTIONS) printf("start Eurostat_initialization\n");
	current_xmachine_Eurostat_holder = Eurostat_start_Eurostat_state->agents;
	while(current_xmachine_Eurostat_holder)
	{
		temp_xmachine_Eurostat_holder = current_xmachine_Eurostat_holder->next;
		current_xmachine_Eurostat = current_xmachine_Eurostat_holder->agent;
		current_xmachine_Eurostat_next_state = Eurostat_00_state;
		/* For backwards compatibility set current_xmachine */
		current_xmachine->xmachine_Firm = NULL;
		current_xmachine->xmachine_Household = NULL;
		current_xmachine->xmachine_Mall = NULL;
		current_xmachine->xmachine_IGFirm = NULL;
		current_xmachine->xmachine_Eurostat = NULL;
		current_xmachine->xmachine_Bank = NULL;
		current_xmachine->xmachine_Government = NULL;
		current_xmachine->xmachine_CentralBank = NULL;
		current_xmachine->xmachine_ClearingHouse = NULL;
		current_xmachine->xmachine_Eurostat = current_xmachine_Eurostat;

		if(FLAME_condition_Eurostat_Eurostat_initialization_start_Eurostat_00(current_xmachine_Eurostat)==1)
		{

		

			i = Eurostat_initialization();

		

			if(i == 1)
			{
				free_Eurostat_agent(current_xmachine_Eurostat_holder, Eurostat_start_Eurostat_state);
			}
			else
			{
				transition_Eurostat_agent(current_xmachine_Eurostat_holder, Eurostat_start_Eurostat_state, Eurostat_00_state);
			}
		}

		current_xmachine_Eurostat = NULL;

		current_xmachine_Eurostat_holder = temp_xmachine_Eurostat_holder;
	}
	if(FLAME_TEST_PRINT_START_AND_END_OF_MODEL_FUNCTIONS) printf("finish Eurostat_initialization\n");


	if(FLAME_TEST_PRINT_START_AND_END_OF_MODEL_FUNCTIONS) printf("start idle\n");
	current_xmachine_IGFirm_holder = IGFirm_IGFirm_start_state->agents;
	while(current_xmachine_IGFirm_holder)
	{
		temp_xmachine_IGFirm_holder = current_xmachine_IGFirm_holder->next;
		current_xmachine_IGFirm = current_xmachine_IGFirm_holder->agent;
		current_xmachine_IGFirm_next_state = IGFirm_IGFirm_interest_state;
		/* For backwards compatibility set current_xmachine */
		current_xmachine->xmachine_Firm = NULL;
		current_xmachine->xmachine_Household = NULL;
		current_xmachine->xmachine_Mall = NULL;
		current_xmachine->xmachine_IGFirm = NULL;
		current_xmachine->xmachine_Eurostat = NULL;
		current_xmachine->xmachine_Bank = NULL;
		current_xmachine->xmachine_Government = NULL;
		current_xmachine->xmachine_CentralBank = NULL;
		current_xmachine->xmachine_ClearingHouse = NULL;
		current_xmachine->xmachine_IGFirm = current_xmachine_IGFirm;

		if(FLAME_condition_IGFirm_idle_IGFirm_start_IGFirm_interest(current_xmachine_IGFirm)==1)
		{

		

			i = idle();

		

			if(i == 1)
			{
				free_IGFirm_agent(current_xmachine_IGFirm_holder, IGFirm_IGFirm_start_state);
			}
			else
			{
				transition_IGFirm_agent(current_xmachine_IGFirm_holder, IGFirm_IGFirm_start_state, IGFirm_IGFirm_interest_state);
			}
		}

		current_xmachine_IGFirm = NULL;

		current_xmachine_IGFirm_holder = temp_xmachine_IGFirm_holder;
	}
	if(FLAME_TEST_PRINT_START_AND_END_OF_MODEL_FUNCTIONS) printf("finish idle\n");


	if(FLAME_TEST_PRINT_START_AND_END_OF_MODEL_FUNCTIONS) printf("start IGFirm_reset_variables\n");
	current_xmachine_IGFirm_holder = IGFirm_IGFirm_start_state->agents;
	while(current_xmachine_IGFirm_holder)
	{
		temp_xmachine_IGFirm_holder = current_xmachine_IGFirm_holder->next;
		current_xmachine_IGFirm = current_xmachine_IGFirm_holder->agent;
		current_xmachine_IGFirm_next_state = IGFirm_IGFirm_init_01_state;
		/* For backwards compatibility set current_xmachine */
		current_xmachine->xmachine_Firm = NULL;
		current_xmachine->xmachine_Household = NULL;
		current_xmachine->xmachine_Mall = NULL;
		current_xmachine->xmachine_IGFirm = NULL;
		current_xmachine->xmachine_Eurostat = NULL;
		current_xmachine->xmachine_Bank = NULL;
		current_xmachine->xmachine_Government = NULL;
		current_xmachine->xmachine_CentralBank = NULL;
		current_xmachine->xmachine_ClearingHouse = NULL;
		current_xmachine->xmachine_IGFirm = current_xmachine_IGFirm;

		if(FLAME_condition_IGFirm_IGFirm_reset_variables_IGFirm_start_IGFirm_init_01(current_xmachine_IGFirm)==1)
		{

		

			i = IGFirm_reset_variables();

		

			if(i == 1)
			{
				free_IGFirm_agent(current_xmachine_IGFirm_holder, IGFirm_IGFirm_start_state);
			}
			else
			{
				transition_IGFirm_agent(current_xmachine_IGFirm_holder, IGFirm_IGFirm_start_state, IGFirm_IGFirm_init_01_state);
			}
		}

		current_xmachine_IGFirm = NULL;

		current_xmachine_IGFirm_holder = temp_xmachine_IGFirm_holder;
	}
	if(FLAME_TEST_PRINT_START_AND_END_OF_MODEL_FUNCTIONS) printf("finish IGFirm_reset_variables\n");


	if(FLAME_TEST_PRINT_START_AND_END_OF_MODEL_FUNCTIONS) printf("start idle\n");
	current_xmachine_Mall_holder = Mall_start_Mall_state->agents;
	while(current_xmachine_Mall_holder)
	{
		temp_xmachine_Mall_holder = current_xmachine_Mall_holder->next;
		current_xmachine_Mall = current_xmachine_Mall_holder->agent;
		current_xmachine_Mall_next_state = Mall_001_state;
		/* For backwards compatibility set current_xmachine */
		current_xmachine->xmachine_Firm = NULL;
		current_xmachine->xmachine_Household = NULL;
		current_xmachine->xmachine_Mall = NULL;
		current_xmachine->xmachine_IGFirm = NULL;
		current_xmachine->xmachine_Eurostat = NULL;
		current_xmachine->xmachine_Bank = NULL;
		current_xmachine->xmachine_Government = NULL;
		current_xmachine->xmachine_CentralBank = NULL;
		current_xmachine->xmachine_ClearingHouse = NULL;
		current_xmachine->xmachine_Mall = current_xmachine_Mall;

		if(FLAME_condition_Mall_idle_start_Mall_001(current_xmachine_Mall)==1)
		{

		

			i = idle();

		

			if(i == 1)
			{
				free_Mall_agent(current_xmachine_Mall_holder, Mall_start_Mall_state);
			}
			else
			{
				transition_Mall_agent(current_xmachine_Mall_holder, Mall_start_Mall_state, Mall_001_state);
			}
		}

		current_xmachine_Mall = NULL;

		current_xmachine_Mall_holder = temp_xmachine_Mall_holder;
	}
	if(FLAME_TEST_PRINT_START_AND_END_OF_MODEL_FUNCTIONS) printf("finish idle\n");


	if(FLAME_TEST_PRINT_START_AND_END_OF_MODEL_FUNCTIONS) printf("start idle\n");
	current_xmachine_Household_holder = Household_start_Household_state->agents;
	while(current_xmachine_Household_holder)
	{
		temp_xmachine_Household_holder = current_xmachine_Household_holder->next;
		current_xmachine_Household = current_xmachine_Household_holder->agent;
		current_xmachine_Household_next_state = Household_Household_initialize_state;
		/* For backwards compatibility set current_xmachine */
		current_xmachine->xmachine_Firm = NULL;
		current_xmachine->xmachine_Household = NULL;
		current_xmachine->xmachine_Mall = NULL;
		current_xmachine->xmachine_IGFirm = NULL;
		current_xmachine->xmachine_Eurostat = NULL;
		current_xmachine->xmachine_Bank = NULL;
		current_xmachine->xmachine_Government = NULL;
		current_xmachine->xmachine_CentralBank = NULL;
		current_xmachine->xmachine_ClearingHouse = NULL;
		current_xmachine->xmachine_Household = current_xmachine_Household;

		if(FLAME_condition_Household_idle_start_Household_Household_initialize(current_xmachine_Household)==1)
		{

		

			i = idle();

		

			if(i == 1)
			{
				free_Household_agent(current_xmachine_Household_holder, Household_start_Household_state);
			}
			else
			{
				transition_Household_agent(current_xmachine_Household_holder, Household_start_Household_state, Household_Household_initialize_state);
			}
		}

		current_xmachine_Household = NULL;

		current_xmachine_Household_holder = temp_xmachine_Household_holder;
	}
	if(FLAME_TEST_PRINT_START_AND_END_OF_MODEL_FUNCTIONS) printf("finish idle\n");


	if(FLAME_TEST_PRINT_START_AND_END_OF_MODEL_FUNCTIONS) printf("start Household_reset_variables\n");
	current_xmachine_Household_holder = Household_start_Household_state->agents;
	while(current_xmachine_Household_holder)
	{
		temp_xmachine_Household_holder = current_xmachine_Household_holder->next;
		current_xmachine_Household = current_xmachine_Household_holder->agent;
		current_xmachine_Household_next_state = Household_Household_initialize_state;
		/* For backwards compatibility set current_xmachine */
		current_xmachine->xmachine_Firm = NULL;
		current_xmachine->xmachine_Household = NULL;
		current_xmachine->xmachine_Mall = NULL;
		current_xmachine->xmachine_IGFirm = NULL;
		current_xmachine->xmachine_Eurostat = NULL;
		current_xmachine->xmachine_Bank = NULL;
		current_xmachine->xmachine_Government = NULL;
		current_xmachine->xmachine_CentralBank = NULL;
		current_xmachine->xmachine_ClearingHouse = NULL;
		current_xmachine->xmachine_Household = current_xmachine_Household;

		if(FLAME_condition_Household_Household_reset_variables_start_Household_Household_initialize(current_xmachine_Household)==1)
		{

		

			i = Household_reset_variables();

		

			if(i == 1)
			{
				free_Household_agent(current_xmachine_Household_holder, Household_start_Household_state);
			}
			else
			{
				transition_Household_agent(current_xmachine_Household_holder, Household_start_Household_state, Household_Household_initialize_state);
			}
		}

		current_xmachine_Household = NULL;

		current_xmachine_Household_holder = temp_xmachine_Household_holder;
	}
	if(FLAME_TEST_PRINT_START_AND_END_OF_MODEL_FUNCTIONS) printf("finish Household_reset_variables\n");


	if(FLAME_TEST_PRINT_START_AND_END_OF_MODEL_FUNCTIONS) printf("start idle\n");
	current_xmachine_Firm_holder = Firm_start_Firm_state->agents;
	while(current_xmachine_Firm_holder)
	{
		temp_xmachine_Firm_holder = current_xmachine_Firm_holder->next;
		current_xmachine_Firm = current_xmachine_Firm_holder->agent;
		current_xmachine_Firm_next_state = Firm_Firm_reset_state;
		/* For backwards compatibility set current_xmachine */
		current_xmachine->xmachine_Firm = NULL;
		current_xmachine->xmachine_Household = NULL;
		current_xmachine->xmachine_Mall = NULL;
		current_xmachine->xmachine_IGFirm = NULL;
		current_xmachine->xmachine_Eurostat = NULL;
		current_xmachine->xmachine_Bank = NULL;
		current_xmachine->xmachine_Government = NULL;
		current_xmachine->xmachine_CentralBank = NULL;
		current_xmachine->xmachine_ClearingHouse = NULL;
		current_xmachine->xmachine_Firm = current_xmachine_Firm;

		if(FLAME_condition_Firm_idle_start_Firm_Firm_reset(current_xmachine_Firm)==1)
		{

		

			i = idle();

		

			if(i == 1)
			{
				free_Firm_agent(current_xmachine_Firm_holder, Firm_start_Firm_state);
			}
			else
			{
				transition_Firm_agent(current_xmachine_Firm_holder, Firm_start_Firm_state, Firm_Firm_reset_state);
			}
		}

		current_xmachine_Firm = NULL;

		current_xmachine_Firm_holder = temp_xmachine_Firm_holder;
	}
	if(FLAME_TEST_PRINT_START_AND_END_OF_MODEL_FUNCTIONS) printf("finish idle\n");


/* End of layer number 0 */

/* Clear message boards that have finished being used
 * and sync complete if doing late sync complete */


	if(FLAME_TEST_PRINT_START_AND_END_OF_MODEL_FUNCTIONS) printf("start ClearingHouse_send_index_price\n");
	current_xmachine_ClearingHouse_holder = ClearingHouse_AFM_00_state->agents;
	while(current_xmachine_ClearingHouse_holder)
	{
		temp_xmachine_ClearingHouse_holder = current_xmachine_ClearingHouse_holder->next;
		current_xmachine_ClearingHouse = current_xmachine_ClearingHouse_holder->agent;
		current_xmachine_ClearingHouse_next_state = ClearingHouse_AFM_01_state;
		/* For backwards compatibility set current_xmachine */
		current_xmachine->xmachine_Firm = NULL;
		current_xmachine->xmachine_Household = NULL;
		current_xmachine->xmachine_Mall = NULL;
		current_xmachine->xmachine_IGFirm = NULL;
		current_xmachine->xmachine_Eurostat = NULL;
		current_xmachine->xmachine_Bank = NULL;
		current_xmachine->xmachine_Government = NULL;
		current_xmachine->xmachine_CentralBank = NULL;
		current_xmachine->xmachine_ClearingHouse = NULL;
		current_xmachine->xmachine_ClearingHouse = current_xmachine_ClearingHouse;

		

		

			i = ClearingHouse_send_index_price();

		

			if(i == 1)
			{
				free_ClearingHouse_agent(current_xmachine_ClearingHouse_holder, ClearingHouse_AFM_00_state);
			}
			else
			{
				transition_ClearingHouse_agent(current_xmachine_ClearingHouse_holder, ClearingHouse_AFM_00_state, ClearingHouse_AFM_01_state);
			}
		

		current_xmachine_ClearingHouse = NULL;

		current_xmachine_ClearingHouse_holder = temp_xmachine_ClearingHouse_holder;
	}
	if(FLAME_TEST_PRINT_START_AND_END_OF_MODEL_FUNCTIONS) printf("finish ClearingHouse_send_index_price\n");

	if(FLAME_index_price_message_board_write == 1)
	{

		if(FLAME_TEST_PRINT_START_AND_END_OF_LIBMBOARD_CALLS) printf("start MB_SyncStart(b_index_price)\n");
		rc = MB_SyncStart(b_index_price);
		if(FLAME_TEST_PRINT_START_AND_END_OF_LIBMBOARD_CALLS) printf("finish MB_SyncStart(b_index_price)\n");
		#ifdef ERRCHECK
		if (rc != MB_SUCCESS)
		{
		   fprintf(stderr, "ERROR: Could not start sync of 'index_price' board\n");
		   switch(rc) {
			   case MB_ERR_INVALID:
				   fprintf(stderr, "\t reason: 'index_price' board is invalid\n");
				   break;
			   case MB_ERR_LOCKED:
				   fprintf(stderr, "\t reason: 'index_price' board is locked\n");
				   break;
			   case MB_ERR_MEMALLOC:
				   fprintf(stderr, "\t reason: out of memory\n");
				   break;
			   case MB_ERR_INTERNAL:
				   fprintf(stderr, "\t reason: internal error. Recompile libmoard in debug mode for more info \n");
				   break;
			   default:
				   fprintf(stderr, "\t MB_SyncStart returned error code: %d (see libmboard docs for details)\n", rc);
				   break;
		   }

			
			exit(rc);
		}
		#endif
    }
    


	if(FLAME_TEST_PRINT_START_AND_END_OF_MODEL_FUNCTIONS) printf("start Eurostat_send_data\n");
	current_xmachine_Eurostat_holder = Eurostat_00_state->agents;
	while(current_xmachine_Eurostat_holder)
	{
		temp_xmachine_Eurostat_holder = current_xmachine_Eurostat_holder->next;
		current_xmachine_Eurostat = current_xmachine_Eurostat_holder->agent;
		current_xmachine_Eurostat_next_state = Eurostat_01_state;
		/* For backwards compatibility set current_xmachine */
		current_xmachine->xmachine_Firm = NULL;
		current_xmachine->xmachine_Household = NULL;
		current_xmachine->xmachine_Mall = NULL;
		current_xmachine->xmachine_IGFirm = NULL;
		current_xmachine->xmachine_Eurostat = NULL;
		current_xmachine->xmachine_Bank = NULL;
		current_xmachine->xmachine_Government = NULL;
		current_xmachine->xmachine_CentralBank = NULL;
		current_xmachine->xmachine_ClearingHouse = NULL;
		current_xmachine->xmachine_Eurostat = current_xmachine_Eurostat;

		if(FLAME_condition_Eurostat_Eurostat_send_data_00_01(current_xmachine_Eurostat)==1)
		{

		

			i = Eurostat_send_data();

		

			if(i == 1)
			{
				free_Eurostat_agent(current_xmachine_Eurostat_holder, Eurostat_00_state);
			}
			else
			{
				transition_Eurostat_agent(current_xmachine_Eurostat_holder, Eurostat_00_state, Eurostat_01_state);
			}
		}

		current_xmachine_Eurostat = NULL;

		current_xmachine_Eurostat_holder = temp_xmachine_Eurostat_holder;
	}
	if(FLAME_TEST_PRINT_START_AND_END_OF_MODEL_FUNCTIONS) printf("finish Eurostat_send_data\n");

	if(FLAME_quality_price_message_board_write == 1)
	{

		if(FLAME_TEST_PRINT_START_AND_END_OF_LIBMBOARD_CALLS) printf("start MB_SyncStart(b_quality_price)\n");
		rc = MB_SyncStart(b_quality_price);
		if(FLAME_TEST_PRINT_START_AND_END_OF_LIBMBOARD_CALLS) printf("finish MB_SyncStart(b_quality_price)\n");
		#ifdef ERRCHECK
		if (rc != MB_SUCCESS)
		{
		   fprintf(stderr, "ERROR: Could not start sync of 'quality_price' board\n");
		   switch(rc) {
			   case MB_ERR_INVALID:
				   fprintf(stderr, "\t reason: 'quality_price' board is invalid\n");
				   break;
			   case MB_ERR_LOCKED:
				   fprintf(stderr, "\t reason: 'quality_price' board is locked\n");
				   break;
			   case MB_ERR_MEMALLOC:
				   fprintf(stderr, "\t reason: out of memory\n");
				   break;
			   case MB_ERR_INTERNAL:
				   fprintf(stderr, "\t reason: internal error. Recompile libmoard in debug mode for more info \n");
				   break;
			   default:
				   fprintf(stderr, "\t MB_SyncStart returned error code: %d (see libmboard docs for details)\n", rc);
				   break;
		   }

			
			exit(rc);
		}
		#endif
    }
    

	if(FLAME_redistributed_subsidies_message_board_write == 1)
	{

		if(FLAME_TEST_PRINT_START_AND_END_OF_LIBMBOARD_CALLS) printf("start MB_SyncStart(b_redistributed_subsidies)\n");
		rc = MB_SyncStart(b_redistributed_subsidies);
		if(FLAME_TEST_PRINT_START_AND_END_OF_LIBMBOARD_CALLS) printf("finish MB_SyncStart(b_redistributed_subsidies)\n");
		#ifdef ERRCHECK
		if (rc != MB_SUCCESS)
		{
		   fprintf(stderr, "ERROR: Could not start sync of 'redistributed_subsidies' board\n");
		   switch(rc) {
			   case MB_ERR_INVALID:
				   fprintf(stderr, "\t reason: 'redistributed_subsidies' board is invalid\n");
				   break;
			   case MB_ERR_LOCKED:
				   fprintf(stderr, "\t reason: 'redistributed_subsidies' board is locked\n");
				   break;
			   case MB_ERR_MEMALLOC:
				   fprintf(stderr, "\t reason: out of memory\n");
				   break;
			   case MB_ERR_INTERNAL:
				   fprintf(stderr, "\t reason: internal error. Recompile libmoard in debug mode for more info \n");
				   break;
			   default:
				   fprintf(stderr, "\t MB_SyncStart returned error code: %d (see libmboard docs for details)\n", rc);
				   break;
		   }

			
			exit(rc);
		}
		#endif
    }
    

	if(FLAME_msg_market_sizes_message_board_write == 1)
	{

		if(FLAME_TEST_PRINT_START_AND_END_OF_LIBMBOARD_CALLS) printf("start MB_SyncStart(b_msg_market_sizes)\n");
		rc = MB_SyncStart(b_msg_market_sizes);
		if(FLAME_TEST_PRINT_START_AND_END_OF_LIBMBOARD_CALLS) printf("finish MB_SyncStart(b_msg_market_sizes)\n");
		#ifdef ERRCHECK
		if (rc != MB_SUCCESS)
		{
		   fprintf(stderr, "ERROR: Could not start sync of 'msg_market_sizes' board\n");
		   switch(rc) {
			   case MB_ERR_INVALID:
				   fprintf(stderr, "\t reason: 'msg_market_sizes' board is invalid\n");
				   break;
			   case MB_ERR_LOCKED:
				   fprintf(stderr, "\t reason: 'msg_market_sizes' board is locked\n");
				   break;
			   case MB_ERR_MEMALLOC:
				   fprintf(stderr, "\t reason: out of memory\n");
				   break;
			   case MB_ERR_INTERNAL:
				   fprintf(stderr, "\t reason: internal error. Recompile libmoard in debug mode for more info \n");
				   break;
			   default:
				   fprintf(stderr, "\t MB_SyncStart returned error code: %d (see libmboard docs for details)\n", rc);
				   break;
		   }

			
			exit(rc);
		}
		#endif
    }
    

	if(FLAME_msg_skills_eurostat_to_igfirm_message_board_write == 1)
	{

		if(FLAME_TEST_PRINT_START_AND_END_OF_LIBMBOARD_CALLS) printf("start MB_SyncStart(b_msg_skills_eurostat_to_igfirm)\n");
		rc = MB_SyncStart(b_msg_skills_eurostat_to_igfirm);
		if(FLAME_TEST_PRINT_START_AND_END_OF_LIBMBOARD_CALLS) printf("finish MB_SyncStart(b_msg_skills_eurostat_to_igfirm)\n");
		#ifdef ERRCHECK
		if (rc != MB_SUCCESS)
		{
		   fprintf(stderr, "ERROR: Could not start sync of 'msg_skills_eurostat_to_igfirm' board\n");
		   switch(rc) {
			   case MB_ERR_INVALID:
				   fprintf(stderr, "\t reason: 'msg_skills_eurostat_to_igfirm' board is invalid\n");
				   break;
			   case MB_ERR_LOCKED:
				   fprintf(stderr, "\t reason: 'msg_skills_eurostat_to_igfirm' board is locked\n");
				   break;
			   case MB_ERR_MEMALLOC:
				   fprintf(stderr, "\t reason: out of memory\n");
				   break;
			   case MB_ERR_INTERNAL:
				   fprintf(stderr, "\t reason: internal error. Recompile libmoard in debug mode for more info \n");
				   break;
			   default:
				   fprintf(stderr, "\t MB_SyncStart returned error code: %d (see libmboard docs for details)\n", rc);
				   break;
		   }

			
			exit(rc);
		}
		#endif
    }
    

	if(FLAME_eurostat_send_macrodata_message_board_write == 1)
	{

		if(FLAME_TEST_PRINT_START_AND_END_OF_LIBMBOARD_CALLS) printf("start MB_SyncStart(b_eurostat_send_macrodata)\n");
		rc = MB_SyncStart(b_eurostat_send_macrodata);
		if(FLAME_TEST_PRINT_START_AND_END_OF_LIBMBOARD_CALLS) printf("finish MB_SyncStart(b_eurostat_send_macrodata)\n");
		#ifdef ERRCHECK
		if (rc != MB_SUCCESS)
		{
		   fprintf(stderr, "ERROR: Could not start sync of 'eurostat_send_macrodata' board\n");
		   switch(rc) {
			   case MB_ERR_INVALID:
				   fprintf(stderr, "\t reason: 'eurostat_send_macrodata' board is invalid\n");
				   break;
			   case MB_ERR_LOCKED:
				   fprintf(stderr, "\t reason: 'eurostat_send_macrodata' board is locked\n");
				   break;
			   case MB_ERR_MEMALLOC:
				   fprintf(stderr, "\t reason: out of memory\n");
				   break;
			   case MB_ERR_INTERNAL:
				   fprintf(stderr, "\t reason: internal error. Recompile libmoard in debug mode for more info \n");
				   break;
			   default:
				   fprintf(stderr, "\t MB_SyncStart returned error code: %d (see libmboard docs for details)\n", rc);
				   break;
		   }

			
			exit(rc);
		}
		#endif
    }
    

	if(FLAME_data_for_government_message_board_write == 1)
	{

		if(FLAME_TEST_PRINT_START_AND_END_OF_LIBMBOARD_CALLS) printf("start MB_SyncStart(b_data_for_government)\n");
		rc = MB_SyncStart(b_data_for_government);
		if(FLAME_TEST_PRINT_START_AND_END_OF_LIBMBOARD_CALLS) printf("finish MB_SyncStart(b_data_for_government)\n");
		#ifdef ERRCHECK
		if (rc != MB_SUCCESS)
		{
		   fprintf(stderr, "ERROR: Could not start sync of 'data_for_government' board\n");
		   switch(rc) {
			   case MB_ERR_INVALID:
				   fprintf(stderr, "\t reason: 'data_for_government' board is invalid\n");
				   break;
			   case MB_ERR_LOCKED:
				   fprintf(stderr, "\t reason: 'data_for_government' board is locked\n");
				   break;
			   case MB_ERR_MEMALLOC:
				   fprintf(stderr, "\t reason: out of memory\n");
				   break;
			   case MB_ERR_INTERNAL:
				   fprintf(stderr, "\t reason: internal error. Recompile libmoard in debug mode for more info \n");
				   break;
			   default:
				   fprintf(stderr, "\t MB_SyncStart returned error code: %d (see libmboard docs for details)\n", rc);
				   break;
		   }

			
			exit(rc);
		}
		#endif
    }
    

	if(FLAME_eurostat_send_specific_skills_message_board_write == 1)
	{

		if(FLAME_TEST_PRINT_START_AND_END_OF_LIBMBOARD_CALLS) printf("start MB_SyncStart(b_eurostat_send_specific_skills)\n");
		rc = MB_SyncStart(b_eurostat_send_specific_skills);
		if(FLAME_TEST_PRINT_START_AND_END_OF_LIBMBOARD_CALLS) printf("finish MB_SyncStart(b_eurostat_send_specific_skills)\n");
		#ifdef ERRCHECK
		if (rc != MB_SUCCESS)
		{
		   fprintf(stderr, "ERROR: Could not start sync of 'eurostat_send_specific_skills' board\n");
		   switch(rc) {
			   case MB_ERR_INVALID:
				   fprintf(stderr, "\t reason: 'eurostat_send_specific_skills' board is invalid\n");
				   break;
			   case MB_ERR_LOCKED:
				   fprintf(stderr, "\t reason: 'eurostat_send_specific_skills' board is locked\n");
				   break;
			   case MB_ERR_MEMALLOC:
				   fprintf(stderr, "\t reason: out of memory\n");
				   break;
			   case MB_ERR_INTERNAL:
				   fprintf(stderr, "\t reason: internal error. Recompile libmoard in debug mode for more info \n");
				   break;
			   default:
				   fprintf(stderr, "\t MB_SyncStart returned error code: %d (see libmboard docs for details)\n", rc);
				   break;
		   }

			
			exit(rc);
		}
		#endif
    }
    


	if(FLAME_TEST_PRINT_START_AND_END_OF_MODEL_FUNCTIONS) printf("start idle\n");
	current_xmachine_Government_holder = Government_Government_Start_Monthly_Loop_Top_state->agents;
	while(current_xmachine_Government_holder)
	{
		temp_xmachine_Government_holder = current_xmachine_Government_holder->next;
		current_xmachine_Government = current_xmachine_Government_holder->agent;
		current_xmachine_Government_next_state = Government_Government_Start_Yearly_Loop_Top_state;
		/* For backwards compatibility set current_xmachine */
		current_xmachine->xmachine_Firm = NULL;
		current_xmachine->xmachine_Household = NULL;
		current_xmachine->xmachine_Mall = NULL;
		current_xmachine->xmachine_IGFirm = NULL;
		current_xmachine->xmachine_Eurostat = NULL;
		current_xmachine->xmachine_Bank = NULL;
		current_xmachine->xmachine_Government = NULL;
		current_xmachine->xmachine_CentralBank = NULL;
		current_xmachine->xmachine_ClearingHouse = NULL;
		current_xmachine->xmachine_Government = current_xmachine_Government;

		if(FLAME_condition_Government_idle_Government_Start_Monthly_Loop_Top_Government_Start_Yearly_Loop_Top(current_xmachine_Government)==1)
		{

		

			i = idle();

		

			if(i == 1)
			{
				free_Government_agent(current_xmachine_Government_holder, Government_Government_Start_Monthly_Loop_Top_state);
			}
			else
			{
				transition_Government_agent(current_xmachine_Government_holder, Government_Government_Start_Monthly_Loop_Top_state, Government_Government_Start_Yearly_Loop_Top_state);
			}
		}

		current_xmachine_Government = NULL;

		current_xmachine_Government_holder = temp_xmachine_Government_holder;
	}
	if(FLAME_TEST_PRINT_START_AND_END_OF_MODEL_FUNCTIONS) printf("finish idle\n");


	if(FLAME_TEST_PRINT_START_AND_END_OF_MODEL_FUNCTIONS) printf("start Government_monthly_resetting\n");
	current_xmachine_Government_holder = Government_Government_Start_Monthly_Loop_Top_state->agents;
	while(current_xmachine_Government_holder)
	{
		temp_xmachine_Government_holder = current_xmachine_Government_holder->next;
		current_xmachine_Government = current_xmachine_Government_holder->agent;
		current_xmachine_Government_next_state = Government_001_state;
		/* For backwards compatibility set current_xmachine */
		current_xmachine->xmachine_Firm = NULL;
		current_xmachine->xmachine_Household = NULL;
		current_xmachine->xmachine_Mall = NULL;
		current_xmachine->xmachine_IGFirm = NULL;
		current_xmachine->xmachine_Eurostat = NULL;
		current_xmachine->xmachine_Bank = NULL;
		current_xmachine->xmachine_Government = NULL;
		current_xmachine->xmachine_CentralBank = NULL;
		current_xmachine->xmachine_ClearingHouse = NULL;
		current_xmachine->xmachine_Government = current_xmachine_Government;

		if(FLAME_condition_Government_Government_monthly_resetting_Government_Start_Monthly_Loop_Top_001(current_xmachine_Government)==1)
		{

		

			i = Government_monthly_resetting();

		

			if(i == 1)
			{
				free_Government_agent(current_xmachine_Government_holder, Government_Government_Start_Monthly_Loop_Top_state);
			}
			else
			{
				transition_Government_agent(current_xmachine_Government_holder, Government_Government_Start_Monthly_Loop_Top_state, Government_001_state);
			}
		}

		current_xmachine_Government = NULL;

		current_xmachine_Government_holder = temp_xmachine_Government_holder;
	}
	if(FLAME_TEST_PRINT_START_AND_END_OF_MODEL_FUNCTIONS) printf("finish Government_monthly_resetting\n");


	if(FLAME_TEST_PRINT_START_AND_END_OF_MODEL_FUNCTIONS) printf("start Eurostat_idle\n");
	current_xmachine_Eurostat_holder = Eurostat_00_state->agents;
	while(current_xmachine_Eurostat_holder)
	{
		temp_xmachine_Eurostat_holder = current_xmachine_Eurostat_holder->next;
		current_xmachine_Eurostat = current_xmachine_Eurostat_holder->agent;
		current_xmachine_Eurostat_next_state = Eurostat_01_state;
		/* For backwards compatibility set current_xmachine */
		current_xmachine->xmachine_Firm = NULL;
		current_xmachine->xmachine_Household = NULL;
		current_xmachine->xmachine_Mall = NULL;
		current_xmachine->xmachine_IGFirm = NULL;
		current_xmachine->xmachine_Eurostat = NULL;
		current_xmachine->xmachine_Bank = NULL;
		current_xmachine->xmachine_Government = NULL;
		current_xmachine->xmachine_CentralBank = NULL;
		current_xmachine->xmachine_ClearingHouse = NULL;
		current_xmachine->xmachine_Eurostat = current_xmachine_Eurostat;

		if(FLAME_condition_Eurostat_Eurostat_idle_00_01(current_xmachine_Eurostat)==1)
		{

		

			i = Eurostat_idle();

		

			if(i == 1)
			{
				free_Eurostat_agent(current_xmachine_Eurostat_holder, Eurostat_00_state);
			}
			else
			{
				transition_Eurostat_agent(current_xmachine_Eurostat_holder, Eurostat_00_state, Eurostat_01_state);
			}
		}

		current_xmachine_Eurostat = NULL;

		current_xmachine_Eurostat_holder = temp_xmachine_Eurostat_holder;
	}
	if(FLAME_TEST_PRINT_START_AND_END_OF_MODEL_FUNCTIONS) printf("finish Eurostat_idle\n");


	if(FLAME_TEST_PRINT_START_AND_END_OF_MODEL_FUNCTIONS) printf("start idle\n");
	current_xmachine_Household_holder = Household_Household_initialize_state->agents;
	while(current_xmachine_Household_holder)
	{
		temp_xmachine_Household_holder = current_xmachine_Household_holder->next;
		current_xmachine_Household = current_xmachine_Household_holder->agent;
		current_xmachine_Household_next_state = Household_Household_Start_Yearly_Loop_Top_state;
		/* For backwards compatibility set current_xmachine */
		current_xmachine->xmachine_Firm = NULL;
		current_xmachine->xmachine_Household = NULL;
		current_xmachine->xmachine_Mall = NULL;
		current_xmachine->xmachine_IGFirm = NULL;
		current_xmachine->xmachine_Eurostat = NULL;
		current_xmachine->xmachine_Bank = NULL;
		current_xmachine->xmachine_Government = NULL;
		current_xmachine->xmachine_CentralBank = NULL;
		current_xmachine->xmachine_ClearingHouse = NULL;
		current_xmachine->xmachine_Household = current_xmachine_Household;

		if(FLAME_condition_Household_idle_Household_initialize_Household_Start_Yearly_Loop_Top(current_xmachine_Household)==1)
		{

		

			i = idle();

		

			if(i == 1)
			{
				free_Household_agent(current_xmachine_Household_holder, Household_Household_initialize_state);
			}
			else
			{
				transition_Household_agent(current_xmachine_Household_holder, Household_Household_initialize_state, Household_Household_Start_Yearly_Loop_Top_state);
			}
		}

		current_xmachine_Household = NULL;

		current_xmachine_Household_holder = temp_xmachine_Household_holder;
	}
	if(FLAME_TEST_PRINT_START_AND_END_OF_MODEL_FUNCTIONS) printf("finish idle\n");


	if(FLAME_TEST_PRINT_START_AND_END_OF_MODEL_FUNCTIONS) printf("start Household_initialization\n");
	current_xmachine_Household_holder = Household_Household_initialize_state->agents;
	while(current_xmachine_Household_holder)
	{
		temp_xmachine_Household_holder = current_xmachine_Household_holder->next;
		current_xmachine_Household = current_xmachine_Household_holder->agent;
		current_xmachine_Household_next_state = Household_Household_Start_Yearly_Loop_Top_state;
		/* For backwards compatibility set current_xmachine */
		current_xmachine->xmachine_Firm = NULL;
		current_xmachine->xmachine_Household = NULL;
		current_xmachine->xmachine_Mall = NULL;
		current_xmachine->xmachine_IGFirm = NULL;
		current_xmachine->xmachine_Eurostat = NULL;
		current_xmachine->xmachine_Bank = NULL;
		current_xmachine->xmachine_Government = NULL;
		current_xmachine->xmachine_CentralBank = NULL;
		current_xmachine->xmachine_ClearingHouse = NULL;
		current_xmachine->xmachine_Household = current_xmachine_Household;

		if(FLAME_condition_Household_Household_initialization_Household_initialize_Household_Start_Yearly_Loop_Top(current_xmachine_Household)==1)
		{

		

			i = Household_initialization();

		

			if(i == 1)
			{
				free_Household_agent(current_xmachine_Household_holder, Household_Household_initialize_state);
			}
			else
			{
				transition_Household_agent(current_xmachine_Household_holder, Household_Household_initialize_state, Household_Household_Start_Yearly_Loop_Top_state);
			}
		}

		current_xmachine_Household = NULL;

		current_xmachine_Household_holder = temp_xmachine_Household_holder;
	}
	if(FLAME_TEST_PRINT_START_AND_END_OF_MODEL_FUNCTIONS) printf("finish Household_initialization\n");


	/* If mb is not read then leave sync complete until last possible moment */
	if(FLAME_msg_mall_id_to_firms_message_board_read == 1)
	{
		if(FLAME_TEST_PRINT_START_AND_END_OF_LIBMBOARD_CALLS) printf("start MB_SyncComplete(b_msg_mall_id_to_firms)\n");
		rc = MB_SyncComplete(b_msg_mall_id_to_firms);
		if(FLAME_TEST_PRINT_START_AND_END_OF_LIBMBOARD_CALLS) printf("finsh MB_SyncComplete(b_msg_mall_id_to_firms)\n");
		#ifdef ERRCHECK
		if (rc != MB_SUCCESS)
		{
		   fprintf(stderr, "ERROR: Could not complete sync of 'msg_mall_id_to_firms' board\n");
		   switch(rc) {
				case MB_ERR_INVALID:
				   fprintf(stderr, "\t reason: 'msg_mall_id_to_firms' board is invalid\n");
				   break;
			   case MB_ERR_MEMALLOC:
				   fprintf(stderr, "\t reason: out of memory\n");
				   break;
			   case MB_ERR_INTERNAL:
				   fprintf(stderr, "\t reason: internal error. Recompile libmoard in debug mode for more info \n");
				   break;
			   default:
				   fprintf(stderr, "\t MB_SyncComplete returned error code: %d (see libmboard docs for details)\n", rc);
				   break;
		   }
	
		   
		   exit(rc);
		}
		#endif
    
	}
	
	if(FLAME_TEST_PRINT_START_AND_END_OF_MODEL_FUNCTIONS) printf("start Firm_initialize_mall_arrays\n");
	current_xmachine_Firm_holder = Firm_Firm_initialize_state->agents;
	while(current_xmachine_Firm_holder)
	{
		temp_xmachine_Firm_holder = current_xmachine_Firm_holder->next;
		current_xmachine_Firm = current_xmachine_Firm_holder->agent;
		current_xmachine_Firm_next_state = Firm_Firm_reset_state;
		/* For backwards compatibility set current_xmachine */
		current_xmachine->xmachine_Firm = NULL;
		current_xmachine->xmachine_Household = NULL;
		current_xmachine->xmachine_Mall = NULL;
		current_xmachine->xmachine_IGFirm = NULL;
		current_xmachine->xmachine_Eurostat = NULL;
		current_xmachine->xmachine_Bank = NULL;
		current_xmachine->xmachine_Government = NULL;
		current_xmachine->xmachine_CentralBank = NULL;
		current_xmachine->xmachine_ClearingHouse = NULL;
		current_xmachine->xmachine_Firm = current_xmachine_Firm;

		

		
		
		rc = MB_Iterator_Create(b_msg_mall_id_to_firms, &i_msg_mall_id_to_firms);
		#ifdef ERRCHECK
		if (rc != MB_SUCCESS)
		{
		   fprintf(stderr, "ERROR: Could not create Iterator for 'msg_mall_id_to_firms'\n");
		   switch(rc) {
		       case MB_ERR_INVALID:
		           fprintf(stderr, "\t reason: 'msg_mall_id_to_firms' board is invalid\n");
		           break;
		       case MB_ERR_LOCKED:
	               fprintf(stderr, "\t reason: 'msg_mall_id_to_firms' board is locked\n");
	               break;
	           case MB_ERR_MEMALLOC:
	               fprintf(stderr, "\t reason: out of memory\n");
	               break;
	           case MB_ERR_INTERNAL:
	               fprintf(stderr, "\t reason: internal error. Recompile libmoard in debug mode for more info \n");
	               break;
	           default:
	           
               
                   fprintf(stderr, "\t MB_Iterator_Create returned error code: %d (see libmboard docs for details)\n", rc);
               
                   break;
		   }

		   
           exit(rc);
		}
		#endif
		
		

			i = Firm_initialize_mall_arrays();

		
		    rc = MB_Iterator_Delete(&i_msg_mall_id_to_firms);
		    #ifdef ERRCHECK
		    if (rc != MB_SUCCESS)
		    {
		       fprintf(stderr, "ERROR: Could not delete 'msg_mall_id_to_firms' iterator\n");
		       switch(rc) {
		           case MB_ERR_INVALID:
		               fprintf(stderr, "\t reason: 'msg_mall_id_to_firms' iterator is invalid\n");
		               break;
		           case MB_ERR_INTERNAL:
		               fprintf(stderr, "\t reason: internal error. Recompile libmoard in debug mode for more info \n");
		               break;
		           default:
                       fprintf(stderr, "\t MB_Iterator_Delete returned error code: %d (see libmboard docs for details)\n", rc);
                       break;
		       }

		       
               exit(rc);
		    }
		    #endif
		

			if(i == 1)
			{
				free_Firm_agent(current_xmachine_Firm_holder, Firm_Firm_initialize_state);
			}
			else
			{
				transition_Firm_agent(current_xmachine_Firm_holder, Firm_Firm_initialize_state, Firm_Firm_reset_state);
			}
		

		current_xmachine_Firm = NULL;

		current_xmachine_Firm_holder = temp_xmachine_Firm_holder;
	}
	if(FLAME_TEST_PRINT_START_AND_END_OF_MODEL_FUNCTIONS) printf("finish Firm_initialize_mall_arrays\n");


	/* If mb is not read then leave sync complete until last possible moment */
	if(FLAME_msg_firm_id_to_malls_message_board_read == 1)
	{
		if(FLAME_TEST_PRINT_START_AND_END_OF_LIBMBOARD_CALLS) printf("start MB_SyncComplete(b_msg_firm_id_to_malls)\n");
		rc = MB_SyncComplete(b_msg_firm_id_to_malls);
		if(FLAME_TEST_PRINT_START_AND_END_OF_LIBMBOARD_CALLS) printf("finsh MB_SyncComplete(b_msg_firm_id_to_malls)\n");
		#ifdef ERRCHECK
		if (rc != MB_SUCCESS)
		{
		   fprintf(stderr, "ERROR: Could not complete sync of 'msg_firm_id_to_malls' board\n");
		   switch(rc) {
				case MB_ERR_INVALID:
				   fprintf(stderr, "\t reason: 'msg_firm_id_to_malls' board is invalid\n");
				   break;
			   case MB_ERR_MEMALLOC:
				   fprintf(stderr, "\t reason: out of memory\n");
				   break;
			   case MB_ERR_INTERNAL:
				   fprintf(stderr, "\t reason: internal error. Recompile libmoard in debug mode for more info \n");
				   break;
			   default:
				   fprintf(stderr, "\t MB_SyncComplete returned error code: %d (see libmboard docs for details)\n", rc);
				   break;
		   }
	
		   
		   exit(rc);
		}
		#endif
    
	}
	
	if(FLAME_TEST_PRINT_START_AND_END_OF_MODEL_FUNCTIONS) printf("start Mall_initialize_firm_arrays\n");
	current_xmachine_Mall_holder = Mall_Mall_initialize_state->agents;
	while(current_xmachine_Mall_holder)
	{
		temp_xmachine_Mall_holder = current_xmachine_Mall_holder->next;
		current_xmachine_Mall = current_xmachine_Mall_holder->agent;
		current_xmachine_Mall_next_state = Mall_001_state;
		/* For backwards compatibility set current_xmachine */
		current_xmachine->xmachine_Firm = NULL;
		current_xmachine->xmachine_Household = NULL;
		current_xmachine->xmachine_Mall = NULL;
		current_xmachine->xmachine_IGFirm = NULL;
		current_xmachine->xmachine_Eurostat = NULL;
		current_xmachine->xmachine_Bank = NULL;
		current_xmachine->xmachine_Government = NULL;
		current_xmachine->xmachine_CentralBank = NULL;
		current_xmachine->xmachine_ClearingHouse = NULL;
		current_xmachine->xmachine_Mall = current_xmachine_Mall;

		

		
		
		rc = MB_Iterator_Create(b_msg_firm_id_to_malls, &i_msg_firm_id_to_malls);
		#ifdef ERRCHECK
		if (rc != MB_SUCCESS)
		{
		   fprintf(stderr, "ERROR: Could not create Iterator for 'msg_firm_id_to_malls'\n");
		   switch(rc) {
		       case MB_ERR_INVALID:
		           fprintf(stderr, "\t reason: 'msg_firm_id_to_malls' board is invalid\n");
		           break;
		       case MB_ERR_LOCKED:
	               fprintf(stderr, "\t reason: 'msg_firm_id_to_malls' board is locked\n");
	               break;
	           case MB_ERR_MEMALLOC:
	               fprintf(stderr, "\t reason: out of memory\n");
	               break;
	           case MB_ERR_INTERNAL:
	               fprintf(stderr, "\t reason: internal error. Recompile libmoard in debug mode for more info \n");
	               break;
	           default:
	           
               
                   fprintf(stderr, "\t MB_Iterator_Create returned error code: %d (see libmboard docs for details)\n", rc);
               
                   break;
		   }

		   
           exit(rc);
		}
		#endif
		
		

			i = Mall_initialize_firm_arrays();

		
		    rc = MB_Iterator_Delete(&i_msg_firm_id_to_malls);
		    #ifdef ERRCHECK
		    if (rc != MB_SUCCESS)
		    {
		       fprintf(stderr, "ERROR: Could not delete 'msg_firm_id_to_malls' iterator\n");
		       switch(rc) {
		           case MB_ERR_INVALID:
		               fprintf(stderr, "\t reason: 'msg_firm_id_to_malls' iterator is invalid\n");
		               break;
		           case MB_ERR_INTERNAL:
		               fprintf(stderr, "\t reason: internal error. Recompile libmoard in debug mode for more info \n");
		               break;
		           default:
                       fprintf(stderr, "\t MB_Iterator_Delete returned error code: %d (see libmboard docs for details)\n", rc);
                       break;
		       }

		       
               exit(rc);
		    }
		    #endif
		

			if(i == 1)
			{
				free_Mall_agent(current_xmachine_Mall_holder, Mall_Mall_initialize_state);
			}
			else
			{
				transition_Mall_agent(current_xmachine_Mall_holder, Mall_Mall_initialize_state, Mall_001_state);
			}
		

		current_xmachine_Mall = NULL;

		current_xmachine_Mall_holder = temp_xmachine_Mall_holder;
	}
	if(FLAME_TEST_PRINT_START_AND_END_OF_MODEL_FUNCTIONS) printf("finish Mall_initialize_firm_arrays\n");


/* End of layer number 1 */

/* Clear message boards that have finished being used
 * and sync complete if doing late sync complete */

if(FLAME_msg_firm_id_to_malls_message_board_read == 0)
{
	/*printf("%d> msg_firm_id_to_malls message board sync complete late as no agents reading any messages of this type\n", node_number);*/
	
	if(FLAME_TEST_PRINT_START_AND_END_OF_LIBMBOARD_CALLS) printf("start MB_SyncComplete(b_msg_firm_id_to_malls)\n");
	rc = MB_SyncComplete(b_msg_firm_id_to_malls);
	if(FLAME_TEST_PRINT_START_AND_END_OF_LIBMBOARD_CALLS) printf("finsh MB_SyncComplete(b_msg_firm_id_to_malls)\n");
	#ifdef ERRCHECK
	if (rc != MB_SUCCESS)
	{
	   fprintf(stderr, "ERROR: Could not complete sync of 'msg_firm_id_to_malls' board\n");
	   switch(rc) {
			case MB_ERR_INVALID:
			   fprintf(stderr, "\t reason: 'msg_firm_id_to_malls' board is invalid\n");
			   break;
		   case MB_ERR_MEMALLOC:
			   fprintf(stderr, "\t reason: out of memory\n");
			   break;
		   case MB_ERR_INTERNAL:
			   fprintf(stderr, "\t reason: internal error. Recompile libmoard in debug mode for more info \n");
			   break;
		   default:
			   fprintf(stderr, "\t MB_SyncComplete returned error code: %d (see libmboard docs for details)\n", rc);
			   break;
	   }

	   
	   exit(rc);
	}
	#endif
}

    rc = MB_Clear(b_msg_firm_id_to_malls);
    #ifdef ERRCHECK
    if (rc != MB_SUCCESS)
    {
       fprintf(stderr, "ERROR: Could not clear 'msg_firm_id_to_malls' board\n");
       switch(rc) {
           case MB_ERR_INVALID:
               fprintf(stderr, "\t reason: 'msg_firm_id_to_malls' board is invalid\n");
               break;
           case MB_ERR_LOCKED:
               fprintf(stderr, "\t reason: 'msg_firm_id_to_malls' board is locked\n");
               break;
           case MB_ERR_INTERNAL:
               fprintf(stderr, "\t reason: internal error. Recompile libmoard in debug mode for more info \n");
               break;
           default:
               fprintf(stderr, "\t MB_Clear returned error code: %d (see libmboard docs for details)\n", rc);
               break;

       }

       
       exit(rc);
    }
    #endif

if(FLAME_msg_mall_id_to_firms_message_board_read == 0)
{
	/*printf("%d> msg_mall_id_to_firms message board sync complete late as no agents reading any messages of this type\n", node_number);*/
	
	if(FLAME_TEST_PRINT_START_AND_END_OF_LIBMBOARD_CALLS) printf("start MB_SyncComplete(b_msg_mall_id_to_firms)\n");
	rc = MB_SyncComplete(b_msg_mall_id_to_firms);
	if(FLAME_TEST_PRINT_START_AND_END_OF_LIBMBOARD_CALLS) printf("finsh MB_SyncComplete(b_msg_mall_id_to_firms)\n");
	#ifdef ERRCHECK
	if (rc != MB_SUCCESS)
	{
	   fprintf(stderr, "ERROR: Could not complete sync of 'msg_mall_id_to_firms' board\n");
	   switch(rc) {
			case MB_ERR_INVALID:
			   fprintf(stderr, "\t reason: 'msg_mall_id_to_firms' board is invalid\n");
			   break;
		   case MB_ERR_MEMALLOC:
			   fprintf(stderr, "\t reason: out of memory\n");
			   break;
		   case MB_ERR_INTERNAL:
			   fprintf(stderr, "\t reason: internal error. Recompile libmoard in debug mode for more info \n");
			   break;
		   default:
			   fprintf(stderr, "\t MB_SyncComplete returned error code: %d (see libmboard docs for details)\n", rc);
			   break;
	   }

	   
	   exit(rc);
	}
	#endif
}

    rc = MB_Clear(b_msg_mall_id_to_firms);
    #ifdef ERRCHECK
    if (rc != MB_SUCCESS)
    {
       fprintf(stderr, "ERROR: Could not clear 'msg_mall_id_to_firms' board\n");
       switch(rc) {
           case MB_ERR_INVALID:
               fprintf(stderr, "\t reason: 'msg_mall_id_to_firms' board is invalid\n");
               break;
           case MB_ERR_LOCKED:
               fprintf(stderr, "\t reason: 'msg_mall_id_to_firms' board is locked\n");
               break;
           case MB_ERR_INTERNAL:
               fprintf(stderr, "\t reason: internal error. Recompile libmoard in debug mode for more info \n");
               break;
           default:
               fprintf(stderr, "\t MB_Clear returned error code: %d (see libmboard docs for details)\n", rc);
               break;

       }

       
       exit(rc);
    }
    #endif


	/* If mb is not read then leave sync complete until last possible moment */
	if(FLAME_eurostat_send_macrodata_message_board_read == 1)
	{
		if(FLAME_TEST_PRINT_START_AND_END_OF_LIBMBOARD_CALLS) printf("start MB_SyncComplete(b_eurostat_send_macrodata)\n");
		rc = MB_SyncComplete(b_eurostat_send_macrodata);
		if(FLAME_TEST_PRINT_START_AND_END_OF_LIBMBOARD_CALLS) printf("finsh MB_SyncComplete(b_eurostat_send_macrodata)\n");
		#ifdef ERRCHECK
		if (rc != MB_SUCCESS)
		{
		   fprintf(stderr, "ERROR: Could not complete sync of 'eurostat_send_macrodata' board\n");
		   switch(rc) {
				case MB_ERR_INVALID:
				   fprintf(stderr, "\t reason: 'eurostat_send_macrodata' board is invalid\n");
				   break;
			   case MB_ERR_MEMALLOC:
				   fprintf(stderr, "\t reason: out of memory\n");
				   break;
			   case MB_ERR_INTERNAL:
				   fprintf(stderr, "\t reason: internal error. Recompile libmoard in debug mode for more info \n");
				   break;
			   default:
				   fprintf(stderr, "\t MB_SyncComplete returned error code: %d (see libmboard docs for details)\n", rc);
				   break;
		   }
	
		   
		   exit(rc);
		}
		#endif
    
	}
	
	if(FLAME_TEST_PRINT_START_AND_END_OF_MODEL_FUNCTIONS) printf("start Central_Bank_monetary_policy\n");
	current_xmachine_CentralBank_holder = CentralBank_CB_reset_state->agents;
	while(current_xmachine_CentralBank_holder)
	{
		temp_xmachine_CentralBank_holder = current_xmachine_CentralBank_holder->next;
		current_xmachine_CentralBank = current_xmachine_CentralBank_holder->agent;
		current_xmachine_CentralBank_next_state = CentralBank_CB_market_operations_state;
		/* For backwards compatibility set current_xmachine */
		current_xmachine->xmachine_Firm = NULL;
		current_xmachine->xmachine_Household = NULL;
		current_xmachine->xmachine_Mall = NULL;
		current_xmachine->xmachine_IGFirm = NULL;
		current_xmachine->xmachine_Eurostat = NULL;
		current_xmachine->xmachine_Bank = NULL;
		current_xmachine->xmachine_Government = NULL;
		current_xmachine->xmachine_CentralBank = NULL;
		current_xmachine->xmachine_ClearingHouse = NULL;
		current_xmachine->xmachine_CentralBank = current_xmachine_CentralBank;

		if(FLAME_condition_CentralBank_Central_Bank_monetary_policy_CB_reset_CB_market_operations(current_xmachine_CentralBank)==1)
		{

		
		
		rc = MB_Iterator_Create(b_eurostat_send_macrodata, &i_eurostat_send_macrodata);
		#ifdef ERRCHECK
		if (rc != MB_SUCCESS)
		{
		   fprintf(stderr, "ERROR: Could not create Iterator for 'eurostat_send_macrodata'\n");
		   switch(rc) {
		       case MB_ERR_INVALID:
		           fprintf(stderr, "\t reason: 'eurostat_send_macrodata' board is invalid\n");
		           break;
		       case MB_ERR_LOCKED:
	               fprintf(stderr, "\t reason: 'eurostat_send_macrodata' board is locked\n");
	               break;
	           case MB_ERR_MEMALLOC:
	               fprintf(stderr, "\t reason: out of memory\n");
	               break;
	           case MB_ERR_INTERNAL:
	               fprintf(stderr, "\t reason: internal error. Recompile libmoard in debug mode for more info \n");
	               break;
	           default:
	           
               
                   fprintf(stderr, "\t MB_Iterator_Create returned error code: %d (see libmboard docs for details)\n", rc);
               
                   break;
		   }

		   
           exit(rc);
		}
		#endif
		
		

			i = Central_Bank_monetary_policy();

		
		    rc = MB_Iterator_Delete(&i_eurostat_send_macrodata);
		    #ifdef ERRCHECK
		    if (rc != MB_SUCCESS)
		    {
		       fprintf(stderr, "ERROR: Could not delete 'eurostat_send_macrodata' iterator\n");
		       switch(rc) {
		           case MB_ERR_INVALID:
		               fprintf(stderr, "\t reason: 'eurostat_send_macrodata' iterator is invalid\n");
		               break;
		           case MB_ERR_INTERNAL:
		               fprintf(stderr, "\t reason: internal error. Recompile libmoard in debug mode for more info \n");
		               break;
		           default:
                       fprintf(stderr, "\t MB_Iterator_Delete returned error code: %d (see libmboard docs for details)\n", rc);
                       break;
		       }

		       
               exit(rc);
		    }
		    #endif
		

			if(i == 1)
			{
				free_CentralBank_agent(current_xmachine_CentralBank_holder, CentralBank_CB_reset_state);
			}
			else
			{
				transition_CentralBank_agent(current_xmachine_CentralBank_holder, CentralBank_CB_reset_state, CentralBank_CB_market_operations_state);
			}
		}

		current_xmachine_CentralBank = NULL;

		current_xmachine_CentralBank_holder = temp_xmachine_CentralBank_holder;
	}
	if(FLAME_TEST_PRINT_START_AND_END_OF_MODEL_FUNCTIONS) printf("finish Central_Bank_monetary_policy\n");

	if(FLAME_policy_rate_message_board_write == 1)
	{

		if(FLAME_TEST_PRINT_START_AND_END_OF_LIBMBOARD_CALLS) printf("start MB_SyncStart(b_policy_rate)\n");
		rc = MB_SyncStart(b_policy_rate);
		if(FLAME_TEST_PRINT_START_AND_END_OF_LIBMBOARD_CALLS) printf("finish MB_SyncStart(b_policy_rate)\n");
		#ifdef ERRCHECK
		if (rc != MB_SUCCESS)
		{
		   fprintf(stderr, "ERROR: Could not start sync of 'policy_rate' board\n");
		   switch(rc) {
			   case MB_ERR_INVALID:
				   fprintf(stderr, "\t reason: 'policy_rate' board is invalid\n");
				   break;
			   case MB_ERR_LOCKED:
				   fprintf(stderr, "\t reason: 'policy_rate' board is locked\n");
				   break;
			   case MB_ERR_MEMALLOC:
				   fprintf(stderr, "\t reason: out of memory\n");
				   break;
			   case MB_ERR_INTERNAL:
				   fprintf(stderr, "\t reason: internal error. Recompile libmoard in debug mode for more info \n");
				   break;
			   default:
				   fprintf(stderr, "\t MB_SyncStart returned error code: %d (see libmboard docs for details)\n", rc);
				   break;
		   }

			
			exit(rc);
		}
		#endif
    }
    


	if(FLAME_TEST_PRINT_START_AND_END_OF_MODEL_FUNCTIONS) printf("start Eurostat_idle\n");
	current_xmachine_Eurostat_holder = Eurostat_01_state->agents;
	while(current_xmachine_Eurostat_holder)
	{
		temp_xmachine_Eurostat_holder = current_xmachine_Eurostat_holder->next;
		current_xmachine_Eurostat = current_xmachine_Eurostat_holder->agent;
		current_xmachine_Eurostat_next_state = Eurostat_Eurostat_Start_Monthly_Loop_state;
		/* For backwards compatibility set current_xmachine */
		current_xmachine->xmachine_Firm = NULL;
		current_xmachine->xmachine_Household = NULL;
		current_xmachine->xmachine_Mall = NULL;
		current_xmachine->xmachine_IGFirm = NULL;
		current_xmachine->xmachine_Eurostat = NULL;
		current_xmachine->xmachine_Bank = NULL;
		current_xmachine->xmachine_Government = NULL;
		current_xmachine->xmachine_CentralBank = NULL;
		current_xmachine->xmachine_ClearingHouse = NULL;
		current_xmachine->xmachine_Eurostat = current_xmachine_Eurostat;

		if(FLAME_condition_Eurostat_Eurostat_idle_01_Eurostat_Start_Monthly_Loop(current_xmachine_Eurostat)==1)
		{

		

			i = Eurostat_idle();

		

			if(i == 1)
			{
				free_Eurostat_agent(current_xmachine_Eurostat_holder, Eurostat_01_state);
			}
			else
			{
				transition_Eurostat_agent(current_xmachine_Eurostat_holder, Eurostat_01_state, Eurostat_Eurostat_Start_Monthly_Loop_state);
			}
		}

		current_xmachine_Eurostat = NULL;

		current_xmachine_Eurostat_holder = temp_xmachine_Eurostat_holder;
	}
	if(FLAME_TEST_PRINT_START_AND_END_OF_MODEL_FUNCTIONS) printf("finish Eurostat_idle\n");


	if(FLAME_TEST_PRINT_START_AND_END_OF_MODEL_FUNCTIONS) printf("start idle\n");
	current_xmachine_Mall_holder = Mall_001_state->agents;
	while(current_xmachine_Mall_holder)
	{
		temp_xmachine_Mall_holder = current_xmachine_Mall_holder->next;
		current_xmachine_Mall = current_xmachine_Mall_holder->agent;
		current_xmachine_Mall_next_state = Mall_01_state;
		/* For backwards compatibility set current_xmachine */
		current_xmachine->xmachine_Firm = NULL;
		current_xmachine->xmachine_Household = NULL;
		current_xmachine->xmachine_Mall = NULL;
		current_xmachine->xmachine_IGFirm = NULL;
		current_xmachine->xmachine_Eurostat = NULL;
		current_xmachine->xmachine_Bank = NULL;
		current_xmachine->xmachine_Government = NULL;
		current_xmachine->xmachine_CentralBank = NULL;
		current_xmachine->xmachine_ClearingHouse = NULL;
		current_xmachine->xmachine_Mall = current_xmachine_Mall;

		if(FLAME_condition_Mall_idle_001_01(current_xmachine_Mall)==1)
		{

		

			i = idle();

		

			if(i == 1)
			{
				free_Mall_agent(current_xmachine_Mall_holder, Mall_001_state);
			}
			else
			{
				transition_Mall_agent(current_xmachine_Mall_holder, Mall_001_state, Mall_01_state);
			}
		}

		current_xmachine_Mall = NULL;

		current_xmachine_Mall_holder = temp_xmachine_Mall_holder;
	}
	if(FLAME_TEST_PRINT_START_AND_END_OF_MODEL_FUNCTIONS) printf("finish idle\n");


	if(FLAME_TEST_PRINT_START_AND_END_OF_MODEL_FUNCTIONS) printf("start Mall_reset_export_data\n");
	current_xmachine_Mall_holder = Mall_001_state->agents;
	while(current_xmachine_Mall_holder)
	{
		temp_xmachine_Mall_holder = current_xmachine_Mall_holder->next;
		current_xmachine_Mall = current_xmachine_Mall_holder->agent;
		current_xmachine_Mall_next_state = Mall_01_state;
		/* For backwards compatibility set current_xmachine */
		current_xmachine->xmachine_Firm = NULL;
		current_xmachine->xmachine_Household = NULL;
		current_xmachine->xmachine_Mall = NULL;
		current_xmachine->xmachine_IGFirm = NULL;
		current_xmachine->xmachine_Eurostat = NULL;
		current_xmachine->xmachine_Bank = NULL;
		current_xmachine->xmachine_Government = NULL;
		current_xmachine->xmachine_CentralBank = NULL;
		current_xmachine->xmachine_ClearingHouse = NULL;
		current_xmachine->xmachine_Mall = current_xmachine_Mall;

		if(FLAME_condition_Mall_Mall_reset_export_data_001_01(current_xmachine_Mall)==1)
		{

		

			i = Mall_reset_export_data();

		

			if(i == 1)
			{
				free_Mall_agent(current_xmachine_Mall_holder, Mall_001_state);
			}
			else
			{
				transition_Mall_agent(current_xmachine_Mall_holder, Mall_001_state, Mall_01_state);
			}
		}

		current_xmachine_Mall = NULL;

		current_xmachine_Mall_holder = temp_xmachine_Mall_holder;
	}
	if(FLAME_TEST_PRINT_START_AND_END_OF_MODEL_FUNCTIONS) printf("finish Mall_reset_export_data\n");


	if(FLAME_TEST_PRINT_START_AND_END_OF_MODEL_FUNCTIONS) printf("start idle\n");
	current_xmachine_Household_holder = Household_Household_Start_Yearly_Loop_Top_state->agents;
	while(current_xmachine_Household_holder)
	{
		temp_xmachine_Household_holder = current_xmachine_Household_holder->next;
		current_xmachine_Household = current_xmachine_Household_holder->agent;
		current_xmachine_Household_next_state = Household_Household_Start_Policy_Data_state;
		/* For backwards compatibility set current_xmachine */
		current_xmachine->xmachine_Firm = NULL;
		current_xmachine->xmachine_Household = NULL;
		current_xmachine->xmachine_Mall = NULL;
		current_xmachine->xmachine_IGFirm = NULL;
		current_xmachine->xmachine_Eurostat = NULL;
		current_xmachine->xmachine_Bank = NULL;
		current_xmachine->xmachine_Government = NULL;
		current_xmachine->xmachine_CentralBank = NULL;
		current_xmachine->xmachine_ClearingHouse = NULL;
		current_xmachine->xmachine_Household = current_xmachine_Household;

		if(FLAME_condition_Household_idle_Household_Start_Yearly_Loop_Top_Household_Start_Policy_Data(current_xmachine_Household)==1)
		{

		

			i = idle();

		

			if(i == 1)
			{
				free_Household_agent(current_xmachine_Household_holder, Household_Household_Start_Yearly_Loop_Top_state);
			}
			else
			{
				transition_Household_agent(current_xmachine_Household_holder, Household_Household_Start_Yearly_Loop_Top_state, Household_Household_Start_Policy_Data_state);
			}
		}

		current_xmachine_Household = NULL;

		current_xmachine_Household_holder = temp_xmachine_Household_holder;
	}
	if(FLAME_TEST_PRINT_START_AND_END_OF_MODEL_FUNCTIONS) printf("finish idle\n");


	if(FLAME_TEST_PRINT_START_AND_END_OF_MODEL_FUNCTIONS) printf("start idle\n");
	current_xmachine_Firm_holder = Firm_Firm_reset_state->agents;
	while(current_xmachine_Firm_holder)
	{
		temp_xmachine_Firm_holder = current_xmachine_Firm_holder->next;
		current_xmachine_Firm = current_xmachine_Firm_holder->agent;
		current_xmachine_Firm_next_state = Firm_Firm_interest_state;
		/* For backwards compatibility set current_xmachine */
		current_xmachine->xmachine_Firm = NULL;
		current_xmachine->xmachine_Household = NULL;
		current_xmachine->xmachine_Mall = NULL;
		current_xmachine->xmachine_IGFirm = NULL;
		current_xmachine->xmachine_Eurostat = NULL;
		current_xmachine->xmachine_Bank = NULL;
		current_xmachine->xmachine_Government = NULL;
		current_xmachine->xmachine_CentralBank = NULL;
		current_xmachine->xmachine_ClearingHouse = NULL;
		current_xmachine->xmachine_Firm = current_xmachine_Firm;

		if(FLAME_condition_Firm_idle_Firm_reset_Firm_interest(current_xmachine_Firm)==1)
		{

		

			i = idle();

		

			if(i == 1)
			{
				free_Firm_agent(current_xmachine_Firm_holder, Firm_Firm_reset_state);
			}
			else
			{
				transition_Firm_agent(current_xmachine_Firm_holder, Firm_Firm_reset_state, Firm_Firm_interest_state);
			}
		}

		current_xmachine_Firm = NULL;

		current_xmachine_Firm_holder = temp_xmachine_Firm_holder;
	}
	if(FLAME_TEST_PRINT_START_AND_END_OF_MODEL_FUNCTIONS) printf("finish idle\n");


	if(FLAME_TEST_PRINT_START_AND_END_OF_MODEL_FUNCTIONS) printf("start Firm_reset_variables\n");
	current_xmachine_Firm_holder = Firm_Firm_reset_state->agents;
	while(current_xmachine_Firm_holder)
	{
		temp_xmachine_Firm_holder = current_xmachine_Firm_holder->next;
		current_xmachine_Firm = current_xmachine_Firm_holder->agent;
		current_xmachine_Firm_next_state = Firm_Firm_init_01_state;
		/* For backwards compatibility set current_xmachine */
		current_xmachine->xmachine_Firm = NULL;
		current_xmachine->xmachine_Household = NULL;
		current_xmachine->xmachine_Mall = NULL;
		current_xmachine->xmachine_IGFirm = NULL;
		current_xmachine->xmachine_Eurostat = NULL;
		current_xmachine->xmachine_Bank = NULL;
		current_xmachine->xmachine_Government = NULL;
		current_xmachine->xmachine_CentralBank = NULL;
		current_xmachine->xmachine_ClearingHouse = NULL;
		current_xmachine->xmachine_Firm = current_xmachine_Firm;

		if(FLAME_condition_Firm_Firm_reset_variables_Firm_reset_Firm_init_01(current_xmachine_Firm)==1)
		{

		

			i = Firm_reset_variables();

		

			if(i == 1)
			{
				free_Firm_agent(current_xmachine_Firm_holder, Firm_Firm_reset_state);
			}
			else
			{
				transition_Firm_agent(current_xmachine_Firm_holder, Firm_Firm_reset_state, Firm_Firm_init_01_state);
			}
		}

		current_xmachine_Firm = NULL;

		current_xmachine_Firm_holder = temp_xmachine_Firm_holder;
	}
	if(FLAME_TEST_PRINT_START_AND_END_OF_MODEL_FUNCTIONS) printf("finish Firm_reset_variables\n");


	/* If mb is not read then leave sync complete until last possible moment */
	if(FLAME_redistributed_subsidies_message_board_read == 1)
	{
		if(FLAME_TEST_PRINT_START_AND_END_OF_LIBMBOARD_CALLS) printf("start MB_SyncComplete(b_redistributed_subsidies)\n");
		rc = MB_SyncComplete(b_redistributed_subsidies);
		if(FLAME_TEST_PRINT_START_AND_END_OF_LIBMBOARD_CALLS) printf("finsh MB_SyncComplete(b_redistributed_subsidies)\n");
		#ifdef ERRCHECK
		if (rc != MB_SUCCESS)
		{
		   fprintf(stderr, "ERROR: Could not complete sync of 'redistributed_subsidies' board\n");
		   switch(rc) {
				case MB_ERR_INVALID:
				   fprintf(stderr, "\t reason: 'redistributed_subsidies' board is invalid\n");
				   break;
			   case MB_ERR_MEMALLOC:
				   fprintf(stderr, "\t reason: out of memory\n");
				   break;
			   case MB_ERR_INTERNAL:
				   fprintf(stderr, "\t reason: internal error. Recompile libmoard in debug mode for more info \n");
				   break;
			   default:
				   fprintf(stderr, "\t MB_SyncComplete returned error code: %d (see libmboard docs for details)\n", rc);
				   break;
		   }
	
		   
		   exit(rc);
		}
		#endif
    
	}
	
	/* If mb is not read then leave sync complete until last possible moment */
	if(FLAME_data_for_government_message_board_read == 1)
	{
		if(FLAME_TEST_PRINT_START_AND_END_OF_LIBMBOARD_CALLS) printf("start MB_SyncComplete(b_data_for_government)\n");
		rc = MB_SyncComplete(b_data_for_government);
		if(FLAME_TEST_PRINT_START_AND_END_OF_LIBMBOARD_CALLS) printf("finsh MB_SyncComplete(b_data_for_government)\n");
		#ifdef ERRCHECK
		if (rc != MB_SUCCESS)
		{
		   fprintf(stderr, "ERROR: Could not complete sync of 'data_for_government' board\n");
		   switch(rc) {
				case MB_ERR_INVALID:
				   fprintf(stderr, "\t reason: 'data_for_government' board is invalid\n");
				   break;
			   case MB_ERR_MEMALLOC:
				   fprintf(stderr, "\t reason: out of memory\n");
				   break;
			   case MB_ERR_INTERNAL:
				   fprintf(stderr, "\t reason: internal error. Recompile libmoard in debug mode for more info \n");
				   break;
			   default:
				   fprintf(stderr, "\t MB_SyncComplete returned error code: %d (see libmboard docs for details)\n", rc);
				   break;
		   }
	
		   
		   exit(rc);
		}
		#endif
    
	}
	
	if(FLAME_TEST_PRINT_START_AND_END_OF_MODEL_FUNCTIONS) printf("start Government_read_data_from_Eurostat\n");
	current_xmachine_Government_holder = Government_001_state->agents;
	while(current_xmachine_Government_holder)
	{
		temp_xmachine_Government_holder = current_xmachine_Government_holder->next;
		current_xmachine_Government = current_xmachine_Government_holder->agent;
		current_xmachine_Government_next_state = Government_Government_Start_Yearly_Loop_Top_state;
		/* For backwards compatibility set current_xmachine */
		current_xmachine->xmachine_Firm = NULL;
		current_xmachine->xmachine_Household = NULL;
		current_xmachine->xmachine_Mall = NULL;
		current_xmachine->xmachine_IGFirm = NULL;
		current_xmachine->xmachine_Eurostat = NULL;
		current_xmachine->xmachine_Bank = NULL;
		current_xmachine->xmachine_Government = NULL;
		current_xmachine->xmachine_CentralBank = NULL;
		current_xmachine->xmachine_ClearingHouse = NULL;
		current_xmachine->xmachine_Government = current_xmachine_Government;

		

		
		
		rc = MB_Iterator_Create(b_data_for_government, &i_data_for_government);
		#ifdef ERRCHECK
		if (rc != MB_SUCCESS)
		{
		   fprintf(stderr, "ERROR: Could not create Iterator for 'data_for_government'\n");
		   switch(rc) {
		       case MB_ERR_INVALID:
		           fprintf(stderr, "\t reason: 'data_for_government' board is invalid\n");
		           break;
		       case MB_ERR_LOCKED:
	               fprintf(stderr, "\t reason: 'data_for_government' board is locked\n");
	               break;
	           case MB_ERR_MEMALLOC:
	               fprintf(stderr, "\t reason: out of memory\n");
	               break;
	           case MB_ERR_INTERNAL:
	               fprintf(stderr, "\t reason: internal error. Recompile libmoard in debug mode for more info \n");
	               break;
	           default:
	           
               
                   fprintf(stderr, "\t MB_Iterator_Create returned error code: %d (see libmboard docs for details)\n", rc);
               
                   break;
		   }

		   
           exit(rc);
		}
		#endif
		
		
		
		rc = MB_Iterator_Create(b_eurostat_send_macrodata, &i_eurostat_send_macrodata);
		#ifdef ERRCHECK
		if (rc != MB_SUCCESS)
		{
		   fprintf(stderr, "ERROR: Could not create Iterator for 'eurostat_send_macrodata'\n");
		   switch(rc) {
		       case MB_ERR_INVALID:
		           fprintf(stderr, "\t reason: 'eurostat_send_macrodata' board is invalid\n");
		           break;
		       case MB_ERR_LOCKED:
	               fprintf(stderr, "\t reason: 'eurostat_send_macrodata' board is locked\n");
	               break;
	           case MB_ERR_MEMALLOC:
	               fprintf(stderr, "\t reason: out of memory\n");
	               break;
	           case MB_ERR_INTERNAL:
	               fprintf(stderr, "\t reason: internal error. Recompile libmoard in debug mode for more info \n");
	               break;
	           default:
	           
               
                   fprintf(stderr, "\t MB_Iterator_Create returned error code: %d (see libmboard docs for details)\n", rc);
               
                   break;
		   }

		   
           exit(rc);
		}
		#endif
		
		
		rc = MB_Iterator_CreateFiltered(b_redistributed_subsidies, &i_redistributed_subsidies, &FLAME_filter_Government_Government_read_data_from_Eurostat_001_Government_Start_Yearly_Loop_Top_redistributed_subsidies, current_xmachine_Government);
		
		#ifdef ERRCHECK
		if (rc != MB_SUCCESS)
		{
		   fprintf(stderr, "ERROR: Could not create Iterator for 'redistributed_subsidies'\n");
		   switch(rc) {
		       case MB_ERR_INVALID:
		           fprintf(stderr, "\t reason: 'redistributed_subsidies' board is invalid\n");
		           break;
		       case MB_ERR_LOCKED:
	               fprintf(stderr, "\t reason: 'redistributed_subsidies' board is locked\n");
	               break;
	           case MB_ERR_MEMALLOC:
	               fprintf(stderr, "\t reason: out of memory\n");
	               break;
	           case MB_ERR_INTERNAL:
	               fprintf(stderr, "\t reason: internal error. Recompile libmoard in debug mode for more info \n");
	               break;
	           default:
	           
                   fprintf(stderr, "\t MB_Iterator_CreateFiltered returned error code: %d (see libmboard docs for details)\n", rc);
               
               
                   break;
		   }

		   
           exit(rc);
		}
		#endif
		
		

			i = Government_read_data_from_Eurostat();

		
		    rc = MB_Iterator_Delete(&i_data_for_government);
		    #ifdef ERRCHECK
		    if (rc != MB_SUCCESS)
		    {
		       fprintf(stderr, "ERROR: Could not delete 'data_for_government' iterator\n");
		       switch(rc) {
		           case MB_ERR_INVALID:
		               fprintf(stderr, "\t reason: 'data_for_government' iterator is invalid\n");
		               break;
		           case MB_ERR_INTERNAL:
		               fprintf(stderr, "\t reason: internal error. Recompile libmoard in debug mode for more info \n");
		               break;
		           default:
                       fprintf(stderr, "\t MB_Iterator_Delete returned error code: %d (see libmboard docs for details)\n", rc);
                       break;
		       }

		       
               exit(rc);
		    }
		    #endif
		
		    rc = MB_Iterator_Delete(&i_eurostat_send_macrodata);
		    #ifdef ERRCHECK
		    if (rc != MB_SUCCESS)
		    {
		       fprintf(stderr, "ERROR: Could not delete 'eurostat_send_macrodata' iterator\n");
		       switch(rc) {
		           case MB_ERR_INVALID:
		               fprintf(stderr, "\t reason: 'eurostat_send_macrodata' iterator is invalid\n");
		               break;
		           case MB_ERR_INTERNAL:
		               fprintf(stderr, "\t reason: internal error. Recompile libmoard in debug mode for more info \n");
		               break;
		           default:
                       fprintf(stderr, "\t MB_Iterator_Delete returned error code: %d (see libmboard docs for details)\n", rc);
                       break;
		       }

		       
               exit(rc);
		    }
		    #endif
		
		    rc = MB_Iterator_Delete(&i_redistributed_subsidies);
		    #ifdef ERRCHECK
		    if (rc != MB_SUCCESS)
		    {
		       fprintf(stderr, "ERROR: Could not delete 'redistributed_subsidies' iterator\n");
		       switch(rc) {
		           case MB_ERR_INVALID:
		               fprintf(stderr, "\t reason: 'redistributed_subsidies' iterator is invalid\n");
		               break;
		           case MB_ERR_INTERNAL:
		               fprintf(stderr, "\t reason: internal error. Recompile libmoard in debug mode for more info \n");
		               break;
		           default:
                       fprintf(stderr, "\t MB_Iterator_Delete returned error code: %d (see libmboard docs for details)\n", rc);
                       break;
		       }

		       
               exit(rc);
		    }
		    #endif
		

			if(i == 1)
			{
				free_Government_agent(current_xmachine_Government_holder, Government_001_state);
			}
			else
			{
				transition_Government_agent(current_xmachine_Government_holder, Government_001_state, Government_Government_Start_Yearly_Loop_Top_state);
			}
		

		current_xmachine_Government = NULL;

		current_xmachine_Government_holder = temp_xmachine_Government_holder;
	}
	if(FLAME_TEST_PRINT_START_AND_END_OF_MODEL_FUNCTIONS) printf("finish Government_read_data_from_Eurostat\n");


/* End of layer number 2 */

/* Clear message boards that have finished being used
 * and sync complete if doing late sync complete */

if(FLAME_eurostat_send_macrodata_message_board_read == 0)
{
	/*printf("%d> eurostat_send_macrodata message board sync complete late as no agents reading any messages of this type\n", node_number);*/
	
	if(FLAME_TEST_PRINT_START_AND_END_OF_LIBMBOARD_CALLS) printf("start MB_SyncComplete(b_eurostat_send_macrodata)\n");
	rc = MB_SyncComplete(b_eurostat_send_macrodata);
	if(FLAME_TEST_PRINT_START_AND_END_OF_LIBMBOARD_CALLS) printf("finsh MB_SyncComplete(b_eurostat_send_macrodata)\n");
	#ifdef ERRCHECK
	if (rc != MB_SUCCESS)
	{
	   fprintf(stderr, "ERROR: Could not complete sync of 'eurostat_send_macrodata' board\n");
	   switch(rc) {
			case MB_ERR_INVALID:
			   fprintf(stderr, "\t reason: 'eurostat_send_macrodata' board is invalid\n");
			   break;
		   case MB_ERR_MEMALLOC:
			   fprintf(stderr, "\t reason: out of memory\n");
			   break;
		   case MB_ERR_INTERNAL:
			   fprintf(stderr, "\t reason: internal error. Recompile libmoard in debug mode for more info \n");
			   break;
		   default:
			   fprintf(stderr, "\t MB_SyncComplete returned error code: %d (see libmboard docs for details)\n", rc);
			   break;
	   }

	   
	   exit(rc);
	}
	#endif
}

    rc = MB_Clear(b_eurostat_send_macrodata);
    #ifdef ERRCHECK
    if (rc != MB_SUCCESS)
    {
       fprintf(stderr, "ERROR: Could not clear 'eurostat_send_macrodata' board\n");
       switch(rc) {
           case MB_ERR_INVALID:
               fprintf(stderr, "\t reason: 'eurostat_send_macrodata' board is invalid\n");
               break;
           case MB_ERR_LOCKED:
               fprintf(stderr, "\t reason: 'eurostat_send_macrodata' board is locked\n");
               break;
           case MB_ERR_INTERNAL:
               fprintf(stderr, "\t reason: internal error. Recompile libmoard in debug mode for more info \n");
               break;
           default:
               fprintf(stderr, "\t MB_Clear returned error code: %d (see libmboard docs for details)\n", rc);
               break;

       }

       
       exit(rc);
    }
    #endif

if(FLAME_redistributed_subsidies_message_board_read == 0)
{
	/*printf("%d> redistributed_subsidies message board sync complete late as no agents reading any messages of this type\n", node_number);*/
	
	if(FLAME_TEST_PRINT_START_AND_END_OF_LIBMBOARD_CALLS) printf("start MB_SyncComplete(b_redistributed_subsidies)\n");
	rc = MB_SyncComplete(b_redistributed_subsidies);
	if(FLAME_TEST_PRINT_START_AND_END_OF_LIBMBOARD_CALLS) printf("finsh MB_SyncComplete(b_redistributed_subsidies)\n");
	#ifdef ERRCHECK
	if (rc != MB_SUCCESS)
	{
	   fprintf(stderr, "ERROR: Could not complete sync of 'redistributed_subsidies' board\n");
	   switch(rc) {
			case MB_ERR_INVALID:
			   fprintf(stderr, "\t reason: 'redistributed_subsidies' board is invalid\n");
			   break;
		   case MB_ERR_MEMALLOC:
			   fprintf(stderr, "\t reason: out of memory\n");
			   break;
		   case MB_ERR_INTERNAL:
			   fprintf(stderr, "\t reason: internal error. Recompile libmoard in debug mode for more info \n");
			   break;
		   default:
			   fprintf(stderr, "\t MB_SyncComplete returned error code: %d (see libmboard docs for details)\n", rc);
			   break;
	   }

	   
	   exit(rc);
	}
	#endif
}

    rc = MB_Clear(b_redistributed_subsidies);
    #ifdef ERRCHECK
    if (rc != MB_SUCCESS)
    {
       fprintf(stderr, "ERROR: Could not clear 'redistributed_subsidies' board\n");
       switch(rc) {
           case MB_ERR_INVALID:
               fprintf(stderr, "\t reason: 'redistributed_subsidies' board is invalid\n");
               break;
           case MB_ERR_LOCKED:
               fprintf(stderr, "\t reason: 'redistributed_subsidies' board is locked\n");
               break;
           case MB_ERR_INTERNAL:
               fprintf(stderr, "\t reason: internal error. Recompile libmoard in debug mode for more info \n");
               break;
           default:
               fprintf(stderr, "\t MB_Clear returned error code: %d (see libmboard docs for details)\n", rc);
               break;

       }

       
       exit(rc);
    }
    #endif


	if(FLAME_TEST_PRINT_START_AND_END_OF_MODEL_FUNCTIONS) printf("start Central_Bank_dummy\n");
	current_xmachine_CentralBank_holder = CentralBank_CB_market_operations_state->agents;
	while(current_xmachine_CentralBank_holder)
	{
		temp_xmachine_CentralBank_holder = current_xmachine_CentralBank_holder->next;
		current_xmachine_CentralBank = current_xmachine_CentralBank_holder->agent;
		current_xmachine_CentralBank_next_state = CentralBank_CB_financial_operations_end_state;
		/* For backwards compatibility set current_xmachine */
		current_xmachine->xmachine_Firm = NULL;
		current_xmachine->xmachine_Household = NULL;
		current_xmachine->xmachine_Mall = NULL;
		current_xmachine->xmachine_IGFirm = NULL;
		current_xmachine->xmachine_Eurostat = NULL;
		current_xmachine->xmachine_Bank = NULL;
		current_xmachine->xmachine_Government = NULL;
		current_xmachine->xmachine_CentralBank = NULL;
		current_xmachine->xmachine_ClearingHouse = NULL;
		current_xmachine->xmachine_CentralBank = current_xmachine_CentralBank;

		

		

			i = Central_Bank_dummy();

		

			if(i == 1)
			{
				free_CentralBank_agent(current_xmachine_CentralBank_holder, CentralBank_CB_market_operations_state);
			}
			else
			{
				transition_CentralBank_agent(current_xmachine_CentralBank_holder, CentralBank_CB_market_operations_state, CentralBank_CB_financial_operations_end_state);
			}
		

		current_xmachine_CentralBank = NULL;

		current_xmachine_CentralBank_holder = temp_xmachine_CentralBank_holder;
	}
	if(FLAME_TEST_PRINT_START_AND_END_OF_MODEL_FUNCTIONS) printf("finish Central_Bank_dummy\n");


	if(FLAME_TEST_PRINT_START_AND_END_OF_MODEL_FUNCTIONS) printf("start idle\n");
	current_xmachine_Government_holder = Government_Government_Start_Yearly_Loop_Top_state->agents;
	while(current_xmachine_Government_holder)
	{
		temp_xmachine_Government_holder = current_xmachine_Government_holder->next;
		current_xmachine_Government = current_xmachine_Government_holder->agent;
		current_xmachine_Government_next_state = Government_003b_state;
		/* For backwards compatibility set current_xmachine */
		current_xmachine->xmachine_Firm = NULL;
		current_xmachine->xmachine_Household = NULL;
		current_xmachine->xmachine_Mall = NULL;
		current_xmachine->xmachine_IGFirm = NULL;
		current_xmachine->xmachine_Eurostat = NULL;
		current_xmachine->xmachine_Bank = NULL;
		current_xmachine->xmachine_Government = NULL;
		current_xmachine->xmachine_CentralBank = NULL;
		current_xmachine->xmachine_ClearingHouse = NULL;
		current_xmachine->xmachine_Government = current_xmachine_Government;

		if(FLAME_condition_Government_idle_Government_Start_Yearly_Loop_Top_003b(current_xmachine_Government)==1)
		{

		

			i = idle();

		

			if(i == 1)
			{
				free_Government_agent(current_xmachine_Government_holder, Government_Government_Start_Yearly_Loop_Top_state);
			}
			else
			{
				transition_Government_agent(current_xmachine_Government_holder, Government_Government_Start_Yearly_Loop_Top_state, Government_003b_state);
			}
		}

		current_xmachine_Government = NULL;

		current_xmachine_Government_holder = temp_xmachine_Government_holder;
	}
	if(FLAME_TEST_PRINT_START_AND_END_OF_MODEL_FUNCTIONS) printf("finish idle\n");


	if(FLAME_TEST_PRINT_START_AND_END_OF_MODEL_FUNCTIONS) printf("start Government_set_policy\n");
	current_xmachine_Government_holder = Government_Government_Start_Yearly_Loop_Top_state->agents;
	while(current_xmachine_Government_holder)
	{
		temp_xmachine_Government_holder = current_xmachine_Government_holder->next;
		current_xmachine_Government = current_xmachine_Government_holder->agent;
		current_xmachine_Government_next_state = Government_002_state;
		/* For backwards compatibility set current_xmachine */
		current_xmachine->xmachine_Firm = NULL;
		current_xmachine->xmachine_Household = NULL;
		current_xmachine->xmachine_Mall = NULL;
		current_xmachine->xmachine_IGFirm = NULL;
		current_xmachine->xmachine_Eurostat = NULL;
		current_xmachine->xmachine_Bank = NULL;
		current_xmachine->xmachine_Government = NULL;
		current_xmachine->xmachine_CentralBank = NULL;
		current_xmachine->xmachine_ClearingHouse = NULL;
		current_xmachine->xmachine_Government = current_xmachine_Government;

		if(FLAME_condition_Government_Government_set_policy_Government_Start_Yearly_Loop_Top_002(current_xmachine_Government)==1)
		{

		

			i = Government_set_policy();

		

			if(i == 1)
			{
				free_Government_agent(current_xmachine_Government_holder, Government_Government_Start_Yearly_Loop_Top_state);
			}
			else
			{
				transition_Government_agent(current_xmachine_Government_holder, Government_Government_Start_Yearly_Loop_Top_state, Government_002_state);
			}
		}

		current_xmachine_Government = NULL;

		current_xmachine_Government_holder = temp_xmachine_Government_holder;
	}
	if(FLAME_TEST_PRINT_START_AND_END_OF_MODEL_FUNCTIONS) printf("finish Government_set_policy\n");


/* End of layer number 3 */

/* Clear message boards that have finished being used
 * and sync complete if doing late sync complete */


	if(FLAME_TEST_PRINT_START_AND_END_OF_MODEL_FUNCTIONS) printf("start Government_send_policy_announcements\n");
	current_xmachine_Government_holder = Government_002_state->agents;
	while(current_xmachine_Government_holder)
	{
		temp_xmachine_Government_holder = current_xmachine_Government_holder->next;
		current_xmachine_Government = current_xmachine_Government_holder->agent;
		current_xmachine_Government_next_state = Government_003_state;
		/* For backwards compatibility set current_xmachine */
		current_xmachine->xmachine_Firm = NULL;
		current_xmachine->xmachine_Household = NULL;
		current_xmachine->xmachine_Mall = NULL;
		current_xmachine->xmachine_IGFirm = NULL;
		current_xmachine->xmachine_Eurostat = NULL;
		current_xmachine->xmachine_Bank = NULL;
		current_xmachine->xmachine_Government = NULL;
		current_xmachine->xmachine_CentralBank = NULL;
		current_xmachine->xmachine_ClearingHouse = NULL;
		current_xmachine->xmachine_Government = current_xmachine_Government;

		

		

			i = Government_send_policy_announcements();

		

			if(i == 1)
			{
				free_Government_agent(current_xmachine_Government_holder, Government_002_state);
			}
			else
			{
				transition_Government_agent(current_xmachine_Government_holder, Government_002_state, Government_003_state);
			}
		

		current_xmachine_Government = NULL;

		current_xmachine_Government_holder = temp_xmachine_Government_holder;
	}
	if(FLAME_TEST_PRINT_START_AND_END_OF_MODEL_FUNCTIONS) printf("finish Government_send_policy_announcements\n");

	if(FLAME_human_capital_policy_announcement_message_board_write == 1)
	{

		if(FLAME_TEST_PRINT_START_AND_END_OF_LIBMBOARD_CALLS) printf("start MB_SyncStart(b_human_capital_policy_announcement)\n");
		rc = MB_SyncStart(b_human_capital_policy_announcement);
		if(FLAME_TEST_PRINT_START_AND_END_OF_LIBMBOARD_CALLS) printf("finish MB_SyncStart(b_human_capital_policy_announcement)\n");
		#ifdef ERRCHECK
		if (rc != MB_SUCCESS)
		{
		   fprintf(stderr, "ERROR: Could not start sync of 'human_capital_policy_announcement' board\n");
		   switch(rc) {
			   case MB_ERR_INVALID:
				   fprintf(stderr, "\t reason: 'human_capital_policy_announcement' board is invalid\n");
				   break;
			   case MB_ERR_LOCKED:
				   fprintf(stderr, "\t reason: 'human_capital_policy_announcement' board is locked\n");
				   break;
			   case MB_ERR_MEMALLOC:
				   fprintf(stderr, "\t reason: out of memory\n");
				   break;
			   case MB_ERR_INTERNAL:
				   fprintf(stderr, "\t reason: internal error. Recompile libmoard in debug mode for more info \n");
				   break;
			   default:
				   fprintf(stderr, "\t MB_SyncStart returned error code: %d (see libmboard docs for details)\n", rc);
				   break;
		   }

			
			exit(rc);
		}
		#endif
    }
    

	if(FLAME_policy_announcement_message_board_write == 1)
	{

		if(FLAME_TEST_PRINT_START_AND_END_OF_LIBMBOARD_CALLS) printf("start MB_SyncStart(b_policy_announcement)\n");
		rc = MB_SyncStart(b_policy_announcement);
		if(FLAME_TEST_PRINT_START_AND_END_OF_LIBMBOARD_CALLS) printf("finish MB_SyncStart(b_policy_announcement)\n");
		#ifdef ERRCHECK
		if (rc != MB_SUCCESS)
		{
		   fprintf(stderr, "ERROR: Could not start sync of 'policy_announcement' board\n");
		   switch(rc) {
			   case MB_ERR_INVALID:
				   fprintf(stderr, "\t reason: 'policy_announcement' board is invalid\n");
				   break;
			   case MB_ERR_LOCKED:
				   fprintf(stderr, "\t reason: 'policy_announcement' board is locked\n");
				   break;
			   case MB_ERR_MEMALLOC:
				   fprintf(stderr, "\t reason: out of memory\n");
				   break;
			   case MB_ERR_INTERNAL:
				   fprintf(stderr, "\t reason: internal error. Recompile libmoard in debug mode for more info \n");
				   break;
			   default:
				   fprintf(stderr, "\t MB_SyncStart returned error code: %d (see libmboard docs for details)\n", rc);
				   break;
		   }

			
			exit(rc);
		}
		#endif
    }
    


	if(FLAME_TEST_PRINT_START_AND_END_OF_MODEL_FUNCTIONS) printf("start idle\n");
	current_xmachine_CentralBank_holder = CentralBank_CB_financial_operations_end_state->agents;
	while(current_xmachine_CentralBank_holder)
	{
		temp_xmachine_CentralBank_holder = current_xmachine_CentralBank_holder->next;
		current_xmachine_CentralBank = current_xmachine_CentralBank_holder->agent;
		current_xmachine_CentralBank_next_state = CentralBank_00_state;
		/* For backwards compatibility set current_xmachine */
		current_xmachine->xmachine_Firm = NULL;
		current_xmachine->xmachine_Household = NULL;
		current_xmachine->xmachine_Mall = NULL;
		current_xmachine->xmachine_IGFirm = NULL;
		current_xmachine->xmachine_Eurostat = NULL;
		current_xmachine->xmachine_Bank = NULL;
		current_xmachine->xmachine_Government = NULL;
		current_xmachine->xmachine_CentralBank = NULL;
		current_xmachine->xmachine_ClearingHouse = NULL;
		current_xmachine->xmachine_CentralBank = current_xmachine_CentralBank;

		if(FLAME_condition_CentralBank_idle_CB_financial_operations_end_00(current_xmachine_CentralBank)==1)
		{

		

			i = idle();

		

			if(i == 1)
			{
				free_CentralBank_agent(current_xmachine_CentralBank_holder, CentralBank_CB_financial_operations_end_state);
			}
			else
			{
				transition_CentralBank_agent(current_xmachine_CentralBank_holder, CentralBank_CB_financial_operations_end_state, CentralBank_00_state);
			}
		}

		current_xmachine_CentralBank = NULL;

		current_xmachine_CentralBank_holder = temp_xmachine_CentralBank_holder;
	}
	if(FLAME_TEST_PRINT_START_AND_END_OF_MODEL_FUNCTIONS) printf("finish idle\n");


/* End of layer number 4 */

/* Clear message boards that have finished being used
 * and sync complete if doing late sync complete */


	if(FLAME_TEST_PRINT_START_AND_END_OF_MODEL_FUNCTIONS) printf("start Government_idle\n");
	current_xmachine_Government_holder = Government_003_state->agents;
	while(current_xmachine_Government_holder)
	{
		temp_xmachine_Government_holder = current_xmachine_Government_holder->next;
		current_xmachine_Government = current_xmachine_Government_holder->agent;
		current_xmachine_Government_next_state = Government_003a_state;
		/* For backwards compatibility set current_xmachine */
		current_xmachine->xmachine_Firm = NULL;
		current_xmachine->xmachine_Household = NULL;
		current_xmachine->xmachine_Mall = NULL;
		current_xmachine->xmachine_IGFirm = NULL;
		current_xmachine->xmachine_Eurostat = NULL;
		current_xmachine->xmachine_Bank = NULL;
		current_xmachine->xmachine_Government = NULL;
		current_xmachine->xmachine_CentralBank = NULL;
		current_xmachine->xmachine_ClearingHouse = NULL;
		current_xmachine->xmachine_Government = current_xmachine_Government;

		if(FLAME_condition_Government_Government_idle_003_003a(current_xmachine_Government)==1)
		{

		

			i = Government_idle();

		

			if(i == 1)
			{
				free_Government_agent(current_xmachine_Government_holder, Government_003_state);
			}
			else
			{
				transition_Government_agent(current_xmachine_Government_holder, Government_003_state, Government_003a_state);
			}
		}

		current_xmachine_Government = NULL;

		current_xmachine_Government_holder = temp_xmachine_Government_holder;
	}
	if(FLAME_TEST_PRINT_START_AND_END_OF_MODEL_FUNCTIONS) printf("finish Government_idle\n");


	/* If mb is not read then leave sync complete until last possible moment */
	if(FLAME_quality_price_message_board_read == 1)
	{
		if(FLAME_TEST_PRINT_START_AND_END_OF_LIBMBOARD_CALLS) printf("start MB_SyncComplete(b_quality_price)\n");
		rc = MB_SyncComplete(b_quality_price);
		if(FLAME_TEST_PRINT_START_AND_END_OF_LIBMBOARD_CALLS) printf("finsh MB_SyncComplete(b_quality_price)\n");
		#ifdef ERRCHECK
		if (rc != MB_SUCCESS)
		{
		   fprintf(stderr, "ERROR: Could not complete sync of 'quality_price' board\n");
		   switch(rc) {
				case MB_ERR_INVALID:
				   fprintf(stderr, "\t reason: 'quality_price' board is invalid\n");
				   break;
			   case MB_ERR_MEMALLOC:
				   fprintf(stderr, "\t reason: out of memory\n");
				   break;
			   case MB_ERR_INTERNAL:
				   fprintf(stderr, "\t reason: internal error. Recompile libmoard in debug mode for more info \n");
				   break;
			   default:
				   fprintf(stderr, "\t MB_SyncComplete returned error code: %d (see libmboard docs for details)\n", rc);
				   break;
		   }
	
		   
		   exit(rc);
		}
		#endif
    
	}
	
	/* If mb is not read then leave sync complete until last possible moment */
	if(FLAME_msg_market_sizes_message_board_read == 1)
	{
		if(FLAME_TEST_PRINT_START_AND_END_OF_LIBMBOARD_CALLS) printf("start MB_SyncComplete(b_msg_market_sizes)\n");
		rc = MB_SyncComplete(b_msg_market_sizes);
		if(FLAME_TEST_PRINT_START_AND_END_OF_LIBMBOARD_CALLS) printf("finsh MB_SyncComplete(b_msg_market_sizes)\n");
		#ifdef ERRCHECK
		if (rc != MB_SUCCESS)
		{
		   fprintf(stderr, "ERROR: Could not complete sync of 'msg_market_sizes' board\n");
		   switch(rc) {
				case MB_ERR_INVALID:
				   fprintf(stderr, "\t reason: 'msg_market_sizes' board is invalid\n");
				   break;
			   case MB_ERR_MEMALLOC:
				   fprintf(stderr, "\t reason: out of memory\n");
				   break;
			   case MB_ERR_INTERNAL:
				   fprintf(stderr, "\t reason: internal error. Recompile libmoard in debug mode for more info \n");
				   break;
			   default:
				   fprintf(stderr, "\t MB_SyncComplete returned error code: %d (see libmboard docs for details)\n", rc);
				   break;
		   }
	
		   
		   exit(rc);
		}
		#endif
    
	}
	
	/* If mb is not read then leave sync complete until last possible moment */
	if(FLAME_eurostat_send_specific_skills_message_board_read == 1)
	{
		if(FLAME_TEST_PRINT_START_AND_END_OF_LIBMBOARD_CALLS) printf("start MB_SyncComplete(b_eurostat_send_specific_skills)\n");
		rc = MB_SyncComplete(b_eurostat_send_specific_skills);
		if(FLAME_TEST_PRINT_START_AND_END_OF_LIBMBOARD_CALLS) printf("finsh MB_SyncComplete(b_eurostat_send_specific_skills)\n");
		#ifdef ERRCHECK
		if (rc != MB_SUCCESS)
		{
		   fprintf(stderr, "ERROR: Could not complete sync of 'eurostat_send_specific_skills' board\n");
		   switch(rc) {
				case MB_ERR_INVALID:
				   fprintf(stderr, "\t reason: 'eurostat_send_specific_skills' board is invalid\n");
				   break;
			   case MB_ERR_MEMALLOC:
				   fprintf(stderr, "\t reason: out of memory\n");
				   break;
			   case MB_ERR_INTERNAL:
				   fprintf(stderr, "\t reason: internal error. Recompile libmoard in debug mode for more info \n");
				   break;
			   default:
				   fprintf(stderr, "\t MB_SyncComplete returned error code: %d (see libmboard docs for details)\n", rc);
				   break;
		   }
	
		   
		   exit(rc);
		}
		#endif
    
	}
	
	/* If mb is not read then leave sync complete until last possible moment */
	if(FLAME_policy_announcement_message_board_read == 1)
	{
		if(FLAME_TEST_PRINT_START_AND_END_OF_LIBMBOARD_CALLS) printf("start MB_SyncComplete(b_policy_announcement)\n");
		rc = MB_SyncComplete(b_policy_announcement);
		if(FLAME_TEST_PRINT_START_AND_END_OF_LIBMBOARD_CALLS) printf("finsh MB_SyncComplete(b_policy_announcement)\n");
		#ifdef ERRCHECK
		if (rc != MB_SUCCESS)
		{
		   fprintf(stderr, "ERROR: Could not complete sync of 'policy_announcement' board\n");
		   switch(rc) {
				case MB_ERR_INVALID:
				   fprintf(stderr, "\t reason: 'policy_announcement' board is invalid\n");
				   break;
			   case MB_ERR_MEMALLOC:
				   fprintf(stderr, "\t reason: out of memory\n");
				   break;
			   case MB_ERR_INTERNAL:
				   fprintf(stderr, "\t reason: internal error. Recompile libmoard in debug mode for more info \n");
				   break;
			   default:
				   fprintf(stderr, "\t MB_SyncComplete returned error code: %d (see libmboard docs for details)\n", rc);
				   break;
		   }
	
		   
		   exit(rc);
		}
		#endif
    
	}
	
	if(FLAME_TEST_PRINT_START_AND_END_OF_MODEL_FUNCTIONS) printf("start Firm_receive_data\n");
	current_xmachine_Firm_holder = Firm_Firm_init_01_state->agents;
	while(current_xmachine_Firm_holder)
	{
		temp_xmachine_Firm_holder = current_xmachine_Firm_holder->next;
		current_xmachine_Firm = current_xmachine_Firm_holder->agent;
		current_xmachine_Firm_next_state = Firm_Firm_interest_state;
		/* For backwards compatibility set current_xmachine */
		current_xmachine->xmachine_Firm = NULL;
		current_xmachine->xmachine_Household = NULL;
		current_xmachine->xmachine_Mall = NULL;
		current_xmachine->xmachine_IGFirm = NULL;
		current_xmachine->xmachine_Eurostat = NULL;
		current_xmachine->xmachine_Bank = NULL;
		current_xmachine->xmachine_Government = NULL;
		current_xmachine->xmachine_CentralBank = NULL;
		current_xmachine->xmachine_ClearingHouse = NULL;
		current_xmachine->xmachine_Firm = current_xmachine_Firm;

		if(FLAME_condition_Firm_Firm_receive_data_Firm_init_01_Firm_interest(current_xmachine_Firm)==1)
		{

		
		rc = MB_Iterator_CreateFiltered(b_eurostat_send_specific_skills, &i_eurostat_send_specific_skills, &FLAME_filter_Firm_Firm_receive_data_Firm_init_01_Firm_interest_eurostat_send_specific_skills, current_xmachine_Firm);
		
		#ifdef ERRCHECK
		if (rc != MB_SUCCESS)
		{
		   fprintf(stderr, "ERROR: Could not create Iterator for 'eurostat_send_specific_skills'\n");
		   switch(rc) {
		       case MB_ERR_INVALID:
		           fprintf(stderr, "\t reason: 'eurostat_send_specific_skills' board is invalid\n");
		           break;
		       case MB_ERR_LOCKED:
	               fprintf(stderr, "\t reason: 'eurostat_send_specific_skills' board is locked\n");
	               break;
	           case MB_ERR_MEMALLOC:
	               fprintf(stderr, "\t reason: out of memory\n");
	               break;
	           case MB_ERR_INTERNAL:
	               fprintf(stderr, "\t reason: internal error. Recompile libmoard in debug mode for more info \n");
	               break;
	           default:
	           
                   fprintf(stderr, "\t MB_Iterator_CreateFiltered returned error code: %d (see libmboard docs for details)\n", rc);
               
               
                   break;
		   }

		   
           exit(rc);
		}
		#endif
		
		
		rc = MB_Iterator_CreateFiltered(b_policy_announcement, &i_policy_announcement, &FLAME_filter_Firm_Firm_receive_data_Firm_init_01_Firm_interest_policy_announcement, current_xmachine_Firm);
		
		#ifdef ERRCHECK
		if (rc != MB_SUCCESS)
		{
		   fprintf(stderr, "ERROR: Could not create Iterator for 'policy_announcement'\n");
		   switch(rc) {
		       case MB_ERR_INVALID:
		           fprintf(stderr, "\t reason: 'policy_announcement' board is invalid\n");
		           break;
		       case MB_ERR_LOCKED:
	               fprintf(stderr, "\t reason: 'policy_announcement' board is locked\n");
	               break;
	           case MB_ERR_MEMALLOC:
	               fprintf(stderr, "\t reason: out of memory\n");
	               break;
	           case MB_ERR_INTERNAL:
	               fprintf(stderr, "\t reason: internal error. Recompile libmoard in debug mode for more info \n");
	               break;
	           default:
	           
                   fprintf(stderr, "\t MB_Iterator_CreateFiltered returned error code: %d (see libmboard docs for details)\n", rc);
               
               
                   break;
		   }

		   
           exit(rc);
		}
		#endif
		
		
		
		rc = MB_Iterator_Create(b_msg_market_sizes, &i_msg_market_sizes);
		#ifdef ERRCHECK
		if (rc != MB_SUCCESS)
		{
		   fprintf(stderr, "ERROR: Could not create Iterator for 'msg_market_sizes'\n");
		   switch(rc) {
		       case MB_ERR_INVALID:
		           fprintf(stderr, "\t reason: 'msg_market_sizes' board is invalid\n");
		           break;
		       case MB_ERR_LOCKED:
	               fprintf(stderr, "\t reason: 'msg_market_sizes' board is locked\n");
	               break;
	           case MB_ERR_MEMALLOC:
	               fprintf(stderr, "\t reason: out of memory\n");
	               break;
	           case MB_ERR_INTERNAL:
	               fprintf(stderr, "\t reason: internal error. Recompile libmoard in debug mode for more info \n");
	               break;
	           default:
	           
               
                   fprintf(stderr, "\t MB_Iterator_Create returned error code: %d (see libmboard docs for details)\n", rc);
               
                   break;
		   }

		   
           exit(rc);
		}
		#endif
		
		
		
		rc = MB_Iterator_Create(b_quality_price, &i_quality_price);
		#ifdef ERRCHECK
		if (rc != MB_SUCCESS)
		{
		   fprintf(stderr, "ERROR: Could not create Iterator for 'quality_price'\n");
		   switch(rc) {
		       case MB_ERR_INVALID:
		           fprintf(stderr, "\t reason: 'quality_price' board is invalid\n");
		           break;
		       case MB_ERR_LOCKED:
	               fprintf(stderr, "\t reason: 'quality_price' board is locked\n");
	               break;
	           case MB_ERR_MEMALLOC:
	               fprintf(stderr, "\t reason: out of memory\n");
	               break;
	           case MB_ERR_INTERNAL:
	               fprintf(stderr, "\t reason: internal error. Recompile libmoard in debug mode for more info \n");
	               break;
	           default:
	           
               
                   fprintf(stderr, "\t MB_Iterator_Create returned error code: %d (see libmboard docs for details)\n", rc);
               
                   break;
		   }

		   
           exit(rc);
		}
		#endif
		
		

			i = Firm_receive_data();

		
		    rc = MB_Iterator_Delete(&i_eurostat_send_specific_skills);
		    #ifdef ERRCHECK
		    if (rc != MB_SUCCESS)
		    {
		       fprintf(stderr, "ERROR: Could not delete 'eurostat_send_specific_skills' iterator\n");
		       switch(rc) {
		           case MB_ERR_INVALID:
		               fprintf(stderr, "\t reason: 'eurostat_send_specific_skills' iterator is invalid\n");
		               break;
		           case MB_ERR_INTERNAL:
		               fprintf(stderr, "\t reason: internal error. Recompile libmoard in debug mode for more info \n");
		               break;
		           default:
                       fprintf(stderr, "\t MB_Iterator_Delete returned error code: %d (see libmboard docs for details)\n", rc);
                       break;
		       }

		       
               exit(rc);
		    }
		    #endif
		
		    rc = MB_Iterator_Delete(&i_policy_announcement);
		    #ifdef ERRCHECK
		    if (rc != MB_SUCCESS)
		    {
		       fprintf(stderr, "ERROR: Could not delete 'policy_announcement' iterator\n");
		       switch(rc) {
		           case MB_ERR_INVALID:
		               fprintf(stderr, "\t reason: 'policy_announcement' iterator is invalid\n");
		               break;
		           case MB_ERR_INTERNAL:
		               fprintf(stderr, "\t reason: internal error. Recompile libmoard in debug mode for more info \n");
		               break;
		           default:
                       fprintf(stderr, "\t MB_Iterator_Delete returned error code: %d (see libmboard docs for details)\n", rc);
                       break;
		       }

		       
               exit(rc);
		    }
		    #endif
		
		    rc = MB_Iterator_Delete(&i_msg_market_sizes);
		    #ifdef ERRCHECK
		    if (rc != MB_SUCCESS)
		    {
		       fprintf(stderr, "ERROR: Could not delete 'msg_market_sizes' iterator\n");
		       switch(rc) {
		           case MB_ERR_INVALID:
		               fprintf(stderr, "\t reason: 'msg_market_sizes' iterator is invalid\n");
		               break;
		           case MB_ERR_INTERNAL:
		               fprintf(stderr, "\t reason: internal error. Recompile libmoard in debug mode for more info \n");
		               break;
		           default:
                       fprintf(stderr, "\t MB_Iterator_Delete returned error code: %d (see libmboard docs for details)\n", rc);
                       break;
		       }

		       
               exit(rc);
		    }
		    #endif
		
		    rc = MB_Iterator_Delete(&i_quality_price);
		    #ifdef ERRCHECK
		    if (rc != MB_SUCCESS)
		    {
		       fprintf(stderr, "ERROR: Could not delete 'quality_price' iterator\n");
		       switch(rc) {
		           case MB_ERR_INVALID:
		               fprintf(stderr, "\t reason: 'quality_price' iterator is invalid\n");
		               break;
		           case MB_ERR_INTERNAL:
		               fprintf(stderr, "\t reason: internal error. Recompile libmoard in debug mode for more info \n");
		               break;
		           default:
                       fprintf(stderr, "\t MB_Iterator_Delete returned error code: %d (see libmboard docs for details)\n", rc);
                       break;
		       }

		       
               exit(rc);
		    }
		    #endif
		

			if(i == 1)
			{
				free_Firm_agent(current_xmachine_Firm_holder, Firm_Firm_init_01_state);
			}
			else
			{
				transition_Firm_agent(current_xmachine_Firm_holder, Firm_Firm_init_01_state, Firm_Firm_interest_state);
			}
		}

		current_xmachine_Firm = NULL;

		current_xmachine_Firm_holder = temp_xmachine_Firm_holder;
	}
	if(FLAME_TEST_PRINT_START_AND_END_OF_MODEL_FUNCTIONS) printf("finish Firm_receive_data\n");


	/* If mb is not read then leave sync complete until last possible moment */
	if(FLAME_msg_skills_eurostat_to_igfirm_message_board_read == 1)
	{
		if(FLAME_TEST_PRINT_START_AND_END_OF_LIBMBOARD_CALLS) printf("start MB_SyncComplete(b_msg_skills_eurostat_to_igfirm)\n");
		rc = MB_SyncComplete(b_msg_skills_eurostat_to_igfirm);
		if(FLAME_TEST_PRINT_START_AND_END_OF_LIBMBOARD_CALLS) printf("finsh MB_SyncComplete(b_msg_skills_eurostat_to_igfirm)\n");
		#ifdef ERRCHECK
		if (rc != MB_SUCCESS)
		{
		   fprintf(stderr, "ERROR: Could not complete sync of 'msg_skills_eurostat_to_igfirm' board\n");
		   switch(rc) {
				case MB_ERR_INVALID:
				   fprintf(stderr, "\t reason: 'msg_skills_eurostat_to_igfirm' board is invalid\n");
				   break;
			   case MB_ERR_MEMALLOC:
				   fprintf(stderr, "\t reason: out of memory\n");
				   break;
			   case MB_ERR_INTERNAL:
				   fprintf(stderr, "\t reason: internal error. Recompile libmoard in debug mode for more info \n");
				   break;
			   default:
				   fprintf(stderr, "\t MB_SyncComplete returned error code: %d (see libmboard docs for details)\n", rc);
				   break;
		   }
	
		   
		   exit(rc);
		}
		#endif
    
	}
	
	if(FLAME_TEST_PRINT_START_AND_END_OF_MODEL_FUNCTIONS) printf("start IGFirm_receive_data\n");
	current_xmachine_IGFirm_holder = IGFirm_IGFirm_init_01_state->agents;
	while(current_xmachine_IGFirm_holder)
	{
		temp_xmachine_IGFirm_holder = current_xmachine_IGFirm_holder->next;
		current_xmachine_IGFirm = current_xmachine_IGFirm_holder->agent;
		current_xmachine_IGFirm_next_state = IGFirm_IGFirm_interest_state;
		/* For backwards compatibility set current_xmachine */
		current_xmachine->xmachine_Firm = NULL;
		current_xmachine->xmachine_Household = NULL;
		current_xmachine->xmachine_Mall = NULL;
		current_xmachine->xmachine_IGFirm = NULL;
		current_xmachine->xmachine_Eurostat = NULL;
		current_xmachine->xmachine_Bank = NULL;
		current_xmachine->xmachine_Government = NULL;
		current_xmachine->xmachine_CentralBank = NULL;
		current_xmachine->xmachine_ClearingHouse = NULL;
		current_xmachine->xmachine_IGFirm = current_xmachine_IGFirm;

		if(FLAME_condition_IGFirm_IGFirm_receive_data_IGFirm_init_01_IGFirm_interest(current_xmachine_IGFirm)==1)
		{

		
		rc = MB_Iterator_CreateFiltered(b_eurostat_send_specific_skills, &i_eurostat_send_specific_skills, &FLAME_filter_IGFirm_IGFirm_receive_data_IGFirm_init_01_IGFirm_interest_eurostat_send_specific_skills, current_xmachine_IGFirm);
		
		#ifdef ERRCHECK
		if (rc != MB_SUCCESS)
		{
		   fprintf(stderr, "ERROR: Could not create Iterator for 'eurostat_send_specific_skills'\n");
		   switch(rc) {
		       case MB_ERR_INVALID:
		           fprintf(stderr, "\t reason: 'eurostat_send_specific_skills' board is invalid\n");
		           break;
		       case MB_ERR_LOCKED:
	               fprintf(stderr, "\t reason: 'eurostat_send_specific_skills' board is locked\n");
	               break;
	           case MB_ERR_MEMALLOC:
	               fprintf(stderr, "\t reason: out of memory\n");
	               break;
	           case MB_ERR_INTERNAL:
	               fprintf(stderr, "\t reason: internal error. Recompile libmoard in debug mode for more info \n");
	               break;
	           default:
	           
                   fprintf(stderr, "\t MB_Iterator_CreateFiltered returned error code: %d (see libmboard docs for details)\n", rc);
               
               
                   break;
		   }

		   
           exit(rc);
		}
		#endif
		
		
		rc = MB_Iterator_CreateFiltered(b_policy_announcement, &i_policy_announcement, &FLAME_filter_IGFirm_IGFirm_receive_data_IGFirm_init_01_IGFirm_interest_policy_announcement, current_xmachine_IGFirm);
		
		#ifdef ERRCHECK
		if (rc != MB_SUCCESS)
		{
		   fprintf(stderr, "ERROR: Could not create Iterator for 'policy_announcement'\n");
		   switch(rc) {
		       case MB_ERR_INVALID:
		           fprintf(stderr, "\t reason: 'policy_announcement' board is invalid\n");
		           break;
		       case MB_ERR_LOCKED:
	               fprintf(stderr, "\t reason: 'policy_announcement' board is locked\n");
	               break;
	           case MB_ERR_MEMALLOC:
	               fprintf(stderr, "\t reason: out of memory\n");
	               break;
	           case MB_ERR_INTERNAL:
	               fprintf(stderr, "\t reason: internal error. Recompile libmoard in debug mode for more info \n");
	               break;
	           default:
	           
                   fprintf(stderr, "\t MB_Iterator_CreateFiltered returned error code: %d (see libmboard docs for details)\n", rc);
               
               
                   break;
		   }

		   
           exit(rc);
		}
		#endif
		
		
		
		rc = MB_Iterator_Create(b_msg_skills_eurostat_to_igfirm, &i_msg_skills_eurostat_to_igfirm);
		#ifdef ERRCHECK
		if (rc != MB_SUCCESS)
		{
		   fprintf(stderr, "ERROR: Could not create Iterator for 'msg_skills_eurostat_to_igfirm'\n");
		   switch(rc) {
		       case MB_ERR_INVALID:
		           fprintf(stderr, "\t reason: 'msg_skills_eurostat_to_igfirm' board is invalid\n");
		           break;
		       case MB_ERR_LOCKED:
	               fprintf(stderr, "\t reason: 'msg_skills_eurostat_to_igfirm' board is locked\n");
	               break;
	           case MB_ERR_MEMALLOC:
	               fprintf(stderr, "\t reason: out of memory\n");
	               break;
	           case MB_ERR_INTERNAL:
	               fprintf(stderr, "\t reason: internal error. Recompile libmoard in debug mode for more info \n");
	               break;
	           default:
	           
               
                   fprintf(stderr, "\t MB_Iterator_Create returned error code: %d (see libmboard docs for details)\n", rc);
               
                   break;
		   }

		   
           exit(rc);
		}
		#endif
		
		

			i = IGFirm_receive_data();

		
		    rc = MB_Iterator_Delete(&i_eurostat_send_specific_skills);
		    #ifdef ERRCHECK
		    if (rc != MB_SUCCESS)
		    {
		       fprintf(stderr, "ERROR: Could not delete 'eurostat_send_specific_skills' iterator\n");
		       switch(rc) {
		           case MB_ERR_INVALID:
		               fprintf(stderr, "\t reason: 'eurostat_send_specific_skills' iterator is invalid\n");
		               break;
		           case MB_ERR_INTERNAL:
		               fprintf(stderr, "\t reason: internal error. Recompile libmoard in debug mode for more info \n");
		               break;
		           default:
                       fprintf(stderr, "\t MB_Iterator_Delete returned error code: %d (see libmboard docs for details)\n", rc);
                       break;
		       }

		       
               exit(rc);
		    }
		    #endif
		
		    rc = MB_Iterator_Delete(&i_policy_announcement);
		    #ifdef ERRCHECK
		    if (rc != MB_SUCCESS)
		    {
		       fprintf(stderr, "ERROR: Could not delete 'policy_announcement' iterator\n");
		       switch(rc) {
		           case MB_ERR_INVALID:
		               fprintf(stderr, "\t reason: 'policy_announcement' iterator is invalid\n");
		               break;
		           case MB_ERR_INTERNAL:
		               fprintf(stderr, "\t reason: internal error. Recompile libmoard in debug mode for more info \n");
		               break;
		           default:
                       fprintf(stderr, "\t MB_Iterator_Delete returned error code: %d (see libmboard docs for details)\n", rc);
                       break;
		       }

		       
               exit(rc);
		    }
		    #endif
		
		    rc = MB_Iterator_Delete(&i_msg_skills_eurostat_to_igfirm);
		    #ifdef ERRCHECK
		    if (rc != MB_SUCCESS)
		    {
		       fprintf(stderr, "ERROR: Could not delete 'msg_skills_eurostat_to_igfirm' iterator\n");
		       switch(rc) {
		           case MB_ERR_INVALID:
		               fprintf(stderr, "\t reason: 'msg_skills_eurostat_to_igfirm' iterator is invalid\n");
		               break;
		           case MB_ERR_INTERNAL:
		               fprintf(stderr, "\t reason: internal error. Recompile libmoard in debug mode for more info \n");
		               break;
		           default:
                       fprintf(stderr, "\t MB_Iterator_Delete returned error code: %d (see libmboard docs for details)\n", rc);
                       break;
		       }

		       
               exit(rc);
		    }
		    #endif
		

			if(i == 1)
			{
				free_IGFirm_agent(current_xmachine_IGFirm_holder, IGFirm_IGFirm_init_01_state);
			}
			else
			{
				transition_IGFirm_agent(current_xmachine_IGFirm_holder, IGFirm_IGFirm_init_01_state, IGFirm_IGFirm_interest_state);
			}
		}

		current_xmachine_IGFirm = NULL;

		current_xmachine_IGFirm_holder = temp_xmachine_IGFirm_holder;
	}
	if(FLAME_TEST_PRINT_START_AND_END_OF_MODEL_FUNCTIONS) printf("finish IGFirm_receive_data\n");


	/* If mb is not read then leave sync complete until last possible moment */
	if(FLAME_human_capital_policy_announcement_message_board_read == 1)
	{
		if(FLAME_TEST_PRINT_START_AND_END_OF_LIBMBOARD_CALLS) printf("start MB_SyncComplete(b_human_capital_policy_announcement)\n");
		rc = MB_SyncComplete(b_human_capital_policy_announcement);
		if(FLAME_TEST_PRINT_START_AND_END_OF_LIBMBOARD_CALLS) printf("finsh MB_SyncComplete(b_human_capital_policy_announcement)\n");
		#ifdef ERRCHECK
		if (rc != MB_SUCCESS)
		{
		   fprintf(stderr, "ERROR: Could not complete sync of 'human_capital_policy_announcement' board\n");
		   switch(rc) {
				case MB_ERR_INVALID:
				   fprintf(stderr, "\t reason: 'human_capital_policy_announcement' board is invalid\n");
				   break;
			   case MB_ERR_MEMALLOC:
				   fprintf(stderr, "\t reason: out of memory\n");
				   break;
			   case MB_ERR_INTERNAL:
				   fprintf(stderr, "\t reason: internal error. Recompile libmoard in debug mode for more info \n");
				   break;
			   default:
				   fprintf(stderr, "\t MB_SyncComplete returned error code: %d (see libmboard docs for details)\n", rc);
				   break;
		   }
	
		   
		   exit(rc);
		}
		#endif
    
	}
	
	if(FLAME_TEST_PRINT_START_AND_END_OF_MODEL_FUNCTIONS) printf("start Household_read_policy_announcements\n");
	current_xmachine_Household_holder = Household_Household_Start_Yearly_Loop_Top_state->agents;
	while(current_xmachine_Household_holder)
	{
		temp_xmachine_Household_holder = current_xmachine_Household_holder->next;
		current_xmachine_Household = current_xmachine_Household_holder->agent;
		current_xmachine_Household_next_state = Household_Pol_01_state;
		/* For backwards compatibility set current_xmachine */
		current_xmachine->xmachine_Firm = NULL;
		current_xmachine->xmachine_Household = NULL;
		current_xmachine->xmachine_Mall = NULL;
		current_xmachine->xmachine_IGFirm = NULL;
		current_xmachine->xmachine_Eurostat = NULL;
		current_xmachine->xmachine_Bank = NULL;
		current_xmachine->xmachine_Government = NULL;
		current_xmachine->xmachine_CentralBank = NULL;
		current_xmachine->xmachine_ClearingHouse = NULL;
		current_xmachine->xmachine_Household = current_xmachine_Household;

		if(FLAME_condition_Household_Household_read_policy_announcements_Household_Start_Yearly_Loop_Top_Pol_01(current_xmachine_Household)==1)
		{

		
		rc = MB_Iterator_CreateFiltered(b_policy_announcement, &i_policy_announcement, &FLAME_filter_Household_Household_read_policy_announcements_Household_Start_Yearly_Loop_Top_Pol_01_policy_announcement, current_xmachine_Household);
		
		#ifdef ERRCHECK
		if (rc != MB_SUCCESS)
		{
		   fprintf(stderr, "ERROR: Could not create Iterator for 'policy_announcement'\n");
		   switch(rc) {
		       case MB_ERR_INVALID:
		           fprintf(stderr, "\t reason: 'policy_announcement' board is invalid\n");
		           break;
		       case MB_ERR_LOCKED:
	               fprintf(stderr, "\t reason: 'policy_announcement' board is locked\n");
	               break;
	           case MB_ERR_MEMALLOC:
	               fprintf(stderr, "\t reason: out of memory\n");
	               break;
	           case MB_ERR_INTERNAL:
	               fprintf(stderr, "\t reason: internal error. Recompile libmoard in debug mode for more info \n");
	               break;
	           default:
	           
                   fprintf(stderr, "\t MB_Iterator_CreateFiltered returned error code: %d (see libmboard docs for details)\n", rc);
               
               
                   break;
		   }

		   
           exit(rc);
		}
		#endif
		
		
		rc = MB_Iterator_CreateFiltered(b_human_capital_policy_announcement, &i_human_capital_policy_announcement, &FLAME_filter_Household_Household_read_policy_announcements_Household_Start_Yearly_Loop_Top_Pol_01_human_capital_policy_announcement, current_xmachine_Household);
		
		#ifdef ERRCHECK
		if (rc != MB_SUCCESS)
		{
		   fprintf(stderr, "ERROR: Could not create Iterator for 'human_capital_policy_announcement'\n");
		   switch(rc) {
		       case MB_ERR_INVALID:
		           fprintf(stderr, "\t reason: 'human_capital_policy_announcement' board is invalid\n");
		           break;
		       case MB_ERR_LOCKED:
	               fprintf(stderr, "\t reason: 'human_capital_policy_announcement' board is locked\n");
	               break;
	           case MB_ERR_MEMALLOC:
	               fprintf(stderr, "\t reason: out of memory\n");
	               break;
	           case MB_ERR_INTERNAL:
	               fprintf(stderr, "\t reason: internal error. Recompile libmoard in debug mode for more info \n");
	               break;
	           default:
	           
                   fprintf(stderr, "\t MB_Iterator_CreateFiltered returned error code: %d (see libmboard docs for details)\n", rc);
               
               
                   break;
		   }

		   
           exit(rc);
		}
		#endif
		
		

			i = Household_read_policy_announcements();

		
		    rc = MB_Iterator_Delete(&i_policy_announcement);
		    #ifdef ERRCHECK
		    if (rc != MB_SUCCESS)
		    {
		       fprintf(stderr, "ERROR: Could not delete 'policy_announcement' iterator\n");
		       switch(rc) {
		           case MB_ERR_INVALID:
		               fprintf(stderr, "\t reason: 'policy_announcement' iterator is invalid\n");
		               break;
		           case MB_ERR_INTERNAL:
		               fprintf(stderr, "\t reason: internal error. Recompile libmoard in debug mode for more info \n");
		               break;
		           default:
                       fprintf(stderr, "\t MB_Iterator_Delete returned error code: %d (see libmboard docs for details)\n", rc);
                       break;
		       }

		       
               exit(rc);
		    }
		    #endif
		
		    rc = MB_Iterator_Delete(&i_human_capital_policy_announcement);
		    #ifdef ERRCHECK
		    if (rc != MB_SUCCESS)
		    {
		       fprintf(stderr, "ERROR: Could not delete 'human_capital_policy_announcement' iterator\n");
		       switch(rc) {
		           case MB_ERR_INVALID:
		               fprintf(stderr, "\t reason: 'human_capital_policy_announcement' iterator is invalid\n");
		               break;
		           case MB_ERR_INTERNAL:
		               fprintf(stderr, "\t reason: internal error. Recompile libmoard in debug mode for more info \n");
		               break;
		           default:
                       fprintf(stderr, "\t MB_Iterator_Delete returned error code: %d (see libmboard docs for details)\n", rc);
                       break;
		       }

		       
               exit(rc);
		    }
		    #endif
		

			if(i == 1)
			{
				free_Household_agent(current_xmachine_Household_holder, Household_Household_Start_Yearly_Loop_Top_state);
			}
			else
			{
				transition_Household_agent(current_xmachine_Household_holder, Household_Household_Start_Yearly_Loop_Top_state, Household_Pol_01_state);
			}
		}

		current_xmachine_Household = NULL;

		current_xmachine_Household_holder = temp_xmachine_Household_holder;
	}
	if(FLAME_TEST_PRINT_START_AND_END_OF_MODEL_FUNCTIONS) printf("finish Household_read_policy_announcements\n");

	if(FLAME_human_capital_policy_general_skill_information_message_board_write == 1)
	{

		if(FLAME_TEST_PRINT_START_AND_END_OF_LIBMBOARD_CALLS) printf("start MB_SyncStart(b_human_capital_policy_general_skill_information)\n");
		rc = MB_SyncStart(b_human_capital_policy_general_skill_information);
		if(FLAME_TEST_PRINT_START_AND_END_OF_LIBMBOARD_CALLS) printf("finish MB_SyncStart(b_human_capital_policy_general_skill_information)\n");
		#ifdef ERRCHECK
		if (rc != MB_SUCCESS)
		{
		   fprintf(stderr, "ERROR: Could not start sync of 'human_capital_policy_general_skill_information' board\n");
		   switch(rc) {
			   case MB_ERR_INVALID:
				   fprintf(stderr, "\t reason: 'human_capital_policy_general_skill_information' board is invalid\n");
				   break;
			   case MB_ERR_LOCKED:
				   fprintf(stderr, "\t reason: 'human_capital_policy_general_skill_information' board is locked\n");
				   break;
			   case MB_ERR_MEMALLOC:
				   fprintf(stderr, "\t reason: out of memory\n");
				   break;
			   case MB_ERR_INTERNAL:
				   fprintf(stderr, "\t reason: internal error. Recompile libmoard in debug mode for more info \n");
				   break;
			   default:
				   fprintf(stderr, "\t MB_SyncStart returned error code: %d (see libmboard docs for details)\n", rc);
				   break;
		   }

			
			exit(rc);
		}
		#endif
    }
    


	if(FLAME_TEST_PRINT_START_AND_END_OF_MODEL_FUNCTIONS) printf("start Bank_read_policy_announcements\n");
	current_xmachine_Bank_holder = Bank_start_Bank_state->agents;
	while(current_xmachine_Bank_holder)
	{
		temp_xmachine_Bank_holder = current_xmachine_Bank_holder->next;
		current_xmachine_Bank = current_xmachine_Bank_holder->agent;
		current_xmachine_Bank_next_state = Bank_Bank_reset_state;
		/* For backwards compatibility set current_xmachine */
		current_xmachine->xmachine_Firm = NULL;
		current_xmachine->xmachine_Household = NULL;
		current_xmachine->xmachine_Mall = NULL;
		current_xmachine->xmachine_IGFirm = NULL;
		current_xmachine->xmachine_Eurostat = NULL;
		current_xmachine->xmachine_Bank = NULL;
		current_xmachine->xmachine_Government = NULL;
		current_xmachine->xmachine_CentralBank = NULL;
		current_xmachine->xmachine_ClearingHouse = NULL;
		current_xmachine->xmachine_Bank = current_xmachine_Bank;

		if(FLAME_condition_Bank_Bank_read_policy_announcements_start_Bank_Bank_reset(current_xmachine_Bank)==1)
		{

		
		rc = MB_Iterator_CreateFiltered(b_policy_announcement, &i_policy_announcement, &FLAME_filter_Bank_Bank_read_policy_announcements_start_Bank_Bank_reset_policy_announcement, current_xmachine_Bank);
		
		#ifdef ERRCHECK
		if (rc != MB_SUCCESS)
		{
		   fprintf(stderr, "ERROR: Could not create Iterator for 'policy_announcement'\n");
		   switch(rc) {
		       case MB_ERR_INVALID:
		           fprintf(stderr, "\t reason: 'policy_announcement' board is invalid\n");
		           break;
		       case MB_ERR_LOCKED:
	               fprintf(stderr, "\t reason: 'policy_announcement' board is locked\n");
	               break;
	           case MB_ERR_MEMALLOC:
	               fprintf(stderr, "\t reason: out of memory\n");
	               break;
	           case MB_ERR_INTERNAL:
	               fprintf(stderr, "\t reason: internal error. Recompile libmoard in debug mode for more info \n");
	               break;
	           default:
	           
                   fprintf(stderr, "\t MB_Iterator_CreateFiltered returned error code: %d (see libmboard docs for details)\n", rc);
               
               
                   break;
		   }

		   
           exit(rc);
		}
		#endif
		
		

			i = Bank_read_policy_announcements();

		
		    rc = MB_Iterator_Delete(&i_policy_announcement);
		    #ifdef ERRCHECK
		    if (rc != MB_SUCCESS)
		    {
		       fprintf(stderr, "ERROR: Could not delete 'policy_announcement' iterator\n");
		       switch(rc) {
		           case MB_ERR_INVALID:
		               fprintf(stderr, "\t reason: 'policy_announcement' iterator is invalid\n");
		               break;
		           case MB_ERR_INTERNAL:
		               fprintf(stderr, "\t reason: internal error. Recompile libmoard in debug mode for more info \n");
		               break;
		           default:
                       fprintf(stderr, "\t MB_Iterator_Delete returned error code: %d (see libmboard docs for details)\n", rc);
                       break;
		       }

		       
               exit(rc);
		    }
		    #endif
		

			if(i == 1)
			{
				free_Bank_agent(current_xmachine_Bank_holder, Bank_start_Bank_state);
			}
			else
			{
				transition_Bank_agent(current_xmachine_Bank_holder, Bank_start_Bank_state, Bank_Bank_reset_state);
			}
		}

		current_xmachine_Bank = NULL;

		current_xmachine_Bank_holder = temp_xmachine_Bank_holder;
	}
	if(FLAME_TEST_PRINT_START_AND_END_OF_MODEL_FUNCTIONS) printf("finish Bank_read_policy_announcements\n");


/* End of layer number 5 */

/* Clear message boards that have finished being used
 * and sync complete if doing late sync complete */

if(FLAME_policy_announcement_message_board_read == 0)
{
	/*printf("%d> policy_announcement message board sync complete late as no agents reading any messages of this type\n", node_number);*/
	
	if(FLAME_TEST_PRINT_START_AND_END_OF_LIBMBOARD_CALLS) printf("start MB_SyncComplete(b_policy_announcement)\n");
	rc = MB_SyncComplete(b_policy_announcement);
	if(FLAME_TEST_PRINT_START_AND_END_OF_LIBMBOARD_CALLS) printf("finsh MB_SyncComplete(b_policy_announcement)\n");
	#ifdef ERRCHECK
	if (rc != MB_SUCCESS)
	{
	   fprintf(stderr, "ERROR: Could not complete sync of 'policy_announcement' board\n");
	   switch(rc) {
			case MB_ERR_INVALID:
			   fprintf(stderr, "\t reason: 'policy_announcement' board is invalid\n");
			   break;
		   case MB_ERR_MEMALLOC:
			   fprintf(stderr, "\t reason: out of memory\n");
			   break;
		   case MB_ERR_INTERNAL:
			   fprintf(stderr, "\t reason: internal error. Recompile libmoard in debug mode for more info \n");
			   break;
		   default:
			   fprintf(stderr, "\t MB_SyncComplete returned error code: %d (see libmboard docs for details)\n", rc);
			   break;
	   }

	   
	   exit(rc);
	}
	#endif
}

    rc = MB_Clear(b_policy_announcement);
    #ifdef ERRCHECK
    if (rc != MB_SUCCESS)
    {
       fprintf(stderr, "ERROR: Could not clear 'policy_announcement' board\n");
       switch(rc) {
           case MB_ERR_INVALID:
               fprintf(stderr, "\t reason: 'policy_announcement' board is invalid\n");
               break;
           case MB_ERR_LOCKED:
               fprintf(stderr, "\t reason: 'policy_announcement' board is locked\n");
               break;
           case MB_ERR_INTERNAL:
               fprintf(stderr, "\t reason: internal error. Recompile libmoard in debug mode for more info \n");
               break;
           default:
               fprintf(stderr, "\t MB_Clear returned error code: %d (see libmboard docs for details)\n", rc);
               break;

       }

       
       exit(rc);
    }
    #endif

if(FLAME_human_capital_policy_announcement_message_board_read == 0)
{
	/*printf("%d> human_capital_policy_announcement message board sync complete late as no agents reading any messages of this type\n", node_number);*/
	
	if(FLAME_TEST_PRINT_START_AND_END_OF_LIBMBOARD_CALLS) printf("start MB_SyncComplete(b_human_capital_policy_announcement)\n");
	rc = MB_SyncComplete(b_human_capital_policy_announcement);
	if(FLAME_TEST_PRINT_START_AND_END_OF_LIBMBOARD_CALLS) printf("finsh MB_SyncComplete(b_human_capital_policy_announcement)\n");
	#ifdef ERRCHECK
	if (rc != MB_SUCCESS)
	{
	   fprintf(stderr, "ERROR: Could not complete sync of 'human_capital_policy_announcement' board\n");
	   switch(rc) {
			case MB_ERR_INVALID:
			   fprintf(stderr, "\t reason: 'human_capital_policy_announcement' board is invalid\n");
			   break;
		   case MB_ERR_MEMALLOC:
			   fprintf(stderr, "\t reason: out of memory\n");
			   break;
		   case MB_ERR_INTERNAL:
			   fprintf(stderr, "\t reason: internal error. Recompile libmoard in debug mode for more info \n");
			   break;
		   default:
			   fprintf(stderr, "\t MB_SyncComplete returned error code: %d (see libmboard docs for details)\n", rc);
			   break;
	   }

	   
	   exit(rc);
	}
	#endif
}

    rc = MB_Clear(b_human_capital_policy_announcement);
    #ifdef ERRCHECK
    if (rc != MB_SUCCESS)
    {
       fprintf(stderr, "ERROR: Could not clear 'human_capital_policy_announcement' board\n");
       switch(rc) {
           case MB_ERR_INVALID:
               fprintf(stderr, "\t reason: 'human_capital_policy_announcement' board is invalid\n");
               break;
           case MB_ERR_LOCKED:
               fprintf(stderr, "\t reason: 'human_capital_policy_announcement' board is locked\n");
               break;
           case MB_ERR_INTERNAL:
               fprintf(stderr, "\t reason: internal error. Recompile libmoard in debug mode for more info \n");
               break;
           default:
               fprintf(stderr, "\t MB_Clear returned error code: %d (see libmboard docs for details)\n", rc);
               break;

       }

       
       exit(rc);
    }
    #endif

if(FLAME_eurostat_send_specific_skills_message_board_read == 0)
{
	/*printf("%d> eurostat_send_specific_skills message board sync complete late as no agents reading any messages of this type\n", node_number);*/
	
	if(FLAME_TEST_PRINT_START_AND_END_OF_LIBMBOARD_CALLS) printf("start MB_SyncComplete(b_eurostat_send_specific_skills)\n");
	rc = MB_SyncComplete(b_eurostat_send_specific_skills);
	if(FLAME_TEST_PRINT_START_AND_END_OF_LIBMBOARD_CALLS) printf("finsh MB_SyncComplete(b_eurostat_send_specific_skills)\n");
	#ifdef ERRCHECK
	if (rc != MB_SUCCESS)
	{
	   fprintf(stderr, "ERROR: Could not complete sync of 'eurostat_send_specific_skills' board\n");
	   switch(rc) {
			case MB_ERR_INVALID:
			   fprintf(stderr, "\t reason: 'eurostat_send_specific_skills' board is invalid\n");
			   break;
		   case MB_ERR_MEMALLOC:
			   fprintf(stderr, "\t reason: out of memory\n");
			   break;
		   case MB_ERR_INTERNAL:
			   fprintf(stderr, "\t reason: internal error. Recompile libmoard in debug mode for more info \n");
			   break;
		   default:
			   fprintf(stderr, "\t MB_SyncComplete returned error code: %d (see libmboard docs for details)\n", rc);
			   break;
	   }

	   
	   exit(rc);
	}
	#endif
}

    rc = MB_Clear(b_eurostat_send_specific_skills);
    #ifdef ERRCHECK
    if (rc != MB_SUCCESS)
    {
       fprintf(stderr, "ERROR: Could not clear 'eurostat_send_specific_skills' board\n");
       switch(rc) {
           case MB_ERR_INVALID:
               fprintf(stderr, "\t reason: 'eurostat_send_specific_skills' board is invalid\n");
               break;
           case MB_ERR_LOCKED:
               fprintf(stderr, "\t reason: 'eurostat_send_specific_skills' board is locked\n");
               break;
           case MB_ERR_INTERNAL:
               fprintf(stderr, "\t reason: internal error. Recompile libmoard in debug mode for more info \n");
               break;
           default:
               fprintf(stderr, "\t MB_Clear returned error code: %d (see libmboard docs for details)\n", rc);
               break;

       }

       
       exit(rc);
    }
    #endif

if(FLAME_msg_skills_eurostat_to_igfirm_message_board_read == 0)
{
	/*printf("%d> msg_skills_eurostat_to_igfirm message board sync complete late as no agents reading any messages of this type\n", node_number);*/
	
	if(FLAME_TEST_PRINT_START_AND_END_OF_LIBMBOARD_CALLS) printf("start MB_SyncComplete(b_msg_skills_eurostat_to_igfirm)\n");
	rc = MB_SyncComplete(b_msg_skills_eurostat_to_igfirm);
	if(FLAME_TEST_PRINT_START_AND_END_OF_LIBMBOARD_CALLS) printf("finsh MB_SyncComplete(b_msg_skills_eurostat_to_igfirm)\n");
	#ifdef ERRCHECK
	if (rc != MB_SUCCESS)
	{
	   fprintf(stderr, "ERROR: Could not complete sync of 'msg_skills_eurostat_to_igfirm' board\n");
	   switch(rc) {
			case MB_ERR_INVALID:
			   fprintf(stderr, "\t reason: 'msg_skills_eurostat_to_igfirm' board is invalid\n");
			   break;
		   case MB_ERR_MEMALLOC:
			   fprintf(stderr, "\t reason: out of memory\n");
			   break;
		   case MB_ERR_INTERNAL:
			   fprintf(stderr, "\t reason: internal error. Recompile libmoard in debug mode for more info \n");
			   break;
		   default:
			   fprintf(stderr, "\t MB_SyncComplete returned error code: %d (see libmboard docs for details)\n", rc);
			   break;
	   }

	   
	   exit(rc);
	}
	#endif
}

    rc = MB_Clear(b_msg_skills_eurostat_to_igfirm);
    #ifdef ERRCHECK
    if (rc != MB_SUCCESS)
    {
       fprintf(stderr, "ERROR: Could not clear 'msg_skills_eurostat_to_igfirm' board\n");
       switch(rc) {
           case MB_ERR_INVALID:
               fprintf(stderr, "\t reason: 'msg_skills_eurostat_to_igfirm' board is invalid\n");
               break;
           case MB_ERR_LOCKED:
               fprintf(stderr, "\t reason: 'msg_skills_eurostat_to_igfirm' board is locked\n");
               break;
           case MB_ERR_INTERNAL:
               fprintf(stderr, "\t reason: internal error. Recompile libmoard in debug mode for more info \n");
               break;
           default:
               fprintf(stderr, "\t MB_Clear returned error code: %d (see libmboard docs for details)\n", rc);
               break;

       }

       
       exit(rc);
    }
    #endif

if(FLAME_msg_market_sizes_message_board_read == 0)
{
	/*printf("%d> msg_market_sizes message board sync complete late as no agents reading any messages of this type\n", node_number);*/
	
	if(FLAME_TEST_PRINT_START_AND_END_OF_LIBMBOARD_CALLS) printf("start MB_SyncComplete(b_msg_market_sizes)\n");
	rc = MB_SyncComplete(b_msg_market_sizes);
	if(FLAME_TEST_PRINT_START_AND_END_OF_LIBMBOARD_CALLS) printf("finsh MB_SyncComplete(b_msg_market_sizes)\n");
	#ifdef ERRCHECK
	if (rc != MB_SUCCESS)
	{
	   fprintf(stderr, "ERROR: Could not complete sync of 'msg_market_sizes' board\n");
	   switch(rc) {
			case MB_ERR_INVALID:
			   fprintf(stderr, "\t reason: 'msg_market_sizes' board is invalid\n");
			   break;
		   case MB_ERR_MEMALLOC:
			   fprintf(stderr, "\t reason: out of memory\n");
			   break;
		   case MB_ERR_INTERNAL:
			   fprintf(stderr, "\t reason: internal error. Recompile libmoard in debug mode for more info \n");
			   break;
		   default:
			   fprintf(stderr, "\t MB_SyncComplete returned error code: %d (see libmboard docs for details)\n", rc);
			   break;
	   }

	   
	   exit(rc);
	}
	#endif
}

    rc = MB_Clear(b_msg_market_sizes);
    #ifdef ERRCHECK
    if (rc != MB_SUCCESS)
    {
       fprintf(stderr, "ERROR: Could not clear 'msg_market_sizes' board\n");
       switch(rc) {
           case MB_ERR_INVALID:
               fprintf(stderr, "\t reason: 'msg_market_sizes' board is invalid\n");
               break;
           case MB_ERR_LOCKED:
               fprintf(stderr, "\t reason: 'msg_market_sizes' board is locked\n");
               break;
           case MB_ERR_INTERNAL:
               fprintf(stderr, "\t reason: internal error. Recompile libmoard in debug mode for more info \n");
               break;
           default:
               fprintf(stderr, "\t MB_Clear returned error code: %d (see libmboard docs for details)\n", rc);
               break;

       }

       
       exit(rc);
    }
    #endif

if(FLAME_quality_price_message_board_read == 0)
{
	/*printf("%d> quality_price message board sync complete late as no agents reading any messages of this type\n", node_number);*/
	
	if(FLAME_TEST_PRINT_START_AND_END_OF_LIBMBOARD_CALLS) printf("start MB_SyncComplete(b_quality_price)\n");
	rc = MB_SyncComplete(b_quality_price);
	if(FLAME_TEST_PRINT_START_AND_END_OF_LIBMBOARD_CALLS) printf("finsh MB_SyncComplete(b_quality_price)\n");
	#ifdef ERRCHECK
	if (rc != MB_SUCCESS)
	{
	   fprintf(stderr, "ERROR: Could not complete sync of 'quality_price' board\n");
	   switch(rc) {
			case MB_ERR_INVALID:
			   fprintf(stderr, "\t reason: 'quality_price' board is invalid\n");
			   break;
		   case MB_ERR_MEMALLOC:
			   fprintf(stderr, "\t reason: out of memory\n");
			   break;
		   case MB_ERR_INTERNAL:
			   fprintf(stderr, "\t reason: internal error. Recompile libmoard in debug mode for more info \n");
			   break;
		   default:
			   fprintf(stderr, "\t MB_SyncComplete returned error code: %d (see libmboard docs for details)\n", rc);
			   break;
	   }

	   
	   exit(rc);
	}
	#endif
}

    rc = MB_Clear(b_quality_price);
    #ifdef ERRCHECK
    if (rc != MB_SUCCESS)
    {
       fprintf(stderr, "ERROR: Could not clear 'quality_price' board\n");
       switch(rc) {
           case MB_ERR_INVALID:
               fprintf(stderr, "\t reason: 'quality_price' board is invalid\n");
               break;
           case MB_ERR_LOCKED:
               fprintf(stderr, "\t reason: 'quality_price' board is locked\n");
               break;
           case MB_ERR_INTERNAL:
               fprintf(stderr, "\t reason: internal error. Recompile libmoard in debug mode for more info \n");
               break;
           default:
               fprintf(stderr, "\t MB_Clear returned error code: %d (see libmboard docs for details)\n", rc);
               break;

       }

       
       exit(rc);
    }
    #endif


	/* If mb is not read then leave sync complete until last possible moment */
	if(FLAME_human_capital_policy_general_skill_information_message_board_read == 1)
	{
		if(FLAME_TEST_PRINT_START_AND_END_OF_LIBMBOARD_CALLS) printf("start MB_SyncComplete(b_human_capital_policy_general_skill_information)\n");
		rc = MB_SyncComplete(b_human_capital_policy_general_skill_information);
		if(FLAME_TEST_PRINT_START_AND_END_OF_LIBMBOARD_CALLS) printf("finsh MB_SyncComplete(b_human_capital_policy_general_skill_information)\n");
		#ifdef ERRCHECK
		if (rc != MB_SUCCESS)
		{
		   fprintf(stderr, "ERROR: Could not complete sync of 'human_capital_policy_general_skill_information' board\n");
		   switch(rc) {
				case MB_ERR_INVALID:
				   fprintf(stderr, "\t reason: 'human_capital_policy_general_skill_information' board is invalid\n");
				   break;
			   case MB_ERR_MEMALLOC:
				   fprintf(stderr, "\t reason: out of memory\n");
				   break;
			   case MB_ERR_INTERNAL:
				   fprintf(stderr, "\t reason: internal error. Recompile libmoard in debug mode for more info \n");
				   break;
			   default:
				   fprintf(stderr, "\t MB_SyncComplete returned error code: %d (see libmboard docs for details)\n", rc);
				   break;
		   }
	
		   
		   exit(rc);
		}
		#endif
    
	}
	
	if(FLAME_TEST_PRINT_START_AND_END_OF_MODEL_FUNCTIONS) printf("start Government_install_human_capital_policy\n");
	current_xmachine_Government_holder = Government_003_state->agents;
	while(current_xmachine_Government_holder)
	{
		temp_xmachine_Government_holder = current_xmachine_Government_holder->next;
		current_xmachine_Government = current_xmachine_Government_holder->agent;
		current_xmachine_Government_next_state = Government_003a_state;
		/* For backwards compatibility set current_xmachine */
		current_xmachine->xmachine_Firm = NULL;
		current_xmachine->xmachine_Household = NULL;
		current_xmachine->xmachine_Mall = NULL;
		current_xmachine->xmachine_IGFirm = NULL;
		current_xmachine->xmachine_Eurostat = NULL;
		current_xmachine->xmachine_Bank = NULL;
		current_xmachine->xmachine_Government = NULL;
		current_xmachine->xmachine_CentralBank = NULL;
		current_xmachine->xmachine_ClearingHouse = NULL;
		current_xmachine->xmachine_Government = current_xmachine_Government;

		if(FLAME_condition_Government_Government_install_human_capital_policy_003_003a(current_xmachine_Government)==1)
		{

		
		rc = MB_Iterator_CreateFiltered(b_human_capital_policy_general_skill_information, &i_human_capital_policy_general_skill_information, &FLAME_filter_Government_Government_install_human_capital_policy_003_003a_human_capital_policy_general_skill_information, current_xmachine_Government);
		
		#ifdef ERRCHECK
		if (rc != MB_SUCCESS)
		{
		   fprintf(stderr, "ERROR: Could not create Iterator for 'human_capital_policy_general_skill_information'\n");
		   switch(rc) {
		       case MB_ERR_INVALID:
		           fprintf(stderr, "\t reason: 'human_capital_policy_general_skill_information' board is invalid\n");
		           break;
		       case MB_ERR_LOCKED:
	               fprintf(stderr, "\t reason: 'human_capital_policy_general_skill_information' board is locked\n");
	               break;
	           case MB_ERR_MEMALLOC:
	               fprintf(stderr, "\t reason: out of memory\n");
	               break;
	           case MB_ERR_INTERNAL:
	               fprintf(stderr, "\t reason: internal error. Recompile libmoard in debug mode for more info \n");
	               break;
	           default:
	           
                   fprintf(stderr, "\t MB_Iterator_CreateFiltered returned error code: %d (see libmboard docs for details)\n", rc);
               
               
                   break;
		   }

		   
           exit(rc);
		}
		#endif
		
		

			i = Government_install_human_capital_policy();

		
		    rc = MB_Iterator_Delete(&i_human_capital_policy_general_skill_information);
		    #ifdef ERRCHECK
		    if (rc != MB_SUCCESS)
		    {
		       fprintf(stderr, "ERROR: Could not delete 'human_capital_policy_general_skill_information' iterator\n");
		       switch(rc) {
		           case MB_ERR_INVALID:
		               fprintf(stderr, "\t reason: 'human_capital_policy_general_skill_information' iterator is invalid\n");
		               break;
		           case MB_ERR_INTERNAL:
		               fprintf(stderr, "\t reason: internal error. Recompile libmoard in debug mode for more info \n");
		               break;
		           default:
                       fprintf(stderr, "\t MB_Iterator_Delete returned error code: %d (see libmboard docs for details)\n", rc);
                       break;
		       }

		       
               exit(rc);
		    }
		    #endif
		

			if(i == 1)
			{
				free_Government_agent(current_xmachine_Government_holder, Government_003_state);
			}
			else
			{
				transition_Government_agent(current_xmachine_Government_holder, Government_003_state, Government_003a_state);
			}
		}

		current_xmachine_Government = NULL;

		current_xmachine_Government_holder = temp_xmachine_Government_holder;
	}
	if(FLAME_TEST_PRINT_START_AND_END_OF_MODEL_FUNCTIONS) printf("finish Government_install_human_capital_policy\n");

	if(FLAME_human_capital_policy_new_general_skill_notification_message_board_write == 1)
	{

		if(FLAME_TEST_PRINT_START_AND_END_OF_LIBMBOARD_CALLS) printf("start MB_SyncStart(b_human_capital_policy_new_general_skill_notification)\n");
		rc = MB_SyncStart(b_human_capital_policy_new_general_skill_notification);
		if(FLAME_TEST_PRINT_START_AND_END_OF_LIBMBOARD_CALLS) printf("finish MB_SyncStart(b_human_capital_policy_new_general_skill_notification)\n");
		#ifdef ERRCHECK
		if (rc != MB_SUCCESS)
		{
		   fprintf(stderr, "ERROR: Could not start sync of 'human_capital_policy_new_general_skill_notification' board\n");
		   switch(rc) {
			   case MB_ERR_INVALID:
				   fprintf(stderr, "\t reason: 'human_capital_policy_new_general_skill_notification' board is invalid\n");
				   break;
			   case MB_ERR_LOCKED:
				   fprintf(stderr, "\t reason: 'human_capital_policy_new_general_skill_notification' board is locked\n");
				   break;
			   case MB_ERR_MEMALLOC:
				   fprintf(stderr, "\t reason: out of memory\n");
				   break;
			   case MB_ERR_INTERNAL:
				   fprintf(stderr, "\t reason: internal error. Recompile libmoard in debug mode for more info \n");
				   break;
			   default:
				   fprintf(stderr, "\t MB_SyncStart returned error code: %d (see libmboard docs for details)\n", rc);
				   break;
		   }

			
			exit(rc);
		}
		#endif
    }
    


	if(FLAME_TEST_PRINT_START_AND_END_OF_MODEL_FUNCTIONS) printf("start Bank_reset_variables\n");
	current_xmachine_Bank_holder = Bank_Bank_reset_state->agents;
	while(current_xmachine_Bank_holder)
	{
		temp_xmachine_Bank_holder = current_xmachine_Bank_holder->next;
		current_xmachine_Bank = current_xmachine_Bank_holder->agent;
		current_xmachine_Bank_next_state = Bank_Bank_update_policy_rate_state;
		/* For backwards compatibility set current_xmachine */
		current_xmachine->xmachine_Firm = NULL;
		current_xmachine->xmachine_Household = NULL;
		current_xmachine->xmachine_Mall = NULL;
		current_xmachine->xmachine_IGFirm = NULL;
		current_xmachine->xmachine_Eurostat = NULL;
		current_xmachine->xmachine_Bank = NULL;
		current_xmachine->xmachine_Government = NULL;
		current_xmachine->xmachine_CentralBank = NULL;
		current_xmachine->xmachine_ClearingHouse = NULL;
		current_xmachine->xmachine_Bank = current_xmachine_Bank;

		

		

			i = Bank_reset_variables();

		

			if(i == 1)
			{
				free_Bank_agent(current_xmachine_Bank_holder, Bank_Bank_reset_state);
			}
			else
			{
				transition_Bank_agent(current_xmachine_Bank_holder, Bank_Bank_reset_state, Bank_Bank_update_policy_rate_state);
			}
		

		current_xmachine_Bank = NULL;

		current_xmachine_Bank_holder = temp_xmachine_Bank_holder;
	}
	if(FLAME_TEST_PRINT_START_AND_END_OF_MODEL_FUNCTIONS) printf("finish Bank_reset_variables\n");


	if(FLAME_TEST_PRINT_START_AND_END_OF_MODEL_FUNCTIONS) printf("start Household_idle\n");
	current_xmachine_Household_holder = Household_Pol_01_state->agents;
	while(current_xmachine_Household_holder)
	{
		temp_xmachine_Household_holder = current_xmachine_Household_holder->next;
		current_xmachine_Household = current_xmachine_Household_holder->agent;
		current_xmachine_Household_next_state = Household_Household_Start_Policy_Data_state;
		/* For backwards compatibility set current_xmachine */
		current_xmachine->xmachine_Firm = NULL;
		current_xmachine->xmachine_Household = NULL;
		current_xmachine->xmachine_Mall = NULL;
		current_xmachine->xmachine_IGFirm = NULL;
		current_xmachine->xmachine_Eurostat = NULL;
		current_xmachine->xmachine_Bank = NULL;
		current_xmachine->xmachine_Government = NULL;
		current_xmachine->xmachine_CentralBank = NULL;
		current_xmachine->xmachine_ClearingHouse = NULL;
		current_xmachine->xmachine_Household = current_xmachine_Household;

		if(FLAME_condition_Household_Household_idle_Pol_01_Household_Start_Policy_Data(current_xmachine_Household)==1)
		{

		

			i = Household_idle();

		

			if(i == 1)
			{
				free_Household_agent(current_xmachine_Household_holder, Household_Pol_01_state);
			}
			else
			{
				transition_Household_agent(current_xmachine_Household_holder, Household_Pol_01_state, Household_Household_Start_Policy_Data_state);
			}
		}

		current_xmachine_Household = NULL;

		current_xmachine_Household_holder = temp_xmachine_Household_holder;
	}
	if(FLAME_TEST_PRINT_START_AND_END_OF_MODEL_FUNCTIONS) printf("finish Household_idle\n");


/* End of layer number 6 */

/* Clear message boards that have finished being used
 * and sync complete if doing late sync complete */

if(FLAME_human_capital_policy_general_skill_information_message_board_read == 0)
{
	/*printf("%d> human_capital_policy_general_skill_information message board sync complete late as no agents reading any messages of this type\n", node_number);*/
	
	if(FLAME_TEST_PRINT_START_AND_END_OF_LIBMBOARD_CALLS) printf("start MB_SyncComplete(b_human_capital_policy_general_skill_information)\n");
	rc = MB_SyncComplete(b_human_capital_policy_general_skill_information);
	if(FLAME_TEST_PRINT_START_AND_END_OF_LIBMBOARD_CALLS) printf("finsh MB_SyncComplete(b_human_capital_policy_general_skill_information)\n");
	#ifdef ERRCHECK
	if (rc != MB_SUCCESS)
	{
	   fprintf(stderr, "ERROR: Could not complete sync of 'human_capital_policy_general_skill_information' board\n");
	   switch(rc) {
			case MB_ERR_INVALID:
			   fprintf(stderr, "\t reason: 'human_capital_policy_general_skill_information' board is invalid\n");
			   break;
		   case MB_ERR_MEMALLOC:
			   fprintf(stderr, "\t reason: out of memory\n");
			   break;
		   case MB_ERR_INTERNAL:
			   fprintf(stderr, "\t reason: internal error. Recompile libmoard in debug mode for more info \n");
			   break;
		   default:
			   fprintf(stderr, "\t MB_SyncComplete returned error code: %d (see libmboard docs for details)\n", rc);
			   break;
	   }

	   
	   exit(rc);
	}
	#endif
}

    rc = MB_Clear(b_human_capital_policy_general_skill_information);
    #ifdef ERRCHECK
    if (rc != MB_SUCCESS)
    {
       fprintf(stderr, "ERROR: Could not clear 'human_capital_policy_general_skill_information' board\n");
       switch(rc) {
           case MB_ERR_INVALID:
               fprintf(stderr, "\t reason: 'human_capital_policy_general_skill_information' board is invalid\n");
               break;
           case MB_ERR_LOCKED:
               fprintf(stderr, "\t reason: 'human_capital_policy_general_skill_information' board is locked\n");
               break;
           case MB_ERR_INTERNAL:
               fprintf(stderr, "\t reason: internal error. Recompile libmoard in debug mode for more info \n");
               break;
           default:
               fprintf(stderr, "\t MB_Clear returned error code: %d (see libmboard docs for details)\n", rc);
               break;

       }

       
       exit(rc);
    }
    #endif


	if(FLAME_TEST_PRINT_START_AND_END_OF_MODEL_FUNCTIONS) printf("start Government_yearly_resetting\n");
	current_xmachine_Government_holder = Government_003a_state->agents;
	while(current_xmachine_Government_holder)
	{
		temp_xmachine_Government_holder = current_xmachine_Government_holder->next;
		current_xmachine_Government = current_xmachine_Government_holder->agent;
		current_xmachine_Government_next_state = Government_003b_state;
		/* For backwards compatibility set current_xmachine */
		current_xmachine->xmachine_Firm = NULL;
		current_xmachine->xmachine_Household = NULL;
		current_xmachine->xmachine_Mall = NULL;
		current_xmachine->xmachine_IGFirm = NULL;
		current_xmachine->xmachine_Eurostat = NULL;
		current_xmachine->xmachine_Bank = NULL;
		current_xmachine->xmachine_Government = NULL;
		current_xmachine->xmachine_CentralBank = NULL;
		current_xmachine->xmachine_ClearingHouse = NULL;
		current_xmachine->xmachine_Government = current_xmachine_Government;

		

		

			i = Government_yearly_resetting();

		

			if(i == 1)
			{
				free_Government_agent(current_xmachine_Government_holder, Government_003a_state);
			}
			else
			{
				transition_Government_agent(current_xmachine_Government_holder, Government_003a_state, Government_003b_state);
			}
		

		current_xmachine_Government = NULL;

		current_xmachine_Government_holder = temp_xmachine_Government_holder;
	}
	if(FLAME_TEST_PRINT_START_AND_END_OF_MODEL_FUNCTIONS) printf("finish Government_yearly_resetting\n");


	if(FLAME_TEST_PRINT_START_AND_END_OF_MODEL_FUNCTIONS) printf("start idle\n");
	current_xmachine_Bank_holder = Bank_Bank_update_policy_rate_state->agents;
	while(current_xmachine_Bank_holder)
	{
		temp_xmachine_Bank_holder = current_xmachine_Bank_holder->next;
		current_xmachine_Bank = current_xmachine_Bank_holder->agent;
		current_xmachine_Bank_next_state = Bank_Bank_start_credit_market_role_state;
		/* For backwards compatibility set current_xmachine */
		current_xmachine->xmachine_Firm = NULL;
		current_xmachine->xmachine_Household = NULL;
		current_xmachine->xmachine_Mall = NULL;
		current_xmachine->xmachine_IGFirm = NULL;
		current_xmachine->xmachine_Eurostat = NULL;
		current_xmachine->xmachine_Bank = NULL;
		current_xmachine->xmachine_Government = NULL;
		current_xmachine->xmachine_CentralBank = NULL;
		current_xmachine->xmachine_ClearingHouse = NULL;
		current_xmachine->xmachine_Bank = current_xmachine_Bank;

		if(FLAME_condition_Bank_idle_Bank_update_policy_rate_Bank_start_credit_market_role(current_xmachine_Bank)==1)
		{

		

			i = idle();

		

			if(i == 1)
			{
				free_Bank_agent(current_xmachine_Bank_holder, Bank_Bank_update_policy_rate_state);
			}
			else
			{
				transition_Bank_agent(current_xmachine_Bank_holder, Bank_Bank_update_policy_rate_state, Bank_Bank_start_credit_market_role_state);
			}
		}

		current_xmachine_Bank = NULL;

		current_xmachine_Bank_holder = temp_xmachine_Bank_holder;
	}
	if(FLAME_TEST_PRINT_START_AND_END_OF_MODEL_FUNCTIONS) printf("finish idle\n");


	/* If mb is not read then leave sync complete until last possible moment */
	if(FLAME_policy_rate_message_board_read == 1)
	{
		if(FLAME_TEST_PRINT_START_AND_END_OF_LIBMBOARD_CALLS) printf("start MB_SyncComplete(b_policy_rate)\n");
		rc = MB_SyncComplete(b_policy_rate);
		if(FLAME_TEST_PRINT_START_AND_END_OF_LIBMBOARD_CALLS) printf("finsh MB_SyncComplete(b_policy_rate)\n");
		#ifdef ERRCHECK
		if (rc != MB_SUCCESS)
		{
		   fprintf(stderr, "ERROR: Could not complete sync of 'policy_rate' board\n");
		   switch(rc) {
				case MB_ERR_INVALID:
				   fprintf(stderr, "\t reason: 'policy_rate' board is invalid\n");
				   break;
			   case MB_ERR_MEMALLOC:
				   fprintf(stderr, "\t reason: out of memory\n");
				   break;
			   case MB_ERR_INTERNAL:
				   fprintf(stderr, "\t reason: internal error. Recompile libmoard in debug mode for more info \n");
				   break;
			   default:
				   fprintf(stderr, "\t MB_SyncComplete returned error code: %d (see libmboard docs for details)\n", rc);
				   break;
		   }
	
		   
		   exit(rc);
		}
		#endif
    
	}
	
	if(FLAME_TEST_PRINT_START_AND_END_OF_MODEL_FUNCTIONS) printf("start Bank_read_policy_rate\n");
	current_xmachine_Bank_holder = Bank_Bank_update_policy_rate_state->agents;
	while(current_xmachine_Bank_holder)
	{
		temp_xmachine_Bank_holder = current_xmachine_Bank_holder->next;
		current_xmachine_Bank = current_xmachine_Bank_holder->agent;
		current_xmachine_Bank_next_state = Bank_Bank_start_credit_market_role_state;
		/* For backwards compatibility set current_xmachine */
		current_xmachine->xmachine_Firm = NULL;
		current_xmachine->xmachine_Household = NULL;
		current_xmachine->xmachine_Mall = NULL;
		current_xmachine->xmachine_IGFirm = NULL;
		current_xmachine->xmachine_Eurostat = NULL;
		current_xmachine->xmachine_Bank = NULL;
		current_xmachine->xmachine_Government = NULL;
		current_xmachine->xmachine_CentralBank = NULL;
		current_xmachine->xmachine_ClearingHouse = NULL;
		current_xmachine->xmachine_Bank = current_xmachine_Bank;

		if(FLAME_condition_Bank_Bank_read_policy_rate_Bank_update_policy_rate_Bank_start_credit_market_role(current_xmachine_Bank)==1)
		{

		
		
		rc = MB_Iterator_Create(b_policy_rate, &i_policy_rate);
		#ifdef ERRCHECK
		if (rc != MB_SUCCESS)
		{
		   fprintf(stderr, "ERROR: Could not create Iterator for 'policy_rate'\n");
		   switch(rc) {
		       case MB_ERR_INVALID:
		           fprintf(stderr, "\t reason: 'policy_rate' board is invalid\n");
		           break;
		       case MB_ERR_LOCKED:
	               fprintf(stderr, "\t reason: 'policy_rate' board is locked\n");
	               break;
	           case MB_ERR_MEMALLOC:
	               fprintf(stderr, "\t reason: out of memory\n");
	               break;
	           case MB_ERR_INTERNAL:
	               fprintf(stderr, "\t reason: internal error. Recompile libmoard in debug mode for more info \n");
	               break;
	           default:
	           
               
                   fprintf(stderr, "\t MB_Iterator_Create returned error code: %d (see libmboard docs for details)\n", rc);
               
                   break;
		   }

		   
           exit(rc);
		}
		#endif
		
		

			i = Bank_read_policy_rate();

		
		    rc = MB_Iterator_Delete(&i_policy_rate);
		    #ifdef ERRCHECK
		    if (rc != MB_SUCCESS)
		    {
		       fprintf(stderr, "ERROR: Could not delete 'policy_rate' iterator\n");
		       switch(rc) {
		           case MB_ERR_INVALID:
		               fprintf(stderr, "\t reason: 'policy_rate' iterator is invalid\n");
		               break;
		           case MB_ERR_INTERNAL:
		               fprintf(stderr, "\t reason: internal error. Recompile libmoard in debug mode for more info \n");
		               break;
		           default:
                       fprintf(stderr, "\t MB_Iterator_Delete returned error code: %d (see libmboard docs for details)\n", rc);
                       break;
		       }

		       
               exit(rc);
		    }
		    #endif
		

			if(i == 1)
			{
				free_Bank_agent(current_xmachine_Bank_holder, Bank_Bank_update_policy_rate_state);
			}
			else
			{
				transition_Bank_agent(current_xmachine_Bank_holder, Bank_Bank_update_policy_rate_state, Bank_Bank_start_credit_market_role_state);
			}
		}

		current_xmachine_Bank = NULL;

		current_xmachine_Bank_holder = temp_xmachine_Bank_holder;
	}
	if(FLAME_TEST_PRINT_START_AND_END_OF_MODEL_FUNCTIONS) printf("finish Bank_read_policy_rate\n");


	/* If mb is not read then leave sync complete until last possible moment */
	if(FLAME_human_capital_policy_new_general_skill_notification_message_board_read == 1)
	{
		if(FLAME_TEST_PRINT_START_AND_END_OF_LIBMBOARD_CALLS) printf("start MB_SyncComplete(b_human_capital_policy_new_general_skill_notification)\n");
		rc = MB_SyncComplete(b_human_capital_policy_new_general_skill_notification);
		if(FLAME_TEST_PRINT_START_AND_END_OF_LIBMBOARD_CALLS) printf("finsh MB_SyncComplete(b_human_capital_policy_new_general_skill_notification)\n");
		#ifdef ERRCHECK
		if (rc != MB_SUCCESS)
		{
		   fprintf(stderr, "ERROR: Could not complete sync of 'human_capital_policy_new_general_skill_notification' board\n");
		   switch(rc) {
				case MB_ERR_INVALID:
				   fprintf(stderr, "\t reason: 'human_capital_policy_new_general_skill_notification' board is invalid\n");
				   break;
			   case MB_ERR_MEMALLOC:
				   fprintf(stderr, "\t reason: out of memory\n");
				   break;
			   case MB_ERR_INTERNAL:
				   fprintf(stderr, "\t reason: internal error. Recompile libmoard in debug mode for more info \n");
				   break;
			   default:
				   fprintf(stderr, "\t MB_SyncComplete returned error code: %d (see libmboard docs for details)\n", rc);
				   break;
		   }
	
		   
		   exit(rc);
		}
		#endif
    
	}
	
	if(FLAME_TEST_PRINT_START_AND_END_OF_MODEL_FUNCTIONS) printf("start Household_human_capital_policy\n");
	current_xmachine_Household_holder = Household_Pol_01_state->agents;
	while(current_xmachine_Household_holder)
	{
		temp_xmachine_Household_holder = current_xmachine_Household_holder->next;
		current_xmachine_Household = current_xmachine_Household_holder->agent;
		current_xmachine_Household_next_state = Household_Household_Start_Policy_Data_state;
		/* For backwards compatibility set current_xmachine */
		current_xmachine->xmachine_Firm = NULL;
		current_xmachine->xmachine_Household = NULL;
		current_xmachine->xmachine_Mall = NULL;
		current_xmachine->xmachine_IGFirm = NULL;
		current_xmachine->xmachine_Eurostat = NULL;
		current_xmachine->xmachine_Bank = NULL;
		current_xmachine->xmachine_Government = NULL;
		current_xmachine->xmachine_CentralBank = NULL;
		current_xmachine->xmachine_ClearingHouse = NULL;
		current_xmachine->xmachine_Household = current_xmachine_Household;

		if(FLAME_condition_Household_Household_human_capital_policy_Pol_01_Household_Start_Policy_Data(current_xmachine_Household)==1)
		{

		
		rc = MB_Iterator_CreateFiltered(b_human_capital_policy_new_general_skill_notification, &i_human_capital_policy_new_general_skill_notification, &FLAME_filter_Household_Household_human_capital_policy_Pol_01_Household_Start_Policy_Data_human_capital_policy_new_general_skill_notification, current_xmachine_Household);
		
		#ifdef ERRCHECK
		if (rc != MB_SUCCESS)
		{
		   fprintf(stderr, "ERROR: Could not create Iterator for 'human_capital_policy_new_general_skill_notification'\n");
		   switch(rc) {
		       case MB_ERR_INVALID:
		           fprintf(stderr, "\t reason: 'human_capital_policy_new_general_skill_notification' board is invalid\n");
		           break;
		       case MB_ERR_LOCKED:
	               fprintf(stderr, "\t reason: 'human_capital_policy_new_general_skill_notification' board is locked\n");
	               break;
	           case MB_ERR_MEMALLOC:
	               fprintf(stderr, "\t reason: out of memory\n");
	               break;
	           case MB_ERR_INTERNAL:
	               fprintf(stderr, "\t reason: internal error. Recompile libmoard in debug mode for more info \n");
	               break;
	           default:
	           
                   fprintf(stderr, "\t MB_Iterator_CreateFiltered returned error code: %d (see libmboard docs for details)\n", rc);
               
               
                   break;
		   }

		   
           exit(rc);
		}
		#endif
		
		

			i = Household_human_capital_policy();

		
		    rc = MB_Iterator_Delete(&i_human_capital_policy_new_general_skill_notification);
		    #ifdef ERRCHECK
		    if (rc != MB_SUCCESS)
		    {
		       fprintf(stderr, "ERROR: Could not delete 'human_capital_policy_new_general_skill_notification' iterator\n");
		       switch(rc) {
		           case MB_ERR_INVALID:
		               fprintf(stderr, "\t reason: 'human_capital_policy_new_general_skill_notification' iterator is invalid\n");
		               break;
		           case MB_ERR_INTERNAL:
		               fprintf(stderr, "\t reason: internal error. Recompile libmoard in debug mode for more info \n");
		               break;
		           default:
                       fprintf(stderr, "\t MB_Iterator_Delete returned error code: %d (see libmboard docs for details)\n", rc);
                       break;
		       }

		       
               exit(rc);
		    }
		    #endif
		

			if(i == 1)
			{
				free_Household_agent(current_xmachine_Household_holder, Household_Pol_01_state);
			}
			else
			{
				transition_Household_agent(current_xmachine_Household_holder, Household_Pol_01_state, Household_Household_Start_Policy_Data_state);
			}
		}

		current_xmachine_Household = NULL;

		current_xmachine_Household_holder = temp_xmachine_Household_holder;
	}
	if(FLAME_TEST_PRINT_START_AND_END_OF_MODEL_FUNCTIONS) printf("finish Household_human_capital_policy\n");


/* End of layer number 7 */

/* Clear message boards that have finished being used
 * and sync complete if doing late sync complete */

if(FLAME_policy_rate_message_board_read == 0)
{
	/*printf("%d> policy_rate message board sync complete late as no agents reading any messages of this type\n", node_number);*/
	
	if(FLAME_TEST_PRINT_START_AND_END_OF_LIBMBOARD_CALLS) printf("start MB_SyncComplete(b_policy_rate)\n");
	rc = MB_SyncComplete(b_policy_rate);
	if(FLAME_TEST_PRINT_START_AND_END_OF_LIBMBOARD_CALLS) printf("finsh MB_SyncComplete(b_policy_rate)\n");
	#ifdef ERRCHECK
	if (rc != MB_SUCCESS)
	{
	   fprintf(stderr, "ERROR: Could not complete sync of 'policy_rate' board\n");
	   switch(rc) {
			case MB_ERR_INVALID:
			   fprintf(stderr, "\t reason: 'policy_rate' board is invalid\n");
			   break;
		   case MB_ERR_MEMALLOC:
			   fprintf(stderr, "\t reason: out of memory\n");
			   break;
		   case MB_ERR_INTERNAL:
			   fprintf(stderr, "\t reason: internal error. Recompile libmoard in debug mode for more info \n");
			   break;
		   default:
			   fprintf(stderr, "\t MB_SyncComplete returned error code: %d (see libmboard docs for details)\n", rc);
			   break;
	   }

	   
	   exit(rc);
	}
	#endif
}

    rc = MB_Clear(b_policy_rate);
    #ifdef ERRCHECK
    if (rc != MB_SUCCESS)
    {
       fprintf(stderr, "ERROR: Could not clear 'policy_rate' board\n");
       switch(rc) {
           case MB_ERR_INVALID:
               fprintf(stderr, "\t reason: 'policy_rate' board is invalid\n");
               break;
           case MB_ERR_LOCKED:
               fprintf(stderr, "\t reason: 'policy_rate' board is locked\n");
               break;
           case MB_ERR_INTERNAL:
               fprintf(stderr, "\t reason: internal error. Recompile libmoard in debug mode for more info \n");
               break;
           default:
               fprintf(stderr, "\t MB_Clear returned error code: %d (see libmboard docs for details)\n", rc);
               break;

       }

       
       exit(rc);
    }
    #endif

if(FLAME_human_capital_policy_new_general_skill_notification_message_board_read == 0)
{
	/*printf("%d> human_capital_policy_new_general_skill_notification message board sync complete late as no agents reading any messages of this type\n", node_number);*/
	
	if(FLAME_TEST_PRINT_START_AND_END_OF_LIBMBOARD_CALLS) printf("start MB_SyncComplete(b_human_capital_policy_new_general_skill_notification)\n");
	rc = MB_SyncComplete(b_human_capital_policy_new_general_skill_notification);
	if(FLAME_TEST_PRINT_START_AND_END_OF_LIBMBOARD_CALLS) printf("finsh MB_SyncComplete(b_human_capital_policy_new_general_skill_notification)\n");
	#ifdef ERRCHECK
	if (rc != MB_SUCCESS)
	{
	   fprintf(stderr, "ERROR: Could not complete sync of 'human_capital_policy_new_general_skill_notification' board\n");
	   switch(rc) {
			case MB_ERR_INVALID:
			   fprintf(stderr, "\t reason: 'human_capital_policy_new_general_skill_notification' board is invalid\n");
			   break;
		   case MB_ERR_MEMALLOC:
			   fprintf(stderr, "\t reason: out of memory\n");
			   break;
		   case MB_ERR_INTERNAL:
			   fprintf(stderr, "\t reason: internal error. Recompile libmoard in debug mode for more info \n");
			   break;
		   default:
			   fprintf(stderr, "\t MB_SyncComplete returned error code: %d (see libmboard docs for details)\n", rc);
			   break;
	   }

	   
	   exit(rc);
	}
	#endif
}

    rc = MB_Clear(b_human_capital_policy_new_general_skill_notification);
    #ifdef ERRCHECK
    if (rc != MB_SUCCESS)
    {
       fprintf(stderr, "ERROR: Could not clear 'human_capital_policy_new_general_skill_notification' board\n");
       switch(rc) {
           case MB_ERR_INVALID:
               fprintf(stderr, "\t reason: 'human_capital_policy_new_general_skill_notification' board is invalid\n");
               break;
           case MB_ERR_LOCKED:
               fprintf(stderr, "\t reason: 'human_capital_policy_new_general_skill_notification' board is locked\n");
               break;
           case MB_ERR_INTERNAL:
               fprintf(stderr, "\t reason: internal error. Recompile libmoard in debug mode for more info \n");
               break;
           default:
               fprintf(stderr, "\t MB_Clear returned error code: %d (see libmboard docs for details)\n", rc);
               break;

       }

       
       exit(rc);
    }
    #endif


	if(FLAME_TEST_PRINT_START_AND_END_OF_MODEL_FUNCTIONS) printf("start Bank_communicate_identity\n");
	current_xmachine_Bank_holder = Bank_Bank_start_credit_market_role_state->agents;
	while(current_xmachine_Bank_holder)
	{
		temp_xmachine_Bank_holder = current_xmachine_Bank_holder->next;
		current_xmachine_Bank = current_xmachine_Bank_holder->agent;
		current_xmachine_Bank_next_state = Bank_Bank_01_state;
		/* For backwards compatibility set current_xmachine */
		current_xmachine->xmachine_Firm = NULL;
		current_xmachine->xmachine_Household = NULL;
		current_xmachine->xmachine_Mall = NULL;
		current_xmachine->xmachine_IGFirm = NULL;
		current_xmachine->xmachine_Eurostat = NULL;
		current_xmachine->xmachine_Bank = NULL;
		current_xmachine->xmachine_Government = NULL;
		current_xmachine->xmachine_CentralBank = NULL;
		current_xmachine->xmachine_ClearingHouse = NULL;
		current_xmachine->xmachine_Bank = current_xmachine_Bank;

		

		

			i = Bank_communicate_identity();

		

			if(i == 1)
			{
				free_Bank_agent(current_xmachine_Bank_holder, Bank_Bank_start_credit_market_role_state);
			}
			else
			{
				transition_Bank_agent(current_xmachine_Bank_holder, Bank_Bank_start_credit_market_role_state, Bank_Bank_01_state);
			}
		

		current_xmachine_Bank = NULL;

		current_xmachine_Bank_holder = temp_xmachine_Bank_holder;
	}
	if(FLAME_TEST_PRINT_START_AND_END_OF_MODEL_FUNCTIONS) printf("finish Bank_communicate_identity\n");

	if(FLAME_bank_identity_message_board_write == 1)
	{

		if(FLAME_TEST_PRINT_START_AND_END_OF_LIBMBOARD_CALLS) printf("start MB_SyncStart(b_bank_identity)\n");
		rc = MB_SyncStart(b_bank_identity);
		if(FLAME_TEST_PRINT_START_AND_END_OF_LIBMBOARD_CALLS) printf("finish MB_SyncStart(b_bank_identity)\n");
		#ifdef ERRCHECK
		if (rc != MB_SUCCESS)
		{
		   fprintf(stderr, "ERROR: Could not start sync of 'bank_identity' board\n");
		   switch(rc) {
			   case MB_ERR_INVALID:
				   fprintf(stderr, "\t reason: 'bank_identity' board is invalid\n");
				   break;
			   case MB_ERR_LOCKED:
				   fprintf(stderr, "\t reason: 'bank_identity' board is locked\n");
				   break;
			   case MB_ERR_MEMALLOC:
				   fprintf(stderr, "\t reason: out of memory\n");
				   break;
			   case MB_ERR_INTERNAL:
				   fprintf(stderr, "\t reason: internal error. Recompile libmoard in debug mode for more info \n");
				   break;
			   default:
				   fprintf(stderr, "\t MB_SyncStart returned error code: %d (see libmboard docs for details)\n", rc);
				   break;
		   }

			
			exit(rc);
		}
		#endif
    }
    


	if(FLAME_TEST_PRINT_START_AND_END_OF_MODEL_FUNCTIONS) printf("start idle\n");
	current_xmachine_Government_holder = Government_003b_state->agents;
	while(current_xmachine_Government_holder)
	{
		temp_xmachine_Government_holder = current_xmachine_Government_holder->next;
		current_xmachine_Government = current_xmachine_Government_holder->agent;
		current_xmachine_Government_next_state = Government_Gov_Start_Bond_Market_state;
		/* For backwards compatibility set current_xmachine */
		current_xmachine->xmachine_Firm = NULL;
		current_xmachine->xmachine_Household = NULL;
		current_xmachine->xmachine_Mall = NULL;
		current_xmachine->xmachine_IGFirm = NULL;
		current_xmachine->xmachine_Eurostat = NULL;
		current_xmachine->xmachine_Bank = NULL;
		current_xmachine->xmachine_Government = NULL;
		current_xmachine->xmachine_CentralBank = NULL;
		current_xmachine->xmachine_ClearingHouse = NULL;
		current_xmachine->xmachine_Government = current_xmachine_Government;

		if(FLAME_condition_Government_idle_003b_Gov_Start_Bond_Market(current_xmachine_Government)==1)
		{

		

			i = idle();

		

			if(i == 1)
			{
				free_Government_agent(current_xmachine_Government_holder, Government_003b_state);
			}
			else
			{
				transition_Government_agent(current_xmachine_Government_holder, Government_003b_state, Government_Gov_Start_Bond_Market_state);
			}
		}

		current_xmachine_Government = NULL;

		current_xmachine_Government_holder = temp_xmachine_Government_holder;
	}
	if(FLAME_TEST_PRINT_START_AND_END_OF_MODEL_FUNCTIONS) printf("finish idle\n");


	if(FLAME_TEST_PRINT_START_AND_END_OF_MODEL_FUNCTIONS) printf("start Government_migration\n");
	current_xmachine_Government_holder = Government_003b_state->agents;
	while(current_xmachine_Government_holder)
	{
		temp_xmachine_Government_holder = current_xmachine_Government_holder->next;
		current_xmachine_Government = current_xmachine_Government_holder->agent;
		current_xmachine_Government_next_state = Government_Gov_Start_Bond_Market_state;
		/* For backwards compatibility set current_xmachine */
		current_xmachine->xmachine_Firm = NULL;
		current_xmachine->xmachine_Household = NULL;
		current_xmachine->xmachine_Mall = NULL;
		current_xmachine->xmachine_IGFirm = NULL;
		current_xmachine->xmachine_Eurostat = NULL;
		current_xmachine->xmachine_Bank = NULL;
		current_xmachine->xmachine_Government = NULL;
		current_xmachine->xmachine_CentralBank = NULL;
		current_xmachine->xmachine_ClearingHouse = NULL;
		current_xmachine->xmachine_Government = current_xmachine_Government;

		if(FLAME_condition_Government_Government_migration_003b_Gov_Start_Bond_Market(current_xmachine_Government)==1)
		{

		

			i = Government_migration();

		

			if(i == 1)
			{
				free_Government_agent(current_xmachine_Government_holder, Government_003b_state);
			}
			else
			{
				transition_Government_agent(current_xmachine_Government_holder, Government_003b_state, Government_Gov_Start_Bond_Market_state);
			}
		}

		current_xmachine_Government = NULL;

		current_xmachine_Government_holder = temp_xmachine_Government_holder;
	}
	if(FLAME_TEST_PRINT_START_AND_END_OF_MODEL_FUNCTIONS) printf("finish Government_migration\n");


/* End of layer number 8 */

/* Clear message boards that have finished being used
 * and sync complete if doing late sync complete */


	if(FLAME_TEST_PRINT_START_AND_END_OF_MODEL_FUNCTIONS) printf("start Bank_send_dividend_payment\n");
	current_xmachine_Bank_holder = Bank_Bank_01_state->agents;
	while(current_xmachine_Bank_holder)
	{
		temp_xmachine_Bank_holder = current_xmachine_Bank_holder->next;
		current_xmachine_Bank = current_xmachine_Bank_holder->agent;
		current_xmachine_Bank_next_state = Bank_Bank_01b_state;
		/* For backwards compatibility set current_xmachine */
		current_xmachine->xmachine_Firm = NULL;
		current_xmachine->xmachine_Household = NULL;
		current_xmachine->xmachine_Mall = NULL;
		current_xmachine->xmachine_IGFirm = NULL;
		current_xmachine->xmachine_Eurostat = NULL;
		current_xmachine->xmachine_Bank = NULL;
		current_xmachine->xmachine_Government = NULL;
		current_xmachine->xmachine_CentralBank = NULL;
		current_xmachine->xmachine_ClearingHouse = NULL;
		current_xmachine->xmachine_Bank = current_xmachine_Bank;

		if(FLAME_condition_Bank_Bank_send_dividend_payment_Bank_01_Bank_01b(current_xmachine_Bank)==1)
		{

		

			i = Bank_send_dividend_payment();

		

			if(i == 1)
			{
				free_Bank_agent(current_xmachine_Bank_holder, Bank_Bank_01_state);
			}
			else
			{
				transition_Bank_agent(current_xmachine_Bank_holder, Bank_Bank_01_state, Bank_Bank_01b_state);
			}
		}

		current_xmachine_Bank = NULL;

		current_xmachine_Bank_holder = temp_xmachine_Bank_holder;
	}
	if(FLAME_TEST_PRINT_START_AND_END_OF_MODEL_FUNCTIONS) printf("finish Bank_send_dividend_payment\n");


	if(FLAME_TEST_PRINT_START_AND_END_OF_MODEL_FUNCTIONS) printf("start Government_bond_market_dummy\n");
	current_xmachine_Government_holder = Government_Gov_Start_Bond_Market_state->agents;
	while(current_xmachine_Government_holder)
	{
		temp_xmachine_Government_holder = current_xmachine_Government_holder->next;
		current_xmachine_Government = current_xmachine_Government_holder->agent;
		current_xmachine_Government_next_state = Government_Start_Gov_Consumer_Role_state;
		/* For backwards compatibility set current_xmachine */
		current_xmachine->xmachine_Firm = NULL;
		current_xmachine->xmachine_Household = NULL;
		current_xmachine->xmachine_Mall = NULL;
		current_xmachine->xmachine_IGFirm = NULL;
		current_xmachine->xmachine_Eurostat = NULL;
		current_xmachine->xmachine_Bank = NULL;
		current_xmachine->xmachine_Government = NULL;
		current_xmachine->xmachine_CentralBank = NULL;
		current_xmachine->xmachine_ClearingHouse = NULL;
		current_xmachine->xmachine_Government = current_xmachine_Government;

		

		

			i = Government_bond_market_dummy();

		

			if(i == 1)
			{
				free_Government_agent(current_xmachine_Government_holder, Government_Gov_Start_Bond_Market_state);
			}
			else
			{
				transition_Government_agent(current_xmachine_Government_holder, Government_Gov_Start_Bond_Market_state, Government_Start_Gov_Consumer_Role_state);
			}
		

		current_xmachine_Government = NULL;

		current_xmachine_Government_holder = temp_xmachine_Government_holder;
	}
	if(FLAME_TEST_PRINT_START_AND_END_OF_MODEL_FUNCTIONS) printf("finish Government_bond_market_dummy\n");


	if(FLAME_TEST_PRINT_START_AND_END_OF_MODEL_FUNCTIONS) printf("start Bank_set_quantities_zero\n");
	current_xmachine_Bank_holder = Bank_Bank_01_state->agents;
	while(current_xmachine_Bank_holder)
	{
		temp_xmachine_Bank_holder = current_xmachine_Bank_holder->next;
		current_xmachine_Bank = current_xmachine_Bank_holder->agent;
		current_xmachine_Bank_next_state = Bank_Bank_01b_state;
		/* For backwards compatibility set current_xmachine */
		current_xmachine->xmachine_Firm = NULL;
		current_xmachine->xmachine_Household = NULL;
		current_xmachine->xmachine_Mall = NULL;
		current_xmachine->xmachine_IGFirm = NULL;
		current_xmachine->xmachine_Eurostat = NULL;
		current_xmachine->xmachine_Bank = NULL;
		current_xmachine->xmachine_Government = NULL;
		current_xmachine->xmachine_CentralBank = NULL;
		current_xmachine->xmachine_ClearingHouse = NULL;
		current_xmachine->xmachine_Bank = current_xmachine_Bank;

		if(FLAME_condition_Bank_Bank_set_quantities_zero_Bank_01_Bank_01b(current_xmachine_Bank)==1)
		{

		

			i = Bank_set_quantities_zero();

		

			if(i == 1)
			{
				free_Bank_agent(current_xmachine_Bank_holder, Bank_Bank_01_state);
			}
			else
			{
				transition_Bank_agent(current_xmachine_Bank_holder, Bank_Bank_01_state, Bank_Bank_01b_state);
			}
		}

		current_xmachine_Bank = NULL;

		current_xmachine_Bank_holder = temp_xmachine_Bank_holder;
	}
	if(FLAME_TEST_PRINT_START_AND_END_OF_MODEL_FUNCTIONS) printf("finish Bank_set_quantities_zero\n");


/* End of layer number 9 */

/* Clear message boards that have finished being used
 * and sync complete if doing late sync complete */


	if(FLAME_TEST_PRINT_START_AND_END_OF_MODEL_FUNCTIONS) printf("start Bank_send_account_interest\n");
	current_xmachine_Bank_holder = Bank_Bank_01b_state->agents;
	while(current_xmachine_Bank_holder)
	{
		temp_xmachine_Bank_holder = current_xmachine_Bank_holder->next;
		current_xmachine_Bank = current_xmachine_Bank_holder->agent;
		current_xmachine_Bank_next_state = Bank_Bank_02_state;
		/* For backwards compatibility set current_xmachine */
		current_xmachine->xmachine_Firm = NULL;
		current_xmachine->xmachine_Household = NULL;
		current_xmachine->xmachine_Mall = NULL;
		current_xmachine->xmachine_IGFirm = NULL;
		current_xmachine->xmachine_Eurostat = NULL;
		current_xmachine->xmachine_Bank = NULL;
		current_xmachine->xmachine_Government = NULL;
		current_xmachine->xmachine_CentralBank = NULL;
		current_xmachine->xmachine_ClearingHouse = NULL;
		current_xmachine->xmachine_Bank = current_xmachine_Bank;

		

		

			i = Bank_send_account_interest();

		

			if(i == 1)
			{
				free_Bank_agent(current_xmachine_Bank_holder, Bank_Bank_01b_state);
			}
			else
			{
				transition_Bank_agent(current_xmachine_Bank_holder, Bank_Bank_01b_state, Bank_Bank_02_state);
			}
		

		current_xmachine_Bank = NULL;

		current_xmachine_Bank_holder = temp_xmachine_Bank_holder;
	}
	if(FLAME_TEST_PRINT_START_AND_END_OF_MODEL_FUNCTIONS) printf("finish Bank_send_account_interest\n");

	if(FLAME_account_interest_message_board_write == 1)
	{

		if(FLAME_TEST_PRINT_START_AND_END_OF_LIBMBOARD_CALLS) printf("start MB_SyncStart(b_account_interest)\n");
		rc = MB_SyncStart(b_account_interest);
		if(FLAME_TEST_PRINT_START_AND_END_OF_LIBMBOARD_CALLS) printf("finish MB_SyncStart(b_account_interest)\n");
		#ifdef ERRCHECK
		if (rc != MB_SUCCESS)
		{
		   fprintf(stderr, "ERROR: Could not start sync of 'account_interest' board\n");
		   switch(rc) {
			   case MB_ERR_INVALID:
				   fprintf(stderr, "\t reason: 'account_interest' board is invalid\n");
				   break;
			   case MB_ERR_LOCKED:
				   fprintf(stderr, "\t reason: 'account_interest' board is locked\n");
				   break;
			   case MB_ERR_MEMALLOC:
				   fprintf(stderr, "\t reason: out of memory\n");
				   break;
			   case MB_ERR_INTERNAL:
				   fprintf(stderr, "\t reason: internal error. Recompile libmoard in debug mode for more info \n");
				   break;
			   default:
				   fprintf(stderr, "\t MB_SyncStart returned error code: %d (see libmboard docs for details)\n", rc);
				   break;
		   }

			
			exit(rc);
		}
		#endif
    }
    

	if(FLAME_bank_interest_payment_message_board_write == 1)
	{

		if(FLAME_TEST_PRINT_START_AND_END_OF_LIBMBOARD_CALLS) printf("start MB_SyncStart(b_bank_interest_payment)\n");
		rc = MB_SyncStart(b_bank_interest_payment);
		if(FLAME_TEST_PRINT_START_AND_END_OF_LIBMBOARD_CALLS) printf("finish MB_SyncStart(b_bank_interest_payment)\n");
		#ifdef ERRCHECK
		if (rc != MB_SUCCESS)
		{
		   fprintf(stderr, "ERROR: Could not start sync of 'bank_interest_payment' board\n");
		   switch(rc) {
			   case MB_ERR_INVALID:
				   fprintf(stderr, "\t reason: 'bank_interest_payment' board is invalid\n");
				   break;
			   case MB_ERR_LOCKED:
				   fprintf(stderr, "\t reason: 'bank_interest_payment' board is locked\n");
				   break;
			   case MB_ERR_MEMALLOC:
				   fprintf(stderr, "\t reason: out of memory\n");
				   break;
			   case MB_ERR_INTERNAL:
				   fprintf(stderr, "\t reason: internal error. Recompile libmoard in debug mode for more info \n");
				   break;
			   default:
				   fprintf(stderr, "\t MB_SyncStart returned error code: %d (see libmboard docs for details)\n", rc);
				   break;
		   }

			
			exit(rc);
		}
		#endif
    }
    


	if(FLAME_TEST_PRINT_START_AND_END_OF_MODEL_FUNCTIONS) printf("start Government_determine_consumption_budget\n");
	current_xmachine_Government_holder = Government_Start_Gov_Consumer_Role_state->agents;
	while(current_xmachine_Government_holder)
	{
		temp_xmachine_Government_holder = current_xmachine_Government_holder->next;
		current_xmachine_Government = current_xmachine_Government_holder->agent;
		current_xmachine_Government_next_state = Government_Gov_Cons_1_state;
		/* For backwards compatibility set current_xmachine */
		current_xmachine->xmachine_Firm = NULL;
		current_xmachine->xmachine_Household = NULL;
		current_xmachine->xmachine_Mall = NULL;
		current_xmachine->xmachine_IGFirm = NULL;
		current_xmachine->xmachine_Eurostat = NULL;
		current_xmachine->xmachine_Bank = NULL;
		current_xmachine->xmachine_Government = NULL;
		current_xmachine->xmachine_CentralBank = NULL;
		current_xmachine->xmachine_ClearingHouse = NULL;
		current_xmachine->xmachine_Government = current_xmachine_Government;

		if(FLAME_condition_Government_Government_determine_consumption_budget_Start_Gov_Consumer_Role_Gov_Cons_1(current_xmachine_Government)==1)
		{

		

			i = Government_determine_consumption_budget();

		

			if(i == 1)
			{
				free_Government_agent(current_xmachine_Government_holder, Government_Start_Gov_Consumer_Role_state);
			}
			else
			{
				transition_Government_agent(current_xmachine_Government_holder, Government_Start_Gov_Consumer_Role_state, Government_Gov_Cons_1_state);
			}
		}

		current_xmachine_Government = NULL;

		current_xmachine_Government_holder = temp_xmachine_Government_holder;
	}
	if(FLAME_TEST_PRINT_START_AND_END_OF_MODEL_FUNCTIONS) printf("finish Government_determine_consumption_budget\n");


	if(FLAME_TEST_PRINT_START_AND_END_OF_MODEL_FUNCTIONS) printf("start idle\n");
	current_xmachine_Government_holder = Government_Start_Gov_Consumer_Role_state->agents;
	while(current_xmachine_Government_holder)
	{
		temp_xmachine_Government_holder = current_xmachine_Government_holder->next;
		current_xmachine_Government = current_xmachine_Government_holder->agent;
		current_xmachine_Government_next_state = Government_Gov_Cons_1_state;
		/* For backwards compatibility set current_xmachine */
		current_xmachine->xmachine_Firm = NULL;
		current_xmachine->xmachine_Household = NULL;
		current_xmachine->xmachine_Mall = NULL;
		current_xmachine->xmachine_IGFirm = NULL;
		current_xmachine->xmachine_Eurostat = NULL;
		current_xmachine->xmachine_Bank = NULL;
		current_xmachine->xmachine_Government = NULL;
		current_xmachine->xmachine_CentralBank = NULL;
		current_xmachine->xmachine_ClearingHouse = NULL;
		current_xmachine->xmachine_Government = current_xmachine_Government;

		if(FLAME_condition_Government_idle_Start_Gov_Consumer_Role_Gov_Cons_1(current_xmachine_Government)==1)
		{

		

			i = idle();

		

			if(i == 1)
			{
				free_Government_agent(current_xmachine_Government_holder, Government_Start_Gov_Consumer_Role_state);
			}
			else
			{
				transition_Government_agent(current_xmachine_Government_holder, Government_Start_Gov_Consumer_Role_state, Government_Gov_Cons_1_state);
			}
		}

		current_xmachine_Government = NULL;

		current_xmachine_Government_holder = temp_xmachine_Government_holder;
	}
	if(FLAME_TEST_PRINT_START_AND_END_OF_MODEL_FUNCTIONS) printf("finish idle\n");


/* End of layer number 10 */

/* Clear message boards that have finished being used
 * and sync complete if doing late sync complete */


	if(FLAME_TEST_PRINT_START_AND_END_OF_MODEL_FUNCTIONS) printf("start idle\n");
	current_xmachine_Bank_holder = Bank_Bank_02_state->agents;
	while(current_xmachine_Bank_holder)
	{
		temp_xmachine_Bank_holder = current_xmachine_Bank_holder->next;
		current_xmachine_Bank = current_xmachine_Bank_holder->agent;
		current_xmachine_Bank_next_state = Bank_Bank_04_state;
		/* For backwards compatibility set current_xmachine */
		current_xmachine->xmachine_Firm = NULL;
		current_xmachine->xmachine_Household = NULL;
		current_xmachine->xmachine_Mall = NULL;
		current_xmachine->xmachine_IGFirm = NULL;
		current_xmachine->xmachine_Eurostat = NULL;
		current_xmachine->xmachine_Bank = NULL;
		current_xmachine->xmachine_Government = NULL;
		current_xmachine->xmachine_CentralBank = NULL;
		current_xmachine->xmachine_ClearingHouse = NULL;
		current_xmachine->xmachine_Bank = current_xmachine_Bank;

		if(FLAME_condition_Bank_idle_Bank_02_Bank_04(current_xmachine_Bank)==1)
		{

		

			i = idle();

		

			if(i == 1)
			{
				free_Bank_agent(current_xmachine_Bank_holder, Bank_Bank_02_state);
			}
			else
			{
				transition_Bank_agent(current_xmachine_Bank_holder, Bank_Bank_02_state, Bank_Bank_04_state);
			}
		}

		current_xmachine_Bank = NULL;

		current_xmachine_Bank_holder = temp_xmachine_Bank_holder;
	}
	if(FLAME_TEST_PRINT_START_AND_END_OF_MODEL_FUNCTIONS) printf("finish idle\n");


	/* If mb is not read then leave sync complete until last possible moment */
	if(FLAME_account_interest_message_board_read == 1)
	{
		if(FLAME_TEST_PRINT_START_AND_END_OF_LIBMBOARD_CALLS) printf("start MB_SyncComplete(b_account_interest)\n");
		rc = MB_SyncComplete(b_account_interest);
		if(FLAME_TEST_PRINT_START_AND_END_OF_LIBMBOARD_CALLS) printf("finsh MB_SyncComplete(b_account_interest)\n");
		#ifdef ERRCHECK
		if (rc != MB_SUCCESS)
		{
		   fprintf(stderr, "ERROR: Could not complete sync of 'account_interest' board\n");
		   switch(rc) {
				case MB_ERR_INVALID:
				   fprintf(stderr, "\t reason: 'account_interest' board is invalid\n");
				   break;
			   case MB_ERR_MEMALLOC:
				   fprintf(stderr, "\t reason: out of memory\n");
				   break;
			   case MB_ERR_INTERNAL:
				   fprintf(stderr, "\t reason: internal error. Recompile libmoard in debug mode for more info \n");
				   break;
			   default:
				   fprintf(stderr, "\t MB_SyncComplete returned error code: %d (see libmboard docs for details)\n", rc);
				   break;
		   }
	
		   
		   exit(rc);
		}
		#endif
    
	}
	
	if(FLAME_TEST_PRINT_START_AND_END_OF_MODEL_FUNCTIONS) printf("start Firm_receive_account_interest\n");
	current_xmachine_Firm_holder = Firm_Firm_interest_state->agents;
	while(current_xmachine_Firm_holder)
	{
		temp_xmachine_Firm_holder = current_xmachine_Firm_holder->next;
		current_xmachine_Firm = current_xmachine_Firm_holder->agent;
		current_xmachine_Firm_next_state = Firm_Firm_checks_if_active_state;
		/* For backwards compatibility set current_xmachine */
		current_xmachine->xmachine_Firm = NULL;
		current_xmachine->xmachine_Household = NULL;
		current_xmachine->xmachine_Mall = NULL;
		current_xmachine->xmachine_IGFirm = NULL;
		current_xmachine->xmachine_Eurostat = NULL;
		current_xmachine->xmachine_Bank = NULL;
		current_xmachine->xmachine_Government = NULL;
		current_xmachine->xmachine_CentralBank = NULL;
		current_xmachine->xmachine_ClearingHouse = NULL;
		current_xmachine->xmachine_Firm = current_xmachine_Firm;

		

		
		
		rc = MB_Iterator_Create(b_account_interest, &i_account_interest);
		#ifdef ERRCHECK
		if (rc != MB_SUCCESS)
		{
		   fprintf(stderr, "ERROR: Could not create Iterator for 'account_interest'\n");
		   switch(rc) {
		       case MB_ERR_INVALID:
		           fprintf(stderr, "\t reason: 'account_interest' board is invalid\n");
		           break;
		       case MB_ERR_LOCKED:
	               fprintf(stderr, "\t reason: 'account_interest' board is locked\n");
	               break;
	           case MB_ERR_MEMALLOC:
	               fprintf(stderr, "\t reason: out of memory\n");
	               break;
	           case MB_ERR_INTERNAL:
	               fprintf(stderr, "\t reason: internal error. Recompile libmoard in debug mode for more info \n");
	               break;
	           default:
	           
               
                   fprintf(stderr, "\t MB_Iterator_Create returned error code: %d (see libmboard docs for details)\n", rc);
               
                   break;
		   }

		   
           exit(rc);
		}
		#endif
		
		

			i = Firm_receive_account_interest();

		
		    rc = MB_Iterator_Delete(&i_account_interest);
		    #ifdef ERRCHECK
		    if (rc != MB_SUCCESS)
		    {
		       fprintf(stderr, "ERROR: Could not delete 'account_interest' iterator\n");
		       switch(rc) {
		           case MB_ERR_INVALID:
		               fprintf(stderr, "\t reason: 'account_interest' iterator is invalid\n");
		               break;
		           case MB_ERR_INTERNAL:
		               fprintf(stderr, "\t reason: internal error. Recompile libmoard in debug mode for more info \n");
		               break;
		           default:
                       fprintf(stderr, "\t MB_Iterator_Delete returned error code: %d (see libmboard docs for details)\n", rc);
                       break;
		       }

		       
               exit(rc);
		    }
		    #endif
		

			if(i == 1)
			{
				free_Firm_agent(current_xmachine_Firm_holder, Firm_Firm_interest_state);
			}
			else
			{
				transition_Firm_agent(current_xmachine_Firm_holder, Firm_Firm_interest_state, Firm_Firm_checks_if_active_state);
			}
		

		current_xmachine_Firm = NULL;

		current_xmachine_Firm_holder = temp_xmachine_Firm_holder;
	}
	if(FLAME_TEST_PRINT_START_AND_END_OF_MODEL_FUNCTIONS) printf("finish Firm_receive_account_interest\n");


	if(FLAME_TEST_PRINT_START_AND_END_OF_MODEL_FUNCTIONS) printf("start Household_receive_account_interest\n");
	current_xmachine_Household_holder = Household_Household_Start_Policy_Data_state->agents;
	while(current_xmachine_Household_holder)
	{
		temp_xmachine_Household_holder = current_xmachine_Household_holder->next;
		current_xmachine_Household = current_xmachine_Household_holder->agent;
		current_xmachine_Household_next_state = Household_Household_Start_Market_Research_Role_state;
		/* For backwards compatibility set current_xmachine */
		current_xmachine->xmachine_Firm = NULL;
		current_xmachine->xmachine_Household = NULL;
		current_xmachine->xmachine_Mall = NULL;
		current_xmachine->xmachine_IGFirm = NULL;
		current_xmachine->xmachine_Eurostat = NULL;
		current_xmachine->xmachine_Bank = NULL;
		current_xmachine->xmachine_Government = NULL;
		current_xmachine->xmachine_CentralBank = NULL;
		current_xmachine->xmachine_ClearingHouse = NULL;
		current_xmachine->xmachine_Household = current_xmachine_Household;

		

		
		
		rc = MB_Iterator_Create(b_account_interest, &i_account_interest);
		#ifdef ERRCHECK
		if (rc != MB_SUCCESS)
		{
		   fprintf(stderr, "ERROR: Could not create Iterator for 'account_interest'\n");
		   switch(rc) {
		       case MB_ERR_INVALID:
		           fprintf(stderr, "\t reason: 'account_interest' board is invalid\n");
		           break;
		       case MB_ERR_LOCKED:
	               fprintf(stderr, "\t reason: 'account_interest' board is locked\n");
	               break;
	           case MB_ERR_MEMALLOC:
	               fprintf(stderr, "\t reason: out of memory\n");
	               break;
	           case MB_ERR_INTERNAL:
	               fprintf(stderr, "\t reason: internal error. Recompile libmoard in debug mode for more info \n");
	               break;
	           default:
	           
               
                   fprintf(stderr, "\t MB_Iterator_Create returned error code: %d (see libmboard docs for details)\n", rc);
               
                   break;
		   }

		   
           exit(rc);
		}
		#endif
		
		

			i = Household_receive_account_interest();

		
		    rc = MB_Iterator_Delete(&i_account_interest);
		    #ifdef ERRCHECK
		    if (rc != MB_SUCCESS)
		    {
		       fprintf(stderr, "ERROR: Could not delete 'account_interest' iterator\n");
		       switch(rc) {
		           case MB_ERR_INVALID:
		               fprintf(stderr, "\t reason: 'account_interest' iterator is invalid\n");
		               break;
		           case MB_ERR_INTERNAL:
		               fprintf(stderr, "\t reason: internal error. Recompile libmoard in debug mode for more info \n");
		               break;
		           default:
                       fprintf(stderr, "\t MB_Iterator_Delete returned error code: %d (see libmboard docs for details)\n", rc);
                       break;
		       }

		       
               exit(rc);
		    }
		    #endif
		

			if(i == 1)
			{
				free_Household_agent(current_xmachine_Household_holder, Household_Household_Start_Policy_Data_state);
			}
			else
			{
				transition_Household_agent(current_xmachine_Household_holder, Household_Household_Start_Policy_Data_state, Household_Household_Start_Market_Research_Role_state);
			}
		

		current_xmachine_Household = NULL;

		current_xmachine_Household_holder = temp_xmachine_Household_holder;
	}
	if(FLAME_TEST_PRINT_START_AND_END_OF_MODEL_FUNCTIONS) printf("finish Household_receive_account_interest\n");


	if(FLAME_TEST_PRINT_START_AND_END_OF_MODEL_FUNCTIONS) printf("start IGFirm_receive_account_interest\n");
	current_xmachine_IGFirm_holder = IGFirm_IGFirm_interest_state->agents;
	while(current_xmachine_IGFirm_holder)
	{
		temp_xmachine_IGFirm_holder = current_xmachine_IGFirm_holder->next;
		current_xmachine_IGFirm = current_xmachine_IGFirm_holder->agent;
		current_xmachine_IGFirm_next_state = IGFirm_IGFirm_checks_if_active_state;
		/* For backwards compatibility set current_xmachine */
		current_xmachine->xmachine_Firm = NULL;
		current_xmachine->xmachine_Household = NULL;
		current_xmachine->xmachine_Mall = NULL;
		current_xmachine->xmachine_IGFirm = NULL;
		current_xmachine->xmachine_Eurostat = NULL;
		current_xmachine->xmachine_Bank = NULL;
		current_xmachine->xmachine_Government = NULL;
		current_xmachine->xmachine_CentralBank = NULL;
		current_xmachine->xmachine_ClearingHouse = NULL;
		current_xmachine->xmachine_IGFirm = current_xmachine_IGFirm;

		

		
		
		rc = MB_Iterator_Create(b_account_interest, &i_account_interest);
		#ifdef ERRCHECK
		if (rc != MB_SUCCESS)
		{
		   fprintf(stderr, "ERROR: Could not create Iterator for 'account_interest'\n");
		   switch(rc) {
		       case MB_ERR_INVALID:
		           fprintf(stderr, "\t reason: 'account_interest' board is invalid\n");
		           break;
		       case MB_ERR_LOCKED:
	               fprintf(stderr, "\t reason: 'account_interest' board is locked\n");
	               break;
	           case MB_ERR_MEMALLOC:
	               fprintf(stderr, "\t reason: out of memory\n");
	               break;
	           case MB_ERR_INTERNAL:
	               fprintf(stderr, "\t reason: internal error. Recompile libmoard in debug mode for more info \n");
	               break;
	           default:
	           
               
                   fprintf(stderr, "\t MB_Iterator_Create returned error code: %d (see libmboard docs for details)\n", rc);
               
                   break;
		   }

		   
           exit(rc);
		}
		#endif
		
		

			i = IGFirm_receive_account_interest();

		
		    rc = MB_Iterator_Delete(&i_account_interest);
		    #ifdef ERRCHECK
		    if (rc != MB_SUCCESS)
		    {
		       fprintf(stderr, "ERROR: Could not delete 'account_interest' iterator\n");
		       switch(rc) {
		           case MB_ERR_INVALID:
		               fprintf(stderr, "\t reason: 'account_interest' iterator is invalid\n");
		               break;
		           case MB_ERR_INTERNAL:
		               fprintf(stderr, "\t reason: internal error. Recompile libmoard in debug mode for more info \n");
		               break;
		           default:
                       fprintf(stderr, "\t MB_Iterator_Delete returned error code: %d (see libmboard docs for details)\n", rc);
                       break;
		       }

		       
               exit(rc);
		    }
		    #endif
		

			if(i == 1)
			{
				free_IGFirm_agent(current_xmachine_IGFirm_holder, IGFirm_IGFirm_interest_state);
			}
			else
			{
				transition_IGFirm_agent(current_xmachine_IGFirm_holder, IGFirm_IGFirm_interest_state, IGFirm_IGFirm_checks_if_active_state);
			}
		

		current_xmachine_IGFirm = NULL;

		current_xmachine_IGFirm_holder = temp_xmachine_IGFirm_holder;
	}
	if(FLAME_TEST_PRINT_START_AND_END_OF_MODEL_FUNCTIONS) printf("finish IGFirm_receive_account_interest\n");


/* End of layer number 11 */

/* Clear message boards that have finished being used
 * and sync complete if doing late sync complete */

if(FLAME_account_interest_message_board_read == 0)
{
	/*printf("%d> account_interest message board sync complete late as no agents reading any messages of this type\n", node_number);*/
	
	if(FLAME_TEST_PRINT_START_AND_END_OF_LIBMBOARD_CALLS) printf("start MB_SyncComplete(b_account_interest)\n");
	rc = MB_SyncComplete(b_account_interest);
	if(FLAME_TEST_PRINT_START_AND_END_OF_LIBMBOARD_CALLS) printf("finsh MB_SyncComplete(b_account_interest)\n");
	#ifdef ERRCHECK
	if (rc != MB_SUCCESS)
	{
	   fprintf(stderr, "ERROR: Could not complete sync of 'account_interest' board\n");
	   switch(rc) {
			case MB_ERR_INVALID:
			   fprintf(stderr, "\t reason: 'account_interest' board is invalid\n");
			   break;
		   case MB_ERR_MEMALLOC:
			   fprintf(stderr, "\t reason: out of memory\n");
			   break;
		   case MB_ERR_INTERNAL:
			   fprintf(stderr, "\t reason: internal error. Recompile libmoard in debug mode for more info \n");
			   break;
		   default:
			   fprintf(stderr, "\t MB_SyncComplete returned error code: %d (see libmboard docs for details)\n", rc);
			   break;
	   }

	   
	   exit(rc);
	}
	#endif
}

    rc = MB_Clear(b_account_interest);
    #ifdef ERRCHECK
    if (rc != MB_SUCCESS)
    {
       fprintf(stderr, "ERROR: Could not clear 'account_interest' board\n");
       switch(rc) {
           case MB_ERR_INVALID:
               fprintf(stderr, "\t reason: 'account_interest' board is invalid\n");
               break;
           case MB_ERR_LOCKED:
               fprintf(stderr, "\t reason: 'account_interest' board is locked\n");
               break;
           case MB_ERR_INTERNAL:
               fprintf(stderr, "\t reason: internal error. Recompile libmoard in debug mode for more info \n");
               break;
           default:
               fprintf(stderr, "\t MB_Clear returned error code: %d (see libmboard docs for details)\n", rc);
               break;

       }

       
       exit(rc);
    }
    #endif


	if(FLAME_TEST_PRINT_START_AND_END_OF_MODEL_FUNCTIONS) printf("start idle\n");
	current_xmachine_IGFirm_holder = IGFirm_IGFirm_checks_if_active_state->agents;
	while(current_xmachine_IGFirm_holder)
	{
		temp_xmachine_IGFirm_holder = current_xmachine_IGFirm_holder->next;
		current_xmachine_IGFirm = current_xmachine_IGFirm_holder->agent;
		current_xmachine_IGFirm_next_state = IGFirm_IGFirm_is_active_state;
		/* For backwards compatibility set current_xmachine */
		current_xmachine->xmachine_Firm = NULL;
		current_xmachine->xmachine_Household = NULL;
		current_xmachine->xmachine_Mall = NULL;
		current_xmachine->xmachine_IGFirm = NULL;
		current_xmachine->xmachine_Eurostat = NULL;
		current_xmachine->xmachine_Bank = NULL;
		current_xmachine->xmachine_Government = NULL;
		current_xmachine->xmachine_CentralBank = NULL;
		current_xmachine->xmachine_ClearingHouse = NULL;
		current_xmachine->xmachine_IGFirm = current_xmachine_IGFirm;

		

		

			i = idle();

		

			if(i == 1)
			{
				free_IGFirm_agent(current_xmachine_IGFirm_holder, IGFirm_IGFirm_checks_if_active_state);
			}
			else
			{
				transition_IGFirm_agent(current_xmachine_IGFirm_holder, IGFirm_IGFirm_checks_if_active_state, IGFirm_IGFirm_is_active_state);
			}
		

		current_xmachine_IGFirm = NULL;

		current_xmachine_IGFirm_holder = temp_xmachine_IGFirm_holder;
	}
	if(FLAME_TEST_PRINT_START_AND_END_OF_MODEL_FUNCTIONS) printf("finish idle\n");


	if(FLAME_TEST_PRINT_START_AND_END_OF_MODEL_FUNCTIONS) printf("start Household_decide_to_attend_interview\n");
	current_xmachine_Household_holder = Household_Household_Start_Market_Research_Role_state->agents;
	while(current_xmachine_Household_holder)
	{
		temp_xmachine_Household_holder = current_xmachine_Household_holder->next;
		current_xmachine_Household = current_xmachine_Household_holder->agent;
		current_xmachine_Household_next_state = Household_HH_MR_1_state;
		/* For backwards compatibility set current_xmachine */
		current_xmachine->xmachine_Firm = NULL;
		current_xmachine->xmachine_Household = NULL;
		current_xmachine->xmachine_Mall = NULL;
		current_xmachine->xmachine_IGFirm = NULL;
		current_xmachine->xmachine_Eurostat = NULL;
		current_xmachine->xmachine_Bank = NULL;
		current_xmachine->xmachine_Government = NULL;
		current_xmachine->xmachine_CentralBank = NULL;
		current_xmachine->xmachine_ClearingHouse = NULL;
		current_xmachine->xmachine_Household = current_xmachine_Household;

		

		

			i = Household_decide_to_attend_interview();

		

			if(i == 1)
			{
				free_Household_agent(current_xmachine_Household_holder, Household_Household_Start_Market_Research_Role_state);
			}
			else
			{
				transition_Household_agent(current_xmachine_Household_holder, Household_Household_Start_Market_Research_Role_state, Household_HH_MR_1_state);
			}
		

		current_xmachine_Household = NULL;

		current_xmachine_Household_holder = temp_xmachine_Household_holder;
	}
	if(FLAME_TEST_PRINT_START_AND_END_OF_MODEL_FUNCTIONS) printf("finish Household_decide_to_attend_interview\n");


	if(FLAME_TEST_PRINT_START_AND_END_OF_MODEL_FUNCTIONS) printf("start idle\n");
	current_xmachine_Firm_holder = Firm_Firm_checks_if_active_state->agents;
	while(current_xmachine_Firm_holder)
	{
		temp_xmachine_Firm_holder = current_xmachine_Firm_holder->next;
		current_xmachine_Firm = current_xmachine_Firm_holder->agent;
		current_xmachine_Firm_next_state = Firm_Firm_is_active_state;
		/* For backwards compatibility set current_xmachine */
		current_xmachine->xmachine_Firm = NULL;
		current_xmachine->xmachine_Household = NULL;
		current_xmachine->xmachine_Mall = NULL;
		current_xmachine->xmachine_IGFirm = NULL;
		current_xmachine->xmachine_Eurostat = NULL;
		current_xmachine->xmachine_Bank = NULL;
		current_xmachine->xmachine_Government = NULL;
		current_xmachine->xmachine_CentralBank = NULL;
		current_xmachine->xmachine_ClearingHouse = NULL;
		current_xmachine->xmachine_Firm = current_xmachine_Firm;

		if(FLAME_condition_Firm_idle_Firm_checks_if_active_Firm_is_active(current_xmachine_Firm)==1)
		{

		

			i = idle();

		

			if(i == 1)
			{
				free_Firm_agent(current_xmachine_Firm_holder, Firm_Firm_checks_if_active_state);
			}
			else
			{
				transition_Firm_agent(current_xmachine_Firm_holder, Firm_Firm_checks_if_active_state, Firm_Firm_is_active_state);
			}
		}

		current_xmachine_Firm = NULL;

		current_xmachine_Firm_holder = temp_xmachine_Firm_holder;
	}
	if(FLAME_TEST_PRINT_START_AND_END_OF_MODEL_FUNCTIONS) printf("finish idle\n");


	if(FLAME_TEST_PRINT_START_AND_END_OF_MODEL_FUNCTIONS) printf("start Firm_bankruptcy_idle_counter\n");
	current_xmachine_Firm_holder = Firm_Firm_checks_if_active_state->agents;
	while(current_xmachine_Firm_holder)
	{
		temp_xmachine_Firm_holder = current_xmachine_Firm_holder->next;
		current_xmachine_Firm = current_xmachine_Firm_holder->agent;
		current_xmachine_Firm_next_state = Firm_Firm_not_active_state;
		/* For backwards compatibility set current_xmachine */
		current_xmachine->xmachine_Firm = NULL;
		current_xmachine->xmachine_Household = NULL;
		current_xmachine->xmachine_Mall = NULL;
		current_xmachine->xmachine_IGFirm = NULL;
		current_xmachine->xmachine_Eurostat = NULL;
		current_xmachine->xmachine_Bank = NULL;
		current_xmachine->xmachine_Government = NULL;
		current_xmachine->xmachine_CentralBank = NULL;
		current_xmachine->xmachine_ClearingHouse = NULL;
		current_xmachine->xmachine_Firm = current_xmachine_Firm;

		if(FLAME_condition_Firm_Firm_bankruptcy_idle_counter_Firm_checks_if_active_Firm_not_active(current_xmachine_Firm)==1)
		{

		

			i = Firm_bankruptcy_idle_counter();

		

			if(i == 1)
			{
				free_Firm_agent(current_xmachine_Firm_holder, Firm_Firm_checks_if_active_state);
			}
			else
			{
				transition_Firm_agent(current_xmachine_Firm_holder, Firm_Firm_checks_if_active_state, Firm_Firm_not_active_state);
			}
		}

		current_xmachine_Firm = NULL;

		current_xmachine_Firm_holder = temp_xmachine_Firm_holder;
	}
	if(FLAME_TEST_PRINT_START_AND_END_OF_MODEL_FUNCTIONS) printf("finish Firm_bankruptcy_idle_counter\n");


/* End of layer number 12 */

/* Clear message boards that have finished being used
 * and sync complete if doing late sync complete */


	if(FLAME_TEST_PRINT_START_AND_END_OF_MODEL_FUNCTIONS) printf("start Firm_bankruptcy_generic_procedure\n");
	current_xmachine_Firm_holder = Firm_Firm_not_active_state->agents;
	while(current_xmachine_Firm_holder)
	{
		temp_xmachine_Firm_holder = current_xmachine_Firm_holder->next;
		current_xmachine_Firm = current_xmachine_Firm_holder->agent;
		current_xmachine_Firm_next_state = Firm_Firm_bankruptcy_state_0_state;
		/* For backwards compatibility set current_xmachine */
		current_xmachine->xmachine_Firm = NULL;
		current_xmachine->xmachine_Household = NULL;
		current_xmachine->xmachine_Mall = NULL;
		current_xmachine->xmachine_IGFirm = NULL;
		current_xmachine->xmachine_Eurostat = NULL;
		current_xmachine->xmachine_Bank = NULL;
		current_xmachine->xmachine_Government = NULL;
		current_xmachine->xmachine_CentralBank = NULL;
		current_xmachine->xmachine_ClearingHouse = NULL;
		current_xmachine->xmachine_Firm = current_xmachine_Firm;

		if(FLAME_condition_Firm_Firm_bankruptcy_generic_procedure_Firm_not_active_Firm_bankruptcy_state_0(current_xmachine_Firm)==1)
		{

		

			i = Firm_bankruptcy_generic_procedure();

		

			if(i == 1)
			{
				free_Firm_agent(current_xmachine_Firm_holder, Firm_Firm_not_active_state);
			}
			else
			{
				transition_Firm_agent(current_xmachine_Firm_holder, Firm_Firm_not_active_state, Firm_Firm_bankruptcy_state_0_state);
			}
		}

		current_xmachine_Firm = NULL;

		current_xmachine_Firm_holder = temp_xmachine_Firm_holder;
	}
	if(FLAME_TEST_PRINT_START_AND_END_OF_MODEL_FUNCTIONS) printf("finish Firm_bankruptcy_generic_procedure\n");


	if(FLAME_TEST_PRINT_START_AND_END_OF_MODEL_FUNCTIONS) printf("start idle\n");
	current_xmachine_IGFirm_holder = IGFirm_IGFirm_is_active_state->agents;
	while(current_xmachine_IGFirm_holder)
	{
		temp_xmachine_IGFirm_holder = current_xmachine_IGFirm_holder->next;
		current_xmachine_IGFirm = current_xmachine_IGFirm_holder->agent;
		current_xmachine_IGFirm_next_state = IGFirm_Start_IGFirm_Productivity_state;
		/* For backwards compatibility set current_xmachine */
		current_xmachine->xmachine_Firm = NULL;
		current_xmachine->xmachine_Household = NULL;
		current_xmachine->xmachine_Mall = NULL;
		current_xmachine->xmachine_IGFirm = NULL;
		current_xmachine->xmachine_Eurostat = NULL;
		current_xmachine->xmachine_Bank = NULL;
		current_xmachine->xmachine_Government = NULL;
		current_xmachine->xmachine_CentralBank = NULL;
		current_xmachine->xmachine_ClearingHouse = NULL;
		current_xmachine->xmachine_IGFirm = current_xmachine_IGFirm;

		

		

			i = idle();

		

			if(i == 1)
			{
				free_IGFirm_agent(current_xmachine_IGFirm_holder, IGFirm_IGFirm_is_active_state);
			}
			else
			{
				transition_IGFirm_agent(current_xmachine_IGFirm_holder, IGFirm_IGFirm_is_active_state, IGFirm_Start_IGFirm_Productivity_state);
			}
		

		current_xmachine_IGFirm = NULL;

		current_xmachine_IGFirm_holder = temp_xmachine_IGFirm_holder;
	}
	if(FLAME_TEST_PRINT_START_AND_END_OF_MODEL_FUNCTIONS) printf("finish idle\n");


	if(FLAME_TEST_PRINT_START_AND_END_OF_MODEL_FUNCTIONS) printf("start Household_idle\n");
	current_xmachine_Household_holder = Household_HH_MR_1_state->agents;
	while(current_xmachine_Household_holder)
	{
		temp_xmachine_Household_holder = current_xmachine_Household_holder->next;
		current_xmachine_Household = current_xmachine_Household_holder->agent;
		current_xmachine_Household_next_state = Household_Household_Start_Financial_Market_Role_state;
		/* For backwards compatibility set current_xmachine */
		current_xmachine->xmachine_Firm = NULL;
		current_xmachine->xmachine_Household = NULL;
		current_xmachine->xmachine_Mall = NULL;
		current_xmachine->xmachine_IGFirm = NULL;
		current_xmachine->xmachine_Eurostat = NULL;
		current_xmachine->xmachine_Bank = NULL;
		current_xmachine->xmachine_Government = NULL;
		current_xmachine->xmachine_CentralBank = NULL;
		current_xmachine->xmachine_ClearingHouse = NULL;
		current_xmachine->xmachine_Household = current_xmachine_Household;

		if(FLAME_condition_Household_Household_idle_HH_MR_1_Household_Start_Financial_Market_Role(current_xmachine_Household)==1)
		{

		

			i = Household_idle();

		

			if(i == 1)
			{
				free_Household_agent(current_xmachine_Household_holder, Household_HH_MR_1_state);
			}
			else
			{
				transition_Household_agent(current_xmachine_Household_holder, Household_HH_MR_1_state, Household_Household_Start_Financial_Market_Role_state);
			}
		}

		current_xmachine_Household = NULL;

		current_xmachine_Household_holder = temp_xmachine_Household_holder;
	}
	if(FLAME_TEST_PRINT_START_AND_END_OF_MODEL_FUNCTIONS) printf("finish Household_idle\n");


	if(FLAME_TEST_PRINT_START_AND_END_OF_MODEL_FUNCTIONS) printf("start idle\n");
	current_xmachine_Firm_holder = Firm_Firm_is_active_state->agents;
	while(current_xmachine_Firm_holder)
	{
		temp_xmachine_Firm_holder = current_xmachine_Firm_holder->next;
		current_xmachine_Firm = current_xmachine_Firm_holder->agent;
		current_xmachine_Firm_next_state = Firm_Firm_Start_Market_Research_Role_state;
		/* For backwards compatibility set current_xmachine */
		current_xmachine->xmachine_Firm = NULL;
		current_xmachine->xmachine_Household = NULL;
		current_xmachine->xmachine_Mall = NULL;
		current_xmachine->xmachine_IGFirm = NULL;
		current_xmachine->xmachine_Eurostat = NULL;
		current_xmachine->xmachine_Bank = NULL;
		current_xmachine->xmachine_Government = NULL;
		current_xmachine->xmachine_CentralBank = NULL;
		current_xmachine->xmachine_ClearingHouse = NULL;
		current_xmachine->xmachine_Firm = current_xmachine_Firm;

		

		

			i = idle();

		

			if(i == 1)
			{
				free_Firm_agent(current_xmachine_Firm_holder, Firm_Firm_is_active_state);
			}
			else
			{
				transition_Firm_agent(current_xmachine_Firm_holder, Firm_Firm_is_active_state, Firm_Firm_Start_Market_Research_Role_state);
			}
		

		current_xmachine_Firm = NULL;

		current_xmachine_Firm_holder = temp_xmachine_Firm_holder;
	}
	if(FLAME_TEST_PRINT_START_AND_END_OF_MODEL_FUNCTIONS) printf("finish idle\n");


	if(FLAME_TEST_PRINT_START_AND_END_OF_MODEL_FUNCTIONS) printf("start idle\n");
	current_xmachine_Firm_holder = Firm_Firm_not_active_state->agents;
	while(current_xmachine_Firm_holder)
	{
		temp_xmachine_Firm_holder = current_xmachine_Firm_holder->next;
		current_xmachine_Firm = current_xmachine_Firm_holder->agent;
		current_xmachine_Firm_next_state = Firm_Firm_bankruptcy_state_0_state;
		/* For backwards compatibility set current_xmachine */
		current_xmachine->xmachine_Firm = NULL;
		current_xmachine->xmachine_Household = NULL;
		current_xmachine->xmachine_Mall = NULL;
		current_xmachine->xmachine_IGFirm = NULL;
		current_xmachine->xmachine_Eurostat = NULL;
		current_xmachine->xmachine_Bank = NULL;
		current_xmachine->xmachine_Government = NULL;
		current_xmachine->xmachine_CentralBank = NULL;
		current_xmachine->xmachine_ClearingHouse = NULL;
		current_xmachine->xmachine_Firm = current_xmachine_Firm;

		if(FLAME_condition_Firm_idle_Firm_not_active_Firm_bankruptcy_state_0(current_xmachine_Firm)==1)
		{

		

			i = idle();

		

			if(i == 1)
			{
				free_Firm_agent(current_xmachine_Firm_holder, Firm_Firm_not_active_state);
			}
			else
			{
				transition_Firm_agent(current_xmachine_Firm_holder, Firm_Firm_not_active_state, Firm_Firm_bankruptcy_state_0_state);
			}
		}

		current_xmachine_Firm = NULL;

		current_xmachine_Firm_holder = temp_xmachine_Firm_holder;
	}
	if(FLAME_TEST_PRINT_START_AND_END_OF_MODEL_FUNCTIONS) printf("finish idle\n");


/* End of layer number 13 */

/* Clear message boards that have finished being used
 * and sync complete if doing late sync complete */


	if(FLAME_TEST_PRINT_START_AND_END_OF_MODEL_FUNCTIONS) printf("start Firm_bankruptcy_rescale_loans\n");
	current_xmachine_Firm_holder = Firm_Firm_bankruptcy_state_0_state->agents;
	while(current_xmachine_Firm_holder)
	{
		temp_xmachine_Firm_holder = current_xmachine_Firm_holder->next;
		current_xmachine_Firm = current_xmachine_Firm_holder->agent;
		current_xmachine_Firm_next_state = Firm_Firm_bankruptcy_state_01_state;
		/* For backwards compatibility set current_xmachine */
		current_xmachine->xmachine_Firm = NULL;
		current_xmachine->xmachine_Household = NULL;
		current_xmachine->xmachine_Mall = NULL;
		current_xmachine->xmachine_IGFirm = NULL;
		current_xmachine->xmachine_Eurostat = NULL;
		current_xmachine->xmachine_Bank = NULL;
		current_xmachine->xmachine_Government = NULL;
		current_xmachine->xmachine_CentralBank = NULL;
		current_xmachine->xmachine_ClearingHouse = NULL;
		current_xmachine->xmachine_Firm = current_xmachine_Firm;

		

		

			i = Firm_bankruptcy_rescale_loans();

		

			if(i == 1)
			{
				free_Firm_agent(current_xmachine_Firm_holder, Firm_Firm_bankruptcy_state_0_state);
			}
			else
			{
				transition_Firm_agent(current_xmachine_Firm_holder, Firm_Firm_bankruptcy_state_0_state, Firm_Firm_bankruptcy_state_01_state);
			}
		

		current_xmachine_Firm = NULL;

		current_xmachine_Firm_holder = temp_xmachine_Firm_holder;
	}
	if(FLAME_TEST_PRINT_START_AND_END_OF_MODEL_FUNCTIONS) printf("finish Firm_bankruptcy_rescale_loans\n");

	if(FLAME_bankruptcy_message_board_write == 1)
	{

		if(FLAME_TEST_PRINT_START_AND_END_OF_LIBMBOARD_CALLS) printf("start MB_SyncStart(b_bankruptcy)\n");
		rc = MB_SyncStart(b_bankruptcy);
		if(FLAME_TEST_PRINT_START_AND_END_OF_LIBMBOARD_CALLS) printf("finish MB_SyncStart(b_bankruptcy)\n");
		#ifdef ERRCHECK
		if (rc != MB_SUCCESS)
		{
		   fprintf(stderr, "ERROR: Could not start sync of 'bankruptcy' board\n");
		   switch(rc) {
			   case MB_ERR_INVALID:
				   fprintf(stderr, "\t reason: 'bankruptcy' board is invalid\n");
				   break;
			   case MB_ERR_LOCKED:
				   fprintf(stderr, "\t reason: 'bankruptcy' board is locked\n");
				   break;
			   case MB_ERR_MEMALLOC:
				   fprintf(stderr, "\t reason: out of memory\n");
				   break;
			   case MB_ERR_INTERNAL:
				   fprintf(stderr, "\t reason: internal error. Recompile libmoard in debug mode for more info \n");
				   break;
			   default:
				   fprintf(stderr, "\t MB_SyncStart returned error code: %d (see libmboard docs for details)\n", rc);
				   break;
		   }

			
			exit(rc);
		}
		#endif
    }
    


	if(FLAME_TEST_PRINT_START_AND_END_OF_MODEL_FUNCTIONS) printf("start idle\n");
	current_xmachine_IGFirm_holder = IGFirm_Start_IGFirm_Productivity_state->agents;
	while(current_xmachine_IGFirm_holder)
	{
		temp_xmachine_IGFirm_holder = current_xmachine_IGFirm_holder->next;
		current_xmachine_IGFirm = current_xmachine_IGFirm_holder->agent;
		current_xmachine_IGFirm_next_state = IGFirm_01a_state;
		/* For backwards compatibility set current_xmachine */
		current_xmachine->xmachine_Firm = NULL;
		current_xmachine->xmachine_Household = NULL;
		current_xmachine->xmachine_Mall = NULL;
		current_xmachine->xmachine_IGFirm = NULL;
		current_xmachine->xmachine_Eurostat = NULL;
		current_xmachine->xmachine_Bank = NULL;
		current_xmachine->xmachine_Government = NULL;
		current_xmachine->xmachine_CentralBank = NULL;
		current_xmachine->xmachine_ClearingHouse = NULL;
		current_xmachine->xmachine_IGFirm = current_xmachine_IGFirm;

		if(FLAME_condition_IGFirm_idle_Start_IGFirm_Productivity_01a(current_xmachine_IGFirm)==1)
		{

		

			i = idle();

		

			if(i == 1)
			{
				free_IGFirm_agent(current_xmachine_IGFirm_holder, IGFirm_Start_IGFirm_Productivity_state);
			}
			else
			{
				transition_IGFirm_agent(current_xmachine_IGFirm_holder, IGFirm_Start_IGFirm_Productivity_state, IGFirm_01a_state);
			}
		}

		current_xmachine_IGFirm = NULL;

		current_xmachine_IGFirm_holder = temp_xmachine_IGFirm_holder;
	}
	if(FLAME_TEST_PRINT_START_AND_END_OF_MODEL_FUNCTIONS) printf("finish idle\n");


	if(FLAME_TEST_PRINT_START_AND_END_OF_MODEL_FUNCTIONS) printf("start IGFirm_initialize_variables\n");
	current_xmachine_IGFirm_holder = IGFirm_Start_IGFirm_Productivity_state->agents;
	while(current_xmachine_IGFirm_holder)
	{
		temp_xmachine_IGFirm_holder = current_xmachine_IGFirm_holder->next;
		current_xmachine_IGFirm = current_xmachine_IGFirm_holder->agent;
		current_xmachine_IGFirm_next_state = IGFirm_01a_state;
		/* For backwards compatibility set current_xmachine */
		current_xmachine->xmachine_Firm = NULL;
		current_xmachine->xmachine_Household = NULL;
		current_xmachine->xmachine_Mall = NULL;
		current_xmachine->xmachine_IGFirm = NULL;
		current_xmachine->xmachine_Eurostat = NULL;
		current_xmachine->xmachine_Bank = NULL;
		current_xmachine->xmachine_Government = NULL;
		current_xmachine->xmachine_CentralBank = NULL;
		current_xmachine->xmachine_ClearingHouse = NULL;
		current_xmachine->xmachine_IGFirm = current_xmachine_IGFirm;

		if(FLAME_condition_IGFirm_IGFirm_initialize_variables_Start_IGFirm_Productivity_01a(current_xmachine_IGFirm)==1)
		{

		

			i = IGFirm_initialize_variables();

		

			if(i == 1)
			{
				free_IGFirm_agent(current_xmachine_IGFirm_holder, IGFirm_Start_IGFirm_Productivity_state);
			}
			else
			{
				transition_IGFirm_agent(current_xmachine_IGFirm_holder, IGFirm_Start_IGFirm_Productivity_state, IGFirm_01a_state);
			}
		}

		current_xmachine_IGFirm = NULL;

		current_xmachine_IGFirm_holder = temp_xmachine_IGFirm_holder;
	}
	if(FLAME_TEST_PRINT_START_AND_END_OF_MODEL_FUNCTIONS) printf("finish IGFirm_initialize_variables\n");


	if(FLAME_TEST_PRINT_START_AND_END_OF_MODEL_FUNCTIONS) printf("start Firm_idle\n");
	current_xmachine_Firm_holder = Firm_Firm_Start_Market_Research_Role_state->agents;
	while(current_xmachine_Firm_holder)
	{
		temp_xmachine_Firm_holder = current_xmachine_Firm_holder->next;
		current_xmachine_Firm = current_xmachine_Firm_holder->agent;
		current_xmachine_Firm_next_state = Firm_MR_01_state;
		/* For backwards compatibility set current_xmachine */
		current_xmachine->xmachine_Firm = NULL;
		current_xmachine->xmachine_Household = NULL;
		current_xmachine->xmachine_Mall = NULL;
		current_xmachine->xmachine_IGFirm = NULL;
		current_xmachine->xmachine_Eurostat = NULL;
		current_xmachine->xmachine_Bank = NULL;
		current_xmachine->xmachine_Government = NULL;
		current_xmachine->xmachine_CentralBank = NULL;
		current_xmachine->xmachine_ClearingHouse = NULL;
		current_xmachine->xmachine_Firm = current_xmachine_Firm;

		if(FLAME_condition_Firm_Firm_idle_Firm_Start_Market_Research_Role_MR_01(current_xmachine_Firm)==1)
		{

		

			i = Firm_idle();

		

			if(i == 1)
			{
				free_Firm_agent(current_xmachine_Firm_holder, Firm_Firm_Start_Market_Research_Role_state);
			}
			else
			{
				transition_Firm_agent(current_xmachine_Firm_holder, Firm_Firm_Start_Market_Research_Role_state, Firm_MR_01_state);
			}
		}

		current_xmachine_Firm = NULL;

		current_xmachine_Firm_holder = temp_xmachine_Firm_holder;
	}
	if(FLAME_TEST_PRINT_START_AND_END_OF_MODEL_FUNCTIONS) printf("finish Firm_idle\n");


	if(FLAME_TEST_PRINT_START_AND_END_OF_MODEL_FUNCTIONS) printf("start Firm_idle\n");
	current_xmachine_Firm_holder = Firm_Firm_Start_Market_Research_Role_state->agents;
	while(current_xmachine_Firm_holder)
	{
		temp_xmachine_Firm_holder = current_xmachine_Firm_holder->next;
		current_xmachine_Firm = current_xmachine_Firm_holder->agent;
		current_xmachine_Firm_next_state = Firm_MR_3_state;
		/* For backwards compatibility set current_xmachine */
		current_xmachine->xmachine_Firm = NULL;
		current_xmachine->xmachine_Household = NULL;
		current_xmachine->xmachine_Mall = NULL;
		current_xmachine->xmachine_IGFirm = NULL;
		current_xmachine->xmachine_Eurostat = NULL;
		current_xmachine->xmachine_Bank = NULL;
		current_xmachine->xmachine_Government = NULL;
		current_xmachine->xmachine_CentralBank = NULL;
		current_xmachine->xmachine_ClearingHouse = NULL;
		current_xmachine->xmachine_Firm = current_xmachine_Firm;

		if(FLAME_condition_Firm_Firm_idle_Firm_Start_Market_Research_Role_MR_3(current_xmachine_Firm)==1)
		{

		

			i = Firm_idle();

		

			if(i == 1)
			{
				free_Firm_agent(current_xmachine_Firm_holder, Firm_Firm_Start_Market_Research_Role_state);
			}
			else
			{
				transition_Firm_agent(current_xmachine_Firm_holder, Firm_Firm_Start_Market_Research_Role_state, Firm_MR_3_state);
			}
		}

		current_xmachine_Firm = NULL;

		current_xmachine_Firm_holder = temp_xmachine_Firm_holder;
	}
	if(FLAME_TEST_PRINT_START_AND_END_OF_MODEL_FUNCTIONS) printf("finish Firm_idle\n");


/* End of layer number 14 */

/* Clear message boards that have finished being used
 * and sync complete if doing late sync complete */


	if(FLAME_TEST_PRINT_START_AND_END_OF_MODEL_FUNCTIONS) printf("start IGFirm_idle\n");
	current_xmachine_IGFirm_holder = IGFirm_01a_state->agents;
	while(current_xmachine_IGFirm_holder)
	{
		temp_xmachine_IGFirm_holder = current_xmachine_IGFirm_holder->next;
		current_xmachine_IGFirm = current_xmachine_IGFirm_holder->agent;
		current_xmachine_IGFirm_next_state = IGFirm_01_state;
		/* For backwards compatibility set current_xmachine */
		current_xmachine->xmachine_Firm = NULL;
		current_xmachine->xmachine_Household = NULL;
		current_xmachine->xmachine_Mall = NULL;
		current_xmachine->xmachine_IGFirm = NULL;
		current_xmachine->xmachine_Eurostat = NULL;
		current_xmachine->xmachine_Bank = NULL;
		current_xmachine->xmachine_Government = NULL;
		current_xmachine->xmachine_CentralBank = NULL;
		current_xmachine->xmachine_ClearingHouse = NULL;
		current_xmachine->xmachine_IGFirm = current_xmachine_IGFirm;

		if(FLAME_condition_IGFirm_IGFirm_idle_01a_01(current_xmachine_IGFirm)==1)
		{

		

			i = IGFirm_idle();

		

			if(i == 1)
			{
				free_IGFirm_agent(current_xmachine_IGFirm_holder, IGFirm_01a_state);
			}
			else
			{
				transition_IGFirm_agent(current_xmachine_IGFirm_holder, IGFirm_01a_state, IGFirm_01_state);
			}
		}

		current_xmachine_IGFirm = NULL;

		current_xmachine_IGFirm_holder = temp_xmachine_IGFirm_holder;
	}
	if(FLAME_TEST_PRINT_START_AND_END_OF_MODEL_FUNCTIONS) printf("finish IGFirm_idle\n");


	if(FLAME_TEST_PRINT_START_AND_END_OF_MODEL_FUNCTIONS) printf("start IGFirm_innovation_process\n");
	current_xmachine_IGFirm_holder = IGFirm_01a_state->agents;
	while(current_xmachine_IGFirm_holder)
	{
		temp_xmachine_IGFirm_holder = current_xmachine_IGFirm_holder->next;
		current_xmachine_IGFirm = current_xmachine_IGFirm_holder->agent;
		current_xmachine_IGFirm_next_state = IGFirm_01_state;
		/* For backwards compatibility set current_xmachine */
		current_xmachine->xmachine_Firm = NULL;
		current_xmachine->xmachine_Household = NULL;
		current_xmachine->xmachine_Mall = NULL;
		current_xmachine->xmachine_IGFirm = NULL;
		current_xmachine->xmachine_Eurostat = NULL;
		current_xmachine->xmachine_Bank = NULL;
		current_xmachine->xmachine_Government = NULL;
		current_xmachine->xmachine_CentralBank = NULL;
		current_xmachine->xmachine_ClearingHouse = NULL;
		current_xmachine->xmachine_IGFirm = current_xmachine_IGFirm;

		if(FLAME_condition_IGFirm_IGFirm_innovation_process_01a_01(current_xmachine_IGFirm)==1)
		{

		

			i = IGFirm_innovation_process();

		

			if(i == 1)
			{
				free_IGFirm_agent(current_xmachine_IGFirm_holder, IGFirm_01a_state);
			}
			else
			{
				transition_IGFirm_agent(current_xmachine_IGFirm_holder, IGFirm_01a_state, IGFirm_01_state);
			}
		}

		current_xmachine_IGFirm = NULL;

		current_xmachine_IGFirm_holder = temp_xmachine_IGFirm_holder;
	}
	if(FLAME_TEST_PRINT_START_AND_END_OF_MODEL_FUNCTIONS) printf("finish IGFirm_innovation_process\n");


	if(FLAME_TEST_PRINT_START_AND_END_OF_MODEL_FUNCTIONS) printf("start Firm_idle\n");
	current_xmachine_Firm_holder = Firm_MR_01_state->agents;
	while(current_xmachine_Firm_holder)
	{
		temp_xmachine_Firm_holder = current_xmachine_Firm_holder->next;
		current_xmachine_Firm = current_xmachine_Firm_holder->agent;
		current_xmachine_Firm_next_state = Firm_MR_02_state;
		/* For backwards compatibility set current_xmachine */
		current_xmachine->xmachine_Firm = NULL;
		current_xmachine->xmachine_Household = NULL;
		current_xmachine->xmachine_Mall = NULL;
		current_xmachine->xmachine_IGFirm = NULL;
		current_xmachine->xmachine_Eurostat = NULL;
		current_xmachine->xmachine_Bank = NULL;
		current_xmachine->xmachine_Government = NULL;
		current_xmachine->xmachine_CentralBank = NULL;
		current_xmachine->xmachine_ClearingHouse = NULL;
		current_xmachine->xmachine_Firm = current_xmachine_Firm;

		if(FLAME_condition_Firm_Firm_idle_MR_01_MR_02(current_xmachine_Firm)==1)
		{

		

			i = Firm_idle();

		

			if(i == 1)
			{
				free_Firm_agent(current_xmachine_Firm_holder, Firm_MR_01_state);
			}
			else
			{
				transition_Firm_agent(current_xmachine_Firm_holder, Firm_MR_01_state, Firm_MR_02_state);
			}
		}

		current_xmachine_Firm = NULL;

		current_xmachine_Firm_holder = temp_xmachine_Firm_holder;
	}
	if(FLAME_TEST_PRINT_START_AND_END_OF_MODEL_FUNCTIONS) printf("finish Firm_idle\n");


	if(FLAME_TEST_PRINT_START_AND_END_OF_MODEL_FUNCTIONS) printf("start Firm_release_new_product\n");
	current_xmachine_Firm_holder = Firm_MR_01_state->agents;
	while(current_xmachine_Firm_holder)
	{
		temp_xmachine_Firm_holder = current_xmachine_Firm_holder->next;
		current_xmachine_Firm = current_xmachine_Firm_holder->agent;
		current_xmachine_Firm_next_state = Firm_MR_02_state;
		/* For backwards compatibility set current_xmachine */
		current_xmachine->xmachine_Firm = NULL;
		current_xmachine->xmachine_Household = NULL;
		current_xmachine->xmachine_Mall = NULL;
		current_xmachine->xmachine_IGFirm = NULL;
		current_xmachine->xmachine_Eurostat = NULL;
		current_xmachine->xmachine_Bank = NULL;
		current_xmachine->xmachine_Government = NULL;
		current_xmachine->xmachine_CentralBank = NULL;
		current_xmachine->xmachine_ClearingHouse = NULL;
		current_xmachine->xmachine_Firm = current_xmachine_Firm;

		if(FLAME_condition_Firm_Firm_release_new_product_MR_01_MR_02(current_xmachine_Firm)==1)
		{

		

			i = Firm_release_new_product();

		

			if(i == 1)
			{
				free_Firm_agent(current_xmachine_Firm_holder, Firm_MR_01_state);
			}
			else
			{
				transition_Firm_agent(current_xmachine_Firm_holder, Firm_MR_01_state, Firm_MR_02_state);
			}
		}

		current_xmachine_Firm = NULL;

		current_xmachine_Firm_holder = temp_xmachine_Firm_holder;
	}
	if(FLAME_TEST_PRINT_START_AND_END_OF_MODEL_FUNCTIONS) printf("finish Firm_release_new_product\n");


	if(FLAME_TEST_PRINT_START_AND_END_OF_MODEL_FUNCTIONS) printf("start idle\n");
	current_xmachine_Firm_holder = Firm_Firm_bankruptcy_state_01_state->agents;
	while(current_xmachine_Firm_holder)
	{
		temp_xmachine_Firm_holder = current_xmachine_Firm_holder->next;
		current_xmachine_Firm = current_xmachine_Firm_holder->agent;
		current_xmachine_Firm_next_state = Firm_Firm_bankruptcy_state_1_state;
		/* For backwards compatibility set current_xmachine */
		current_xmachine->xmachine_Firm = NULL;
		current_xmachine->xmachine_Household = NULL;
		current_xmachine->xmachine_Mall = NULL;
		current_xmachine->xmachine_IGFirm = NULL;
		current_xmachine->xmachine_Eurostat = NULL;
		current_xmachine->xmachine_Bank = NULL;
		current_xmachine->xmachine_Government = NULL;
		current_xmachine->xmachine_CentralBank = NULL;
		current_xmachine->xmachine_ClearingHouse = NULL;
		current_xmachine->xmachine_Firm = current_xmachine_Firm;

		if(FLAME_condition_Firm_idle_Firm_bankruptcy_state_01_Firm_bankruptcy_state_1(current_xmachine_Firm)==1)
		{

		

			i = idle();

		

			if(i == 1)
			{
				free_Firm_agent(current_xmachine_Firm_holder, Firm_Firm_bankruptcy_state_01_state);
			}
			else
			{
				transition_Firm_agent(current_xmachine_Firm_holder, Firm_Firm_bankruptcy_state_01_state, Firm_Firm_bankruptcy_state_1_state);
			}
		}

		current_xmachine_Firm = NULL;

		current_xmachine_Firm_holder = temp_xmachine_Firm_holder;
	}
	if(FLAME_TEST_PRINT_START_AND_END_OF_MODEL_FUNCTIONS) printf("finish idle\n");


	if(FLAME_TEST_PRINT_START_AND_END_OF_MODEL_FUNCTIONS) printf("start Firm_bankruptcy_reset_delayed\n");
	current_xmachine_Firm_holder = Firm_Firm_bankruptcy_state_01_state->agents;
	while(current_xmachine_Firm_holder)
	{
		temp_xmachine_Firm_holder = current_xmachine_Firm_holder->next;
		current_xmachine_Firm = current_xmachine_Firm_holder->agent;
		current_xmachine_Firm_next_state = Firm_Firm_bankruptcy_state_1_state;
		/* For backwards compatibility set current_xmachine */
		current_xmachine->xmachine_Firm = NULL;
		current_xmachine->xmachine_Household = NULL;
		current_xmachine->xmachine_Mall = NULL;
		current_xmachine->xmachine_IGFirm = NULL;
		current_xmachine->xmachine_Eurostat = NULL;
		current_xmachine->xmachine_Bank = NULL;
		current_xmachine->xmachine_Government = NULL;
		current_xmachine->xmachine_CentralBank = NULL;
		current_xmachine->xmachine_ClearingHouse = NULL;
		current_xmachine->xmachine_Firm = current_xmachine_Firm;

		if(FLAME_condition_Firm_Firm_bankruptcy_reset_delayed_Firm_bankruptcy_state_01_Firm_bankruptcy_state_1(current_xmachine_Firm)==1)
		{

		

			i = Firm_bankruptcy_reset_delayed();

		

			if(i == 1)
			{
				free_Firm_agent(current_xmachine_Firm_holder, Firm_Firm_bankruptcy_state_01_state);
			}
			else
			{
				transition_Firm_agent(current_xmachine_Firm_holder, Firm_Firm_bankruptcy_state_01_state, Firm_Firm_bankruptcy_state_1_state);
			}
		}

		current_xmachine_Firm = NULL;

		current_xmachine_Firm_holder = temp_xmachine_Firm_holder;
	}
	if(FLAME_TEST_PRINT_START_AND_END_OF_MODEL_FUNCTIONS) printf("finish Firm_bankruptcy_reset_delayed\n");


/* End of layer number 15 */

/* Clear message boards that have finished being used
 * and sync complete if doing late sync complete */


	if(FLAME_TEST_PRINT_START_AND_END_OF_MODEL_FUNCTIONS) printf("start IGFirm_set_price_send_info\n");
	current_xmachine_IGFirm_holder = IGFirm_01_state->agents;
	while(current_xmachine_IGFirm_holder)
	{
		temp_xmachine_IGFirm_holder = current_xmachine_IGFirm_holder->next;
		current_xmachine_IGFirm = current_xmachine_IGFirm_holder->agent;
		current_xmachine_IGFirm_next_state = IGFirm_01kk_state;
		/* For backwards compatibility set current_xmachine */
		current_xmachine->xmachine_Firm = NULL;
		current_xmachine->xmachine_Household = NULL;
		current_xmachine->xmachine_Mall = NULL;
		current_xmachine->xmachine_IGFirm = NULL;
		current_xmachine->xmachine_Eurostat = NULL;
		current_xmachine->xmachine_Bank = NULL;
		current_xmachine->xmachine_Government = NULL;
		current_xmachine->xmachine_CentralBank = NULL;
		current_xmachine->xmachine_ClearingHouse = NULL;
		current_xmachine->xmachine_IGFirm = current_xmachine_IGFirm;

		

		

			i = IGFirm_set_price_send_info();

		

			if(i == 1)
			{
				free_IGFirm_agent(current_xmachine_IGFirm_holder, IGFirm_01_state);
			}
			else
			{
				transition_IGFirm_agent(current_xmachine_IGFirm_holder, IGFirm_01_state, IGFirm_01kk_state);
			}
		

		current_xmachine_IGFirm = NULL;

		current_xmachine_IGFirm_holder = temp_xmachine_IGFirm_holder;
	}
	if(FLAME_TEST_PRINT_START_AND_END_OF_MODEL_FUNCTIONS) printf("finish IGFirm_set_price_send_info\n");

	if(FLAME_productivity_message_board_write == 1)
	{

		if(FLAME_TEST_PRINT_START_AND_END_OF_LIBMBOARD_CALLS) printf("start MB_SyncStart(b_productivity)\n");
		rc = MB_SyncStart(b_productivity);
		if(FLAME_TEST_PRINT_START_AND_END_OF_LIBMBOARD_CALLS) printf("finish MB_SyncStart(b_productivity)\n");
		#ifdef ERRCHECK
		if (rc != MB_SUCCESS)
		{
		   fprintf(stderr, "ERROR: Could not start sync of 'productivity' board\n");
		   switch(rc) {
			   case MB_ERR_INVALID:
				   fprintf(stderr, "\t reason: 'productivity' board is invalid\n");
				   break;
			   case MB_ERR_LOCKED:
				   fprintf(stderr, "\t reason: 'productivity' board is locked\n");
				   break;
			   case MB_ERR_MEMALLOC:
				   fprintf(stderr, "\t reason: out of memory\n");
				   break;
			   case MB_ERR_INTERNAL:
				   fprintf(stderr, "\t reason: internal error. Recompile libmoard in debug mode for more info \n");
				   break;
			   default:
				   fprintf(stderr, "\t MB_SyncStart returned error code: %d (see libmboard docs for details)\n", rc);
				   break;
		   }

			
			exit(rc);
		}
		#endif
    }
    


	if(FLAME_TEST_PRINT_START_AND_END_OF_MODEL_FUNCTIONS) printf("start Firm_bypass_setting_if_delayed\n");
	current_xmachine_Firm_holder = Firm_MR_02_state->agents;
	while(current_xmachine_Firm_holder)
	{
		temp_xmachine_Firm_holder = current_xmachine_Firm_holder->next;
		current_xmachine_Firm = current_xmachine_Firm_holder->agent;
		current_xmachine_Firm_next_state = Firm_MR_0_state;
		/* For backwards compatibility set current_xmachine */
		current_xmachine->xmachine_Firm = NULL;
		current_xmachine->xmachine_Household = NULL;
		current_xmachine->xmachine_Mall = NULL;
		current_xmachine->xmachine_IGFirm = NULL;
		current_xmachine->xmachine_Eurostat = NULL;
		current_xmachine->xmachine_Bank = NULL;
		current_xmachine->xmachine_Government = NULL;
		current_xmachine->xmachine_CentralBank = NULL;
		current_xmachine->xmachine_ClearingHouse = NULL;
		current_xmachine->xmachine_Firm = current_xmachine_Firm;

		if(FLAME_condition_Firm_Firm_bypass_setting_if_delayed_MR_02_MR_0(current_xmachine_Firm)==1)
		{

		

			i = Firm_bypass_setting_if_delayed();

		

			if(i == 1)
			{
				free_Firm_agent(current_xmachine_Firm_holder, Firm_MR_02_state);
			}
			else
			{
				transition_Firm_agent(current_xmachine_Firm_holder, Firm_MR_02_state, Firm_MR_0_state);
			}
		}

		current_xmachine_Firm = NULL;

		current_xmachine_Firm_holder = temp_xmachine_Firm_holder;
	}
	if(FLAME_TEST_PRINT_START_AND_END_OF_MODEL_FUNCTIONS) printf("finish Firm_bypass_setting_if_delayed\n");


	if(FLAME_TEST_PRINT_START_AND_END_OF_MODEL_FUNCTIONS) printf("start Firm_set_market_research_data_pricing\n");
	current_xmachine_Firm_holder = Firm_MR_02_state->agents;
	while(current_xmachine_Firm_holder)
	{
		temp_xmachine_Firm_holder = current_xmachine_Firm_holder->next;
		current_xmachine_Firm = current_xmachine_Firm_holder->agent;
		current_xmachine_Firm_next_state = Firm_MR_03_state;
		/* For backwards compatibility set current_xmachine */
		current_xmachine->xmachine_Firm = NULL;
		current_xmachine->xmachine_Household = NULL;
		current_xmachine->xmachine_Mall = NULL;
		current_xmachine->xmachine_IGFirm = NULL;
		current_xmachine->xmachine_Eurostat = NULL;
		current_xmachine->xmachine_Bank = NULL;
		current_xmachine->xmachine_Government = NULL;
		current_xmachine->xmachine_CentralBank = NULL;
		current_xmachine->xmachine_ClearingHouse = NULL;
		current_xmachine->xmachine_Firm = current_xmachine_Firm;

		if(FLAME_condition_Firm_Firm_set_market_research_data_pricing_MR_02_MR_03(current_xmachine_Firm)==1)
		{

		

			i = Firm_set_market_research_data_pricing();

		

			if(i == 1)
			{
				free_Firm_agent(current_xmachine_Firm_holder, Firm_MR_02_state);
			}
			else
			{
				transition_Firm_agent(current_xmachine_Firm_holder, Firm_MR_02_state, Firm_MR_03_state);
			}
		}

		current_xmachine_Firm = NULL;

		current_xmachine_Firm_holder = temp_xmachine_Firm_holder;
	}
	if(FLAME_TEST_PRINT_START_AND_END_OF_MODEL_FUNCTIONS) printf("finish Firm_set_market_research_data_pricing\n");


	if(FLAME_TEST_PRINT_START_AND_END_OF_MODEL_FUNCTIONS) printf("start idle\n");
	current_xmachine_Firm_holder = Firm_Firm_bankruptcy_state_1_state->agents;
	while(current_xmachine_Firm_holder)
	{
		temp_xmachine_Firm_holder = current_xmachine_Firm_holder->next;
		current_xmachine_Firm = current_xmachine_Firm_holder->agent;
		current_xmachine_Firm_next_state = Firm_Firm_bankruptcy_state_4_state;
		/* For backwards compatibility set current_xmachine */
		current_xmachine->xmachine_Firm = NULL;
		current_xmachine->xmachine_Household = NULL;
		current_xmachine->xmachine_Mall = NULL;
		current_xmachine->xmachine_IGFirm = NULL;
		current_xmachine->xmachine_Eurostat = NULL;
		current_xmachine->xmachine_Bank = NULL;
		current_xmachine->xmachine_Government = NULL;
		current_xmachine->xmachine_CentralBank = NULL;
		current_xmachine->xmachine_ClearingHouse = NULL;
		current_xmachine->xmachine_Firm = current_xmachine_Firm;

		if(FLAME_condition_Firm_idle_Firm_bankruptcy_state_1_Firm_bankruptcy_state_4(current_xmachine_Firm)==1)
		{

		

			i = idle();

		

			if(i == 1)
			{
				free_Firm_agent(current_xmachine_Firm_holder, Firm_Firm_bankruptcy_state_1_state);
			}
			else
			{
				transition_Firm_agent(current_xmachine_Firm_holder, Firm_Firm_bankruptcy_state_1_state, Firm_Firm_bankruptcy_state_4_state);
			}
		}

		current_xmachine_Firm = NULL;

		current_xmachine_Firm_holder = temp_xmachine_Firm_holder;
	}
	if(FLAME_TEST_PRINT_START_AND_END_OF_MODEL_FUNCTIONS) printf("finish idle\n");


	if(FLAME_TEST_PRINT_START_AND_END_OF_MODEL_FUNCTIONS) printf("start Firm_remains_in_bankruptcy\n");
	current_xmachine_Firm_holder = Firm_Firm_bankruptcy_state_1_state->agents;
	while(current_xmachine_Firm_holder)
	{
		temp_xmachine_Firm_holder = current_xmachine_Firm_holder->next;
		current_xmachine_Firm = current_xmachine_Firm_holder->agent;
		current_xmachine_Firm_next_state = Firm_Firm_bankruptcy_state_4_state;
		/* For backwards compatibility set current_xmachine */
		current_xmachine->xmachine_Firm = NULL;
		current_xmachine->xmachine_Household = NULL;
		current_xmachine->xmachine_Mall = NULL;
		current_xmachine->xmachine_IGFirm = NULL;
		current_xmachine->xmachine_Eurostat = NULL;
		current_xmachine->xmachine_Bank = NULL;
		current_xmachine->xmachine_Government = NULL;
		current_xmachine->xmachine_CentralBank = NULL;
		current_xmachine->xmachine_ClearingHouse = NULL;
		current_xmachine->xmachine_Firm = current_xmachine_Firm;

		if(FLAME_condition_Firm_Firm_remains_in_bankruptcy_Firm_bankruptcy_state_1_Firm_bankruptcy_state_4(current_xmachine_Firm)==1)
		{

		

			i = Firm_remains_in_bankruptcy();

		

			if(i == 1)
			{
				free_Firm_agent(current_xmachine_Firm_holder, Firm_Firm_bankruptcy_state_1_state);
			}
			else
			{
				transition_Firm_agent(current_xmachine_Firm_holder, Firm_Firm_bankruptcy_state_1_state, Firm_Firm_bankruptcy_state_4_state);
			}
		}

		current_xmachine_Firm = NULL;

		current_xmachine_Firm_holder = temp_xmachine_Firm_holder;
	}
	if(FLAME_TEST_PRINT_START_AND_END_OF_MODEL_FUNCTIONS) printf("finish Firm_remains_in_bankruptcy\n");


/* End of layer number 16 */

/* Clear message boards that have finished being used
 * and sync complete if doing late sync complete */


	if(FLAME_TEST_PRINT_START_AND_END_OF_MODEL_FUNCTIONS) printf("start IGFirm_execute_financial_payments\n");
	current_xmachine_IGFirm_holder = IGFirm_01kk_state->agents;
	while(current_xmachine_IGFirm_holder)
	{
		temp_xmachine_IGFirm_holder = current_xmachine_IGFirm_holder->next;
		current_xmachine_IGFirm = current_xmachine_IGFirm_holder->agent;
		current_xmachine_IGFirm_next_state = IGFirm_IGFirm_End_Financial_Management_state;
		/* For backwards compatibility set current_xmachine */
		current_xmachine->xmachine_Firm = NULL;
		current_xmachine->xmachine_Household = NULL;
		current_xmachine->xmachine_Mall = NULL;
		current_xmachine->xmachine_IGFirm = NULL;
		current_xmachine->xmachine_Eurostat = NULL;
		current_xmachine->xmachine_Bank = NULL;
		current_xmachine->xmachine_Government = NULL;
		current_xmachine->xmachine_CentralBank = NULL;
		current_xmachine->xmachine_ClearingHouse = NULL;
		current_xmachine->xmachine_IGFirm = current_xmachine_IGFirm;

		if(FLAME_condition_IGFirm_IGFirm_execute_financial_payments_01kk_IGFirm_End_Financial_Management(current_xmachine_IGFirm)==1)
		{

		

			i = IGFirm_execute_financial_payments();

		

			if(i == 1)
			{
				free_IGFirm_agent(current_xmachine_IGFirm_holder, IGFirm_01kk_state);
			}
			else
			{
				transition_IGFirm_agent(current_xmachine_IGFirm_holder, IGFirm_01kk_state, IGFirm_IGFirm_End_Financial_Management_state);
			}
		}

		current_xmachine_IGFirm = NULL;

		current_xmachine_IGFirm_holder = temp_xmachine_IGFirm_holder;
	}
	if(FLAME_TEST_PRINT_START_AND_END_OF_MODEL_FUNCTIONS) printf("finish IGFirm_execute_financial_payments\n");


	if(FLAME_TEST_PRINT_START_AND_END_OF_MODEL_FUNCTIONS) printf("start IGFirm_idle\n");
	current_xmachine_IGFirm_holder = IGFirm_01kk_state->agents;
	while(current_xmachine_IGFirm_holder)
	{
		temp_xmachine_IGFirm_holder = current_xmachine_IGFirm_holder->next;
		current_xmachine_IGFirm = current_xmachine_IGFirm_holder->agent;
		current_xmachine_IGFirm_next_state = IGFirm_02_state;
		/* For backwards compatibility set current_xmachine */
		current_xmachine->xmachine_Firm = NULL;
		current_xmachine->xmachine_Household = NULL;
		current_xmachine->xmachine_Mall = NULL;
		current_xmachine->xmachine_IGFirm = NULL;
		current_xmachine->xmachine_Eurostat = NULL;
		current_xmachine->xmachine_Bank = NULL;
		current_xmachine->xmachine_Government = NULL;
		current_xmachine->xmachine_CentralBank = NULL;
		current_xmachine->xmachine_ClearingHouse = NULL;
		current_xmachine->xmachine_IGFirm = current_xmachine_IGFirm;

		if(FLAME_condition_IGFirm_IGFirm_idle_01kk_02(current_xmachine_IGFirm)==1)
		{

		

			i = IGFirm_idle();

		

			if(i == 1)
			{
				free_IGFirm_agent(current_xmachine_IGFirm_holder, IGFirm_01kk_state);
			}
			else
			{
				transition_IGFirm_agent(current_xmachine_IGFirm_holder, IGFirm_01kk_state, IGFirm_02_state);
			}
		}

		current_xmachine_IGFirm = NULL;

		current_xmachine_IGFirm_holder = temp_xmachine_IGFirm_holder;
	}
	if(FLAME_TEST_PRINT_START_AND_END_OF_MODEL_FUNCTIONS) printf("finish IGFirm_idle\n");


	if(FLAME_TEST_PRINT_START_AND_END_OF_MODEL_FUNCTIONS) printf("start Firm_idle\n");
	current_xmachine_Firm_holder = Firm_MR_03_state->agents;
	while(current_xmachine_Firm_holder)
	{
		temp_xmachine_Firm_holder = current_xmachine_Firm_holder->next;
		current_xmachine_Firm = current_xmachine_Firm_holder->agent;
		current_xmachine_Firm_next_state = Firm_MR_0_state;
		/* For backwards compatibility set current_xmachine */
		current_xmachine->xmachine_Firm = NULL;
		current_xmachine->xmachine_Household = NULL;
		current_xmachine->xmachine_Mall = NULL;
		current_xmachine->xmachine_IGFirm = NULL;
		current_xmachine->xmachine_Eurostat = NULL;
		current_xmachine->xmachine_Bank = NULL;
		current_xmachine->xmachine_Government = NULL;
		current_xmachine->xmachine_CentralBank = NULL;
		current_xmachine->xmachine_ClearingHouse = NULL;
		current_xmachine->xmachine_Firm = current_xmachine_Firm;

		if(FLAME_condition_Firm_Firm_idle_MR_03_MR_0(current_xmachine_Firm)==1)
		{

		

			i = Firm_idle();

		

			if(i == 1)
			{
				free_Firm_agent(current_xmachine_Firm_holder, Firm_MR_03_state);
			}
			else
			{
				transition_Firm_agent(current_xmachine_Firm_holder, Firm_MR_03_state, Firm_MR_0_state);
			}
		}

		current_xmachine_Firm = NULL;

		current_xmachine_Firm_holder = temp_xmachine_Firm_holder;
	}
	if(FLAME_TEST_PRINT_START_AND_END_OF_MODEL_FUNCTIONS) printf("finish Firm_idle\n");


	if(FLAME_TEST_PRINT_START_AND_END_OF_MODEL_FUNCTIONS) printf("start Firm_set_market_research_data_innovation\n");
	current_xmachine_Firm_holder = Firm_MR_03_state->agents;
	while(current_xmachine_Firm_holder)
	{
		temp_xmachine_Firm_holder = current_xmachine_Firm_holder->next;
		current_xmachine_Firm = current_xmachine_Firm_holder->agent;
		current_xmachine_Firm_next_state = Firm_MR_0_state;
		/* For backwards compatibility set current_xmachine */
		current_xmachine->xmachine_Firm = NULL;
		current_xmachine->xmachine_Household = NULL;
		current_xmachine->xmachine_Mall = NULL;
		current_xmachine->xmachine_IGFirm = NULL;
		current_xmachine->xmachine_Eurostat = NULL;
		current_xmachine->xmachine_Bank = NULL;
		current_xmachine->xmachine_Government = NULL;
		current_xmachine->xmachine_CentralBank = NULL;
		current_xmachine->xmachine_ClearingHouse = NULL;
		current_xmachine->xmachine_Firm = current_xmachine_Firm;

		if(FLAME_condition_Firm_Firm_set_market_research_data_innovation_MR_03_MR_0(current_xmachine_Firm)==1)
		{

		

			i = Firm_set_market_research_data_innovation();

		

			if(i == 1)
			{
				free_Firm_agent(current_xmachine_Firm_holder, Firm_MR_03_state);
			}
			else
			{
				transition_Firm_agent(current_xmachine_Firm_holder, Firm_MR_03_state, Firm_MR_0_state);
			}
		}

		current_xmachine_Firm = NULL;

		current_xmachine_Firm_holder = temp_xmachine_Firm_holder;
	}
	if(FLAME_TEST_PRINT_START_AND_END_OF_MODEL_FUNCTIONS) printf("finish Firm_set_market_research_data_innovation\n");


	if(FLAME_TEST_PRINT_START_AND_END_OF_MODEL_FUNCTIONS) printf("start idle\n");
	current_xmachine_Firm_holder = Firm_Firm_bankruptcy_state_4_state->agents;
	while(current_xmachine_Firm_holder)
	{
		temp_xmachine_Firm_holder = current_xmachine_Firm_holder->next;
		current_xmachine_Firm = current_xmachine_Firm_holder->agent;
		current_xmachine_Firm_next_state = Firm_Firm_End_Branches_state;
		/* For backwards compatibility set current_xmachine */
		current_xmachine->xmachine_Firm = NULL;
		current_xmachine->xmachine_Household = NULL;
		current_xmachine->xmachine_Mall = NULL;
		current_xmachine->xmachine_IGFirm = NULL;
		current_xmachine->xmachine_Eurostat = NULL;
		current_xmachine->xmachine_Bank = NULL;
		current_xmachine->xmachine_Government = NULL;
		current_xmachine->xmachine_CentralBank = NULL;
		current_xmachine->xmachine_ClearingHouse = NULL;
		current_xmachine->xmachine_Firm = current_xmachine_Firm;

		if(FLAME_condition_Firm_idle_Firm_bankruptcy_state_4_Firm_End_Branches(current_xmachine_Firm)==1)
		{

		

			i = idle();

		

			if(i == 1)
			{
				free_Firm_agent(current_xmachine_Firm_holder, Firm_Firm_bankruptcy_state_4_state);
			}
			else
			{
				transition_Firm_agent(current_xmachine_Firm_holder, Firm_Firm_bankruptcy_state_4_state, Firm_Firm_End_Branches_state);
			}
		}

		current_xmachine_Firm = NULL;

		current_xmachine_Firm_holder = temp_xmachine_Firm_holder;
	}
	if(FLAME_TEST_PRINT_START_AND_END_OF_MODEL_FUNCTIONS) printf("finish idle\n");


	if(FLAME_TEST_PRINT_START_AND_END_OF_MODEL_FUNCTIONS) printf("start Firm_reset_bankruptcy_flags\n");
	current_xmachine_Firm_holder = Firm_Firm_bankruptcy_state_4_state->agents;
	while(current_xmachine_Firm_holder)
	{
		temp_xmachine_Firm_holder = current_xmachine_Firm_holder->next;
		current_xmachine_Firm = current_xmachine_Firm_holder->agent;
		current_xmachine_Firm_next_state = Firm_Firm_Start_Financial_Management_Role_state;
		/* For backwards compatibility set current_xmachine */
		current_xmachine->xmachine_Firm = NULL;
		current_xmachine->xmachine_Household = NULL;
		current_xmachine->xmachine_Mall = NULL;
		current_xmachine->xmachine_IGFirm = NULL;
		current_xmachine->xmachine_Eurostat = NULL;
		current_xmachine->xmachine_Bank = NULL;
		current_xmachine->xmachine_Government = NULL;
		current_xmachine->xmachine_CentralBank = NULL;
		current_xmachine->xmachine_ClearingHouse = NULL;
		current_xmachine->xmachine_Firm = current_xmachine_Firm;

		if(FLAME_condition_Firm_Firm_reset_bankruptcy_flags_Firm_bankruptcy_state_4_Firm_Start_Financial_Management_Role(current_xmachine_Firm)==1)
		{

		

			i = Firm_reset_bankruptcy_flags();

		

			if(i == 1)
			{
				free_Firm_agent(current_xmachine_Firm_holder, Firm_Firm_bankruptcy_state_4_state);
			}
			else
			{
				transition_Firm_agent(current_xmachine_Firm_holder, Firm_Firm_bankruptcy_state_4_state, Firm_Firm_Start_Financial_Management_Role_state);
			}
		}

		current_xmachine_Firm = NULL;

		current_xmachine_Firm_holder = temp_xmachine_Firm_holder;
	}
	if(FLAME_TEST_PRINT_START_AND_END_OF_MODEL_FUNCTIONS) printf("finish Firm_reset_bankruptcy_flags\n");


/* End of layer number 17 */

/* Clear message boards that have finished being used
 * and sync complete if doing late sync complete */


	if(FLAME_TEST_PRINT_START_AND_END_OF_MODEL_FUNCTIONS) printf("start Firm_draw_sample\n");
	current_xmachine_Firm_holder = Firm_MR_0_state->agents;
	while(current_xmachine_Firm_holder)
	{
		temp_xmachine_Firm_holder = current_xmachine_Firm_holder->next;
		current_xmachine_Firm = current_xmachine_Firm_holder->agent;
		current_xmachine_Firm_next_state = Firm_MR_1_state;
		/* For backwards compatibility set current_xmachine */
		current_xmachine->xmachine_Firm = NULL;
		current_xmachine->xmachine_Household = NULL;
		current_xmachine->xmachine_Mall = NULL;
		current_xmachine->xmachine_IGFirm = NULL;
		current_xmachine->xmachine_Eurostat = NULL;
		current_xmachine->xmachine_Bank = NULL;
		current_xmachine->xmachine_Government = NULL;
		current_xmachine->xmachine_CentralBank = NULL;
		current_xmachine->xmachine_ClearingHouse = NULL;
		current_xmachine->xmachine_Firm = current_xmachine_Firm;

		

		

			i = Firm_draw_sample();

		

			if(i == 1)
			{
				free_Firm_agent(current_xmachine_Firm_holder, Firm_MR_0_state);
			}
			else
			{
				transition_Firm_agent(current_xmachine_Firm_holder, Firm_MR_0_state, Firm_MR_1_state);
			}
		

		current_xmachine_Firm = NULL;

		current_xmachine_Firm_holder = temp_xmachine_Firm_holder;
	}
	if(FLAME_TEST_PRINT_START_AND_END_OF_MODEL_FUNCTIONS) printf("finish Firm_draw_sample\n");

	if(FLAME_interview_request_message_board_write == 1)
	{

		if(FLAME_TEST_PRINT_START_AND_END_OF_LIBMBOARD_CALLS) printf("start MB_SyncStart(b_interview_request)\n");
		rc = MB_SyncStart(b_interview_request);
		if(FLAME_TEST_PRINT_START_AND_END_OF_LIBMBOARD_CALLS) printf("finish MB_SyncStart(b_interview_request)\n");
		#ifdef ERRCHECK
		if (rc != MB_SUCCESS)
		{
		   fprintf(stderr, "ERROR: Could not start sync of 'interview_request' board\n");
		   switch(rc) {
			   case MB_ERR_INVALID:
				   fprintf(stderr, "\t reason: 'interview_request' board is invalid\n");
				   break;
			   case MB_ERR_LOCKED:
				   fprintf(stderr, "\t reason: 'interview_request' board is locked\n");
				   break;
			   case MB_ERR_MEMALLOC:
				   fprintf(stderr, "\t reason: out of memory\n");
				   break;
			   case MB_ERR_INTERNAL:
				   fprintf(stderr, "\t reason: internal error. Recompile libmoard in debug mode for more info \n");
				   break;
			   default:
				   fprintf(stderr, "\t MB_SyncStart returned error code: %d (see libmboard docs for details)\n", rc);
				   break;
		   }

			
			exit(rc);
		}
		#endif
    }
    


	if(FLAME_TEST_PRINT_START_AND_END_OF_MODEL_FUNCTIONS) printf("start IGFirm_idle\n");
	current_xmachine_IGFirm_holder = IGFirm_IGFirm_End_Financial_Management_state->agents;
	while(current_xmachine_IGFirm_holder)
	{
		temp_xmachine_IGFirm_holder = current_xmachine_IGFirm_holder->next;
		current_xmachine_IGFirm = current_xmachine_IGFirm_holder->agent;
		current_xmachine_IGFirm_next_state = IGFirm_02_state;
		/* For backwards compatibility set current_xmachine */
		current_xmachine->xmachine_Firm = NULL;
		current_xmachine->xmachine_Household = NULL;
		current_xmachine->xmachine_Mall = NULL;
		current_xmachine->xmachine_IGFirm = NULL;
		current_xmachine->xmachine_Eurostat = NULL;
		current_xmachine->xmachine_Bank = NULL;
		current_xmachine->xmachine_Government = NULL;
		current_xmachine->xmachine_CentralBank = NULL;
		current_xmachine->xmachine_ClearingHouse = NULL;
		current_xmachine->xmachine_IGFirm = current_xmachine_IGFirm;

		

		

			i = IGFirm_idle();

		

			if(i == 1)
			{
				free_IGFirm_agent(current_xmachine_IGFirm_holder, IGFirm_IGFirm_End_Financial_Management_state);
			}
			else
			{
				transition_IGFirm_agent(current_xmachine_IGFirm_holder, IGFirm_IGFirm_End_Financial_Management_state, IGFirm_02_state);
			}
		

		current_xmachine_IGFirm = NULL;

		current_xmachine_IGFirm_holder = temp_xmachine_IGFirm_holder;
	}
	if(FLAME_TEST_PRINT_START_AND_END_OF_MODEL_FUNCTIONS) printf("finish IGFirm_idle\n");


/* End of layer number 18 */

/* Clear message boards that have finished being used
 * and sync complete if doing late sync complete */


	/* If mb is not read then leave sync complete until last possible moment */
	if(FLAME_interview_request_message_board_read == 1)
	{
		if(FLAME_TEST_PRINT_START_AND_END_OF_LIBMBOARD_CALLS) printf("start MB_SyncComplete(b_interview_request)\n");
		rc = MB_SyncComplete(b_interview_request);
		if(FLAME_TEST_PRINT_START_AND_END_OF_LIBMBOARD_CALLS) printf("finsh MB_SyncComplete(b_interview_request)\n");
		#ifdef ERRCHECK
		if (rc != MB_SUCCESS)
		{
		   fprintf(stderr, "ERROR: Could not complete sync of 'interview_request' board\n");
		   switch(rc) {
				case MB_ERR_INVALID:
				   fprintf(stderr, "\t reason: 'interview_request' board is invalid\n");
				   break;
			   case MB_ERR_MEMALLOC:
				   fprintf(stderr, "\t reason: out of memory\n");
				   break;
			   case MB_ERR_INTERNAL:
				   fprintf(stderr, "\t reason: internal error. Recompile libmoard in debug mode for more info \n");
				   break;
			   default:
				   fprintf(stderr, "\t MB_SyncComplete returned error code: %d (see libmboard docs for details)\n", rc);
				   break;
		   }
	
		   
		   exit(rc);
		}
		#endif
    
	}
	
	if(FLAME_TEST_PRINT_START_AND_END_OF_MODEL_FUNCTIONS) printf("start Household_respond\n");
	current_xmachine_Household_holder = Household_HH_MR_1_state->agents;
	while(current_xmachine_Household_holder)
	{
		temp_xmachine_Household_holder = current_xmachine_Household_holder->next;
		current_xmachine_Household = current_xmachine_Household_holder->agent;
		current_xmachine_Household_next_state = Household_HH_MR_2_state;
		/* For backwards compatibility set current_xmachine */
		current_xmachine->xmachine_Firm = NULL;
		current_xmachine->xmachine_Household = NULL;
		current_xmachine->xmachine_Mall = NULL;
		current_xmachine->xmachine_IGFirm = NULL;
		current_xmachine->xmachine_Eurostat = NULL;
		current_xmachine->xmachine_Bank = NULL;
		current_xmachine->xmachine_Government = NULL;
		current_xmachine->xmachine_CentralBank = NULL;
		current_xmachine->xmachine_ClearingHouse = NULL;
		current_xmachine->xmachine_Household = current_xmachine_Household;

		if(FLAME_condition_Household_Household_respond_HH_MR_1_HH_MR_2(current_xmachine_Household)==1)
		{

		
		rc = MB_Iterator_CreateFiltered(b_interview_request, &i_interview_request, &FLAME_filter_Household_Household_respond_HH_MR_1_HH_MR_2_interview_request, current_xmachine_Household);
		
		#ifdef ERRCHECK
		if (rc != MB_SUCCESS)
		{
		   fprintf(stderr, "ERROR: Could not create Iterator for 'interview_request'\n");
		   switch(rc) {
		       case MB_ERR_INVALID:
		           fprintf(stderr, "\t reason: 'interview_request' board is invalid\n");
		           break;
		       case MB_ERR_LOCKED:
	               fprintf(stderr, "\t reason: 'interview_request' board is locked\n");
	               break;
	           case MB_ERR_MEMALLOC:
	               fprintf(stderr, "\t reason: out of memory\n");
	               break;
	           case MB_ERR_INTERNAL:
	               fprintf(stderr, "\t reason: internal error. Recompile libmoard in debug mode for more info \n");
	               break;
	           default:
	           
                   fprintf(stderr, "\t MB_Iterator_CreateFiltered returned error code: %d (see libmboard docs for details)\n", rc);
               
               
                   break;
		   }

		   
           exit(rc);
		}
		#endif
		MB_Iterator_Randomise(i_interview_request);
		

			i = Household_respond();

		
		    rc = MB_Iterator_Delete(&i_interview_request);
		    #ifdef ERRCHECK
		    if (rc != MB_SUCCESS)
		    {
		       fprintf(stderr, "ERROR: Could not delete 'interview_request' iterator\n");
		       switch(rc) {
		           case MB_ERR_INVALID:
		               fprintf(stderr, "\t reason: 'interview_request' iterator is invalid\n");
		               break;
		           case MB_ERR_INTERNAL:
		               fprintf(stderr, "\t reason: internal error. Recompile libmoard in debug mode for more info \n");
		               break;
		           default:
                       fprintf(stderr, "\t MB_Iterator_Delete returned error code: %d (see libmboard docs for details)\n", rc);
                       break;
		       }

		       
               exit(rc);
		    }
		    #endif
		

			if(i == 1)
			{
				free_Household_agent(current_xmachine_Household_holder, Household_HH_MR_1_state);
			}
			else
			{
				transition_Household_agent(current_xmachine_Household_holder, Household_HH_MR_1_state, Household_HH_MR_2_state);
			}
		}

		current_xmachine_Household = NULL;

		current_xmachine_Household_holder = temp_xmachine_Household_holder;
	}
	if(FLAME_TEST_PRINT_START_AND_END_OF_MODEL_FUNCTIONS) printf("finish Household_respond\n");

	if(FLAME_interview_positive_response_message_board_write == 1)
	{

		if(FLAME_TEST_PRINT_START_AND_END_OF_LIBMBOARD_CALLS) printf("start MB_SyncStart(b_interview_positive_response)\n");
		rc = MB_SyncStart(b_interview_positive_response);
		if(FLAME_TEST_PRINT_START_AND_END_OF_LIBMBOARD_CALLS) printf("finish MB_SyncStart(b_interview_positive_response)\n");
		#ifdef ERRCHECK
		if (rc != MB_SUCCESS)
		{
		   fprintf(stderr, "ERROR: Could not start sync of 'interview_positive_response' board\n");
		   switch(rc) {
			   case MB_ERR_INVALID:
				   fprintf(stderr, "\t reason: 'interview_positive_response' board is invalid\n");
				   break;
			   case MB_ERR_LOCKED:
				   fprintf(stderr, "\t reason: 'interview_positive_response' board is locked\n");
				   break;
			   case MB_ERR_MEMALLOC:
				   fprintf(stderr, "\t reason: out of memory\n");
				   break;
			   case MB_ERR_INTERNAL:
				   fprintf(stderr, "\t reason: internal error. Recompile libmoard in debug mode for more info \n");
				   break;
			   default:
				   fprintf(stderr, "\t MB_SyncStart returned error code: %d (see libmboard docs for details)\n", rc);
				   break;
		   }

			
			exit(rc);
		}
		#endif
    }
    


/* End of layer number 19 */

/* Clear message boards that have finished being used
 * and sync complete if doing late sync complete */

if(FLAME_interview_request_message_board_read == 0)
{
	/*printf("%d> interview_request message board sync complete late as no agents reading any messages of this type\n", node_number);*/
	
	if(FLAME_TEST_PRINT_START_AND_END_OF_LIBMBOARD_CALLS) printf("start MB_SyncComplete(b_interview_request)\n");
	rc = MB_SyncComplete(b_interview_request);
	if(FLAME_TEST_PRINT_START_AND_END_OF_LIBMBOARD_CALLS) printf("finsh MB_SyncComplete(b_interview_request)\n");
	#ifdef ERRCHECK
	if (rc != MB_SUCCESS)
	{
	   fprintf(stderr, "ERROR: Could not complete sync of 'interview_request' board\n");
	   switch(rc) {
			case MB_ERR_INVALID:
			   fprintf(stderr, "\t reason: 'interview_request' board is invalid\n");
			   break;
		   case MB_ERR_MEMALLOC:
			   fprintf(stderr, "\t reason: out of memory\n");
			   break;
		   case MB_ERR_INTERNAL:
			   fprintf(stderr, "\t reason: internal error. Recompile libmoard in debug mode for more info \n");
			   break;
		   default:
			   fprintf(stderr, "\t MB_SyncComplete returned error code: %d (see libmboard docs for details)\n", rc);
			   break;
	   }

	   
	   exit(rc);
	}
	#endif
}

    rc = MB_Clear(b_interview_request);
    #ifdef ERRCHECK
    if (rc != MB_SUCCESS)
    {
       fprintf(stderr, "ERROR: Could not clear 'interview_request' board\n");
       switch(rc) {
           case MB_ERR_INVALID:
               fprintf(stderr, "\t reason: 'interview_request' board is invalid\n");
               break;
           case MB_ERR_LOCKED:
               fprintf(stderr, "\t reason: 'interview_request' board is locked\n");
               break;
           case MB_ERR_INTERNAL:
               fprintf(stderr, "\t reason: internal error. Recompile libmoard in debug mode for more info \n");
               break;
           default:
               fprintf(stderr, "\t MB_Clear returned error code: %d (see libmboard docs for details)\n", rc);
               break;

       }

       
       exit(rc);
    }
    #endif


	/* If mb is not read then leave sync complete until last possible moment */
	if(FLAME_interview_positive_response_message_board_read == 1)
	{
		if(FLAME_TEST_PRINT_START_AND_END_OF_LIBMBOARD_CALLS) printf("start MB_SyncComplete(b_interview_positive_response)\n");
		rc = MB_SyncComplete(b_interview_positive_response);
		if(FLAME_TEST_PRINT_START_AND_END_OF_LIBMBOARD_CALLS) printf("finsh MB_SyncComplete(b_interview_positive_response)\n");
		#ifdef ERRCHECK
		if (rc != MB_SUCCESS)
		{
		   fprintf(stderr, "ERROR: Could not complete sync of 'interview_positive_response' board\n");
		   switch(rc) {
				case MB_ERR_INVALID:
				   fprintf(stderr, "\t reason: 'interview_positive_response' board is invalid\n");
				   break;
			   case MB_ERR_MEMALLOC:
				   fprintf(stderr, "\t reason: out of memory\n");
				   break;
			   case MB_ERR_INTERNAL:
				   fprintf(stderr, "\t reason: internal error. Recompile libmoard in debug mode for more info \n");
				   break;
			   default:
				   fprintf(stderr, "\t MB_SyncComplete returned error code: %d (see libmboard docs for details)\n", rc);
				   break;
		   }
	
		   
		   exit(rc);
		}
		#endif
    
	}
	
	if(FLAME_TEST_PRINT_START_AND_END_OF_MODEL_FUNCTIONS) printf("start Firm_send_questionnaire\n");
	current_xmachine_Firm_holder = Firm_MR_1_state->agents;
	while(current_xmachine_Firm_holder)
	{
		temp_xmachine_Firm_holder = current_xmachine_Firm_holder->next;
		current_xmachine_Firm = current_xmachine_Firm_holder->agent;
		current_xmachine_Firm_next_state = Firm_MR_2_state;
		/* For backwards compatibility set current_xmachine */
		current_xmachine->xmachine_Firm = NULL;
		current_xmachine->xmachine_Household = NULL;
		current_xmachine->xmachine_Mall = NULL;
		current_xmachine->xmachine_IGFirm = NULL;
		current_xmachine->xmachine_Eurostat = NULL;
		current_xmachine->xmachine_Bank = NULL;
		current_xmachine->xmachine_Government = NULL;
		current_xmachine->xmachine_CentralBank = NULL;
		current_xmachine->xmachine_ClearingHouse = NULL;
		current_xmachine->xmachine_Firm = current_xmachine_Firm;

		

		
		rc = MB_Iterator_CreateFiltered(b_interview_positive_response, &i_interview_positive_response, &FLAME_filter_Firm_Firm_send_questionnaire_MR_1_MR_2_interview_positive_response, current_xmachine_Firm);
		
		#ifdef ERRCHECK
		if (rc != MB_SUCCESS)
		{
		   fprintf(stderr, "ERROR: Could not create Iterator for 'interview_positive_response'\n");
		   switch(rc) {
		       case MB_ERR_INVALID:
		           fprintf(stderr, "\t reason: 'interview_positive_response' board is invalid\n");
		           break;
		       case MB_ERR_LOCKED:
	               fprintf(stderr, "\t reason: 'interview_positive_response' board is locked\n");
	               break;
	           case MB_ERR_MEMALLOC:
	               fprintf(stderr, "\t reason: out of memory\n");
	               break;
	           case MB_ERR_INTERNAL:
	               fprintf(stderr, "\t reason: internal error. Recompile libmoard in debug mode for more info \n");
	               break;
	           default:
	           
                   fprintf(stderr, "\t MB_Iterator_CreateFiltered returned error code: %d (see libmboard docs for details)\n", rc);
               
               
                   break;
		   }

		   
           exit(rc);
		}
		#endif
		
		

			i = Firm_send_questionnaire();

		
		    rc = MB_Iterator_Delete(&i_interview_positive_response);
		    #ifdef ERRCHECK
		    if (rc != MB_SUCCESS)
		    {
		       fprintf(stderr, "ERROR: Could not delete 'interview_positive_response' iterator\n");
		       switch(rc) {
		           case MB_ERR_INVALID:
		               fprintf(stderr, "\t reason: 'interview_positive_response' iterator is invalid\n");
		               break;
		           case MB_ERR_INTERNAL:
		               fprintf(stderr, "\t reason: internal error. Recompile libmoard in debug mode for more info \n");
		               break;
		           default:
                       fprintf(stderr, "\t MB_Iterator_Delete returned error code: %d (see libmboard docs for details)\n", rc);
                       break;
		       }

		       
               exit(rc);
		    }
		    #endif
		

			if(i == 1)
			{
				free_Firm_agent(current_xmachine_Firm_holder, Firm_MR_1_state);
			}
			else
			{
				transition_Firm_agent(current_xmachine_Firm_holder, Firm_MR_1_state, Firm_MR_2_state);
			}
		

		current_xmachine_Firm = NULL;

		current_xmachine_Firm_holder = temp_xmachine_Firm_holder;
	}
	if(FLAME_TEST_PRINT_START_AND_END_OF_MODEL_FUNCTIONS) printf("finish Firm_send_questionnaire\n");

	if(FLAME_questionnaire_innovation_message_board_write == 1)
	{

		if(FLAME_TEST_PRINT_START_AND_END_OF_LIBMBOARD_CALLS) printf("start MB_SyncStart(b_questionnaire_innovation)\n");
		rc = MB_SyncStart(b_questionnaire_innovation);
		if(FLAME_TEST_PRINT_START_AND_END_OF_LIBMBOARD_CALLS) printf("finish MB_SyncStart(b_questionnaire_innovation)\n");
		#ifdef ERRCHECK
		if (rc != MB_SUCCESS)
		{
		   fprintf(stderr, "ERROR: Could not start sync of 'questionnaire_innovation' board\n");
		   switch(rc) {
			   case MB_ERR_INVALID:
				   fprintf(stderr, "\t reason: 'questionnaire_innovation' board is invalid\n");
				   break;
			   case MB_ERR_LOCKED:
				   fprintf(stderr, "\t reason: 'questionnaire_innovation' board is locked\n");
				   break;
			   case MB_ERR_MEMALLOC:
				   fprintf(stderr, "\t reason: out of memory\n");
				   break;
			   case MB_ERR_INTERNAL:
				   fprintf(stderr, "\t reason: internal error. Recompile libmoard in debug mode for more info \n");
				   break;
			   default:
				   fprintf(stderr, "\t MB_SyncStart returned error code: %d (see libmboard docs for details)\n", rc);
				   break;
		   }

			
			exit(rc);
		}
		#endif
    }
    


/* End of layer number 20 */

/* Clear message boards that have finished being used
 * and sync complete if doing late sync complete */

if(FLAME_interview_positive_response_message_board_read == 0)
{
	/*printf("%d> interview_positive_response message board sync complete late as no agents reading any messages of this type\n", node_number);*/
	
	if(FLAME_TEST_PRINT_START_AND_END_OF_LIBMBOARD_CALLS) printf("start MB_SyncComplete(b_interview_positive_response)\n");
	rc = MB_SyncComplete(b_interview_positive_response);
	if(FLAME_TEST_PRINT_START_AND_END_OF_LIBMBOARD_CALLS) printf("finsh MB_SyncComplete(b_interview_positive_response)\n");
	#ifdef ERRCHECK
	if (rc != MB_SUCCESS)
	{
	   fprintf(stderr, "ERROR: Could not complete sync of 'interview_positive_response' board\n");
	   switch(rc) {
			case MB_ERR_INVALID:
			   fprintf(stderr, "\t reason: 'interview_positive_response' board is invalid\n");
			   break;
		   case MB_ERR_MEMALLOC:
			   fprintf(stderr, "\t reason: out of memory\n");
			   break;
		   case MB_ERR_INTERNAL:
			   fprintf(stderr, "\t reason: internal error. Recompile libmoard in debug mode for more info \n");
			   break;
		   default:
			   fprintf(stderr, "\t MB_SyncComplete returned error code: %d (see libmboard docs for details)\n", rc);
			   break;
	   }

	   
	   exit(rc);
	}
	#endif
}

    rc = MB_Clear(b_interview_positive_response);
    #ifdef ERRCHECK
    if (rc != MB_SUCCESS)
    {
       fprintf(stderr, "ERROR: Could not clear 'interview_positive_response' board\n");
       switch(rc) {
           case MB_ERR_INVALID:
               fprintf(stderr, "\t reason: 'interview_positive_response' board is invalid\n");
               break;
           case MB_ERR_LOCKED:
               fprintf(stderr, "\t reason: 'interview_positive_response' board is locked\n");
               break;
           case MB_ERR_INTERNAL:
               fprintf(stderr, "\t reason: internal error. Recompile libmoard in debug mode for more info \n");
               break;
           default:
               fprintf(stderr, "\t MB_Clear returned error code: %d (see libmboard docs for details)\n", rc);
               break;

       }

       
       exit(rc);
    }
    #endif


	/* If mb is not read then leave sync complete until last possible moment */
	if(FLAME_questionnaire_innovation_message_board_read == 1)
	{
		if(FLAME_TEST_PRINT_START_AND_END_OF_LIBMBOARD_CALLS) printf("start MB_SyncComplete(b_questionnaire_innovation)\n");
		rc = MB_SyncComplete(b_questionnaire_innovation);
		if(FLAME_TEST_PRINT_START_AND_END_OF_LIBMBOARD_CALLS) printf("finsh MB_SyncComplete(b_questionnaire_innovation)\n");
		#ifdef ERRCHECK
		if (rc != MB_SUCCESS)
		{
		   fprintf(stderr, "ERROR: Could not complete sync of 'questionnaire_innovation' board\n");
		   switch(rc) {
				case MB_ERR_INVALID:
				   fprintf(stderr, "\t reason: 'questionnaire_innovation' board is invalid\n");
				   break;
			   case MB_ERR_MEMALLOC:
				   fprintf(stderr, "\t reason: out of memory\n");
				   break;
			   case MB_ERR_INTERNAL:
				   fprintf(stderr, "\t reason: internal error. Recompile libmoard in debug mode for more info \n");
				   break;
			   default:
				   fprintf(stderr, "\t MB_SyncComplete returned error code: %d (see libmboard docs for details)\n", rc);
				   break;
		   }
	
		   
		   exit(rc);
		}
		#endif
    
	}
	
	if(FLAME_TEST_PRINT_START_AND_END_OF_MODEL_FUNCTIONS) printf("start Household_respond_questionnaire\n");
	current_xmachine_Household_holder = Household_HH_MR_2_state->agents;
	while(current_xmachine_Household_holder)
	{
		temp_xmachine_Household_holder = current_xmachine_Household_holder->next;
		current_xmachine_Household = current_xmachine_Household_holder->agent;
		current_xmachine_Household_next_state = Household_Household_Start_Financial_Market_Role_state;
		/* For backwards compatibility set current_xmachine */
		current_xmachine->xmachine_Firm = NULL;
		current_xmachine->xmachine_Household = NULL;
		current_xmachine->xmachine_Mall = NULL;
		current_xmachine->xmachine_IGFirm = NULL;
		current_xmachine->xmachine_Eurostat = NULL;
		current_xmachine->xmachine_Bank = NULL;
		current_xmachine->xmachine_Government = NULL;
		current_xmachine->xmachine_CentralBank = NULL;
		current_xmachine->xmachine_ClearingHouse = NULL;
		current_xmachine->xmachine_Household = current_xmachine_Household;

		

		
		rc = MB_Iterator_CreateFiltered(b_questionnaire_innovation, &i_questionnaire_innovation, &FLAME_filter_Household_Household_respond_questionnaire_HH_MR_2_Household_Start_Financial_Market_Role_questionnaire_innovation, current_xmachine_Household);
		
		#ifdef ERRCHECK
		if (rc != MB_SUCCESS)
		{
		   fprintf(stderr, "ERROR: Could not create Iterator for 'questionnaire_innovation'\n");
		   switch(rc) {
		       case MB_ERR_INVALID:
		           fprintf(stderr, "\t reason: 'questionnaire_innovation' board is invalid\n");
		           break;
		       case MB_ERR_LOCKED:
	               fprintf(stderr, "\t reason: 'questionnaire_innovation' board is locked\n");
	               break;
	           case MB_ERR_MEMALLOC:
	               fprintf(stderr, "\t reason: out of memory\n");
	               break;
	           case MB_ERR_INTERNAL:
	               fprintf(stderr, "\t reason: internal error. Recompile libmoard in debug mode for more info \n");
	               break;
	           default:
	           
                   fprintf(stderr, "\t MB_Iterator_CreateFiltered returned error code: %d (see libmboard docs for details)\n", rc);
               
               
                   break;
		   }

		   
           exit(rc);
		}
		#endif
		
		

			i = Household_respond_questionnaire();

		
		    rc = MB_Iterator_Delete(&i_questionnaire_innovation);
		    #ifdef ERRCHECK
		    if (rc != MB_SUCCESS)
		    {
		       fprintf(stderr, "ERROR: Could not delete 'questionnaire_innovation' iterator\n");
		       switch(rc) {
		           case MB_ERR_INVALID:
		               fprintf(stderr, "\t reason: 'questionnaire_innovation' iterator is invalid\n");
		               break;
		           case MB_ERR_INTERNAL:
		               fprintf(stderr, "\t reason: internal error. Recompile libmoard in debug mode for more info \n");
		               break;
		           default:
                       fprintf(stderr, "\t MB_Iterator_Delete returned error code: %d (see libmboard docs for details)\n", rc);
                       break;
		       }

		       
               exit(rc);
		    }
		    #endif
		

			if(i == 1)
			{
				free_Household_agent(current_xmachine_Household_holder, Household_HH_MR_2_state);
			}
			else
			{
				transition_Household_agent(current_xmachine_Household_holder, Household_HH_MR_2_state, Household_Household_Start_Financial_Market_Role_state);
			}
		

		current_xmachine_Household = NULL;

		current_xmachine_Household_holder = temp_xmachine_Household_holder;
	}
	if(FLAME_TEST_PRINT_START_AND_END_OF_MODEL_FUNCTIONS) printf("finish Household_respond_questionnaire\n");

	if(FLAME_filled_out_questionnaire_product_innovation_message_board_write == 1)
	{

		if(FLAME_TEST_PRINT_START_AND_END_OF_LIBMBOARD_CALLS) printf("start MB_SyncStart(b_filled_out_questionnaire_product_innovation)\n");
		rc = MB_SyncStart(b_filled_out_questionnaire_product_innovation);
		if(FLAME_TEST_PRINT_START_AND_END_OF_LIBMBOARD_CALLS) printf("finish MB_SyncStart(b_filled_out_questionnaire_product_innovation)\n");
		#ifdef ERRCHECK
		if (rc != MB_SUCCESS)
		{
		   fprintf(stderr, "ERROR: Could not start sync of 'filled_out_questionnaire_product_innovation' board\n");
		   switch(rc) {
			   case MB_ERR_INVALID:
				   fprintf(stderr, "\t reason: 'filled_out_questionnaire_product_innovation' board is invalid\n");
				   break;
			   case MB_ERR_LOCKED:
				   fprintf(stderr, "\t reason: 'filled_out_questionnaire_product_innovation' board is locked\n");
				   break;
			   case MB_ERR_MEMALLOC:
				   fprintf(stderr, "\t reason: out of memory\n");
				   break;
			   case MB_ERR_INTERNAL:
				   fprintf(stderr, "\t reason: internal error. Recompile libmoard in debug mode for more info \n");
				   break;
			   default:
				   fprintf(stderr, "\t MB_SyncStart returned error code: %d (see libmboard docs for details)\n", rc);
				   break;
		   }

			
			exit(rc);
		}
		#endif
    }
    


/* End of layer number 21 */

/* Clear message boards that have finished being used
 * and sync complete if doing late sync complete */

if(FLAME_questionnaire_innovation_message_board_read == 0)
{
	/*printf("%d> questionnaire_innovation message board sync complete late as no agents reading any messages of this type\n", node_number);*/
	
	if(FLAME_TEST_PRINT_START_AND_END_OF_LIBMBOARD_CALLS) printf("start MB_SyncComplete(b_questionnaire_innovation)\n");
	rc = MB_SyncComplete(b_questionnaire_innovation);
	if(FLAME_TEST_PRINT_START_AND_END_OF_LIBMBOARD_CALLS) printf("finsh MB_SyncComplete(b_questionnaire_innovation)\n");
	#ifdef ERRCHECK
	if (rc != MB_SUCCESS)
	{
	   fprintf(stderr, "ERROR: Could not complete sync of 'questionnaire_innovation' board\n");
	   switch(rc) {
			case MB_ERR_INVALID:
			   fprintf(stderr, "\t reason: 'questionnaire_innovation' board is invalid\n");
			   break;
		   case MB_ERR_MEMALLOC:
			   fprintf(stderr, "\t reason: out of memory\n");
			   break;
		   case MB_ERR_INTERNAL:
			   fprintf(stderr, "\t reason: internal error. Recompile libmoard in debug mode for more info \n");
			   break;
		   default:
			   fprintf(stderr, "\t MB_SyncComplete returned error code: %d (see libmboard docs for details)\n", rc);
			   break;
	   }

	   
	   exit(rc);
	}
	#endif
}

    rc = MB_Clear(b_questionnaire_innovation);
    #ifdef ERRCHECK
    if (rc != MB_SUCCESS)
    {
       fprintf(stderr, "ERROR: Could not clear 'questionnaire_innovation' board\n");
       switch(rc) {
           case MB_ERR_INVALID:
               fprintf(stderr, "\t reason: 'questionnaire_innovation' board is invalid\n");
               break;
           case MB_ERR_LOCKED:
               fprintf(stderr, "\t reason: 'questionnaire_innovation' board is locked\n");
               break;
           case MB_ERR_INTERNAL:
               fprintf(stderr, "\t reason: internal error. Recompile libmoard in debug mode for more info \n");
               break;
           default:
               fprintf(stderr, "\t MB_Clear returned error code: %d (see libmboard docs for details)\n", rc);
               break;

       }

       
       exit(rc);
    }
    #endif


	if(FLAME_TEST_PRINT_START_AND_END_OF_MODEL_FUNCTIONS) printf("start idle\n");
	current_xmachine_Household_holder = Household_Household_Start_Financial_Market_Role_state->agents;
	while(current_xmachine_Household_holder)
	{
		temp_xmachine_Household_holder = current_xmachine_Household_holder->next;
		current_xmachine_Household = current_xmachine_Household_holder->agent;
		current_xmachine_Household_next_state = Household_AFM_000_state;
		/* For backwards compatibility set current_xmachine */
		current_xmachine->xmachine_Firm = NULL;
		current_xmachine->xmachine_Household = NULL;
		current_xmachine->xmachine_Mall = NULL;
		current_xmachine->xmachine_IGFirm = NULL;
		current_xmachine->xmachine_Eurostat = NULL;
		current_xmachine->xmachine_Bank = NULL;
		current_xmachine->xmachine_Government = NULL;
		current_xmachine->xmachine_CentralBank = NULL;
		current_xmachine->xmachine_ClearingHouse = NULL;
		current_xmachine->xmachine_Household = current_xmachine_Household;

		if(FLAME_condition_Household_idle_Household_Start_Financial_Market_Role_AFM_000(current_xmachine_Household)==1)
		{

		

			i = idle();

		

			if(i == 1)
			{
				free_Household_agent(current_xmachine_Household_holder, Household_Household_Start_Financial_Market_Role_state);
			}
			else
			{
				transition_Household_agent(current_xmachine_Household_holder, Household_Household_Start_Financial_Market_Role_state, Household_AFM_000_state);
			}
		}

		current_xmachine_Household = NULL;

		current_xmachine_Household_holder = temp_xmachine_Household_holder;
	}
	if(FLAME_TEST_PRINT_START_AND_END_OF_MODEL_FUNCTIONS) printf("finish idle\n");


	/* If mb is not read then leave sync complete until last possible moment */
	if(FLAME_index_info_message_board_read == 1)
	{
		if(FLAME_TEST_PRINT_START_AND_END_OF_LIBMBOARD_CALLS) printf("start MB_SyncComplete(b_index_info)\n");
		rc = MB_SyncComplete(b_index_info);
		if(FLAME_TEST_PRINT_START_AND_END_OF_LIBMBOARD_CALLS) printf("finsh MB_SyncComplete(b_index_info)\n");
		#ifdef ERRCHECK
		if (rc != MB_SUCCESS)
		{
		   fprintf(stderr, "ERROR: Could not complete sync of 'index_info' board\n");
		   switch(rc) {
				case MB_ERR_INVALID:
				   fprintf(stderr, "\t reason: 'index_info' board is invalid\n");
				   break;
			   case MB_ERR_MEMALLOC:
				   fprintf(stderr, "\t reason: out of memory\n");
				   break;
			   case MB_ERR_INTERNAL:
				   fprintf(stderr, "\t reason: internal error. Recompile libmoard in debug mode for more info \n");
				   break;
			   default:
				   fprintf(stderr, "\t MB_SyncComplete returned error code: %d (see libmboard docs for details)\n", rc);
				   break;
		   }
	
		   
		   exit(rc);
		}
		#endif
    
	}
	
	if(FLAME_TEST_PRINT_START_AND_END_OF_MODEL_FUNCTIONS) printf("start Household_receive_index_info\n");
	current_xmachine_Household_holder = Household_Household_Start_Financial_Market_Role_state->agents;
	while(current_xmachine_Household_holder)
	{
		temp_xmachine_Household_holder = current_xmachine_Household_holder->next;
		current_xmachine_Household = current_xmachine_Household_holder->agent;
		current_xmachine_Household_next_state = Household_AFM_000_state;
		/* For backwards compatibility set current_xmachine */
		current_xmachine->xmachine_Firm = NULL;
		current_xmachine->xmachine_Household = NULL;
		current_xmachine->xmachine_Mall = NULL;
		current_xmachine->xmachine_IGFirm = NULL;
		current_xmachine->xmachine_Eurostat = NULL;
		current_xmachine->xmachine_Bank = NULL;
		current_xmachine->xmachine_Government = NULL;
		current_xmachine->xmachine_CentralBank = NULL;
		current_xmachine->xmachine_ClearingHouse = NULL;
		current_xmachine->xmachine_Household = current_xmachine_Household;

		if(FLAME_condition_Household_Household_receive_index_info_Household_Start_Financial_Market_Role_AFM_000(current_xmachine_Household)==1)
		{

		
		
		rc = MB_Iterator_Create(b_index_info, &i_index_info);
		#ifdef ERRCHECK
		if (rc != MB_SUCCESS)
		{
		   fprintf(stderr, "ERROR: Could not create Iterator for 'index_info'\n");
		   switch(rc) {
		       case MB_ERR_INVALID:
		           fprintf(stderr, "\t reason: 'index_info' board is invalid\n");
		           break;
		       case MB_ERR_LOCKED:
	               fprintf(stderr, "\t reason: 'index_info' board is locked\n");
	               break;
	           case MB_ERR_MEMALLOC:
	               fprintf(stderr, "\t reason: out of memory\n");
	               break;
	           case MB_ERR_INTERNAL:
	               fprintf(stderr, "\t reason: internal error. Recompile libmoard in debug mode for more info \n");
	               break;
	           default:
	           
               
                   fprintf(stderr, "\t MB_Iterator_Create returned error code: %d (see libmboard docs for details)\n", rc);
               
                   break;
		   }

		   
           exit(rc);
		}
		#endif
		
		

			i = Household_receive_index_info();

		
		    rc = MB_Iterator_Delete(&i_index_info);
		    #ifdef ERRCHECK
		    if (rc != MB_SUCCESS)
		    {
		       fprintf(stderr, "ERROR: Could not delete 'index_info' iterator\n");
		       switch(rc) {
		           case MB_ERR_INVALID:
		               fprintf(stderr, "\t reason: 'index_info' iterator is invalid\n");
		               break;
		           case MB_ERR_INTERNAL:
		               fprintf(stderr, "\t reason: internal error. Recompile libmoard in debug mode for more info \n");
		               break;
		           default:
                       fprintf(stderr, "\t MB_Iterator_Delete returned error code: %d (see libmboard docs for details)\n", rc);
                       break;
		       }

		       
               exit(rc);
		    }
		    #endif
		

			if(i == 1)
			{
				free_Household_agent(current_xmachine_Household_holder, Household_Household_Start_Financial_Market_Role_state);
			}
			else
			{
				transition_Household_agent(current_xmachine_Household_holder, Household_Household_Start_Financial_Market_Role_state, Household_AFM_000_state);
			}
		}

		current_xmachine_Household = NULL;

		current_xmachine_Household_holder = temp_xmachine_Household_holder;
	}
	if(FLAME_TEST_PRINT_START_AND_END_OF_MODEL_FUNCTIONS) printf("finish Household_receive_index_info\n");


	/* If mb is not read then leave sync complete until last possible moment */
	if(FLAME_filled_out_questionnaire_product_innovation_message_board_read == 1)
	{
		if(FLAME_TEST_PRINT_START_AND_END_OF_LIBMBOARD_CALLS) printf("start MB_SyncComplete(b_filled_out_questionnaire_product_innovation)\n");
		rc = MB_SyncComplete(b_filled_out_questionnaire_product_innovation);
		if(FLAME_TEST_PRINT_START_AND_END_OF_LIBMBOARD_CALLS) printf("finsh MB_SyncComplete(b_filled_out_questionnaire_product_innovation)\n");
		#ifdef ERRCHECK
		if (rc != MB_SUCCESS)
		{
		   fprintf(stderr, "ERROR: Could not complete sync of 'filled_out_questionnaire_product_innovation' board\n");
		   switch(rc) {
				case MB_ERR_INVALID:
				   fprintf(stderr, "\t reason: 'filled_out_questionnaire_product_innovation' board is invalid\n");
				   break;
			   case MB_ERR_MEMALLOC:
				   fprintf(stderr, "\t reason: out of memory\n");
				   break;
			   case MB_ERR_INTERNAL:
				   fprintf(stderr, "\t reason: internal error. Recompile libmoard in debug mode for more info \n");
				   break;
			   default:
				   fprintf(stderr, "\t MB_SyncComplete returned error code: %d (see libmboard docs for details)\n", rc);
				   break;
		   }
	
		   
		   exit(rc);
		}
		#endif
    
	}
	
	if(FLAME_TEST_PRINT_START_AND_END_OF_MODEL_FUNCTIONS) printf("start Firm_count_questionnaire\n");
	current_xmachine_Firm_holder = Firm_MR_2_state->agents;
	while(current_xmachine_Firm_holder)
	{
		temp_xmachine_Firm_holder = current_xmachine_Firm_holder->next;
		current_xmachine_Firm = current_xmachine_Firm_holder->agent;
		current_xmachine_Firm_next_state = Firm_MR_3_state;
		/* For backwards compatibility set current_xmachine */
		current_xmachine->xmachine_Firm = NULL;
		current_xmachine->xmachine_Household = NULL;
		current_xmachine->xmachine_Mall = NULL;
		current_xmachine->xmachine_IGFirm = NULL;
		current_xmachine->xmachine_Eurostat = NULL;
		current_xmachine->xmachine_Bank = NULL;
		current_xmachine->xmachine_Government = NULL;
		current_xmachine->xmachine_CentralBank = NULL;
		current_xmachine->xmachine_ClearingHouse = NULL;
		current_xmachine->xmachine_Firm = current_xmachine_Firm;

		

		
		rc = MB_Iterator_CreateFiltered(b_filled_out_questionnaire_product_innovation, &i_filled_out_questionnaire_product_innovation, &FLAME_filter_Firm_Firm_count_questionnaire_MR_2_MR_3_filled_out_questionnaire_product_innovation, current_xmachine_Firm);
		
		#ifdef ERRCHECK
		if (rc != MB_SUCCESS)
		{
		   fprintf(stderr, "ERROR: Could not create Iterator for 'filled_out_questionnaire_product_innovation'\n");
		   switch(rc) {
		       case MB_ERR_INVALID:
		           fprintf(stderr, "\t reason: 'filled_out_questionnaire_product_innovation' board is invalid\n");
		           break;
		       case MB_ERR_LOCKED:
	               fprintf(stderr, "\t reason: 'filled_out_questionnaire_product_innovation' board is locked\n");
	               break;
	           case MB_ERR_MEMALLOC:
	               fprintf(stderr, "\t reason: out of memory\n");
	               break;
	           case MB_ERR_INTERNAL:
	               fprintf(stderr, "\t reason: internal error. Recompile libmoard in debug mode for more info \n");
	               break;
	           default:
	           
                   fprintf(stderr, "\t MB_Iterator_CreateFiltered returned error code: %d (see libmboard docs for details)\n", rc);
               
               
                   break;
		   }

		   
           exit(rc);
		}
		#endif
		
		

			i = Firm_count_questionnaire();

		
		    rc = MB_Iterator_Delete(&i_filled_out_questionnaire_product_innovation);
		    #ifdef ERRCHECK
		    if (rc != MB_SUCCESS)
		    {
		       fprintf(stderr, "ERROR: Could not delete 'filled_out_questionnaire_product_innovation' iterator\n");
		       switch(rc) {
		           case MB_ERR_INVALID:
		               fprintf(stderr, "\t reason: 'filled_out_questionnaire_product_innovation' iterator is invalid\n");
		               break;
		           case MB_ERR_INTERNAL:
		               fprintf(stderr, "\t reason: internal error. Recompile libmoard in debug mode for more info \n");
		               break;
		           default:
                       fprintf(stderr, "\t MB_Iterator_Delete returned error code: %d (see libmboard docs for details)\n", rc);
                       break;
		       }

		       
               exit(rc);
		    }
		    #endif
		

			if(i == 1)
			{
				free_Firm_agent(current_xmachine_Firm_holder, Firm_MR_2_state);
			}
			else
			{
				transition_Firm_agent(current_xmachine_Firm_holder, Firm_MR_2_state, Firm_MR_3_state);
			}
		

		current_xmachine_Firm = NULL;

		current_xmachine_Firm_holder = temp_xmachine_Firm_holder;
	}
	if(FLAME_TEST_PRINT_START_AND_END_OF_MODEL_FUNCTIONS) printf("finish Firm_count_questionnaire\n");


/* End of layer number 22 */

/* Clear message boards that have finished being used
 * and sync complete if doing late sync complete */

if(FLAME_index_info_message_board_read == 0)
{
	/*printf("%d> index_info message board sync complete late as no agents reading any messages of this type\n", node_number);*/
	
	if(FLAME_TEST_PRINT_START_AND_END_OF_LIBMBOARD_CALLS) printf("start MB_SyncComplete(b_index_info)\n");
	rc = MB_SyncComplete(b_index_info);
	if(FLAME_TEST_PRINT_START_AND_END_OF_LIBMBOARD_CALLS) printf("finsh MB_SyncComplete(b_index_info)\n");
	#ifdef ERRCHECK
	if (rc != MB_SUCCESS)
	{
	   fprintf(stderr, "ERROR: Could not complete sync of 'index_info' board\n");
	   switch(rc) {
			case MB_ERR_INVALID:
			   fprintf(stderr, "\t reason: 'index_info' board is invalid\n");
			   break;
		   case MB_ERR_MEMALLOC:
			   fprintf(stderr, "\t reason: out of memory\n");
			   break;
		   case MB_ERR_INTERNAL:
			   fprintf(stderr, "\t reason: internal error. Recompile libmoard in debug mode for more info \n");
			   break;
		   default:
			   fprintf(stderr, "\t MB_SyncComplete returned error code: %d (see libmboard docs for details)\n", rc);
			   break;
	   }

	   
	   exit(rc);
	}
	#endif
}

    rc = MB_Clear(b_index_info);
    #ifdef ERRCHECK
    if (rc != MB_SUCCESS)
    {
       fprintf(stderr, "ERROR: Could not clear 'index_info' board\n");
       switch(rc) {
           case MB_ERR_INVALID:
               fprintf(stderr, "\t reason: 'index_info' board is invalid\n");
               break;
           case MB_ERR_LOCKED:
               fprintf(stderr, "\t reason: 'index_info' board is locked\n");
               break;
           case MB_ERR_INTERNAL:
               fprintf(stderr, "\t reason: internal error. Recompile libmoard in debug mode for more info \n");
               break;
           default:
               fprintf(stderr, "\t MB_Clear returned error code: %d (see libmboard docs for details)\n", rc);
               break;

       }

       
       exit(rc);
    }
    #endif

if(FLAME_filled_out_questionnaire_product_innovation_message_board_read == 0)
{
	/*printf("%d> filled_out_questionnaire_product_innovation message board sync complete late as no agents reading any messages of this type\n", node_number);*/
	
	if(FLAME_TEST_PRINT_START_AND_END_OF_LIBMBOARD_CALLS) printf("start MB_SyncComplete(b_filled_out_questionnaire_product_innovation)\n");
	rc = MB_SyncComplete(b_filled_out_questionnaire_product_innovation);
	if(FLAME_TEST_PRINT_START_AND_END_OF_LIBMBOARD_CALLS) printf("finsh MB_SyncComplete(b_filled_out_questionnaire_product_innovation)\n");
	#ifdef ERRCHECK
	if (rc != MB_SUCCESS)
	{
	   fprintf(stderr, "ERROR: Could not complete sync of 'filled_out_questionnaire_product_innovation' board\n");
	   switch(rc) {
			case MB_ERR_INVALID:
			   fprintf(stderr, "\t reason: 'filled_out_questionnaire_product_innovation' board is invalid\n");
			   break;
		   case MB_ERR_MEMALLOC:
			   fprintf(stderr, "\t reason: out of memory\n");
			   break;
		   case MB_ERR_INTERNAL:
			   fprintf(stderr, "\t reason: internal error. Recompile libmoard in debug mode for more info \n");
			   break;
		   default:
			   fprintf(stderr, "\t MB_SyncComplete returned error code: %d (see libmboard docs for details)\n", rc);
			   break;
	   }

	   
	   exit(rc);
	}
	#endif
}

    rc = MB_Clear(b_filled_out_questionnaire_product_innovation);
    #ifdef ERRCHECK
    if (rc != MB_SUCCESS)
    {
       fprintf(stderr, "ERROR: Could not clear 'filled_out_questionnaire_product_innovation' board\n");
       switch(rc) {
           case MB_ERR_INVALID:
               fprintf(stderr, "\t reason: 'filled_out_questionnaire_product_innovation' board is invalid\n");
               break;
           case MB_ERR_LOCKED:
               fprintf(stderr, "\t reason: 'filled_out_questionnaire_product_innovation' board is locked\n");
               break;
           case MB_ERR_INTERNAL:
               fprintf(stderr, "\t reason: internal error. Recompile libmoard in debug mode for more info \n");
               break;
           default:
               fprintf(stderr, "\t MB_Clear returned error code: %d (see libmboard docs for details)\n", rc);
               break;

       }

       
       exit(rc);
    }
    #endif


	if(FLAME_TEST_PRINT_START_AND_END_OF_MODEL_FUNCTIONS) printf("start idle\n");
	current_xmachine_Household_holder = Household_AFM_000_state->agents;
	while(current_xmachine_Household_holder)
	{
		temp_xmachine_Household_holder = current_xmachine_Household_holder->next;
		current_xmachine_Household = current_xmachine_Household_holder->agent;
		current_xmachine_Household_next_state = Household_Household_Start_Labour_Role_state;
		/* For backwards compatibility set current_xmachine */
		current_xmachine->xmachine_Firm = NULL;
		current_xmachine->xmachine_Household = NULL;
		current_xmachine->xmachine_Mall = NULL;
		current_xmachine->xmachine_IGFirm = NULL;
		current_xmachine->xmachine_Eurostat = NULL;
		current_xmachine->xmachine_Bank = NULL;
		current_xmachine->xmachine_Government = NULL;
		current_xmachine->xmachine_CentralBank = NULL;
		current_xmachine->xmachine_ClearingHouse = NULL;
		current_xmachine->xmachine_Household = current_xmachine_Household;

		if(FLAME_condition_Household_idle_AFM_000_Household_Start_Labour_Role(current_xmachine_Household)==1)
		{

		

			i = idle();

		

			if(i == 1)
			{
				free_Household_agent(current_xmachine_Household_holder, Household_AFM_000_state);
			}
			else
			{
				transition_Household_agent(current_xmachine_Household_holder, Household_AFM_000_state, Household_Household_Start_Labour_Role_state);
			}
		}

		current_xmachine_Household = NULL;

		current_xmachine_Household_holder = temp_xmachine_Household_holder;
	}
	if(FLAME_TEST_PRINT_START_AND_END_OF_MODEL_FUNCTIONS) printf("finish idle\n");


	if(FLAME_TEST_PRINT_START_AND_END_OF_MODEL_FUNCTIONS) printf("start Firm_idle\n");
	current_xmachine_Firm_holder = Firm_MR_3_state->agents;
	while(current_xmachine_Firm_holder)
	{
		temp_xmachine_Firm_holder = current_xmachine_Firm_holder->next;
		current_xmachine_Firm = current_xmachine_Firm_holder->agent;
		current_xmachine_Firm_next_state = Firm_MR_4_state;
		/* For backwards compatibility set current_xmachine */
		current_xmachine->xmachine_Firm = NULL;
		current_xmachine->xmachine_Household = NULL;
		current_xmachine->xmachine_Mall = NULL;
		current_xmachine->xmachine_IGFirm = NULL;
		current_xmachine->xmachine_Eurostat = NULL;
		current_xmachine->xmachine_Bank = NULL;
		current_xmachine->xmachine_Government = NULL;
		current_xmachine->xmachine_CentralBank = NULL;
		current_xmachine->xmachine_ClearingHouse = NULL;
		current_xmachine->xmachine_Firm = current_xmachine_Firm;

		if(FLAME_condition_Firm_Firm_idle_MR_3_MR_4(current_xmachine_Firm)==1)
		{

		

			i = Firm_idle();

		

			if(i == 1)
			{
				free_Firm_agent(current_xmachine_Firm_holder, Firm_MR_3_state);
			}
			else
			{
				transition_Firm_agent(current_xmachine_Firm_holder, Firm_MR_3_state, Firm_MR_4_state);
			}
		}

		current_xmachine_Firm = NULL;

		current_xmachine_Firm_holder = temp_xmachine_Firm_holder;
	}
	if(FLAME_TEST_PRINT_START_AND_END_OF_MODEL_FUNCTIONS) printf("finish Firm_idle\n");


	if(FLAME_TEST_PRINT_START_AND_END_OF_MODEL_FUNCTIONS) printf("start Firm_analyze_questionnaire\n");
	current_xmachine_Firm_holder = Firm_MR_3_state->agents;
	while(current_xmachine_Firm_holder)
	{
		temp_xmachine_Firm_holder = current_xmachine_Firm_holder->next;
		current_xmachine_Firm = current_xmachine_Firm_holder->agent;
		current_xmachine_Firm_next_state = Firm_MR_4_state;
		/* For backwards compatibility set current_xmachine */
		current_xmachine->xmachine_Firm = NULL;
		current_xmachine->xmachine_Household = NULL;
		current_xmachine->xmachine_Mall = NULL;
		current_xmachine->xmachine_IGFirm = NULL;
		current_xmachine->xmachine_Eurostat = NULL;
		current_xmachine->xmachine_Bank = NULL;
		current_xmachine->xmachine_Government = NULL;
		current_xmachine->xmachine_CentralBank = NULL;
		current_xmachine->xmachine_ClearingHouse = NULL;
		current_xmachine->xmachine_Firm = current_xmachine_Firm;

		if(FLAME_condition_Firm_Firm_analyze_questionnaire_MR_3_MR_4(current_xmachine_Firm)==1)
		{

		

			i = Firm_analyze_questionnaire();

		

			if(i == 1)
			{
				free_Firm_agent(current_xmachine_Firm_holder, Firm_MR_3_state);
			}
			else
			{
				transition_Firm_agent(current_xmachine_Firm_holder, Firm_MR_3_state, Firm_MR_4_state);
			}
		}

		current_xmachine_Firm = NULL;

		current_xmachine_Firm_holder = temp_xmachine_Firm_holder;
	}
	if(FLAME_TEST_PRINT_START_AND_END_OF_MODEL_FUNCTIONS) printf("finish Firm_analyze_questionnaire\n");


	/* If mb is not read then leave sync complete until last possible moment */
	if(FLAME_index_price_message_board_read == 1)
	{
		if(FLAME_TEST_PRINT_START_AND_END_OF_LIBMBOARD_CALLS) printf("start MB_SyncComplete(b_index_price)\n");
		rc = MB_SyncComplete(b_index_price);
		if(FLAME_TEST_PRINT_START_AND_END_OF_LIBMBOARD_CALLS) printf("finsh MB_SyncComplete(b_index_price)\n");
		#ifdef ERRCHECK
		if (rc != MB_SUCCESS)
		{
		   fprintf(stderr, "ERROR: Could not complete sync of 'index_price' board\n");
		   switch(rc) {
				case MB_ERR_INVALID:
				   fprintf(stderr, "\t reason: 'index_price' board is invalid\n");
				   break;
			   case MB_ERR_MEMALLOC:
				   fprintf(stderr, "\t reason: out of memory\n");
				   break;
			   case MB_ERR_INTERNAL:
				   fprintf(stderr, "\t reason: internal error. Recompile libmoard in debug mode for more info \n");
				   break;
			   default:
				   fprintf(stderr, "\t MB_SyncComplete returned error code: %d (see libmboard docs for details)\n", rc);
				   break;
		   }
	
		   
		   exit(rc);
		}
		#endif
    
	}
	
	if(FLAME_TEST_PRINT_START_AND_END_OF_MODEL_FUNCTIONS) printf("start Household_receive_index_price\n");
	current_xmachine_Household_holder = Household_AFM_000_state->agents;
	while(current_xmachine_Household_holder)
	{
		temp_xmachine_Household_holder = current_xmachine_Household_holder->next;
		current_xmachine_Household = current_xmachine_Household_holder->agent;
		current_xmachine_Household_next_state = Household_AFM_001_state;
		/* For backwards compatibility set current_xmachine */
		current_xmachine->xmachine_Firm = NULL;
		current_xmachine->xmachine_Household = NULL;
		current_xmachine->xmachine_Mall = NULL;
		current_xmachine->xmachine_IGFirm = NULL;
		current_xmachine->xmachine_Eurostat = NULL;
		current_xmachine->xmachine_Bank = NULL;
		current_xmachine->xmachine_Government = NULL;
		current_xmachine->xmachine_CentralBank = NULL;
		current_xmachine->xmachine_ClearingHouse = NULL;
		current_xmachine->xmachine_Household = current_xmachine_Household;

		if(FLAME_condition_Household_Household_receive_index_price_AFM_000_AFM_001(current_xmachine_Household)==1)
		{

		
		
		rc = MB_Iterator_Create(b_index_price, &i_index_price);
		#ifdef ERRCHECK
		if (rc != MB_SUCCESS)
		{
		   fprintf(stderr, "ERROR: Could not create Iterator for 'index_price'\n");
		   switch(rc) {
		       case MB_ERR_INVALID:
		           fprintf(stderr, "\t reason: 'index_price' board is invalid\n");
		           break;
		       case MB_ERR_LOCKED:
	               fprintf(stderr, "\t reason: 'index_price' board is locked\n");
	               break;
	           case MB_ERR_MEMALLOC:
	               fprintf(stderr, "\t reason: out of memory\n");
	               break;
	           case MB_ERR_INTERNAL:
	               fprintf(stderr, "\t reason: internal error. Recompile libmoard in debug mode for more info \n");
	               break;
	           default:
	           
               
                   fprintf(stderr, "\t MB_Iterator_Create returned error code: %d (see libmboard docs for details)\n", rc);
               
                   break;
		   }

		   
           exit(rc);
		}
		#endif
		
		

			i = Household_receive_index_price();

		
		    rc = MB_Iterator_Delete(&i_index_price);
		    #ifdef ERRCHECK
		    if (rc != MB_SUCCESS)
		    {
		       fprintf(stderr, "ERROR: Could not delete 'index_price' iterator\n");
		       switch(rc) {
		           case MB_ERR_INVALID:
		               fprintf(stderr, "\t reason: 'index_price' iterator is invalid\n");
		               break;
		           case MB_ERR_INTERNAL:
		               fprintf(stderr, "\t reason: internal error. Recompile libmoard in debug mode for more info \n");
		               break;
		           default:
                       fprintf(stderr, "\t MB_Iterator_Delete returned error code: %d (see libmboard docs for details)\n", rc);
                       break;
		       }

		       
               exit(rc);
		    }
		    #endif
		

			if(i == 1)
			{
				free_Household_agent(current_xmachine_Household_holder, Household_AFM_000_state);
			}
			else
			{
				transition_Household_agent(current_xmachine_Household_holder, Household_AFM_000_state, Household_AFM_001_state);
			}
		}

		current_xmachine_Household = NULL;

		current_xmachine_Household_holder = temp_xmachine_Household_holder;
	}
	if(FLAME_TEST_PRINT_START_AND_END_OF_MODEL_FUNCTIONS) printf("finish Household_receive_index_price\n");


/* End of layer number 23 */

/* Clear message boards that have finished being used
 * and sync complete if doing late sync complete */

if(FLAME_index_price_message_board_read == 0)
{
	/*printf("%d> index_price message board sync complete late as no agents reading any messages of this type\n", node_number);*/
	
	if(FLAME_TEST_PRINT_START_AND_END_OF_LIBMBOARD_CALLS) printf("start MB_SyncComplete(b_index_price)\n");
	rc = MB_SyncComplete(b_index_price);
	if(FLAME_TEST_PRINT_START_AND_END_OF_LIBMBOARD_CALLS) printf("finsh MB_SyncComplete(b_index_price)\n");
	#ifdef ERRCHECK
	if (rc != MB_SUCCESS)
	{
	   fprintf(stderr, "ERROR: Could not complete sync of 'index_price' board\n");
	   switch(rc) {
			case MB_ERR_INVALID:
			   fprintf(stderr, "\t reason: 'index_price' board is invalid\n");
			   break;
		   case MB_ERR_MEMALLOC:
			   fprintf(stderr, "\t reason: out of memory\n");
			   break;
		   case MB_ERR_INTERNAL:
			   fprintf(stderr, "\t reason: internal error. Recompile libmoard in debug mode for more info \n");
			   break;
		   default:
			   fprintf(stderr, "\t MB_SyncComplete returned error code: %d (see libmboard docs for details)\n", rc);
			   break;
	   }

	   
	   exit(rc);
	}
	#endif
}

    rc = MB_Clear(b_index_price);
    #ifdef ERRCHECK
    if (rc != MB_SUCCESS)
    {
       fprintf(stderr, "ERROR: Could not clear 'index_price' board\n");
       switch(rc) {
           case MB_ERR_INVALID:
               fprintf(stderr, "\t reason: 'index_price' board is invalid\n");
               break;
           case MB_ERR_LOCKED:
               fprintf(stderr, "\t reason: 'index_price' board is locked\n");
               break;
           case MB_ERR_INTERNAL:
               fprintf(stderr, "\t reason: internal error. Recompile libmoard in debug mode for more info \n");
               break;
           default:
               fprintf(stderr, "\t MB_Clear returned error code: %d (see libmboard docs for details)\n", rc);
               break;

       }

       
       exit(rc);
    }
    #endif


	if(FLAME_TEST_PRINT_START_AND_END_OF_MODEL_FUNCTIONS) printf("start Household_revises_expected_portfolio\n");
	current_xmachine_Household_holder = Household_AFM_001_state->agents;
	while(current_xmachine_Household_holder)
	{
		temp_xmachine_Household_holder = current_xmachine_Household_holder->next;
		current_xmachine_Household = current_xmachine_Household_holder->agent;
		current_xmachine_Household_next_state = Household_AFM_002_state;
		/* For backwards compatibility set current_xmachine */
		current_xmachine->xmachine_Firm = NULL;
		current_xmachine->xmachine_Household = NULL;
		current_xmachine->xmachine_Mall = NULL;
		current_xmachine->xmachine_IGFirm = NULL;
		current_xmachine->xmachine_Eurostat = NULL;
		current_xmachine->xmachine_Bank = NULL;
		current_xmachine->xmachine_Government = NULL;
		current_xmachine->xmachine_CentralBank = NULL;
		current_xmachine->xmachine_ClearingHouse = NULL;
		current_xmachine->xmachine_Household = current_xmachine_Household;

		

		

			i = Household_revises_expected_portfolio();

		

			if(i == 1)
			{
				free_Household_agent(current_xmachine_Household_holder, Household_AFM_001_state);
			}
			else
			{
				transition_Household_agent(current_xmachine_Household_holder, Household_AFM_001_state, Household_AFM_002_state);
			}
		

		current_xmachine_Household = NULL;

		current_xmachine_Household_holder = temp_xmachine_Household_holder;
	}
	if(FLAME_TEST_PRINT_START_AND_END_OF_MODEL_FUNCTIONS) printf("finish Household_revises_expected_portfolio\n");

	if(FLAME_order_message_board_write == 1)
	{

		if(FLAME_TEST_PRINT_START_AND_END_OF_LIBMBOARD_CALLS) printf("start MB_SyncStart(b_order)\n");
		rc = MB_SyncStart(b_order);
		if(FLAME_TEST_PRINT_START_AND_END_OF_LIBMBOARD_CALLS) printf("finish MB_SyncStart(b_order)\n");
		#ifdef ERRCHECK
		if (rc != MB_SUCCESS)
		{
		   fprintf(stderr, "ERROR: Could not start sync of 'order' board\n");
		   switch(rc) {
			   case MB_ERR_INVALID:
				   fprintf(stderr, "\t reason: 'order' board is invalid\n");
				   break;
			   case MB_ERR_LOCKED:
				   fprintf(stderr, "\t reason: 'order' board is locked\n");
				   break;
			   case MB_ERR_MEMALLOC:
				   fprintf(stderr, "\t reason: out of memory\n");
				   break;
			   case MB_ERR_INTERNAL:
				   fprintf(stderr, "\t reason: internal error. Recompile libmoard in debug mode for more info \n");
				   break;
			   default:
				   fprintf(stderr, "\t MB_SyncStart returned error code: %d (see libmboard docs for details)\n", rc);
				   break;
		   }

			
			exit(rc);
		}
		#endif
    }
    


	if(FLAME_TEST_PRINT_START_AND_END_OF_MODEL_FUNCTIONS) printf("start Firm_idle\n");
	current_xmachine_Firm_holder = Firm_MR_4_state->agents;
	while(current_xmachine_Firm_holder)
	{
		temp_xmachine_Firm_holder = current_xmachine_Firm_holder->next;
		current_xmachine_Firm = current_xmachine_Firm_holder->agent;
		current_xmachine_Firm_next_state = Firm_Firm_Start_Producer_Role_state;
		/* For backwards compatibility set current_xmachine */
		current_xmachine->xmachine_Firm = NULL;
		current_xmachine->xmachine_Household = NULL;
		current_xmachine->xmachine_Mall = NULL;
		current_xmachine->xmachine_IGFirm = NULL;
		current_xmachine->xmachine_Eurostat = NULL;
		current_xmachine->xmachine_Bank = NULL;
		current_xmachine->xmachine_Government = NULL;
		current_xmachine->xmachine_CentralBank = NULL;
		current_xmachine->xmachine_ClearingHouse = NULL;
		current_xmachine->xmachine_Firm = current_xmachine_Firm;

		if(FLAME_condition_Firm_Firm_idle_MR_4_Firm_Start_Producer_Role(current_xmachine_Firm)==1)
		{

		

			i = Firm_idle();

		

			if(i == 1)
			{
				free_Firm_agent(current_xmachine_Firm_holder, Firm_MR_4_state);
			}
			else
			{
				transition_Firm_agent(current_xmachine_Firm_holder, Firm_MR_4_state, Firm_Firm_Start_Producer_Role_state);
			}
		}

		current_xmachine_Firm = NULL;

		current_xmachine_Firm_holder = temp_xmachine_Firm_holder;
	}
	if(FLAME_TEST_PRINT_START_AND_END_OF_MODEL_FUNCTIONS) printf("finish Firm_idle\n");


	/* If mb is not read then leave sync complete until last possible moment */
	if(FLAME_productivity_message_board_read == 1)
	{
		if(FLAME_TEST_PRINT_START_AND_END_OF_LIBMBOARD_CALLS) printf("start MB_SyncComplete(b_productivity)\n");
		rc = MB_SyncComplete(b_productivity);
		if(FLAME_TEST_PRINT_START_AND_END_OF_LIBMBOARD_CALLS) printf("finsh MB_SyncComplete(b_productivity)\n");
		#ifdef ERRCHECK
		if (rc != MB_SUCCESS)
		{
		   fprintf(stderr, "ERROR: Could not complete sync of 'productivity' board\n");
		   switch(rc) {
				case MB_ERR_INVALID:
				   fprintf(stderr, "\t reason: 'productivity' board is invalid\n");
				   break;
			   case MB_ERR_MEMALLOC:
				   fprintf(stderr, "\t reason: out of memory\n");
				   break;
			   case MB_ERR_INTERNAL:
				   fprintf(stderr, "\t reason: internal error. Recompile libmoard in debug mode for more info \n");
				   break;
			   default:
				   fprintf(stderr, "\t MB_SyncComplete returned error code: %d (see libmboard docs for details)\n", rc);
				   break;
		   }
	
		   
		   exit(rc);
		}
		#endif
    
	}
	
	if(FLAME_TEST_PRINT_START_AND_END_OF_MODEL_FUNCTIONS) printf("start Firm_prepone_vintage_choice\n");
	current_xmachine_Firm_holder = Firm_MR_4_state->agents;
	while(current_xmachine_Firm_holder)
	{
		temp_xmachine_Firm_holder = current_xmachine_Firm_holder->next;
		current_xmachine_Firm = current_xmachine_Firm_holder->agent;
		current_xmachine_Firm_next_state = Firm_MR_4a_state;
		/* For backwards compatibility set current_xmachine */
		current_xmachine->xmachine_Firm = NULL;
		current_xmachine->xmachine_Household = NULL;
		current_xmachine->xmachine_Mall = NULL;
		current_xmachine->xmachine_IGFirm = NULL;
		current_xmachine->xmachine_Eurostat = NULL;
		current_xmachine->xmachine_Bank = NULL;
		current_xmachine->xmachine_Government = NULL;
		current_xmachine->xmachine_CentralBank = NULL;
		current_xmachine->xmachine_ClearingHouse = NULL;
		current_xmachine->xmachine_Firm = current_xmachine_Firm;

		if(FLAME_condition_Firm_Firm_prepone_vintage_choice_MR_4_MR_4a(current_xmachine_Firm)==1)
		{

		
		
		rc = MB_Iterator_Create(b_productivity, &i_productivity);
		#ifdef ERRCHECK
		if (rc != MB_SUCCESS)
		{
		   fprintf(stderr, "ERROR: Could not create Iterator for 'productivity'\n");
		   switch(rc) {
		       case MB_ERR_INVALID:
		           fprintf(stderr, "\t reason: 'productivity' board is invalid\n");
		           break;
		       case MB_ERR_LOCKED:
	               fprintf(stderr, "\t reason: 'productivity' board is locked\n");
	               break;
	           case MB_ERR_MEMALLOC:
	               fprintf(stderr, "\t reason: out of memory\n");
	               break;
	           case MB_ERR_INTERNAL:
	               fprintf(stderr, "\t reason: internal error. Recompile libmoard in debug mode for more info \n");
	               break;
	           default:
	           
               
                   fprintf(stderr, "\t MB_Iterator_Create returned error code: %d (see libmboard docs for details)\n", rc);
               
                   break;
		   }

		   
           exit(rc);
		}
		#endif
		
		

			i = Firm_prepone_vintage_choice();

		
		    rc = MB_Iterator_Delete(&i_productivity);
		    #ifdef ERRCHECK
		    if (rc != MB_SUCCESS)
		    {
		       fprintf(stderr, "ERROR: Could not delete 'productivity' iterator\n");
		       switch(rc) {
		           case MB_ERR_INVALID:
		               fprintf(stderr, "\t reason: 'productivity' iterator is invalid\n");
		               break;
		           case MB_ERR_INTERNAL:
		               fprintf(stderr, "\t reason: internal error. Recompile libmoard in debug mode for more info \n");
		               break;
		           default:
                       fprintf(stderr, "\t MB_Iterator_Delete returned error code: %d (see libmboard docs for details)\n", rc);
                       break;
		       }

		       
               exit(rc);
		    }
		    #endif
		

			if(i == 1)
			{
				free_Firm_agent(current_xmachine_Firm_holder, Firm_MR_4_state);
			}
			else
			{
				transition_Firm_agent(current_xmachine_Firm_holder, Firm_MR_4_state, Firm_MR_4a_state);
			}
		}

		current_xmachine_Firm = NULL;

		current_xmachine_Firm_holder = temp_xmachine_Firm_holder;
	}
	if(FLAME_TEST_PRINT_START_AND_END_OF_MODEL_FUNCTIONS) printf("finish Firm_prepone_vintage_choice\n");


/* End of layer number 24 */

/* Clear message boards that have finished being used
 * and sync complete if doing late sync complete */


	if(FLAME_TEST_PRINT_START_AND_END_OF_MODEL_FUNCTIONS) printf("start Firm_set_price\n");
	current_xmachine_Firm_holder = Firm_MR_4a_state->agents;
	while(current_xmachine_Firm_holder)
	{
		temp_xmachine_Firm_holder = current_xmachine_Firm_holder->next;
		current_xmachine_Firm = current_xmachine_Firm_holder->agent;
		current_xmachine_Firm_next_state = Firm_MR_5_state;
		/* For backwards compatibility set current_xmachine */
		current_xmachine->xmachine_Firm = NULL;
		current_xmachine->xmachine_Household = NULL;
		current_xmachine->xmachine_Mall = NULL;
		current_xmachine->xmachine_IGFirm = NULL;
		current_xmachine->xmachine_Eurostat = NULL;
		current_xmachine->xmachine_Bank = NULL;
		current_xmachine->xmachine_Government = NULL;
		current_xmachine->xmachine_CentralBank = NULL;
		current_xmachine->xmachine_ClearingHouse = NULL;
		current_xmachine->xmachine_Firm = current_xmachine_Firm;

		

		

			i = Firm_set_price();

		

			if(i == 1)
			{
				free_Firm_agent(current_xmachine_Firm_holder, Firm_MR_4a_state);
			}
			else
			{
				transition_Firm_agent(current_xmachine_Firm_holder, Firm_MR_4a_state, Firm_MR_5_state);
			}
		

		current_xmachine_Firm = NULL;

		current_xmachine_Firm_holder = temp_xmachine_Firm_holder;
	}
	if(FLAME_TEST_PRINT_START_AND_END_OF_MODEL_FUNCTIONS) printf("finish Firm_set_price\n");


	/* If mb is not read then leave sync complete until last possible moment */
	if(FLAME_order_message_board_read == 1)
	{
		if(FLAME_TEST_PRINT_START_AND_END_OF_LIBMBOARD_CALLS) printf("start MB_SyncComplete(b_order)\n");
		rc = MB_SyncComplete(b_order);
		if(FLAME_TEST_PRINT_START_AND_END_OF_LIBMBOARD_CALLS) printf("finsh MB_SyncComplete(b_order)\n");
		#ifdef ERRCHECK
		if (rc != MB_SUCCESS)
		{
		   fprintf(stderr, "ERROR: Could not complete sync of 'order' board\n");
		   switch(rc) {
				case MB_ERR_INVALID:
				   fprintf(stderr, "\t reason: 'order' board is invalid\n");
				   break;
			   case MB_ERR_MEMALLOC:
				   fprintf(stderr, "\t reason: out of memory\n");
				   break;
			   case MB_ERR_INTERNAL:
				   fprintf(stderr, "\t reason: internal error. Recompile libmoard in debug mode for more info \n");
				   break;
			   default:
				   fprintf(stderr, "\t MB_SyncComplete returned error code: %d (see libmboard docs for details)\n", rc);
				   break;
		   }
	
		   
		   exit(rc);
		}
		#endif
    
	}
	
	if(FLAME_TEST_PRINT_START_AND_END_OF_MODEL_FUNCTIONS) printf("start ClearingHouse_receive_orders\n");
	current_xmachine_ClearingHouse_holder = ClearingHouse_AFM_01_state->agents;
	while(current_xmachine_ClearingHouse_holder)
	{
		temp_xmachine_ClearingHouse_holder = current_xmachine_ClearingHouse_holder->next;
		current_xmachine_ClearingHouse = current_xmachine_ClearingHouse_holder->agent;
		current_xmachine_ClearingHouse_next_state = ClearingHouse_AFM_02_state;
		/* For backwards compatibility set current_xmachine */
		current_xmachine->xmachine_Firm = NULL;
		current_xmachine->xmachine_Household = NULL;
		current_xmachine->xmachine_Mall = NULL;
		current_xmachine->xmachine_IGFirm = NULL;
		current_xmachine->xmachine_Eurostat = NULL;
		current_xmachine->xmachine_Bank = NULL;
		current_xmachine->xmachine_Government = NULL;
		current_xmachine->xmachine_CentralBank = NULL;
		current_xmachine->xmachine_ClearingHouse = NULL;
		current_xmachine->xmachine_ClearingHouse = current_xmachine_ClearingHouse;

		

		
		
		rc = MB_Iterator_Create(b_order, &i_order);
		#ifdef ERRCHECK
		if (rc != MB_SUCCESS)
		{
		   fprintf(stderr, "ERROR: Could not create Iterator for 'order'\n");
		   switch(rc) {
		       case MB_ERR_INVALID:
		           fprintf(stderr, "\t reason: 'order' board is invalid\n");
		           break;
		       case MB_ERR_LOCKED:
	               fprintf(stderr, "\t reason: 'order' board is locked\n");
	               break;
	           case MB_ERR_MEMALLOC:
	               fprintf(stderr, "\t reason: out of memory\n");
	               break;
	           case MB_ERR_INTERNAL:
	               fprintf(stderr, "\t reason: internal error. Recompile libmoard in debug mode for more info \n");
	               break;
	           default:
	           
               
                   fprintf(stderr, "\t MB_Iterator_Create returned error code: %d (see libmboard docs for details)\n", rc);
               
                   break;
		   }

		   
           exit(rc);
		}
		#endif
		
		

			i = ClearingHouse_receive_orders();

		
		    rc = MB_Iterator_Delete(&i_order);
		    #ifdef ERRCHECK
		    if (rc != MB_SUCCESS)
		    {
		       fprintf(stderr, "ERROR: Could not delete 'order' iterator\n");
		       switch(rc) {
		           case MB_ERR_INVALID:
		               fprintf(stderr, "\t reason: 'order' iterator is invalid\n");
		               break;
		           case MB_ERR_INTERNAL:
		               fprintf(stderr, "\t reason: internal error. Recompile libmoard in debug mode for more info \n");
		               break;
		           default:
                       fprintf(stderr, "\t MB_Iterator_Delete returned error code: %d (see libmboard docs for details)\n", rc);
                       break;
		       }

		       
               exit(rc);
		    }
		    #endif
		

			if(i == 1)
			{
				free_ClearingHouse_agent(current_xmachine_ClearingHouse_holder, ClearingHouse_AFM_01_state);
			}
			else
			{
				transition_ClearingHouse_agent(current_xmachine_ClearingHouse_holder, ClearingHouse_AFM_01_state, ClearingHouse_AFM_02_state);
			}
		

		current_xmachine_ClearingHouse = NULL;

		current_xmachine_ClearingHouse_holder = temp_xmachine_ClearingHouse_holder;
	}
	if(FLAME_TEST_PRINT_START_AND_END_OF_MODEL_FUNCTIONS) printf("finish ClearingHouse_receive_orders\n");


/* End of layer number 25 */

/* Clear message boards that have finished being used
 * and sync complete if doing late sync complete */

if(FLAME_order_message_board_read == 0)
{
	/*printf("%d> order message board sync complete late as no agents reading any messages of this type\n", node_number);*/
	
	if(FLAME_TEST_PRINT_START_AND_END_OF_LIBMBOARD_CALLS) printf("start MB_SyncComplete(b_order)\n");
	rc = MB_SyncComplete(b_order);
	if(FLAME_TEST_PRINT_START_AND_END_OF_LIBMBOARD_CALLS) printf("finsh MB_SyncComplete(b_order)\n");
	#ifdef ERRCHECK
	if (rc != MB_SUCCESS)
	{
	   fprintf(stderr, "ERROR: Could not complete sync of 'order' board\n");
	   switch(rc) {
			case MB_ERR_INVALID:
			   fprintf(stderr, "\t reason: 'order' board is invalid\n");
			   break;
		   case MB_ERR_MEMALLOC:
			   fprintf(stderr, "\t reason: out of memory\n");
			   break;
		   case MB_ERR_INTERNAL:
			   fprintf(stderr, "\t reason: internal error. Recompile libmoard in debug mode for more info \n");
			   break;
		   default:
			   fprintf(stderr, "\t MB_SyncComplete returned error code: %d (see libmboard docs for details)\n", rc);
			   break;
	   }

	   
	   exit(rc);
	}
	#endif
}

    rc = MB_Clear(b_order);
    #ifdef ERRCHECK
    if (rc != MB_SUCCESS)
    {
       fprintf(stderr, "ERROR: Could not clear 'order' board\n");
       switch(rc) {
           case MB_ERR_INVALID:
               fprintf(stderr, "\t reason: 'order' board is invalid\n");
               break;
           case MB_ERR_LOCKED:
               fprintf(stderr, "\t reason: 'order' board is locked\n");
               break;
           case MB_ERR_INTERNAL:
               fprintf(stderr, "\t reason: internal error. Recompile libmoard in debug mode for more info \n");
               break;
           default:
               fprintf(stderr, "\t MB_Clear returned error code: %d (see libmboard docs for details)\n", rc);
               break;

       }

       
       exit(rc);
    }
    #endif


	if(FLAME_TEST_PRINT_START_AND_END_OF_MODEL_FUNCTIONS) printf("start ClearingHouse_compute_transactions\n");
	current_xmachine_ClearingHouse_holder = ClearingHouse_AFM_02_state->agents;
	while(current_xmachine_ClearingHouse_holder)
	{
		temp_xmachine_ClearingHouse_holder = current_xmachine_ClearingHouse_holder->next;
		current_xmachine_ClearingHouse = current_xmachine_ClearingHouse_holder->agent;
		current_xmachine_ClearingHouse_next_state = ClearingHouse_AFM_03_state;
		/* For backwards compatibility set current_xmachine */
		current_xmachine->xmachine_Firm = NULL;
		current_xmachine->xmachine_Household = NULL;
		current_xmachine->xmachine_Mall = NULL;
		current_xmachine->xmachine_IGFirm = NULL;
		current_xmachine->xmachine_Eurostat = NULL;
		current_xmachine->xmachine_Bank = NULL;
		current_xmachine->xmachine_Government = NULL;
		current_xmachine->xmachine_CentralBank = NULL;
		current_xmachine->xmachine_ClearingHouse = NULL;
		current_xmachine->xmachine_ClearingHouse = current_xmachine_ClearingHouse;

		

		

			i = ClearingHouse_compute_transactions();

		

			if(i == 1)
			{
				free_ClearingHouse_agent(current_xmachine_ClearingHouse_holder, ClearingHouse_AFM_02_state);
			}
			else
			{
				transition_ClearingHouse_agent(current_xmachine_ClearingHouse_holder, ClearingHouse_AFM_02_state, ClearingHouse_AFM_03_state);
			}
		

		current_xmachine_ClearingHouse = NULL;

		current_xmachine_ClearingHouse_holder = temp_xmachine_ClearingHouse_holder;
	}
	if(FLAME_TEST_PRINT_START_AND_END_OF_MODEL_FUNCTIONS) printf("finish ClearingHouse_compute_transactions\n");


	if(FLAME_TEST_PRINT_START_AND_END_OF_MODEL_FUNCTIONS) printf("start Firm_idle\n");
	current_xmachine_Firm_holder = Firm_MR_5_state->agents;
	while(current_xmachine_Firm_holder)
	{
		temp_xmachine_Firm_holder = current_xmachine_Firm_holder->next;
		current_xmachine_Firm = current_xmachine_Firm_holder->agent;
		current_xmachine_Firm_next_state = Firm_MR_6_state;
		/* For backwards compatibility set current_xmachine */
		current_xmachine->xmachine_Firm = NULL;
		current_xmachine->xmachine_Household = NULL;
		current_xmachine->xmachine_Mall = NULL;
		current_xmachine->xmachine_IGFirm = NULL;
		current_xmachine->xmachine_Eurostat = NULL;
		current_xmachine->xmachine_Bank = NULL;
		current_xmachine->xmachine_Government = NULL;
		current_xmachine->xmachine_CentralBank = NULL;
		current_xmachine->xmachine_ClearingHouse = NULL;
		current_xmachine->xmachine_Firm = current_xmachine_Firm;

		if(FLAME_condition_Firm_Firm_idle_MR_5_MR_6(current_xmachine_Firm)==1)
		{

		

			i = Firm_idle();

		

			if(i == 1)
			{
				free_Firm_agent(current_xmachine_Firm_holder, Firm_MR_5_state);
			}
			else
			{
				transition_Firm_agent(current_xmachine_Firm_holder, Firm_MR_5_state, Firm_MR_6_state);
			}
		}

		current_xmachine_Firm = NULL;

		current_xmachine_Firm_holder = temp_xmachine_Firm_holder;
	}
	if(FLAME_TEST_PRINT_START_AND_END_OF_MODEL_FUNCTIONS) printf("finish Firm_idle\n");


	if(FLAME_TEST_PRINT_START_AND_END_OF_MODEL_FUNCTIONS) printf("start Firm_decide_product_innovation\n");
	current_xmachine_Firm_holder = Firm_MR_5_state->agents;
	while(current_xmachine_Firm_holder)
	{
		temp_xmachine_Firm_holder = current_xmachine_Firm_holder->next;
		current_xmachine_Firm = current_xmachine_Firm_holder->agent;
		current_xmachine_Firm_next_state = Firm_MR_6_state;
		/* For backwards compatibility set current_xmachine */
		current_xmachine->xmachine_Firm = NULL;
		current_xmachine->xmachine_Household = NULL;
		current_xmachine->xmachine_Mall = NULL;
		current_xmachine->xmachine_IGFirm = NULL;
		current_xmachine->xmachine_Eurostat = NULL;
		current_xmachine->xmachine_Bank = NULL;
		current_xmachine->xmachine_Government = NULL;
		current_xmachine->xmachine_CentralBank = NULL;
		current_xmachine->xmachine_ClearingHouse = NULL;
		current_xmachine->xmachine_Firm = current_xmachine_Firm;

		if(FLAME_condition_Firm_Firm_decide_product_innovation_MR_5_MR_6(current_xmachine_Firm)==1)
		{

		

			i = Firm_decide_product_innovation();

		

			if(i == 1)
			{
				free_Firm_agent(current_xmachine_Firm_holder, Firm_MR_5_state);
			}
			else
			{
				transition_Firm_agent(current_xmachine_Firm_holder, Firm_MR_5_state, Firm_MR_6_state);
			}
		}

		current_xmachine_Firm = NULL;

		current_xmachine_Firm_holder = temp_xmachine_Firm_holder;
	}
	if(FLAME_TEST_PRINT_START_AND_END_OF_MODEL_FUNCTIONS) printf("finish Firm_decide_product_innovation\n");


/* End of layer number 26 */

/* Clear message boards that have finished being used
 * and sync complete if doing late sync complete */


	if(FLAME_TEST_PRINT_START_AND_END_OF_MODEL_FUNCTIONS) printf("start ClearingHouse_send_transaction_info\n");
	current_xmachine_ClearingHouse_holder = ClearingHouse_AFM_03_state->agents;
	while(current_xmachine_ClearingHouse_holder)
	{
		temp_xmachine_ClearingHouse_holder = current_xmachine_ClearingHouse_holder->next;
		current_xmachine_ClearingHouse = current_xmachine_ClearingHouse_holder->agent;
		current_xmachine_ClearingHouse_next_state = ClearingHouse_AFM_04_state;
		/* For backwards compatibility set current_xmachine */
		current_xmachine->xmachine_Firm = NULL;
		current_xmachine->xmachine_Household = NULL;
		current_xmachine->xmachine_Mall = NULL;
		current_xmachine->xmachine_IGFirm = NULL;
		current_xmachine->xmachine_Eurostat = NULL;
		current_xmachine->xmachine_Bank = NULL;
		current_xmachine->xmachine_Government = NULL;
		current_xmachine->xmachine_CentralBank = NULL;
		current_xmachine->xmachine_ClearingHouse = NULL;
		current_xmachine->xmachine_ClearingHouse = current_xmachine_ClearingHouse;

		

		

			i = ClearingHouse_send_transaction_info();

		

			if(i == 1)
			{
				free_ClearingHouse_agent(current_xmachine_ClearingHouse_holder, ClearingHouse_AFM_03_state);
			}
			else
			{
				transition_ClearingHouse_agent(current_xmachine_ClearingHouse_holder, ClearingHouse_AFM_03_state, ClearingHouse_AFM_04_state);
			}
		

		current_xmachine_ClearingHouse = NULL;

		current_xmachine_ClearingHouse_holder = temp_xmachine_ClearingHouse_holder;
	}
	if(FLAME_TEST_PRINT_START_AND_END_OF_MODEL_FUNCTIONS) printf("finish ClearingHouse_send_transaction_info\n");

	if(FLAME_order_status_message_board_write == 1)
	{

		if(FLAME_TEST_PRINT_START_AND_END_OF_LIBMBOARD_CALLS) printf("start MB_SyncStart(b_order_status)\n");
		rc = MB_SyncStart(b_order_status);
		if(FLAME_TEST_PRINT_START_AND_END_OF_LIBMBOARD_CALLS) printf("finish MB_SyncStart(b_order_status)\n");
		#ifdef ERRCHECK
		if (rc != MB_SUCCESS)
		{
		   fprintf(stderr, "ERROR: Could not start sync of 'order_status' board\n");
		   switch(rc) {
			   case MB_ERR_INVALID:
				   fprintf(stderr, "\t reason: 'order_status' board is invalid\n");
				   break;
			   case MB_ERR_LOCKED:
				   fprintf(stderr, "\t reason: 'order_status' board is locked\n");
				   break;
			   case MB_ERR_MEMALLOC:
				   fprintf(stderr, "\t reason: out of memory\n");
				   break;
			   case MB_ERR_INTERNAL:
				   fprintf(stderr, "\t reason: internal error. Recompile libmoard in debug mode for more info \n");
				   break;
			   default:
				   fprintf(stderr, "\t MB_SyncStart returned error code: %d (see libmboard docs for details)\n", rc);
				   break;
		   }

			
			exit(rc);
		}
		#endif
    }
    


	if(FLAME_TEST_PRINT_START_AND_END_OF_MODEL_FUNCTIONS) printf("start Firm_clean_up_arrays\n");
	current_xmachine_Firm_holder = Firm_MR_6_state->agents;
	while(current_xmachine_Firm_holder)
	{
		temp_xmachine_Firm_holder = current_xmachine_Firm_holder->next;
		current_xmachine_Firm = current_xmachine_Firm_holder->agent;
		current_xmachine_Firm_next_state = Firm_Firm_Start_Producer_Role_state;
		/* For backwards compatibility set current_xmachine */
		current_xmachine->xmachine_Firm = NULL;
		current_xmachine->xmachine_Household = NULL;
		current_xmachine->xmachine_Mall = NULL;
		current_xmachine->xmachine_IGFirm = NULL;
		current_xmachine->xmachine_Eurostat = NULL;
		current_xmachine->xmachine_Bank = NULL;
		current_xmachine->xmachine_Government = NULL;
		current_xmachine->xmachine_CentralBank = NULL;
		current_xmachine->xmachine_ClearingHouse = NULL;
		current_xmachine->xmachine_Firm = current_xmachine_Firm;

		

		

			i = Firm_clean_up_arrays();

		

			if(i == 1)
			{
				free_Firm_agent(current_xmachine_Firm_holder, Firm_MR_6_state);
			}
			else
			{
				transition_Firm_agent(current_xmachine_Firm_holder, Firm_MR_6_state, Firm_Firm_Start_Producer_Role_state);
			}
		

		current_xmachine_Firm = NULL;

		current_xmachine_Firm_holder = temp_xmachine_Firm_holder;
	}
	if(FLAME_TEST_PRINT_START_AND_END_OF_MODEL_FUNCTIONS) printf("finish Firm_clean_up_arrays\n");


/* End of layer number 27 */

/* Clear message boards that have finished being used
 * and sync complete if doing late sync complete */


	if(FLAME_TEST_PRINT_START_AND_END_OF_MODEL_FUNCTIONS) printf("start Firm_set_quantities_zero\n");
	current_xmachine_Firm_holder = Firm_Firm_Start_Producer_Role_state->agents;
	while(current_xmachine_Firm_holder)
	{
		temp_xmachine_Firm_holder = current_xmachine_Firm_holder->next;
		current_xmachine_Firm = current_xmachine_Firm_holder->agent;
		current_xmachine_Firm_next_state = Firm_00b_state;
		/* For backwards compatibility set current_xmachine */
		current_xmachine->xmachine_Firm = NULL;
		current_xmachine->xmachine_Household = NULL;
		current_xmachine->xmachine_Mall = NULL;
		current_xmachine->xmachine_IGFirm = NULL;
		current_xmachine->xmachine_Eurostat = NULL;
		current_xmachine->xmachine_Bank = NULL;
		current_xmachine->xmachine_Government = NULL;
		current_xmachine->xmachine_CentralBank = NULL;
		current_xmachine->xmachine_ClearingHouse = NULL;
		current_xmachine->xmachine_Firm = current_xmachine_Firm;

		if(FLAME_condition_Firm_Firm_set_quantities_zero_Firm_Start_Producer_Role_00b(current_xmachine_Firm)==1)
		{

		

			i = Firm_set_quantities_zero();

		

			if(i == 1)
			{
				free_Firm_agent(current_xmachine_Firm_holder, Firm_Firm_Start_Producer_Role_state);
			}
			else
			{
				transition_Firm_agent(current_xmachine_Firm_holder, Firm_Firm_Start_Producer_Role_state, Firm_00b_state);
			}
		}

		current_xmachine_Firm = NULL;

		current_xmachine_Firm_holder = temp_xmachine_Firm_holder;
	}
	if(FLAME_TEST_PRINT_START_AND_END_OF_MODEL_FUNCTIONS) printf("finish Firm_set_quantities_zero\n");


	if(FLAME_TEST_PRINT_START_AND_END_OF_MODEL_FUNCTIONS) printf("start Firm_calc_production_quantity\n");
	current_xmachine_Firm_holder = Firm_Firm_Start_Producer_Role_state->agents;
	while(current_xmachine_Firm_holder)
	{
		temp_xmachine_Firm_holder = current_xmachine_Firm_holder->next;
		current_xmachine_Firm = current_xmachine_Firm_holder->agent;
		current_xmachine_Firm_next_state = Firm_01_state;
		/* For backwards compatibility set current_xmachine */
		current_xmachine->xmachine_Firm = NULL;
		current_xmachine->xmachine_Household = NULL;
		current_xmachine->xmachine_Mall = NULL;
		current_xmachine->xmachine_IGFirm = NULL;
		current_xmachine->xmachine_Eurostat = NULL;
		current_xmachine->xmachine_Bank = NULL;
		current_xmachine->xmachine_Government = NULL;
		current_xmachine->xmachine_CentralBank = NULL;
		current_xmachine->xmachine_ClearingHouse = NULL;
		current_xmachine->xmachine_Firm = current_xmachine_Firm;

		if(FLAME_condition_Firm_Firm_calc_production_quantity_Firm_Start_Producer_Role_01(current_xmachine_Firm)==1)
		{

		

			i = Firm_calc_production_quantity();

		

			if(i == 1)
			{
				free_Firm_agent(current_xmachine_Firm_holder, Firm_Firm_Start_Producer_Role_state);
			}
			else
			{
				transition_Firm_agent(current_xmachine_Firm_holder, Firm_Firm_Start_Producer_Role_state, Firm_01_state);
			}
		}

		current_xmachine_Firm = NULL;

		current_xmachine_Firm_holder = temp_xmachine_Firm_holder;
	}
	if(FLAME_TEST_PRINT_START_AND_END_OF_MODEL_FUNCTIONS) printf("finish Firm_calc_production_quantity\n");


	/* If mb is not read then leave sync complete until last possible moment */
	if(FLAME_order_status_message_board_read == 1)
	{
		if(FLAME_TEST_PRINT_START_AND_END_OF_LIBMBOARD_CALLS) printf("start MB_SyncComplete(b_order_status)\n");
		rc = MB_SyncComplete(b_order_status);
		if(FLAME_TEST_PRINT_START_AND_END_OF_LIBMBOARD_CALLS) printf("finsh MB_SyncComplete(b_order_status)\n");
		#ifdef ERRCHECK
		if (rc != MB_SUCCESS)
		{
		   fprintf(stderr, "ERROR: Could not complete sync of 'order_status' board\n");
		   switch(rc) {
				case MB_ERR_INVALID:
				   fprintf(stderr, "\t reason: 'order_status' board is invalid\n");
				   break;
			   case MB_ERR_MEMALLOC:
				   fprintf(stderr, "\t reason: out of memory\n");
				   break;
			   case MB_ERR_INTERNAL:
				   fprintf(stderr, "\t reason: internal error. Recompile libmoard in debug mode for more info \n");
				   break;
			   default:
				   fprintf(stderr, "\t MB_SyncComplete returned error code: %d (see libmboard docs for details)\n", rc);
				   break;
		   }
	
		   
		   exit(rc);
		}
		#endif
    
	}
	
	if(FLAME_TEST_PRINT_START_AND_END_OF_MODEL_FUNCTIONS) printf("start Household_update_portfolio\n");
	current_xmachine_Household_holder = Household_AFM_002_state->agents;
	while(current_xmachine_Household_holder)
	{
		temp_xmachine_Household_holder = current_xmachine_Household_holder->next;
		current_xmachine_Household = current_xmachine_Household_holder->agent;
		current_xmachine_Household_next_state = Household_Household_Start_Labour_Role_state;
		/* For backwards compatibility set current_xmachine */
		current_xmachine->xmachine_Firm = NULL;
		current_xmachine->xmachine_Household = NULL;
		current_xmachine->xmachine_Mall = NULL;
		current_xmachine->xmachine_IGFirm = NULL;
		current_xmachine->xmachine_Eurostat = NULL;
		current_xmachine->xmachine_Bank = NULL;
		current_xmachine->xmachine_Government = NULL;
		current_xmachine->xmachine_CentralBank = NULL;
		current_xmachine->xmachine_ClearingHouse = NULL;
		current_xmachine->xmachine_Household = current_xmachine_Household;

		

		
		rc = MB_Iterator_CreateFiltered(b_order_status, &i_order_status, &FLAME_filter_Household_Household_update_portfolio_AFM_002_Household_Start_Labour_Role_order_status, current_xmachine_Household);
		
		#ifdef ERRCHECK
		if (rc != MB_SUCCESS)
		{
		   fprintf(stderr, "ERROR: Could not create Iterator for 'order_status'\n");
		   switch(rc) {
		       case MB_ERR_INVALID:
		           fprintf(stderr, "\t reason: 'order_status' board is invalid\n");
		           break;
		       case MB_ERR_LOCKED:
	               fprintf(stderr, "\t reason: 'order_status' board is locked\n");
	               break;
	           case MB_ERR_MEMALLOC:
	               fprintf(stderr, "\t reason: out of memory\n");
	               break;
	           case MB_ERR_INTERNAL:
	               fprintf(stderr, "\t reason: internal error. Recompile libmoard in debug mode for more info \n");
	               break;
	           default:
	           
                   fprintf(stderr, "\t MB_Iterator_CreateFiltered returned error code: %d (see libmboard docs for details)\n", rc);
               
               
                   break;
		   }

		   
           exit(rc);
		}
		#endif
		
		

			i = Household_update_portfolio();

		
		    rc = MB_Iterator_Delete(&i_order_status);
		    #ifdef ERRCHECK
		    if (rc != MB_SUCCESS)
		    {
		       fprintf(stderr, "ERROR: Could not delete 'order_status' iterator\n");
		       switch(rc) {
		           case MB_ERR_INVALID:
		               fprintf(stderr, "\t reason: 'order_status' iterator is invalid\n");
		               break;
		           case MB_ERR_INTERNAL:
		               fprintf(stderr, "\t reason: internal error. Recompile libmoard in debug mode for more info \n");
		               break;
		           default:
                       fprintf(stderr, "\t MB_Iterator_Delete returned error code: %d (see libmboard docs for details)\n", rc);
                       break;
		       }

		       
               exit(rc);
		    }
		    #endif
		

			if(i == 1)
			{
				free_Household_agent(current_xmachine_Household_holder, Household_AFM_002_state);
			}
			else
			{
				transition_Household_agent(current_xmachine_Household_holder, Household_AFM_002_state, Household_Household_Start_Labour_Role_state);
			}
		

		current_xmachine_Household = NULL;

		current_xmachine_Household_holder = temp_xmachine_Household_holder;
	}
	if(FLAME_TEST_PRINT_START_AND_END_OF_MODEL_FUNCTIONS) printf("finish Household_update_portfolio\n");


/* End of layer number 28 */

/* Clear message boards that have finished being used
 * and sync complete if doing late sync complete */

if(FLAME_order_status_message_board_read == 0)
{
	/*printf("%d> order_status message board sync complete late as no agents reading any messages of this type\n", node_number);*/
	
	if(FLAME_TEST_PRINT_START_AND_END_OF_LIBMBOARD_CALLS) printf("start MB_SyncComplete(b_order_status)\n");
	rc = MB_SyncComplete(b_order_status);
	if(FLAME_TEST_PRINT_START_AND_END_OF_LIBMBOARD_CALLS) printf("finsh MB_SyncComplete(b_order_status)\n");
	#ifdef ERRCHECK
	if (rc != MB_SUCCESS)
	{
	   fprintf(stderr, "ERROR: Could not complete sync of 'order_status' board\n");
	   switch(rc) {
			case MB_ERR_INVALID:
			   fprintf(stderr, "\t reason: 'order_status' board is invalid\n");
			   break;
		   case MB_ERR_MEMALLOC:
			   fprintf(stderr, "\t reason: out of memory\n");
			   break;
		   case MB_ERR_INTERNAL:
			   fprintf(stderr, "\t reason: internal error. Recompile libmoard in debug mode for more info \n");
			   break;
		   default:
			   fprintf(stderr, "\t MB_SyncComplete returned error code: %d (see libmboard docs for details)\n", rc);
			   break;
	   }

	   
	   exit(rc);
	}
	#endif
}

    rc = MB_Clear(b_order_status);
    #ifdef ERRCHECK
    if (rc != MB_SUCCESS)
    {
       fprintf(stderr, "ERROR: Could not clear 'order_status' board\n");
       switch(rc) {
           case MB_ERR_INVALID:
               fprintf(stderr, "\t reason: 'order_status' board is invalid\n");
               break;
           case MB_ERR_LOCKED:
               fprintf(stderr, "\t reason: 'order_status' board is locked\n");
               break;
           case MB_ERR_INTERNAL:
               fprintf(stderr, "\t reason: internal error. Recompile libmoard in debug mode for more info \n");
               break;
           default:
               fprintf(stderr, "\t MB_Clear returned error code: %d (see libmboard docs for details)\n", rc);
               break;

       }

       
       exit(rc);
    }
    #endif


	if(FLAME_TEST_PRINT_START_AND_END_OF_MODEL_FUNCTIONS) printf("start Household_idle\n");
	current_xmachine_Household_holder = Household_Household_Start_Labour_Role_state->agents;
	while(current_xmachine_Household_holder)
	{
		temp_xmachine_Household_holder = current_xmachine_Household_holder->next;
		current_xmachine_Household = current_xmachine_Household_holder->agent;
		current_xmachine_Household_next_state = Household_01a_state;
		/* For backwards compatibility set current_xmachine */
		current_xmachine->xmachine_Firm = NULL;
		current_xmachine->xmachine_Household = NULL;
		current_xmachine->xmachine_Mall = NULL;
		current_xmachine->xmachine_IGFirm = NULL;
		current_xmachine->xmachine_Eurostat = NULL;
		current_xmachine->xmachine_Bank = NULL;
		current_xmachine->xmachine_Government = NULL;
		current_xmachine->xmachine_CentralBank = NULL;
		current_xmachine->xmachine_ClearingHouse = NULL;
		current_xmachine->xmachine_Household = current_xmachine_Household;

		if(FLAME_condition_Household_Household_idle_Household_Start_Labour_Role_01a(current_xmachine_Household)==1)
		{

		

			i = Household_idle();

		

			if(i == 1)
			{
				free_Household_agent(current_xmachine_Household_holder, Household_Household_Start_Labour_Role_state);
			}
			else
			{
				transition_Household_agent(current_xmachine_Household_holder, Household_Household_Start_Labour_Role_state, Household_01a_state);
			}
		}

		current_xmachine_Household = NULL;

		current_xmachine_Household_holder = temp_xmachine_Household_holder;
	}
	if(FLAME_TEST_PRINT_START_AND_END_OF_MODEL_FUNCTIONS) printf("finish Household_idle\n");


	if(FLAME_TEST_PRINT_START_AND_END_OF_MODEL_FUNCTIONS) printf("start Firm_calc_input_demands\n");
	current_xmachine_Firm_holder = Firm_01_state->agents;
	while(current_xmachine_Firm_holder)
	{
		temp_xmachine_Firm_holder = current_xmachine_Firm_holder->next;
		current_xmachine_Firm = current_xmachine_Firm_holder->agent;
		current_xmachine_Firm_next_state = Firm_02_state;
		/* For backwards compatibility set current_xmachine */
		current_xmachine->xmachine_Firm = NULL;
		current_xmachine->xmachine_Household = NULL;
		current_xmachine->xmachine_Mall = NULL;
		current_xmachine->xmachine_IGFirm = NULL;
		current_xmachine->xmachine_Eurostat = NULL;
		current_xmachine->xmachine_Bank = NULL;
		current_xmachine->xmachine_Government = NULL;
		current_xmachine->xmachine_CentralBank = NULL;
		current_xmachine->xmachine_ClearingHouse = NULL;
		current_xmachine->xmachine_Firm = current_xmachine_Firm;

		

		
		
		MB_Iterator_CreateSorted(b_productivity, &i_productivity, &FLAME_sort_Firm_Firm_calc_input_demands_01_02_productivity);
		#ifdef ERRCHECK
		if (rc != MB_SUCCESS)
		{
		   fprintf(stderr, "ERROR: Could not create Iterator for 'productivity'\n");
		   switch(rc) {
		       case MB_ERR_INVALID:
		           fprintf(stderr, "\t reason: 'productivity' board is invalid\n");
		           break;
		       case MB_ERR_LOCKED:
	               fprintf(stderr, "\t reason: 'productivity' board is locked\n");
	               break;
	           case MB_ERR_MEMALLOC:
	               fprintf(stderr, "\t reason: out of memory\n");
	               break;
	           case MB_ERR_INTERNAL:
	               fprintf(stderr, "\t reason: internal error. Recompile libmoard in debug mode for more info \n");
	               break;
	           default:
	           
               
                   fprintf(stderr, "\t MB_Iterator_Create returned error code: %d (see libmboard docs for details)\n", rc);
               
                   break;
		   }

		   
           exit(rc);
		}
		#endif
		
		

			i = Firm_calc_input_demands();

		
		    rc = MB_Iterator_Delete(&i_productivity);
		    #ifdef ERRCHECK
		    if (rc != MB_SUCCESS)
		    {
		       fprintf(stderr, "ERROR: Could not delete 'productivity' iterator\n");
		       switch(rc) {
		           case MB_ERR_INVALID:
		               fprintf(stderr, "\t reason: 'productivity' iterator is invalid\n");
		               break;
		           case MB_ERR_INTERNAL:
		               fprintf(stderr, "\t reason: internal error. Recompile libmoard in debug mode for more info \n");
		               break;
		           default:
                       fprintf(stderr, "\t MB_Iterator_Delete returned error code: %d (see libmboard docs for details)\n", rc);
                       break;
		       }

		       
               exit(rc);
		    }
		    #endif
		

			if(i == 1)
			{
				free_Firm_agent(current_xmachine_Firm_holder, Firm_01_state);
			}
			else
			{
				transition_Firm_agent(current_xmachine_Firm_holder, Firm_01_state, Firm_02_state);
			}
		

		current_xmachine_Firm = NULL;

		current_xmachine_Firm_holder = temp_xmachine_Firm_holder;
	}
	if(FLAME_TEST_PRINT_START_AND_END_OF_MODEL_FUNCTIONS) printf("finish Firm_calc_input_demands\n");


/* End of layer number 29 */

/* Clear message boards that have finished being used
 * and sync complete if doing late sync complete */

if(FLAME_productivity_message_board_read == 0)
{
	/*printf("%d> productivity message board sync complete late as no agents reading any messages of this type\n", node_number);*/
	
	if(FLAME_TEST_PRINT_START_AND_END_OF_LIBMBOARD_CALLS) printf("start MB_SyncComplete(b_productivity)\n");
	rc = MB_SyncComplete(b_productivity);
	if(FLAME_TEST_PRINT_START_AND_END_OF_LIBMBOARD_CALLS) printf("finsh MB_SyncComplete(b_productivity)\n");
	#ifdef ERRCHECK
	if (rc != MB_SUCCESS)
	{
	   fprintf(stderr, "ERROR: Could not complete sync of 'productivity' board\n");
	   switch(rc) {
			case MB_ERR_INVALID:
			   fprintf(stderr, "\t reason: 'productivity' board is invalid\n");
			   break;
		   case MB_ERR_MEMALLOC:
			   fprintf(stderr, "\t reason: out of memory\n");
			   break;
		   case MB_ERR_INTERNAL:
			   fprintf(stderr, "\t reason: internal error. Recompile libmoard in debug mode for more info \n");
			   break;
		   default:
			   fprintf(stderr, "\t MB_SyncComplete returned error code: %d (see libmboard docs for details)\n", rc);
			   break;
	   }

	   
	   exit(rc);
	}
	#endif
}

    rc = MB_Clear(b_productivity);
    #ifdef ERRCHECK
    if (rc != MB_SUCCESS)
    {
       fprintf(stderr, "ERROR: Could not clear 'productivity' board\n");
       switch(rc) {
           case MB_ERR_INVALID:
               fprintf(stderr, "\t reason: 'productivity' board is invalid\n");
               break;
           case MB_ERR_LOCKED:
               fprintf(stderr, "\t reason: 'productivity' board is locked\n");
               break;
           case MB_ERR_INTERNAL:
               fprintf(stderr, "\t reason: internal error. Recompile libmoard in debug mode for more info \n");
               break;
           default:
               fprintf(stderr, "\t MB_Clear returned error code: %d (see libmboard docs for details)\n", rc);
               break;

       }

       
       exit(rc);
    }
    #endif


	if(FLAME_TEST_PRINT_START_AND_END_OF_MODEL_FUNCTIONS) printf("start Firm_compute_total_liquidity_needs\n");
	current_xmachine_Firm_holder = Firm_02_state->agents;
	while(current_xmachine_Firm_holder)
	{
		temp_xmachine_Firm_holder = current_xmachine_Firm_holder->next;
		current_xmachine_Firm = current_xmachine_Firm_holder->agent;
		current_xmachine_Firm_next_state = Firm_02b_state;
		/* For backwards compatibility set current_xmachine */
		current_xmachine->xmachine_Firm = NULL;
		current_xmachine->xmachine_Household = NULL;
		current_xmachine->xmachine_Mall = NULL;
		current_xmachine->xmachine_IGFirm = NULL;
		current_xmachine->xmachine_Eurostat = NULL;
		current_xmachine->xmachine_Bank = NULL;
		current_xmachine->xmachine_Government = NULL;
		current_xmachine->xmachine_CentralBank = NULL;
		current_xmachine->xmachine_ClearingHouse = NULL;
		current_xmachine->xmachine_Firm = current_xmachine_Firm;

		

		

			i = Firm_compute_total_liquidity_needs();

		

			if(i == 1)
			{
				free_Firm_agent(current_xmachine_Firm_holder, Firm_02_state);
			}
			else
			{
				transition_Firm_agent(current_xmachine_Firm_holder, Firm_02_state, Firm_02b_state);
			}
		

		current_xmachine_Firm = NULL;

		current_xmachine_Firm_holder = temp_xmachine_Firm_holder;
	}
	if(FLAME_TEST_PRINT_START_AND_END_OF_MODEL_FUNCTIONS) printf("finish Firm_compute_total_liquidity_needs\n");


/* End of layer number 30 */

/* Clear message boards that have finished being used
 * and sync complete if doing late sync complete */


	if(FLAME_TEST_PRINT_START_AND_END_OF_MODEL_FUNCTIONS) printf("start Firm_check_minsky_class\n");
	current_xmachine_Firm_holder = Firm_02b_state->agents;
	while(current_xmachine_Firm_holder)
	{
		temp_xmachine_Firm_holder = current_xmachine_Firm_holder->next;
		current_xmachine_Firm = current_xmachine_Firm_holder->agent;
		current_xmachine_Firm_next_state = Firm_Firm_Start_Credit_Role_state;
		/* For backwards compatibility set current_xmachine */
		current_xmachine->xmachine_Firm = NULL;
		current_xmachine->xmachine_Household = NULL;
		current_xmachine->xmachine_Mall = NULL;
		current_xmachine->xmachine_IGFirm = NULL;
		current_xmachine->xmachine_Eurostat = NULL;
		current_xmachine->xmachine_Bank = NULL;
		current_xmachine->xmachine_Government = NULL;
		current_xmachine->xmachine_CentralBank = NULL;
		current_xmachine->xmachine_ClearingHouse = NULL;
		current_xmachine->xmachine_Firm = current_xmachine_Firm;

		

		

			i = Firm_check_minsky_class();

		

			if(i == 1)
			{
				free_Firm_agent(current_xmachine_Firm_holder, Firm_02b_state);
			}
			else
			{
				transition_Firm_agent(current_xmachine_Firm_holder, Firm_02b_state, Firm_Firm_Start_Credit_Role_state);
			}
		

		current_xmachine_Firm = NULL;

		current_xmachine_Firm_holder = temp_xmachine_Firm_holder;
	}
	if(FLAME_TEST_PRINT_START_AND_END_OF_MODEL_FUNCTIONS) printf("finish Firm_check_minsky_class\n");


/* End of layer number 31 */

/* Clear message boards that have finished being used
 * and sync complete if doing late sync complete */


	if(FLAME_TEST_PRINT_START_AND_END_OF_MODEL_FUNCTIONS) printf("start idle\n");
	current_xmachine_Firm_holder = Firm_Firm_Start_Credit_Role_state->agents;
	while(current_xmachine_Firm_holder)
	{
		temp_xmachine_Firm_holder = current_xmachine_Firm_holder->next;
		current_xmachine_Firm = current_xmachine_Firm_holder->agent;
		current_xmachine_Firm_next_state = Firm_Firm_End_External_Financing_state;
		/* For backwards compatibility set current_xmachine */
		current_xmachine->xmachine_Firm = NULL;
		current_xmachine->xmachine_Household = NULL;
		current_xmachine->xmachine_Mall = NULL;
		current_xmachine->xmachine_IGFirm = NULL;
		current_xmachine->xmachine_Eurostat = NULL;
		current_xmachine->xmachine_Bank = NULL;
		current_xmachine->xmachine_Government = NULL;
		current_xmachine->xmachine_CentralBank = NULL;
		current_xmachine->xmachine_ClearingHouse = NULL;
		current_xmachine->xmachine_Firm = current_xmachine_Firm;

		if(FLAME_condition_Firm_idle_Firm_Start_Credit_Role_Firm_End_External_Financing(current_xmachine_Firm)==1)
		{

		

			i = idle();

		

			if(i == 1)
			{
				free_Firm_agent(current_xmachine_Firm_holder, Firm_Firm_Start_Credit_Role_state);
			}
			else
			{
				transition_Firm_agent(current_xmachine_Firm_holder, Firm_Firm_Start_Credit_Role_state, Firm_Firm_End_External_Financing_state);
			}
		}

		current_xmachine_Firm = NULL;

		current_xmachine_Firm_holder = temp_xmachine_Firm_holder;
	}
	if(FLAME_TEST_PRINT_START_AND_END_OF_MODEL_FUNCTIONS) printf("finish idle\n");


	/* If mb is not read then leave sync complete until last possible moment */
	if(FLAME_bank_identity_message_board_read == 1)
	{
		if(FLAME_TEST_PRINT_START_AND_END_OF_LIBMBOARD_CALLS) printf("start MB_SyncComplete(b_bank_identity)\n");
		rc = MB_SyncComplete(b_bank_identity);
		if(FLAME_TEST_PRINT_START_AND_END_OF_LIBMBOARD_CALLS) printf("finsh MB_SyncComplete(b_bank_identity)\n");
		#ifdef ERRCHECK
		if (rc != MB_SUCCESS)
		{
		   fprintf(stderr, "ERROR: Could not complete sync of 'bank_identity' board\n");
		   switch(rc) {
				case MB_ERR_INVALID:
				   fprintf(stderr, "\t reason: 'bank_identity' board is invalid\n");
				   break;
			   case MB_ERR_MEMALLOC:
				   fprintf(stderr, "\t reason: out of memory\n");
				   break;
			   case MB_ERR_INTERNAL:
				   fprintf(stderr, "\t reason: internal error. Recompile libmoard in debug mode for more info \n");
				   break;
			   default:
				   fprintf(stderr, "\t MB_SyncComplete returned error code: %d (see libmboard docs for details)\n", rc);
				   break;
		   }
	
		   
		   exit(rc);
		}
		#endif
    
	}
	
	if(FLAME_TEST_PRINT_START_AND_END_OF_MODEL_FUNCTIONS) printf("start Firm_ask_loan\n");
	current_xmachine_Firm_holder = Firm_Firm_Start_Credit_Role_state->agents;
	while(current_xmachine_Firm_holder)
	{
		temp_xmachine_Firm_holder = current_xmachine_Firm_holder->next;
		current_xmachine_Firm = current_xmachine_Firm_holder->agent;
		current_xmachine_Firm_next_state = Firm_Firm_Credit_02_state;
		/* For backwards compatibility set current_xmachine */
		current_xmachine->xmachine_Firm = NULL;
		current_xmachine->xmachine_Household = NULL;
		current_xmachine->xmachine_Mall = NULL;
		current_xmachine->xmachine_IGFirm = NULL;
		current_xmachine->xmachine_Eurostat = NULL;
		current_xmachine->xmachine_Bank = NULL;
		current_xmachine->xmachine_Government = NULL;
		current_xmachine->xmachine_CentralBank = NULL;
		current_xmachine->xmachine_ClearingHouse = NULL;
		current_xmachine->xmachine_Firm = current_xmachine_Firm;

		if(FLAME_condition_Firm_Firm_ask_loan_Firm_Start_Credit_Role_Firm_Credit_02(current_xmachine_Firm)==1)
		{

		
		
		rc = MB_Iterator_Create(b_bank_identity, &i_bank_identity);
		#ifdef ERRCHECK
		if (rc != MB_SUCCESS)
		{
		   fprintf(stderr, "ERROR: Could not create Iterator for 'bank_identity'\n");
		   switch(rc) {
		       case MB_ERR_INVALID:
		           fprintf(stderr, "\t reason: 'bank_identity' board is invalid\n");
		           break;
		       case MB_ERR_LOCKED:
	               fprintf(stderr, "\t reason: 'bank_identity' board is locked\n");
	               break;
	           case MB_ERR_MEMALLOC:
	               fprintf(stderr, "\t reason: out of memory\n");
	               break;
	           case MB_ERR_INTERNAL:
	               fprintf(stderr, "\t reason: internal error. Recompile libmoard in debug mode for more info \n");
	               break;
	           default:
	           
               
                   fprintf(stderr, "\t MB_Iterator_Create returned error code: %d (see libmboard docs for details)\n", rc);
               
                   break;
		   }

		   
           exit(rc);
		}
		#endif
		
		

			i = Firm_ask_loan();

		
		    rc = MB_Iterator_Delete(&i_bank_identity);
		    #ifdef ERRCHECK
		    if (rc != MB_SUCCESS)
		    {
		       fprintf(stderr, "ERROR: Could not delete 'bank_identity' iterator\n");
		       switch(rc) {
		           case MB_ERR_INVALID:
		               fprintf(stderr, "\t reason: 'bank_identity' iterator is invalid\n");
		               break;
		           case MB_ERR_INTERNAL:
		               fprintf(stderr, "\t reason: internal error. Recompile libmoard in debug mode for more info \n");
		               break;
		           default:
                       fprintf(stderr, "\t MB_Iterator_Delete returned error code: %d (see libmboard docs for details)\n", rc);
                       break;
		       }

		       
               exit(rc);
		    }
		    #endif
		

			if(i == 1)
			{
				free_Firm_agent(current_xmachine_Firm_holder, Firm_Firm_Start_Credit_Role_state);
			}
			else
			{
				transition_Firm_agent(current_xmachine_Firm_holder, Firm_Firm_Start_Credit_Role_state, Firm_Firm_Credit_02_state);
			}
		}

		current_xmachine_Firm = NULL;

		current_xmachine_Firm_holder = temp_xmachine_Firm_holder;
	}
	if(FLAME_TEST_PRINT_START_AND_END_OF_MODEL_FUNCTIONS) printf("finish Firm_ask_loan\n");

	if(FLAME_loan_request_message_board_write == 1)
	{

		if(FLAME_TEST_PRINT_START_AND_END_OF_LIBMBOARD_CALLS) printf("start MB_SyncStart(b_loan_request)\n");
		rc = MB_SyncStart(b_loan_request);
		if(FLAME_TEST_PRINT_START_AND_END_OF_LIBMBOARD_CALLS) printf("finish MB_SyncStart(b_loan_request)\n");
		#ifdef ERRCHECK
		if (rc != MB_SUCCESS)
		{
		   fprintf(stderr, "ERROR: Could not start sync of 'loan_request' board\n");
		   switch(rc) {
			   case MB_ERR_INVALID:
				   fprintf(stderr, "\t reason: 'loan_request' board is invalid\n");
				   break;
			   case MB_ERR_LOCKED:
				   fprintf(stderr, "\t reason: 'loan_request' board is locked\n");
				   break;
			   case MB_ERR_MEMALLOC:
				   fprintf(stderr, "\t reason: out of memory\n");
				   break;
			   case MB_ERR_INTERNAL:
				   fprintf(stderr, "\t reason: internal error. Recompile libmoard in debug mode for more info \n");
				   break;
			   default:
				   fprintf(stderr, "\t MB_SyncStart returned error code: %d (see libmboard docs for details)\n", rc);
				   break;
		   }

			
			exit(rc);
		}
		#endif
    }
    


/* End of layer number 32 */

/* Clear message boards that have finished being used
 * and sync complete if doing late sync complete */

if(FLAME_bank_identity_message_board_read == 0)
{
	/*printf("%d> bank_identity message board sync complete late as no agents reading any messages of this type\n", node_number);*/
	
	if(FLAME_TEST_PRINT_START_AND_END_OF_LIBMBOARD_CALLS) printf("start MB_SyncComplete(b_bank_identity)\n");
	rc = MB_SyncComplete(b_bank_identity);
	if(FLAME_TEST_PRINT_START_AND_END_OF_LIBMBOARD_CALLS) printf("finsh MB_SyncComplete(b_bank_identity)\n");
	#ifdef ERRCHECK
	if (rc != MB_SUCCESS)
	{
	   fprintf(stderr, "ERROR: Could not complete sync of 'bank_identity' board\n");
	   switch(rc) {
			case MB_ERR_INVALID:
			   fprintf(stderr, "\t reason: 'bank_identity' board is invalid\n");
			   break;
		   case MB_ERR_MEMALLOC:
			   fprintf(stderr, "\t reason: out of memory\n");
			   break;
		   case MB_ERR_INTERNAL:
			   fprintf(stderr, "\t reason: internal error. Recompile libmoard in debug mode for more info \n");
			   break;
		   default:
			   fprintf(stderr, "\t MB_SyncComplete returned error code: %d (see libmboard docs for details)\n", rc);
			   break;
	   }

	   
	   exit(rc);
	}
	#endif
}

    rc = MB_Clear(b_bank_identity);
    #ifdef ERRCHECK
    if (rc != MB_SUCCESS)
    {
       fprintf(stderr, "ERROR: Could not clear 'bank_identity' board\n");
       switch(rc) {
           case MB_ERR_INVALID:
               fprintf(stderr, "\t reason: 'bank_identity' board is invalid\n");
               break;
           case MB_ERR_LOCKED:
               fprintf(stderr, "\t reason: 'bank_identity' board is locked\n");
               break;
           case MB_ERR_INTERNAL:
               fprintf(stderr, "\t reason: internal error. Recompile libmoard in debug mode for more info \n");
               break;
           default:
               fprintf(stderr, "\t MB_Clear returned error code: %d (see libmboard docs for details)\n", rc);
               break;

       }

       
       exit(rc);
    }
    #endif


	/* If mb is not read then leave sync complete until last possible moment */
	if(FLAME_loan_request_message_board_read == 1)
	{
		if(FLAME_TEST_PRINT_START_AND_END_OF_LIBMBOARD_CALLS) printf("start MB_SyncComplete(b_loan_request)\n");
		rc = MB_SyncComplete(b_loan_request);
		if(FLAME_TEST_PRINT_START_AND_END_OF_LIBMBOARD_CALLS) printf("finsh MB_SyncComplete(b_loan_request)\n");
		#ifdef ERRCHECK
		if (rc != MB_SUCCESS)
		{
		   fprintf(stderr, "ERROR: Could not complete sync of 'loan_request' board\n");
		   switch(rc) {
				case MB_ERR_INVALID:
				   fprintf(stderr, "\t reason: 'loan_request' board is invalid\n");
				   break;
			   case MB_ERR_MEMALLOC:
				   fprintf(stderr, "\t reason: out of memory\n");
				   break;
			   case MB_ERR_INTERNAL:
				   fprintf(stderr, "\t reason: internal error. Recompile libmoard in debug mode for more info \n");
				   break;
			   default:
				   fprintf(stderr, "\t MB_SyncComplete returned error code: %d (see libmboard docs for details)\n", rc);
				   break;
		   }
	
		   
		   exit(rc);
		}
		#endif
    
	}
	
	if(FLAME_TEST_PRINT_START_AND_END_OF_MODEL_FUNCTIONS) printf("start Bank_rank_credit_requests\n");
	current_xmachine_Bank_holder = Bank_Bank_02_state->agents;
	while(current_xmachine_Bank_holder)
	{
		temp_xmachine_Bank_holder = current_xmachine_Bank_holder->next;
		current_xmachine_Bank = current_xmachine_Bank_holder->agent;
		current_xmachine_Bank_next_state = Bank_Bank_021_state;
		/* For backwards compatibility set current_xmachine */
		current_xmachine->xmachine_Firm = NULL;
		current_xmachine->xmachine_Household = NULL;
		current_xmachine->xmachine_Mall = NULL;
		current_xmachine->xmachine_IGFirm = NULL;
		current_xmachine->xmachine_Eurostat = NULL;
		current_xmachine->xmachine_Bank = NULL;
		current_xmachine->xmachine_Government = NULL;
		current_xmachine->xmachine_CentralBank = NULL;
		current_xmachine->xmachine_ClearingHouse = NULL;
		current_xmachine->xmachine_Bank = current_xmachine_Bank;

		if(FLAME_condition_Bank_Bank_rank_credit_requests_Bank_02_Bank_021(current_xmachine_Bank)==1)
		{

		
		rc = MB_Iterator_CreateFiltered(b_loan_request, &i_loan_request, &FLAME_filter_Bank_Bank_rank_credit_requests_Bank_02_Bank_021_loan_request, current_xmachine_Bank);
		
		#ifdef ERRCHECK
		if (rc != MB_SUCCESS)
		{
		   fprintf(stderr, "ERROR: Could not create Iterator for 'loan_request'\n");
		   switch(rc) {
		       case MB_ERR_INVALID:
		           fprintf(stderr, "\t reason: 'loan_request' board is invalid\n");
		           break;
		       case MB_ERR_LOCKED:
	               fprintf(stderr, "\t reason: 'loan_request' board is locked\n");
	               break;
	           case MB_ERR_MEMALLOC:
	               fprintf(stderr, "\t reason: out of memory\n");
	               break;
	           case MB_ERR_INTERNAL:
	               fprintf(stderr, "\t reason: internal error. Recompile libmoard in debug mode for more info \n");
	               break;
	           default:
	           
                   fprintf(stderr, "\t MB_Iterator_CreateFiltered returned error code: %d (see libmboard docs for details)\n", rc);
               
               
                   break;
		   }

		   
           exit(rc);
		}
		#endif
		
		

			i = Bank_rank_credit_requests();

		
		    rc = MB_Iterator_Delete(&i_loan_request);
		    #ifdef ERRCHECK
		    if (rc != MB_SUCCESS)
		    {
		       fprintf(stderr, "ERROR: Could not delete 'loan_request' iterator\n");
		       switch(rc) {
		           case MB_ERR_INVALID:
		               fprintf(stderr, "\t reason: 'loan_request' iterator is invalid\n");
		               break;
		           case MB_ERR_INTERNAL:
		               fprintf(stderr, "\t reason: internal error. Recompile libmoard in debug mode for more info \n");
		               break;
		           default:
                       fprintf(stderr, "\t MB_Iterator_Delete returned error code: %d (see libmboard docs for details)\n", rc);
                       break;
		       }

		       
               exit(rc);
		    }
		    #endif
		

			if(i == 1)
			{
				free_Bank_agent(current_xmachine_Bank_holder, Bank_Bank_02_state);
			}
			else
			{
				transition_Bank_agent(current_xmachine_Bank_holder, Bank_Bank_02_state, Bank_Bank_021_state);
			}
		}

		current_xmachine_Bank = NULL;

		current_xmachine_Bank_holder = temp_xmachine_Bank_holder;
	}
	if(FLAME_TEST_PRINT_START_AND_END_OF_MODEL_FUNCTIONS) printf("finish Bank_rank_credit_requests\n");

	if(FLAME_loan_request_ranked_message_board_write == 1)
	{

		if(FLAME_TEST_PRINT_START_AND_END_OF_LIBMBOARD_CALLS) printf("start MB_SyncStart(b_loan_request_ranked)\n");
		rc = MB_SyncStart(b_loan_request_ranked);
		if(FLAME_TEST_PRINT_START_AND_END_OF_LIBMBOARD_CALLS) printf("finish MB_SyncStart(b_loan_request_ranked)\n");
		#ifdef ERRCHECK
		if (rc != MB_SUCCESS)
		{
		   fprintf(stderr, "ERROR: Could not start sync of 'loan_request_ranked' board\n");
		   switch(rc) {
			   case MB_ERR_INVALID:
				   fprintf(stderr, "\t reason: 'loan_request_ranked' board is invalid\n");
				   break;
			   case MB_ERR_LOCKED:
				   fprintf(stderr, "\t reason: 'loan_request_ranked' board is locked\n");
				   break;
			   case MB_ERR_MEMALLOC:
				   fprintf(stderr, "\t reason: out of memory\n");
				   break;
			   case MB_ERR_INTERNAL:
				   fprintf(stderr, "\t reason: internal error. Recompile libmoard in debug mode for more info \n");
				   break;
			   default:
				   fprintf(stderr, "\t MB_SyncStart returned error code: %d (see libmboard docs for details)\n", rc);
				   break;
		   }

			
			exit(rc);
		}
		#endif
    }
    


/* End of layer number 33 */

/* Clear message boards that have finished being used
 * and sync complete if doing late sync complete */

if(FLAME_loan_request_message_board_read == 0)
{
	/*printf("%d> loan_request message board sync complete late as no agents reading any messages of this type\n", node_number);*/
	
	if(FLAME_TEST_PRINT_START_AND_END_OF_LIBMBOARD_CALLS) printf("start MB_SyncComplete(b_loan_request)\n");
	rc = MB_SyncComplete(b_loan_request);
	if(FLAME_TEST_PRINT_START_AND_END_OF_LIBMBOARD_CALLS) printf("finsh MB_SyncComplete(b_loan_request)\n");
	#ifdef ERRCHECK
	if (rc != MB_SUCCESS)
	{
	   fprintf(stderr, "ERROR: Could not complete sync of 'loan_request' board\n");
	   switch(rc) {
			case MB_ERR_INVALID:
			   fprintf(stderr, "\t reason: 'loan_request' board is invalid\n");
			   break;
		   case MB_ERR_MEMALLOC:
			   fprintf(stderr, "\t reason: out of memory\n");
			   break;
		   case MB_ERR_INTERNAL:
			   fprintf(stderr, "\t reason: internal error. Recompile libmoard in debug mode for more info \n");
			   break;
		   default:
			   fprintf(stderr, "\t MB_SyncComplete returned error code: %d (see libmboard docs for details)\n", rc);
			   break;
	   }

	   
	   exit(rc);
	}
	#endif
}

    rc = MB_Clear(b_loan_request);
    #ifdef ERRCHECK
    if (rc != MB_SUCCESS)
    {
       fprintf(stderr, "ERROR: Could not clear 'loan_request' board\n");
       switch(rc) {
           case MB_ERR_INVALID:
               fprintf(stderr, "\t reason: 'loan_request' board is invalid\n");
               break;
           case MB_ERR_LOCKED:
               fprintf(stderr, "\t reason: 'loan_request' board is locked\n");
               break;
           case MB_ERR_INTERNAL:
               fprintf(stderr, "\t reason: internal error. Recompile libmoard in debug mode for more info \n");
               break;
           default:
               fprintf(stderr, "\t MB_Clear returned error code: %d (see libmboard docs for details)\n", rc);
               break;

       }

       
       exit(rc);
    }
    #endif


	/* If mb is not read then leave sync complete until last possible moment */
	if(FLAME_loan_request_ranked_message_board_read == 1)
	{
		if(FLAME_TEST_PRINT_START_AND_END_OF_LIBMBOARD_CALLS) printf("start MB_SyncComplete(b_loan_request_ranked)\n");
		rc = MB_SyncComplete(b_loan_request_ranked);
		if(FLAME_TEST_PRINT_START_AND_END_OF_LIBMBOARD_CALLS) printf("finsh MB_SyncComplete(b_loan_request_ranked)\n");
		#ifdef ERRCHECK
		if (rc != MB_SUCCESS)
		{
		   fprintf(stderr, "ERROR: Could not complete sync of 'loan_request_ranked' board\n");
		   switch(rc) {
				case MB_ERR_INVALID:
				   fprintf(stderr, "\t reason: 'loan_request_ranked' board is invalid\n");
				   break;
			   case MB_ERR_MEMALLOC:
				   fprintf(stderr, "\t reason: out of memory\n");
				   break;
			   case MB_ERR_INTERNAL:
				   fprintf(stderr, "\t reason: internal error. Recompile libmoard in debug mode for more info \n");
				   break;
			   default:
				   fprintf(stderr, "\t MB_SyncComplete returned error code: %d (see libmboard docs for details)\n", rc);
				   break;
		   }
	
		   
		   exit(rc);
		}
		#endif
    
	}
	
	if(FLAME_TEST_PRINT_START_AND_END_OF_MODEL_FUNCTIONS) printf("start Bank_decide_credit_conditions\n");
	current_xmachine_Bank_holder = Bank_Bank_021_state->agents;
	while(current_xmachine_Bank_holder)
	{
		temp_xmachine_Bank_holder = current_xmachine_Bank_holder->next;
		current_xmachine_Bank = current_xmachine_Bank_holder->agent;
		current_xmachine_Bank_next_state = Bank_Bank_03_state;
		/* For backwards compatibility set current_xmachine */
		current_xmachine->xmachine_Firm = NULL;
		current_xmachine->xmachine_Household = NULL;
		current_xmachine->xmachine_Mall = NULL;
		current_xmachine->xmachine_IGFirm = NULL;
		current_xmachine->xmachine_Eurostat = NULL;
		current_xmachine->xmachine_Bank = NULL;
		current_xmachine->xmachine_Government = NULL;
		current_xmachine->xmachine_CentralBank = NULL;
		current_xmachine->xmachine_ClearingHouse = NULL;
		current_xmachine->xmachine_Bank = current_xmachine_Bank;

		

		
		MB_Iterator_CreateFilteredSorted(b_loan_request_ranked, &i_loan_request_ranked, &FLAME_filter_Bank_Bank_decide_credit_conditions_Bank_021_Bank_03_loan_request_ranked, current_xmachine_Bank, &FLAME_sort_Bank_Bank_decide_credit_conditions_Bank_021_Bank_03_loan_request_ranked);
		
		#ifdef ERRCHECK
		if (rc != MB_SUCCESS)
		{
		   fprintf(stderr, "ERROR: Could not create Iterator for 'loan_request_ranked'\n");
		   switch(rc) {
		       case MB_ERR_INVALID:
		           fprintf(stderr, "\t reason: 'loan_request_ranked' board is invalid\n");
		           break;
		       case MB_ERR_LOCKED:
	               fprintf(stderr, "\t reason: 'loan_request_ranked' board is locked\n");
	               break;
	           case MB_ERR_MEMALLOC:
	               fprintf(stderr, "\t reason: out of memory\n");
	               break;
	           case MB_ERR_INTERNAL:
	               fprintf(stderr, "\t reason: internal error. Recompile libmoard in debug mode for more info \n");
	               break;
	           default:
	           
                   fprintf(stderr, "\t MB_Iterator_CreateFiltered returned error code: %d (see libmboard docs for details)\n", rc);
               
               
                   break;
		   }

		   
           exit(rc);
		}
		#endif
		
		

			i = Bank_decide_credit_conditions();

		
		    rc = MB_Iterator_Delete(&i_loan_request_ranked);
		    #ifdef ERRCHECK
		    if (rc != MB_SUCCESS)
		    {
		       fprintf(stderr, "ERROR: Could not delete 'loan_request_ranked' iterator\n");
		       switch(rc) {
		           case MB_ERR_INVALID:
		               fprintf(stderr, "\t reason: 'loan_request_ranked' iterator is invalid\n");
		               break;
		           case MB_ERR_INTERNAL:
		               fprintf(stderr, "\t reason: internal error. Recompile libmoard in debug mode for more info \n");
		               break;
		           default:
                       fprintf(stderr, "\t MB_Iterator_Delete returned error code: %d (see libmboard docs for details)\n", rc);
                       break;
		       }

		       
               exit(rc);
		    }
		    #endif
		

			if(i == 1)
			{
				free_Bank_agent(current_xmachine_Bank_holder, Bank_Bank_021_state);
			}
			else
			{
				transition_Bank_agent(current_xmachine_Bank_holder, Bank_Bank_021_state, Bank_Bank_03_state);
			}
		

		current_xmachine_Bank = NULL;

		current_xmachine_Bank_holder = temp_xmachine_Bank_holder;
	}
	if(FLAME_TEST_PRINT_START_AND_END_OF_MODEL_FUNCTIONS) printf("finish Bank_decide_credit_conditions\n");

	if(FLAME_loan_conditions_message_board_write == 1)
	{

		if(FLAME_TEST_PRINT_START_AND_END_OF_LIBMBOARD_CALLS) printf("start MB_SyncStart(b_loan_conditions)\n");
		rc = MB_SyncStart(b_loan_conditions);
		if(FLAME_TEST_PRINT_START_AND_END_OF_LIBMBOARD_CALLS) printf("finish MB_SyncStart(b_loan_conditions)\n");
		#ifdef ERRCHECK
		if (rc != MB_SUCCESS)
		{
		   fprintf(stderr, "ERROR: Could not start sync of 'loan_conditions' board\n");
		   switch(rc) {
			   case MB_ERR_INVALID:
				   fprintf(stderr, "\t reason: 'loan_conditions' board is invalid\n");
				   break;
			   case MB_ERR_LOCKED:
				   fprintf(stderr, "\t reason: 'loan_conditions' board is locked\n");
				   break;
			   case MB_ERR_MEMALLOC:
				   fprintf(stderr, "\t reason: out of memory\n");
				   break;
			   case MB_ERR_INTERNAL:
				   fprintf(stderr, "\t reason: internal error. Recompile libmoard in debug mode for more info \n");
				   break;
			   default:
				   fprintf(stderr, "\t MB_SyncStart returned error code: %d (see libmboard docs for details)\n", rc);
				   break;
		   }

			
			exit(rc);
		}
		#endif
    }
    


/* End of layer number 34 */

/* Clear message boards that have finished being used
 * and sync complete if doing late sync complete */

if(FLAME_loan_request_ranked_message_board_read == 0)
{
	/*printf("%d> loan_request_ranked message board sync complete late as no agents reading any messages of this type\n", node_number);*/
	
	if(FLAME_TEST_PRINT_START_AND_END_OF_LIBMBOARD_CALLS) printf("start MB_SyncComplete(b_loan_request_ranked)\n");
	rc = MB_SyncComplete(b_loan_request_ranked);
	if(FLAME_TEST_PRINT_START_AND_END_OF_LIBMBOARD_CALLS) printf("finsh MB_SyncComplete(b_loan_request_ranked)\n");
	#ifdef ERRCHECK
	if (rc != MB_SUCCESS)
	{
	   fprintf(stderr, "ERROR: Could not complete sync of 'loan_request_ranked' board\n");
	   switch(rc) {
			case MB_ERR_INVALID:
			   fprintf(stderr, "\t reason: 'loan_request_ranked' board is invalid\n");
			   break;
		   case MB_ERR_MEMALLOC:
			   fprintf(stderr, "\t reason: out of memory\n");
			   break;
		   case MB_ERR_INTERNAL:
			   fprintf(stderr, "\t reason: internal error. Recompile libmoard in debug mode for more info \n");
			   break;
		   default:
			   fprintf(stderr, "\t MB_SyncComplete returned error code: %d (see libmboard docs for details)\n", rc);
			   break;
	   }

	   
	   exit(rc);
	}
	#endif
}

    rc = MB_Clear(b_loan_request_ranked);
    #ifdef ERRCHECK
    if (rc != MB_SUCCESS)
    {
       fprintf(stderr, "ERROR: Could not clear 'loan_request_ranked' board\n");
       switch(rc) {
           case MB_ERR_INVALID:
               fprintf(stderr, "\t reason: 'loan_request_ranked' board is invalid\n");
               break;
           case MB_ERR_LOCKED:
               fprintf(stderr, "\t reason: 'loan_request_ranked' board is locked\n");
               break;
           case MB_ERR_INTERNAL:
               fprintf(stderr, "\t reason: internal error. Recompile libmoard in debug mode for more info \n");
               break;
           default:
               fprintf(stderr, "\t MB_Clear returned error code: %d (see libmboard docs for details)\n", rc);
               break;

       }

       
       exit(rc);
    }
    #endif


	/* If mb is not read then leave sync complete until last possible moment */
	if(FLAME_loan_conditions_message_board_read == 1)
	{
		if(FLAME_TEST_PRINT_START_AND_END_OF_LIBMBOARD_CALLS) printf("start MB_SyncComplete(b_loan_conditions)\n");
		rc = MB_SyncComplete(b_loan_conditions);
		if(FLAME_TEST_PRINT_START_AND_END_OF_LIBMBOARD_CALLS) printf("finsh MB_SyncComplete(b_loan_conditions)\n");
		#ifdef ERRCHECK
		if (rc != MB_SUCCESS)
		{
		   fprintf(stderr, "ERROR: Could not complete sync of 'loan_conditions' board\n");
		   switch(rc) {
				case MB_ERR_INVALID:
				   fprintf(stderr, "\t reason: 'loan_conditions' board is invalid\n");
				   break;
			   case MB_ERR_MEMALLOC:
				   fprintf(stderr, "\t reason: out of memory\n");
				   break;
			   case MB_ERR_INTERNAL:
				   fprintf(stderr, "\t reason: internal error. Recompile libmoard in debug mode for more info \n");
				   break;
			   default:
				   fprintf(stderr, "\t MB_SyncComplete returned error code: %d (see libmboard docs for details)\n", rc);
				   break;
		   }
	
		   
		   exit(rc);
		}
		#endif
    
	}
	
	if(FLAME_TEST_PRINT_START_AND_END_OF_MODEL_FUNCTIONS) printf("start Firm_get_loan\n");
	current_xmachine_Firm_holder = Firm_Firm_Credit_02_state->agents;
	while(current_xmachine_Firm_holder)
	{
		temp_xmachine_Firm_holder = current_xmachine_Firm_holder->next;
		current_xmachine_Firm = current_xmachine_Firm_holder->agent;
		current_xmachine_Firm_next_state = Firm_Firm_End_Credit_Role_state;
		/* For backwards compatibility set current_xmachine */
		current_xmachine->xmachine_Firm = NULL;
		current_xmachine->xmachine_Household = NULL;
		current_xmachine->xmachine_Mall = NULL;
		current_xmachine->xmachine_IGFirm = NULL;
		current_xmachine->xmachine_Eurostat = NULL;
		current_xmachine->xmachine_Bank = NULL;
		current_xmachine->xmachine_Government = NULL;
		current_xmachine->xmachine_CentralBank = NULL;
		current_xmachine->xmachine_ClearingHouse = NULL;
		current_xmachine->xmachine_Firm = current_xmachine_Firm;

		

		
		MB_Iterator_CreateFilteredSorted(b_loan_conditions, &i_loan_conditions, &FLAME_filter_Firm_Firm_get_loan_Firm_Credit_02_Firm_End_Credit_Role_loan_conditions, current_xmachine_Firm, &FLAME_sort_Firm_Firm_get_loan_Firm_Credit_02_Firm_End_Credit_Role_loan_conditions);
		
		#ifdef ERRCHECK
		if (rc != MB_SUCCESS)
		{
		   fprintf(stderr, "ERROR: Could not create Iterator for 'loan_conditions'\n");
		   switch(rc) {
		       case MB_ERR_INVALID:
		           fprintf(stderr, "\t reason: 'loan_conditions' board is invalid\n");
		           break;
		       case MB_ERR_LOCKED:
	               fprintf(stderr, "\t reason: 'loan_conditions' board is locked\n");
	               break;
	           case MB_ERR_MEMALLOC:
	               fprintf(stderr, "\t reason: out of memory\n");
	               break;
	           case MB_ERR_INTERNAL:
	               fprintf(stderr, "\t reason: internal error. Recompile libmoard in debug mode for more info \n");
	               break;
	           default:
	           
                   fprintf(stderr, "\t MB_Iterator_CreateFiltered returned error code: %d (see libmboard docs for details)\n", rc);
               
               
                   break;
		   }

		   
           exit(rc);
		}
		#endif
		
		

			i = Firm_get_loan();

		
		    rc = MB_Iterator_Delete(&i_loan_conditions);
		    #ifdef ERRCHECK
		    if (rc != MB_SUCCESS)
		    {
		       fprintf(stderr, "ERROR: Could not delete 'loan_conditions' iterator\n");
		       switch(rc) {
		           case MB_ERR_INVALID:
		               fprintf(stderr, "\t reason: 'loan_conditions' iterator is invalid\n");
		               break;
		           case MB_ERR_INTERNAL:
		               fprintf(stderr, "\t reason: internal error. Recompile libmoard in debug mode for more info \n");
		               break;
		           default:
                       fprintf(stderr, "\t MB_Iterator_Delete returned error code: %d (see libmboard docs for details)\n", rc);
                       break;
		       }

		       
               exit(rc);
		    }
		    #endif
		

			if(i == 1)
			{
				free_Firm_agent(current_xmachine_Firm_holder, Firm_Firm_Credit_02_state);
			}
			else
			{
				transition_Firm_agent(current_xmachine_Firm_holder, Firm_Firm_Credit_02_state, Firm_Firm_End_Credit_Role_state);
			}
		

		current_xmachine_Firm = NULL;

		current_xmachine_Firm_holder = temp_xmachine_Firm_holder;
	}
	if(FLAME_TEST_PRINT_START_AND_END_OF_MODEL_FUNCTIONS) printf("finish Firm_get_loan\n");

	if(FLAME_loan_acceptance_message_board_write == 1)
	{

		if(FLAME_TEST_PRINT_START_AND_END_OF_LIBMBOARD_CALLS) printf("start MB_SyncStart(b_loan_acceptance)\n");
		rc = MB_SyncStart(b_loan_acceptance);
		if(FLAME_TEST_PRINT_START_AND_END_OF_LIBMBOARD_CALLS) printf("finish MB_SyncStart(b_loan_acceptance)\n");
		#ifdef ERRCHECK
		if (rc != MB_SUCCESS)
		{
		   fprintf(stderr, "ERROR: Could not start sync of 'loan_acceptance' board\n");
		   switch(rc) {
			   case MB_ERR_INVALID:
				   fprintf(stderr, "\t reason: 'loan_acceptance' board is invalid\n");
				   break;
			   case MB_ERR_LOCKED:
				   fprintf(stderr, "\t reason: 'loan_acceptance' board is locked\n");
				   break;
			   case MB_ERR_MEMALLOC:
				   fprintf(stderr, "\t reason: out of memory\n");
				   break;
			   case MB_ERR_INTERNAL:
				   fprintf(stderr, "\t reason: internal error. Recompile libmoard in debug mode for more info \n");
				   break;
			   default:
				   fprintf(stderr, "\t MB_SyncStart returned error code: %d (see libmboard docs for details)\n", rc);
				   break;
		   }

			
			exit(rc);
		}
		#endif
    }
    


/* End of layer number 35 */

/* Clear message boards that have finished being used
 * and sync complete if doing late sync complete */

if(FLAME_loan_conditions_message_board_read == 0)
{
	/*printf("%d> loan_conditions message board sync complete late as no agents reading any messages of this type\n", node_number);*/
	
	if(FLAME_TEST_PRINT_START_AND_END_OF_LIBMBOARD_CALLS) printf("start MB_SyncComplete(b_loan_conditions)\n");
	rc = MB_SyncComplete(b_loan_conditions);
	if(FLAME_TEST_PRINT_START_AND_END_OF_LIBMBOARD_CALLS) printf("finsh MB_SyncComplete(b_loan_conditions)\n");
	#ifdef ERRCHECK
	if (rc != MB_SUCCESS)
	{
	   fprintf(stderr, "ERROR: Could not complete sync of 'loan_conditions' board\n");
	   switch(rc) {
			case MB_ERR_INVALID:
			   fprintf(stderr, "\t reason: 'loan_conditions' board is invalid\n");
			   break;
		   case MB_ERR_MEMALLOC:
			   fprintf(stderr, "\t reason: out of memory\n");
			   break;
		   case MB_ERR_INTERNAL:
			   fprintf(stderr, "\t reason: internal error. Recompile libmoard in debug mode for more info \n");
			   break;
		   default:
			   fprintf(stderr, "\t MB_SyncComplete returned error code: %d (see libmboard docs for details)\n", rc);
			   break;
	   }

	   
	   exit(rc);
	}
	#endif
}

    rc = MB_Clear(b_loan_conditions);
    #ifdef ERRCHECK
    if (rc != MB_SUCCESS)
    {
       fprintf(stderr, "ERROR: Could not clear 'loan_conditions' board\n");
       switch(rc) {
           case MB_ERR_INVALID:
               fprintf(stderr, "\t reason: 'loan_conditions' board is invalid\n");
               break;
           case MB_ERR_LOCKED:
               fprintf(stderr, "\t reason: 'loan_conditions' board is locked\n");
               break;
           case MB_ERR_INTERNAL:
               fprintf(stderr, "\t reason: internal error. Recompile libmoard in debug mode for more info \n");
               break;
           default:
               fprintf(stderr, "\t MB_Clear returned error code: %d (see libmboard docs for details)\n", rc);
               break;

       }

       
       exit(rc);
    }
    #endif


	if(FLAME_TEST_PRINT_START_AND_END_OF_MODEL_FUNCTIONS) printf("start idle\n");
	current_xmachine_Firm_holder = Firm_Firm_End_Credit_Role_state->agents;
	while(current_xmachine_Firm_holder)
	{
		temp_xmachine_Firm_holder = current_xmachine_Firm_holder->next;
		current_xmachine_Firm = current_xmachine_Firm_holder->agent;
		current_xmachine_Firm_next_state = Firm_Firm_End_External_Financing_state;
		/* For backwards compatibility set current_xmachine */
		current_xmachine->xmachine_Firm = NULL;
		current_xmachine->xmachine_Household = NULL;
		current_xmachine->xmachine_Mall = NULL;
		current_xmachine->xmachine_IGFirm = NULL;
		current_xmachine->xmachine_Eurostat = NULL;
		current_xmachine->xmachine_Bank = NULL;
		current_xmachine->xmachine_Government = NULL;
		current_xmachine->xmachine_CentralBank = NULL;
		current_xmachine->xmachine_ClearingHouse = NULL;
		current_xmachine->xmachine_Firm = current_xmachine_Firm;

		if(FLAME_condition_Firm_idle_Firm_End_Credit_Role_Firm_End_External_Financing(current_xmachine_Firm)==1)
		{

		

			i = idle();

		

			if(i == 1)
			{
				free_Firm_agent(current_xmachine_Firm_holder, Firm_Firm_End_Credit_Role_state);
			}
			else
			{
				transition_Firm_agent(current_xmachine_Firm_holder, Firm_Firm_End_Credit_Role_state, Firm_Firm_End_External_Financing_state);
			}
		}

		current_xmachine_Firm = NULL;

		current_xmachine_Firm_holder = temp_xmachine_Firm_holder;
	}
	if(FLAME_TEST_PRINT_START_AND_END_OF_MODEL_FUNCTIONS) printf("finish idle\n");


	if(FLAME_TEST_PRINT_START_AND_END_OF_MODEL_FUNCTIONS) printf("start Firm_check_financial_and_bankruptcy_state\n");
	current_xmachine_Firm_holder = Firm_Firm_End_Credit_Role_state->agents;
	while(current_xmachine_Firm_holder)
	{
		temp_xmachine_Firm_holder = current_xmachine_Firm_holder->next;
		current_xmachine_Firm = current_xmachine_Firm_holder->agent;
		current_xmachine_Firm_next_state = Firm_Firm_bankruptcy_checked_state;
		/* For backwards compatibility set current_xmachine */
		current_xmachine->xmachine_Firm = NULL;
		current_xmachine->xmachine_Household = NULL;
		current_xmachine->xmachine_Mall = NULL;
		current_xmachine->xmachine_IGFirm = NULL;
		current_xmachine->xmachine_Eurostat = NULL;
		current_xmachine->xmachine_Bank = NULL;
		current_xmachine->xmachine_Government = NULL;
		current_xmachine->xmachine_CentralBank = NULL;
		current_xmachine->xmachine_ClearingHouse = NULL;
		current_xmachine->xmachine_Firm = current_xmachine_Firm;

		if(FLAME_condition_Firm_Firm_check_financial_and_bankruptcy_state_Firm_End_Credit_Role_Firm_bankruptcy_checked(current_xmachine_Firm)==1)
		{

		

			i = Firm_check_financial_and_bankruptcy_state();

		

			if(i == 1)
			{
				free_Firm_agent(current_xmachine_Firm_holder, Firm_Firm_End_Credit_Role_state);
			}
			else
			{
				transition_Firm_agent(current_xmachine_Firm_holder, Firm_Firm_End_Credit_Role_state, Firm_Firm_bankruptcy_checked_state);
			}
		}

		current_xmachine_Firm = NULL;

		current_xmachine_Firm_holder = temp_xmachine_Firm_holder;
	}
	if(FLAME_TEST_PRINT_START_AND_END_OF_MODEL_FUNCTIONS) printf("finish Firm_check_financial_and_bankruptcy_state\n");


	/* If mb is not read then leave sync complete until last possible moment */
	if(FLAME_loan_acceptance_message_board_read == 1)
	{
		if(FLAME_TEST_PRINT_START_AND_END_OF_LIBMBOARD_CALLS) printf("start MB_SyncComplete(b_loan_acceptance)\n");
		rc = MB_SyncComplete(b_loan_acceptance);
		if(FLAME_TEST_PRINT_START_AND_END_OF_LIBMBOARD_CALLS) printf("finsh MB_SyncComplete(b_loan_acceptance)\n");
		#ifdef ERRCHECK
		if (rc != MB_SUCCESS)
		{
		   fprintf(stderr, "ERROR: Could not complete sync of 'loan_acceptance' board\n");
		   switch(rc) {
				case MB_ERR_INVALID:
				   fprintf(stderr, "\t reason: 'loan_acceptance' board is invalid\n");
				   break;
			   case MB_ERR_MEMALLOC:
				   fprintf(stderr, "\t reason: out of memory\n");
				   break;
			   case MB_ERR_INTERNAL:
				   fprintf(stderr, "\t reason: internal error. Recompile libmoard in debug mode for more info \n");
				   break;
			   default:
				   fprintf(stderr, "\t MB_SyncComplete returned error code: %d (see libmboard docs for details)\n", rc);
				   break;
		   }
	
		   
		   exit(rc);
		}
		#endif
    
	}
	
	if(FLAME_TEST_PRINT_START_AND_END_OF_MODEL_FUNCTIONS) printf("start Bank_give_loan\n");
	current_xmachine_Bank_holder = Bank_Bank_03_state->agents;
	while(current_xmachine_Bank_holder)
	{
		temp_xmachine_Bank_holder = current_xmachine_Bank_holder->next;
		current_xmachine_Bank = current_xmachine_Bank_holder->agent;
		current_xmachine_Bank_next_state = Bank_Bank_04_state;
		/* For backwards compatibility set current_xmachine */
		current_xmachine->xmachine_Firm = NULL;
		current_xmachine->xmachine_Household = NULL;
		current_xmachine->xmachine_Mall = NULL;
		current_xmachine->xmachine_IGFirm = NULL;
		current_xmachine->xmachine_Eurostat = NULL;
		current_xmachine->xmachine_Bank = NULL;
		current_xmachine->xmachine_Government = NULL;
		current_xmachine->xmachine_CentralBank = NULL;
		current_xmachine->xmachine_ClearingHouse = NULL;
		current_xmachine->xmachine_Bank = current_xmachine_Bank;

		

		
		rc = MB_Iterator_CreateFiltered(b_loan_acceptance, &i_loan_acceptance, &FLAME_filter_Bank_Bank_give_loan_Bank_03_Bank_04_loan_acceptance, current_xmachine_Bank);
		
		#ifdef ERRCHECK
		if (rc != MB_SUCCESS)
		{
		   fprintf(stderr, "ERROR: Could not create Iterator for 'loan_acceptance'\n");
		   switch(rc) {
		       case MB_ERR_INVALID:
		           fprintf(stderr, "\t reason: 'loan_acceptance' board is invalid\n");
		           break;
		       case MB_ERR_LOCKED:
	               fprintf(stderr, "\t reason: 'loan_acceptance' board is locked\n");
	               break;
	           case MB_ERR_MEMALLOC:
	               fprintf(stderr, "\t reason: out of memory\n");
	               break;
	           case MB_ERR_INTERNAL:
	               fprintf(stderr, "\t reason: internal error. Recompile libmoard in debug mode for more info \n");
	               break;
	           default:
	           
                   fprintf(stderr, "\t MB_Iterator_CreateFiltered returned error code: %d (see libmboard docs for details)\n", rc);
               
               
                   break;
		   }

		   
           exit(rc);
		}
		#endif
		
		

			i = Bank_give_loan();

		
		    rc = MB_Iterator_Delete(&i_loan_acceptance);
		    #ifdef ERRCHECK
		    if (rc != MB_SUCCESS)
		    {
		       fprintf(stderr, "ERROR: Could not delete 'loan_acceptance' iterator\n");
		       switch(rc) {
		           case MB_ERR_INVALID:
		               fprintf(stderr, "\t reason: 'loan_acceptance' iterator is invalid\n");
		               break;
		           case MB_ERR_INTERNAL:
		               fprintf(stderr, "\t reason: internal error. Recompile libmoard in debug mode for more info \n");
		               break;
		           default:
                       fprintf(stderr, "\t MB_Iterator_Delete returned error code: %d (see libmboard docs for details)\n", rc);
                       break;
		       }

		       
               exit(rc);
		    }
		    #endif
		

			if(i == 1)
			{
				free_Bank_agent(current_xmachine_Bank_holder, Bank_Bank_03_state);
			}
			else
			{
				transition_Bank_agent(current_xmachine_Bank_holder, Bank_Bank_03_state, Bank_Bank_04_state);
			}
		

		current_xmachine_Bank = NULL;

		current_xmachine_Bank_holder = temp_xmachine_Bank_holder;
	}
	if(FLAME_TEST_PRINT_START_AND_END_OF_MODEL_FUNCTIONS) printf("finish Bank_give_loan\n");


/* End of layer number 36 */

/* Clear message boards that have finished being used
 * and sync complete if doing late sync complete */

if(FLAME_loan_acceptance_message_board_read == 0)
{
	/*printf("%d> loan_acceptance message board sync complete late as no agents reading any messages of this type\n", node_number);*/
	
	if(FLAME_TEST_PRINT_START_AND_END_OF_LIBMBOARD_CALLS) printf("start MB_SyncComplete(b_loan_acceptance)\n");
	rc = MB_SyncComplete(b_loan_acceptance);
	if(FLAME_TEST_PRINT_START_AND_END_OF_LIBMBOARD_CALLS) printf("finsh MB_SyncComplete(b_loan_acceptance)\n");
	#ifdef ERRCHECK
	if (rc != MB_SUCCESS)
	{
	   fprintf(stderr, "ERROR: Could not complete sync of 'loan_acceptance' board\n");
	   switch(rc) {
			case MB_ERR_INVALID:
			   fprintf(stderr, "\t reason: 'loan_acceptance' board is invalid\n");
			   break;
		   case MB_ERR_MEMALLOC:
			   fprintf(stderr, "\t reason: out of memory\n");
			   break;
		   case MB_ERR_INTERNAL:
			   fprintf(stderr, "\t reason: internal error. Recompile libmoard in debug mode for more info \n");
			   break;
		   default:
			   fprintf(stderr, "\t MB_SyncComplete returned error code: %d (see libmboard docs for details)\n", rc);
			   break;
	   }

	   
	   exit(rc);
	}
	#endif
}

    rc = MB_Clear(b_loan_acceptance);
    #ifdef ERRCHECK
    if (rc != MB_SUCCESS)
    {
       fprintf(stderr, "ERROR: Could not clear 'loan_acceptance' board\n");
       switch(rc) {
           case MB_ERR_INVALID:
               fprintf(stderr, "\t reason: 'loan_acceptance' board is invalid\n");
               break;
           case MB_ERR_LOCKED:
               fprintf(stderr, "\t reason: 'loan_acceptance' board is locked\n");
               break;
           case MB_ERR_INTERNAL:
               fprintf(stderr, "\t reason: internal error. Recompile libmoard in debug mode for more info \n");
               break;
           default:
               fprintf(stderr, "\t MB_Clear returned error code: %d (see libmboard docs for details)\n", rc);
               break;

       }

       
       exit(rc);
    }
    #endif


	if(FLAME_TEST_PRINT_START_AND_END_OF_MODEL_FUNCTIONS) printf("start Firm_set_bankruptcy_illiquidity\n");
	current_xmachine_Firm_holder = Firm_Firm_bankruptcy_checked_state->agents;
	while(current_xmachine_Firm_holder)
	{
		temp_xmachine_Firm_holder = current_xmachine_Firm_holder->next;
		current_xmachine_Firm = current_xmachine_Firm_holder->agent;
		current_xmachine_Firm_next_state = Firm_Firm_variables_reset2_state;
		/* For backwards compatibility set current_xmachine */
		current_xmachine->xmachine_Firm = NULL;
		current_xmachine->xmachine_Household = NULL;
		current_xmachine->xmachine_Mall = NULL;
		current_xmachine->xmachine_IGFirm = NULL;
		current_xmachine->xmachine_Eurostat = NULL;
		current_xmachine->xmachine_Bank = NULL;
		current_xmachine->xmachine_Government = NULL;
		current_xmachine->xmachine_CentralBank = NULL;
		current_xmachine->xmachine_ClearingHouse = NULL;
		current_xmachine->xmachine_Firm = current_xmachine_Firm;

		if(FLAME_condition_Firm_Firm_set_bankruptcy_illiquidity_Firm_bankruptcy_checked_Firm_variables_reset2(current_xmachine_Firm)==1)
		{

		

			i = Firm_set_bankruptcy_illiquidity();

		

			if(i == 1)
			{
				free_Firm_agent(current_xmachine_Firm_holder, Firm_Firm_bankruptcy_checked_state);
			}
			else
			{
				transition_Firm_agent(current_xmachine_Firm_holder, Firm_Firm_bankruptcy_checked_state, Firm_Firm_variables_reset2_state);
			}
		}

		current_xmachine_Firm = NULL;

		current_xmachine_Firm_holder = temp_xmachine_Firm_holder;
	}
	if(FLAME_TEST_PRINT_START_AND_END_OF_MODEL_FUNCTIONS) printf("finish Firm_set_bankruptcy_illiquidity\n");

	if(FLAME_bankruptcy_illiquidity_message_board_write == 1)
	{

		if(FLAME_TEST_PRINT_START_AND_END_OF_LIBMBOARD_CALLS) printf("start MB_SyncStart(b_bankruptcy_illiquidity)\n");
		rc = MB_SyncStart(b_bankruptcy_illiquidity);
		if(FLAME_TEST_PRINT_START_AND_END_OF_LIBMBOARD_CALLS) printf("finish MB_SyncStart(b_bankruptcy_illiquidity)\n");
		#ifdef ERRCHECK
		if (rc != MB_SUCCESS)
		{
		   fprintf(stderr, "ERROR: Could not start sync of 'bankruptcy_illiquidity' board\n");
		   switch(rc) {
			   case MB_ERR_INVALID:
				   fprintf(stderr, "\t reason: 'bankruptcy_illiquidity' board is invalid\n");
				   break;
			   case MB_ERR_LOCKED:
				   fprintf(stderr, "\t reason: 'bankruptcy_illiquidity' board is locked\n");
				   break;
			   case MB_ERR_MEMALLOC:
				   fprintf(stderr, "\t reason: out of memory\n");
				   break;
			   case MB_ERR_INTERNAL:
				   fprintf(stderr, "\t reason: internal error. Recompile libmoard in debug mode for more info \n");
				   break;
			   default:
				   fprintf(stderr, "\t MB_SyncStart returned error code: %d (see libmboard docs for details)\n", rc);
				   break;
		   }

			
			exit(rc);
		}
		#endif
    }
    


	if(FLAME_TEST_PRINT_START_AND_END_OF_MODEL_FUNCTIONS) printf("start Firm_not_in_bankruptcy\n");
	current_xmachine_Firm_holder = Firm_Firm_bankruptcy_checked_state->agents;
	while(current_xmachine_Firm_holder)
	{
		temp_xmachine_Firm_holder = current_xmachine_Firm_holder->next;
		current_xmachine_Firm = current_xmachine_Firm_holder->agent;
		current_xmachine_Firm_next_state = Firm_Firm_checks_financial_crisis_state;
		/* For backwards compatibility set current_xmachine */
		current_xmachine->xmachine_Firm = NULL;
		current_xmachine->xmachine_Household = NULL;
		current_xmachine->xmachine_Mall = NULL;
		current_xmachine->xmachine_IGFirm = NULL;
		current_xmachine->xmachine_Eurostat = NULL;
		current_xmachine->xmachine_Bank = NULL;
		current_xmachine->xmachine_Government = NULL;
		current_xmachine->xmachine_CentralBank = NULL;
		current_xmachine->xmachine_ClearingHouse = NULL;
		current_xmachine->xmachine_Firm = current_xmachine_Firm;

		if(FLAME_condition_Firm_Firm_not_in_bankruptcy_Firm_bankruptcy_checked_Firm_checks_financial_crisis(current_xmachine_Firm)==1)
		{

		

			i = Firm_not_in_bankruptcy();

		

			if(i == 1)
			{
				free_Firm_agent(current_xmachine_Firm_holder, Firm_Firm_bankruptcy_checked_state);
			}
			else
			{
				transition_Firm_agent(current_xmachine_Firm_holder, Firm_Firm_bankruptcy_checked_state, Firm_Firm_checks_financial_crisis_state);
			}
		}

		current_xmachine_Firm = NULL;

		current_xmachine_Firm_holder = temp_xmachine_Firm_holder;
	}
	if(FLAME_TEST_PRINT_START_AND_END_OF_MODEL_FUNCTIONS) printf("finish Firm_not_in_bankruptcy\n");


/* End of layer number 37 */

/* Clear message boards that have finished being used
 * and sync complete if doing late sync complete */


	if(FLAME_TEST_PRINT_START_AND_END_OF_MODEL_FUNCTIONS) printf("start idle\n");
	current_xmachine_Firm_holder = Firm_Firm_checks_financial_crisis_state->agents;
	while(current_xmachine_Firm_holder)
	{
		temp_xmachine_Firm_holder = current_xmachine_Firm_holder->next;
		current_xmachine_Firm = current_xmachine_Firm_holder->agent;
		current_xmachine_Firm_next_state = Firm_Firm_End_External_Financing_state;
		/* For backwards compatibility set current_xmachine */
		current_xmachine->xmachine_Firm = NULL;
		current_xmachine->xmachine_Household = NULL;
		current_xmachine->xmachine_Mall = NULL;
		current_xmachine->xmachine_IGFirm = NULL;
		current_xmachine->xmachine_Eurostat = NULL;
		current_xmachine->xmachine_Bank = NULL;
		current_xmachine->xmachine_Government = NULL;
		current_xmachine->xmachine_CentralBank = NULL;
		current_xmachine->xmachine_ClearingHouse = NULL;
		current_xmachine->xmachine_Firm = current_xmachine_Firm;

		if(FLAME_condition_Firm_idle_Firm_checks_financial_crisis_Firm_End_External_Financing(current_xmachine_Firm)==1)
		{

		

			i = idle();

		

			if(i == 1)
			{
				free_Firm_agent(current_xmachine_Firm_holder, Firm_Firm_checks_financial_crisis_state);
			}
			else
			{
				transition_Firm_agent(current_xmachine_Firm_holder, Firm_Firm_checks_financial_crisis_state, Firm_Firm_End_External_Financing_state);
			}
		}

		current_xmachine_Firm = NULL;

		current_xmachine_Firm_holder = temp_xmachine_Firm_holder;
	}
	if(FLAME_TEST_PRINT_START_AND_END_OF_MODEL_FUNCTIONS) printf("finish idle\n");


	if(FLAME_TEST_PRINT_START_AND_END_OF_MODEL_FUNCTIONS) printf("start Firm_set_minsky_state_crisis\n");
	current_xmachine_Firm_holder = Firm_Firm_checks_financial_crisis_state->agents;
	while(current_xmachine_Firm_holder)
	{
		temp_xmachine_Firm_holder = current_xmachine_Firm_holder->next;
		current_xmachine_Firm = current_xmachine_Firm_holder->agent;
		current_xmachine_Firm_next_state = Firm_Firm_resolve_financial_crisis_state;
		/* For backwards compatibility set current_xmachine */
		current_xmachine->xmachine_Firm = NULL;
		current_xmachine->xmachine_Household = NULL;
		current_xmachine->xmachine_Mall = NULL;
		current_xmachine->xmachine_IGFirm = NULL;
		current_xmachine->xmachine_Eurostat = NULL;
		current_xmachine->xmachine_Bank = NULL;
		current_xmachine->xmachine_Government = NULL;
		current_xmachine->xmachine_CentralBank = NULL;
		current_xmachine->xmachine_ClearingHouse = NULL;
		current_xmachine->xmachine_Firm = current_xmachine_Firm;

		if(FLAME_condition_Firm_Firm_set_minsky_state_crisis_Firm_checks_financial_crisis_Firm_resolve_financial_crisis(current_xmachine_Firm)==1)
		{

		

			i = Firm_set_minsky_state_crisis();

		

			if(i == 1)
			{
				free_Firm_agent(current_xmachine_Firm_holder, Firm_Firm_checks_financial_crisis_state);
			}
			else
			{
				transition_Firm_agent(current_xmachine_Firm_holder, Firm_Firm_checks_financial_crisis_state, Firm_Firm_resolve_financial_crisis_state);
			}
		}

		current_xmachine_Firm = NULL;

		current_xmachine_Firm_holder = temp_xmachine_Firm_holder;
	}
	if(FLAME_TEST_PRINT_START_AND_END_OF_MODEL_FUNCTIONS) printf("finish Firm_set_minsky_state_crisis\n");


	if(FLAME_TEST_PRINT_START_AND_END_OF_MODEL_FUNCTIONS) printf("start Firm_bankruptcy_reset_immediately\n");
	current_xmachine_Firm_holder = Firm_Firm_variables_reset2_state->agents;
	while(current_xmachine_Firm_holder)
	{
		temp_xmachine_Firm_holder = current_xmachine_Firm_holder->next;
		current_xmachine_Firm = current_xmachine_Firm_holder->agent;
		current_xmachine_Firm_next_state = Firm_Firm_End_Financial_Management_Role_state;
		/* For backwards compatibility set current_xmachine */
		current_xmachine->xmachine_Firm = NULL;
		current_xmachine->xmachine_Household = NULL;
		current_xmachine->xmachine_Mall = NULL;
		current_xmachine->xmachine_IGFirm = NULL;
		current_xmachine->xmachine_Eurostat = NULL;
		current_xmachine->xmachine_Bank = NULL;
		current_xmachine->xmachine_Government = NULL;
		current_xmachine->xmachine_CentralBank = NULL;
		current_xmachine->xmachine_ClearingHouse = NULL;
		current_xmachine->xmachine_Firm = current_xmachine_Firm;

		

		

			i = Firm_bankruptcy_reset_immediately();

		

			if(i == 1)
			{
				free_Firm_agent(current_xmachine_Firm_holder, Firm_Firm_variables_reset2_state);
			}
			else
			{
				transition_Firm_agent(current_xmachine_Firm_holder, Firm_Firm_variables_reset2_state, Firm_Firm_End_Financial_Management_Role_state);
			}
		

		current_xmachine_Firm = NULL;

		current_xmachine_Firm_holder = temp_xmachine_Firm_holder;
	}
	if(FLAME_TEST_PRINT_START_AND_END_OF_MODEL_FUNCTIONS) printf("finish Firm_bankruptcy_reset_immediately\n");


/* End of layer number 38 */

/* Clear message boards that have finished being used
 * and sync complete if doing late sync complete */


	if(FLAME_TEST_PRINT_START_AND_END_OF_MODEL_FUNCTIONS) printf("start Firm_in_financial_crisis\n");
	current_xmachine_Firm_holder = Firm_Firm_resolve_financial_crisis_state->agents;
	while(current_xmachine_Firm_holder)
	{
		temp_xmachine_Firm_holder = current_xmachine_Firm_holder->next;
		current_xmachine_Firm = current_xmachine_Firm_holder->agent;
		current_xmachine_Firm_next_state = Firm_Firm_End_External_Financing_state;
		/* For backwards compatibility set current_xmachine */
		current_xmachine->xmachine_Firm = NULL;
		current_xmachine->xmachine_Household = NULL;
		current_xmachine->xmachine_Mall = NULL;
		current_xmachine->xmachine_IGFirm = NULL;
		current_xmachine->xmachine_Eurostat = NULL;
		current_xmachine->xmachine_Bank = NULL;
		current_xmachine->xmachine_Government = NULL;
		current_xmachine->xmachine_CentralBank = NULL;
		current_xmachine->xmachine_ClearingHouse = NULL;
		current_xmachine->xmachine_Firm = current_xmachine_Firm;

		

		

			i = Firm_in_financial_crisis();

		

			if(i == 1)
			{
				free_Firm_agent(current_xmachine_Firm_holder, Firm_Firm_resolve_financial_crisis_state);
			}
			else
			{
				transition_Firm_agent(current_xmachine_Firm_holder, Firm_Firm_resolve_financial_crisis_state, Firm_Firm_End_External_Financing_state);
			}
		

		current_xmachine_Firm = NULL;

		current_xmachine_Firm_holder = temp_xmachine_Firm_holder;
	}
	if(FLAME_TEST_PRINT_START_AND_END_OF_MODEL_FUNCTIONS) printf("finish Firm_in_financial_crisis\n");


/* End of layer number 39 */

/* Clear message boards that have finished being used
 * and sync complete if doing late sync complete */


	if(FLAME_TEST_PRINT_START_AND_END_OF_MODEL_FUNCTIONS) printf("start Firm_execute_financial_payments\n");
	current_xmachine_Firm_holder = Firm_Firm_End_External_Financing_state->agents;
	while(current_xmachine_Firm_holder)
	{
		temp_xmachine_Firm_holder = current_xmachine_Firm_holder->next;
		current_xmachine_Firm = current_xmachine_Firm_holder->agent;
		current_xmachine_Firm_next_state = Firm_Firm_End_Financial_Management_state;
		/* For backwards compatibility set current_xmachine */
		current_xmachine->xmachine_Firm = NULL;
		current_xmachine->xmachine_Household = NULL;
		current_xmachine->xmachine_Mall = NULL;
		current_xmachine->xmachine_IGFirm = NULL;
		current_xmachine->xmachine_Eurostat = NULL;
		current_xmachine->xmachine_Bank = NULL;
		current_xmachine->xmachine_Government = NULL;
		current_xmachine->xmachine_CentralBank = NULL;
		current_xmachine->xmachine_ClearingHouse = NULL;
		current_xmachine->xmachine_Firm = current_xmachine_Firm;

		

		

			i = Firm_execute_financial_payments();

		

			if(i == 1)
			{
				free_Firm_agent(current_xmachine_Firm_holder, Firm_Firm_End_External_Financing_state);
			}
			else
			{
				transition_Firm_agent(current_xmachine_Firm_holder, Firm_Firm_End_External_Financing_state, Firm_Firm_End_Financial_Management_state);
			}
		

		current_xmachine_Firm = NULL;

		current_xmachine_Firm_holder = temp_xmachine_Firm_holder;
	}
	if(FLAME_TEST_PRINT_START_AND_END_OF_MODEL_FUNCTIONS) printf("finish Firm_execute_financial_payments\n");

	if(FLAME_dividend_info_message_board_write == 1)
	{

		if(FLAME_TEST_PRINT_START_AND_END_OF_LIBMBOARD_CALLS) printf("start MB_SyncStart(b_dividend_info)\n");
		rc = MB_SyncStart(b_dividend_info);
		if(FLAME_TEST_PRINT_START_AND_END_OF_LIBMBOARD_CALLS) printf("finish MB_SyncStart(b_dividend_info)\n");
		#ifdef ERRCHECK
		if (rc != MB_SUCCESS)
		{
		   fprintf(stderr, "ERROR: Could not start sync of 'dividend_info' board\n");
		   switch(rc) {
			   case MB_ERR_INVALID:
				   fprintf(stderr, "\t reason: 'dividend_info' board is invalid\n");
				   break;
			   case MB_ERR_LOCKED:
				   fprintf(stderr, "\t reason: 'dividend_info' board is locked\n");
				   break;
			   case MB_ERR_MEMALLOC:
				   fprintf(stderr, "\t reason: out of memory\n");
				   break;
			   case MB_ERR_INTERNAL:
				   fprintf(stderr, "\t reason: internal error. Recompile libmoard in debug mode for more info \n");
				   break;
			   default:
				   fprintf(stderr, "\t MB_SyncStart returned error code: %d (see libmboard docs for details)\n", rc);
				   break;
		   }

			
			exit(rc);
		}
		#endif
    }
    

	if(FLAME_installment_message_board_write == 1)
	{

		if(FLAME_TEST_PRINT_START_AND_END_OF_LIBMBOARD_CALLS) printf("start MB_SyncStart(b_installment)\n");
		rc = MB_SyncStart(b_installment);
		if(FLAME_TEST_PRINT_START_AND_END_OF_LIBMBOARD_CALLS) printf("finish MB_SyncStart(b_installment)\n");
		#ifdef ERRCHECK
		if (rc != MB_SUCCESS)
		{
		   fprintf(stderr, "ERROR: Could not start sync of 'installment' board\n");
		   switch(rc) {
			   case MB_ERR_INVALID:
				   fprintf(stderr, "\t reason: 'installment' board is invalid\n");
				   break;
			   case MB_ERR_LOCKED:
				   fprintf(stderr, "\t reason: 'installment' board is locked\n");
				   break;
			   case MB_ERR_MEMALLOC:
				   fprintf(stderr, "\t reason: out of memory\n");
				   break;
			   case MB_ERR_INTERNAL:
				   fprintf(stderr, "\t reason: internal error. Recompile libmoard in debug mode for more info \n");
				   break;
			   default:
				   fprintf(stderr, "\t MB_SyncStart returned error code: %d (see libmboard docs for details)\n", rc);
				   break;
		   }

			
			exit(rc);
		}
		#endif
    }
    


/* End of layer number 40 */

/* Clear message boards that have finished being used
 * and sync complete if doing late sync complete */


	if(FLAME_TEST_PRINT_START_AND_END_OF_MODEL_FUNCTIONS) printf("start Firm_calc_production_quantity_2\n");
	current_xmachine_Firm_holder = Firm_Firm_End_Financial_Management_state->agents;
	while(current_xmachine_Firm_holder)
	{
		temp_xmachine_Firm_holder = current_xmachine_Firm_holder->next;
		current_xmachine_Firm = current_xmachine_Firm_holder->agent;
		current_xmachine_Firm_next_state = Firm_Firm_Start_Labour_Role_state;
		/* For backwards compatibility set current_xmachine */
		current_xmachine->xmachine_Firm = NULL;
		current_xmachine->xmachine_Household = NULL;
		current_xmachine->xmachine_Mall = NULL;
		current_xmachine->xmachine_IGFirm = NULL;
		current_xmachine->xmachine_Eurostat = NULL;
		current_xmachine->xmachine_Bank = NULL;
		current_xmachine->xmachine_Government = NULL;
		current_xmachine->xmachine_CentralBank = NULL;
		current_xmachine->xmachine_ClearingHouse = NULL;
		current_xmachine->xmachine_Firm = current_xmachine_Firm;

		

		

			i = Firm_calc_production_quantity_2();

		

			if(i == 1)
			{
				free_Firm_agent(current_xmachine_Firm_holder, Firm_Firm_End_Financial_Management_state);
			}
			else
			{
				transition_Firm_agent(current_xmachine_Firm_holder, Firm_Firm_End_Financial_Management_state, Firm_Firm_Start_Labour_Role_state);
			}
		

		current_xmachine_Firm = NULL;

		current_xmachine_Firm_holder = temp_xmachine_Firm_holder;
	}
	if(FLAME_TEST_PRINT_START_AND_END_OF_MODEL_FUNCTIONS) printf("finish Firm_calc_production_quantity_2\n");


	/* If mb is not read then leave sync complete until last possible moment */
	if(FLAME_bankruptcy_message_board_read == 1)
	{
		if(FLAME_TEST_PRINT_START_AND_END_OF_LIBMBOARD_CALLS) printf("start MB_SyncComplete(b_bankruptcy)\n");
		rc = MB_SyncComplete(b_bankruptcy);
		if(FLAME_TEST_PRINT_START_AND_END_OF_LIBMBOARD_CALLS) printf("finsh MB_SyncComplete(b_bankruptcy)\n");
		#ifdef ERRCHECK
		if (rc != MB_SUCCESS)
		{
		   fprintf(stderr, "ERROR: Could not complete sync of 'bankruptcy' board\n");
		   switch(rc) {
				case MB_ERR_INVALID:
				   fprintf(stderr, "\t reason: 'bankruptcy' board is invalid\n");
				   break;
			   case MB_ERR_MEMALLOC:
				   fprintf(stderr, "\t reason: out of memory\n");
				   break;
			   case MB_ERR_INTERNAL:
				   fprintf(stderr, "\t reason: internal error. Recompile libmoard in debug mode for more info \n");
				   break;
			   default:
				   fprintf(stderr, "\t MB_SyncComplete returned error code: %d (see libmboard docs for details)\n", rc);
				   break;
		   }
	
		   
		   exit(rc);
		}
		#endif
    
	}
	
	/* If mb is not read then leave sync complete until last possible moment */
	if(FLAME_installment_message_board_read == 1)
	{
		if(FLAME_TEST_PRINT_START_AND_END_OF_LIBMBOARD_CALLS) printf("start MB_SyncComplete(b_installment)\n");
		rc = MB_SyncComplete(b_installment);
		if(FLAME_TEST_PRINT_START_AND_END_OF_LIBMBOARD_CALLS) printf("finsh MB_SyncComplete(b_installment)\n");
		#ifdef ERRCHECK
		if (rc != MB_SUCCESS)
		{
		   fprintf(stderr, "ERROR: Could not complete sync of 'installment' board\n");
		   switch(rc) {
				case MB_ERR_INVALID:
				   fprintf(stderr, "\t reason: 'installment' board is invalid\n");
				   break;
			   case MB_ERR_MEMALLOC:
				   fprintf(stderr, "\t reason: out of memory\n");
				   break;
			   case MB_ERR_INTERNAL:
				   fprintf(stderr, "\t reason: internal error. Recompile libmoard in debug mode for more info \n");
				   break;
			   default:
				   fprintf(stderr, "\t MB_SyncComplete returned error code: %d (see libmboard docs for details)\n", rc);
				   break;
		   }
	
		   
		   exit(rc);
		}
		#endif
    
	}
	
	if(FLAME_TEST_PRINT_START_AND_END_OF_MODEL_FUNCTIONS) printf("start Bank_receive_installment\n");
	current_xmachine_Bank_holder = Bank_Bank_04_state->agents;
	while(current_xmachine_Bank_holder)
	{
		temp_xmachine_Bank_holder = current_xmachine_Bank_holder->next;
		current_xmachine_Bank = current_xmachine_Bank_holder->agent;
		current_xmachine_Bank_next_state = Bank_Bank_05_state;
		/* For backwards compatibility set current_xmachine */
		current_xmachine->xmachine_Firm = NULL;
		current_xmachine->xmachine_Household = NULL;
		current_xmachine->xmachine_Mall = NULL;
		current_xmachine->xmachine_IGFirm = NULL;
		current_xmachine->xmachine_Eurostat = NULL;
		current_xmachine->xmachine_Bank = NULL;
		current_xmachine->xmachine_Government = NULL;
		current_xmachine->xmachine_CentralBank = NULL;
		current_xmachine->xmachine_ClearingHouse = NULL;
		current_xmachine->xmachine_Bank = current_xmachine_Bank;

		

		
		
		rc = MB_Iterator_Create(b_installment, &i_installment);
		#ifdef ERRCHECK
		if (rc != MB_SUCCESS)
		{
		   fprintf(stderr, "ERROR: Could not create Iterator for 'installment'\n");
		   switch(rc) {
		       case MB_ERR_INVALID:
		           fprintf(stderr, "\t reason: 'installment' board is invalid\n");
		           break;
		       case MB_ERR_LOCKED:
	               fprintf(stderr, "\t reason: 'installment' board is locked\n");
	               break;
	           case MB_ERR_MEMALLOC:
	               fprintf(stderr, "\t reason: out of memory\n");
	               break;
	           case MB_ERR_INTERNAL:
	               fprintf(stderr, "\t reason: internal error. Recompile libmoard in debug mode for more info \n");
	               break;
	           default:
	           
               
                   fprintf(stderr, "\t MB_Iterator_Create returned error code: %d (see libmboard docs for details)\n", rc);
               
                   break;
		   }

		   
           exit(rc);
		}
		#endif
		
		
		
		rc = MB_Iterator_Create(b_bankruptcy, &i_bankruptcy);
		#ifdef ERRCHECK
		if (rc != MB_SUCCESS)
		{
		   fprintf(stderr, "ERROR: Could not create Iterator for 'bankruptcy'\n");
		   switch(rc) {
		       case MB_ERR_INVALID:
		           fprintf(stderr, "\t reason: 'bankruptcy' board is invalid\n");
		           break;
		       case MB_ERR_LOCKED:
	               fprintf(stderr, "\t reason: 'bankruptcy' board is locked\n");
	               break;
	           case MB_ERR_MEMALLOC:
	               fprintf(stderr, "\t reason: out of memory\n");
	               break;
	           case MB_ERR_INTERNAL:
	               fprintf(stderr, "\t reason: internal error. Recompile libmoard in debug mode for more info \n");
	               break;
	           default:
	           
               
                   fprintf(stderr, "\t MB_Iterator_Create returned error code: %d (see libmboard docs for details)\n", rc);
               
                   break;
		   }

		   
           exit(rc);
		}
		#endif
		
		

			i = Bank_receive_installment();

		
		    rc = MB_Iterator_Delete(&i_installment);
		    #ifdef ERRCHECK
		    if (rc != MB_SUCCESS)
		    {
		       fprintf(stderr, "ERROR: Could not delete 'installment' iterator\n");
		       switch(rc) {
		           case MB_ERR_INVALID:
		               fprintf(stderr, "\t reason: 'installment' iterator is invalid\n");
		               break;
		           case MB_ERR_INTERNAL:
		               fprintf(stderr, "\t reason: internal error. Recompile libmoard in debug mode for more info \n");
		               break;
		           default:
                       fprintf(stderr, "\t MB_Iterator_Delete returned error code: %d (see libmboard docs for details)\n", rc);
                       break;
		       }

		       
               exit(rc);
		    }
		    #endif
		
		    rc = MB_Iterator_Delete(&i_bankruptcy);
		    #ifdef ERRCHECK
		    if (rc != MB_SUCCESS)
		    {
		       fprintf(stderr, "ERROR: Could not delete 'bankruptcy' iterator\n");
		       switch(rc) {
		           case MB_ERR_INVALID:
		               fprintf(stderr, "\t reason: 'bankruptcy' iterator is invalid\n");
		               break;
		           case MB_ERR_INTERNAL:
		               fprintf(stderr, "\t reason: internal error. Recompile libmoard in debug mode for more info \n");
		               break;
		           default:
                       fprintf(stderr, "\t MB_Iterator_Delete returned error code: %d (see libmboard docs for details)\n", rc);
                       break;
		       }

		       
               exit(rc);
		    }
		    #endif
		

			if(i == 1)
			{
				free_Bank_agent(current_xmachine_Bank_holder, Bank_Bank_04_state);
			}
			else
			{
				transition_Bank_agent(current_xmachine_Bank_holder, Bank_Bank_04_state, Bank_Bank_05_state);
			}
		

		current_xmachine_Bank = NULL;

		current_xmachine_Bank_holder = temp_xmachine_Bank_holder;
	}
	if(FLAME_TEST_PRINT_START_AND_END_OF_MODEL_FUNCTIONS) printf("finish Bank_receive_installment\n");


	/* If mb is not read then leave sync complete until last possible moment */
	if(FLAME_dividend_info_message_board_read == 1)
	{
		if(FLAME_TEST_PRINT_START_AND_END_OF_LIBMBOARD_CALLS) printf("start MB_SyncComplete(b_dividend_info)\n");
		rc = MB_SyncComplete(b_dividend_info);
		if(FLAME_TEST_PRINT_START_AND_END_OF_LIBMBOARD_CALLS) printf("finsh MB_SyncComplete(b_dividend_info)\n");
		#ifdef ERRCHECK
		if (rc != MB_SUCCESS)
		{
		   fprintf(stderr, "ERROR: Could not complete sync of 'dividend_info' board\n");
		   switch(rc) {
				case MB_ERR_INVALID:
				   fprintf(stderr, "\t reason: 'dividend_info' board is invalid\n");
				   break;
			   case MB_ERR_MEMALLOC:
				   fprintf(stderr, "\t reason: out of memory\n");
				   break;
			   case MB_ERR_INTERNAL:
				   fprintf(stderr, "\t reason: internal error. Recompile libmoard in debug mode for more info \n");
				   break;
			   default:
				   fprintf(stderr, "\t MB_SyncComplete returned error code: %d (see libmboard docs for details)\n", rc);
				   break;
		   }
	
		   
		   exit(rc);
		}
		#endif
    
	}
	
	if(FLAME_TEST_PRINT_START_AND_END_OF_MODEL_FUNCTIONS) printf("start ClearingHouse_receive_dividend_info\n");
	current_xmachine_ClearingHouse_holder = ClearingHouse_AFM_04_state->agents;
	while(current_xmachine_ClearingHouse_holder)
	{
		temp_xmachine_ClearingHouse_holder = current_xmachine_ClearingHouse_holder->next;
		current_xmachine_ClearingHouse = current_xmachine_ClearingHouse_holder->agent;
		current_xmachine_ClearingHouse_next_state = ClearingHouse_AFM_05_state;
		/* For backwards compatibility set current_xmachine */
		current_xmachine->xmachine_Firm = NULL;
		current_xmachine->xmachine_Household = NULL;
		current_xmachine->xmachine_Mall = NULL;
		current_xmachine->xmachine_IGFirm = NULL;
		current_xmachine->xmachine_Eurostat = NULL;
		current_xmachine->xmachine_Bank = NULL;
		current_xmachine->xmachine_Government = NULL;
		current_xmachine->xmachine_CentralBank = NULL;
		current_xmachine->xmachine_ClearingHouse = NULL;
		current_xmachine->xmachine_ClearingHouse = current_xmachine_ClearingHouse;

		

		
		
		rc = MB_Iterator_Create(b_dividend_info, &i_dividend_info);
		#ifdef ERRCHECK
		if (rc != MB_SUCCESS)
		{
		   fprintf(stderr, "ERROR: Could not create Iterator for 'dividend_info'\n");
		   switch(rc) {
		       case MB_ERR_INVALID:
		           fprintf(stderr, "\t reason: 'dividend_info' board is invalid\n");
		           break;
		       case MB_ERR_LOCKED:
	               fprintf(stderr, "\t reason: 'dividend_info' board is locked\n");
	               break;
	           case MB_ERR_MEMALLOC:
	               fprintf(stderr, "\t reason: out of memory\n");
	               break;
	           case MB_ERR_INTERNAL:
	               fprintf(stderr, "\t reason: internal error. Recompile libmoard in debug mode for more info \n");
	               break;
	           default:
	           
               
                   fprintf(stderr, "\t MB_Iterator_Create returned error code: %d (see libmboard docs for details)\n", rc);
               
                   break;
		   }

		   
           exit(rc);
		}
		#endif
		
		

			i = ClearingHouse_receive_dividend_info();

		
		    rc = MB_Iterator_Delete(&i_dividend_info);
		    #ifdef ERRCHECK
		    if (rc != MB_SUCCESS)
		    {
		       fprintf(stderr, "ERROR: Could not delete 'dividend_info' iterator\n");
		       switch(rc) {
		           case MB_ERR_INVALID:
		               fprintf(stderr, "\t reason: 'dividend_info' iterator is invalid\n");
		               break;
		           case MB_ERR_INTERNAL:
		               fprintf(stderr, "\t reason: internal error. Recompile libmoard in debug mode for more info \n");
		               break;
		           default:
                       fprintf(stderr, "\t MB_Iterator_Delete returned error code: %d (see libmboard docs for details)\n", rc);
                       break;
		       }

		       
               exit(rc);
		    }
		    #endif
		

			if(i == 1)
			{
				free_ClearingHouse_agent(current_xmachine_ClearingHouse_holder, ClearingHouse_AFM_04_state);
			}
			else
			{
				transition_ClearingHouse_agent(current_xmachine_ClearingHouse_holder, ClearingHouse_AFM_04_state, ClearingHouse_AFM_05_state);
			}
		

		current_xmachine_ClearingHouse = NULL;

		current_xmachine_ClearingHouse_holder = temp_xmachine_ClearingHouse_holder;
	}
	if(FLAME_TEST_PRINT_START_AND_END_OF_MODEL_FUNCTIONS) printf("finish ClearingHouse_receive_dividend_info\n");


/* End of layer number 41 */

/* Clear message boards that have finished being used
 * and sync complete if doing late sync complete */

if(FLAME_installment_message_board_read == 0)
{
	/*printf("%d> installment message board sync complete late as no agents reading any messages of this type\n", node_number);*/
	
	if(FLAME_TEST_PRINT_START_AND_END_OF_LIBMBOARD_CALLS) printf("start MB_SyncComplete(b_installment)\n");
	rc = MB_SyncComplete(b_installment);
	if(FLAME_TEST_PRINT_START_AND_END_OF_LIBMBOARD_CALLS) printf("finsh MB_SyncComplete(b_installment)\n");
	#ifdef ERRCHECK
	if (rc != MB_SUCCESS)
	{
	   fprintf(stderr, "ERROR: Could not complete sync of 'installment' board\n");
	   switch(rc) {
			case MB_ERR_INVALID:
			   fprintf(stderr, "\t reason: 'installment' board is invalid\n");
			   break;
		   case MB_ERR_MEMALLOC:
			   fprintf(stderr, "\t reason: out of memory\n");
			   break;
		   case MB_ERR_INTERNAL:
			   fprintf(stderr, "\t reason: internal error. Recompile libmoard in debug mode for more info \n");
			   break;
		   default:
			   fprintf(stderr, "\t MB_SyncComplete returned error code: %d (see libmboard docs for details)\n", rc);
			   break;
	   }

	   
	   exit(rc);
	}
	#endif
}

    rc = MB_Clear(b_installment);
    #ifdef ERRCHECK
    if (rc != MB_SUCCESS)
    {
       fprintf(stderr, "ERROR: Could not clear 'installment' board\n");
       switch(rc) {
           case MB_ERR_INVALID:
               fprintf(stderr, "\t reason: 'installment' board is invalid\n");
               break;
           case MB_ERR_LOCKED:
               fprintf(stderr, "\t reason: 'installment' board is locked\n");
               break;
           case MB_ERR_INTERNAL:
               fprintf(stderr, "\t reason: internal error. Recompile libmoard in debug mode for more info \n");
               break;
           default:
               fprintf(stderr, "\t MB_Clear returned error code: %d (see libmboard docs for details)\n", rc);
               break;

       }

       
       exit(rc);
    }
    #endif

if(FLAME_bankruptcy_message_board_read == 0)
{
	/*printf("%d> bankruptcy message board sync complete late as no agents reading any messages of this type\n", node_number);*/
	
	if(FLAME_TEST_PRINT_START_AND_END_OF_LIBMBOARD_CALLS) printf("start MB_SyncComplete(b_bankruptcy)\n");
	rc = MB_SyncComplete(b_bankruptcy);
	if(FLAME_TEST_PRINT_START_AND_END_OF_LIBMBOARD_CALLS) printf("finsh MB_SyncComplete(b_bankruptcy)\n");
	#ifdef ERRCHECK
	if (rc != MB_SUCCESS)
	{
	   fprintf(stderr, "ERROR: Could not complete sync of 'bankruptcy' board\n");
	   switch(rc) {
			case MB_ERR_INVALID:
			   fprintf(stderr, "\t reason: 'bankruptcy' board is invalid\n");
			   break;
		   case MB_ERR_MEMALLOC:
			   fprintf(stderr, "\t reason: out of memory\n");
			   break;
		   case MB_ERR_INTERNAL:
			   fprintf(stderr, "\t reason: internal error. Recompile libmoard in debug mode for more info \n");
			   break;
		   default:
			   fprintf(stderr, "\t MB_SyncComplete returned error code: %d (see libmboard docs for details)\n", rc);
			   break;
	   }

	   
	   exit(rc);
	}
	#endif
}

    rc = MB_Clear(b_bankruptcy);
    #ifdef ERRCHECK
    if (rc != MB_SUCCESS)
    {
       fprintf(stderr, "ERROR: Could not clear 'bankruptcy' board\n");
       switch(rc) {
           case MB_ERR_INVALID:
               fprintf(stderr, "\t reason: 'bankruptcy' board is invalid\n");
               break;
           case MB_ERR_LOCKED:
               fprintf(stderr, "\t reason: 'bankruptcy' board is locked\n");
               break;
           case MB_ERR_INTERNAL:
               fprintf(stderr, "\t reason: internal error. Recompile libmoard in debug mode for more info \n");
               break;
           default:
               fprintf(stderr, "\t MB_Clear returned error code: %d (see libmboard docs for details)\n", rc);
               break;

       }

       
       exit(rc);
    }
    #endif

if(FLAME_dividend_info_message_board_read == 0)
{
	/*printf("%d> dividend_info message board sync complete late as no agents reading any messages of this type\n", node_number);*/
	
	if(FLAME_TEST_PRINT_START_AND_END_OF_LIBMBOARD_CALLS) printf("start MB_SyncComplete(b_dividend_info)\n");
	rc = MB_SyncComplete(b_dividend_info);
	if(FLAME_TEST_PRINT_START_AND_END_OF_LIBMBOARD_CALLS) printf("finsh MB_SyncComplete(b_dividend_info)\n");
	#ifdef ERRCHECK
	if (rc != MB_SUCCESS)
	{
	   fprintf(stderr, "ERROR: Could not complete sync of 'dividend_info' board\n");
	   switch(rc) {
			case MB_ERR_INVALID:
			   fprintf(stderr, "\t reason: 'dividend_info' board is invalid\n");
			   break;
		   case MB_ERR_MEMALLOC:
			   fprintf(stderr, "\t reason: out of memory\n");
			   break;
		   case MB_ERR_INTERNAL:
			   fprintf(stderr, "\t reason: internal error. Recompile libmoard in debug mode for more info \n");
			   break;
		   default:
			   fprintf(stderr, "\t MB_SyncComplete returned error code: %d (see libmboard docs for details)\n", rc);
			   break;
	   }

	   
	   exit(rc);
	}
	#endif
}

    rc = MB_Clear(b_dividend_info);
    #ifdef ERRCHECK
    if (rc != MB_SUCCESS)
    {
       fprintf(stderr, "ERROR: Could not clear 'dividend_info' board\n");
       switch(rc) {
           case MB_ERR_INVALID:
               fprintf(stderr, "\t reason: 'dividend_info' board is invalid\n");
               break;
           case MB_ERR_LOCKED:
               fprintf(stderr, "\t reason: 'dividend_info' board is locked\n");
               break;
           case MB_ERR_INTERNAL:
               fprintf(stderr, "\t reason: internal error. Recompile libmoard in debug mode for more info \n");
               break;
           default:
               fprintf(stderr, "\t MB_Clear returned error code: %d (see libmboard docs for details)\n", rc);
               break;

       }

       
       exit(rc);
    }
    #endif


	if(FLAME_TEST_PRINT_START_AND_END_OF_MODEL_FUNCTIONS) printf("start ClearingHouse_update_price\n");
	current_xmachine_ClearingHouse_holder = ClearingHouse_AFM_05_state->agents;
	while(current_xmachine_ClearingHouse_holder)
	{
		temp_xmachine_ClearingHouse_holder = current_xmachine_ClearingHouse_holder->next;
		current_xmachine_ClearingHouse = current_xmachine_ClearingHouse_holder->agent;
		current_xmachine_ClearingHouse_next_state = ClearingHouse_end_Clearinghouse_state;
		/* For backwards compatibility set current_xmachine */
		current_xmachine->xmachine_Firm = NULL;
		current_xmachine->xmachine_Household = NULL;
		current_xmachine->xmachine_Mall = NULL;
		current_xmachine->xmachine_IGFirm = NULL;
		current_xmachine->xmachine_Eurostat = NULL;
		current_xmachine->xmachine_Bank = NULL;
		current_xmachine->xmachine_Government = NULL;
		current_xmachine->xmachine_CentralBank = NULL;
		current_xmachine->xmachine_ClearingHouse = NULL;
		current_xmachine->xmachine_ClearingHouse = current_xmachine_ClearingHouse;

		

		

			i = ClearingHouse_update_price();

		

			if(i == 1)
			{
				free_ClearingHouse_agent(current_xmachine_ClearingHouse_holder, ClearingHouse_AFM_05_state);
			}
			else
			{
				transition_ClearingHouse_agent(current_xmachine_ClearingHouse_holder, ClearingHouse_AFM_05_state, ClearingHouse_end_Clearinghouse_state);
			}
		

		current_xmachine_ClearingHouse = NULL;

		current_xmachine_ClearingHouse_holder = temp_xmachine_ClearingHouse_holder;
	}
	if(FLAME_TEST_PRINT_START_AND_END_OF_MODEL_FUNCTIONS) printf("finish ClearingHouse_update_price\n");


	if(FLAME_TEST_PRINT_START_AND_END_OF_MODEL_FUNCTIONS) printf("start Firm_set_labour_market_actions\n");
	current_xmachine_Firm_holder = Firm_Firm_Start_Labour_Role_state->agents;
	while(current_xmachine_Firm_holder)
	{
		temp_xmachine_Firm_holder = current_xmachine_Firm_holder->next;
		current_xmachine_Firm = current_xmachine_Firm_holder->agent;
		current_xmachine_Firm_next_state = Firm_011a_state;
		/* For backwards compatibility set current_xmachine */
		current_xmachine->xmachine_Firm = NULL;
		current_xmachine->xmachine_Household = NULL;
		current_xmachine->xmachine_Mall = NULL;
		current_xmachine->xmachine_IGFirm = NULL;
		current_xmachine->xmachine_Eurostat = NULL;
		current_xmachine->xmachine_Bank = NULL;
		current_xmachine->xmachine_Government = NULL;
		current_xmachine->xmachine_CentralBank = NULL;
		current_xmachine->xmachine_ClearingHouse = NULL;
		current_xmachine->xmachine_Firm = current_xmachine_Firm;

		

		

			i = Firm_set_labour_market_actions();

		

			if(i == 1)
			{
				free_Firm_agent(current_xmachine_Firm_holder, Firm_Firm_Start_Labour_Role_state);
			}
			else
			{
				transition_Firm_agent(current_xmachine_Firm_holder, Firm_Firm_Start_Labour_Role_state, Firm_011a_state);
			}
		

		current_xmachine_Firm = NULL;

		current_xmachine_Firm_holder = temp_xmachine_Firm_holder;
	}
	if(FLAME_TEST_PRINT_START_AND_END_OF_MODEL_FUNCTIONS) printf("finish Firm_set_labour_market_actions\n");


/* End of layer number 42 */

/* Clear message boards that have finished being used
 * and sync complete if doing late sync complete */


	if(FLAME_TEST_PRINT_START_AND_END_OF_MODEL_FUNCTIONS) printf("start Firm_calculate_specific_skills_and_wage_offer\n");
	current_xmachine_Firm_holder = Firm_011a_state->agents;
	while(current_xmachine_Firm_holder)
	{
		temp_xmachine_Firm_holder = current_xmachine_Firm_holder->next;
		current_xmachine_Firm = current_xmachine_Firm_holder->agent;
		current_xmachine_Firm_next_state = Firm_011_state;
		/* For backwards compatibility set current_xmachine */
		current_xmachine->xmachine_Firm = NULL;
		current_xmachine->xmachine_Household = NULL;
		current_xmachine->xmachine_Mall = NULL;
		current_xmachine->xmachine_IGFirm = NULL;
		current_xmachine->xmachine_Eurostat = NULL;
		current_xmachine->xmachine_Bank = NULL;
		current_xmachine->xmachine_Government = NULL;
		current_xmachine->xmachine_CentralBank = NULL;
		current_xmachine->xmachine_ClearingHouse = NULL;
		current_xmachine->xmachine_Firm = current_xmachine_Firm;

		

		

			i = Firm_calculate_specific_skills_and_wage_offer();

		

			if(i == 1)
			{
				free_Firm_agent(current_xmachine_Firm_holder, Firm_011a_state);
			}
			else
			{
				transition_Firm_agent(current_xmachine_Firm_holder, Firm_011a_state, Firm_011_state);
			}
		

		current_xmachine_Firm = NULL;

		current_xmachine_Firm_holder = temp_xmachine_Firm_holder;
	}
	if(FLAME_TEST_PRINT_START_AND_END_OF_MODEL_FUNCTIONS) printf("finish Firm_calculate_specific_skills_and_wage_offer\n");


/* End of layer number 43 */

/* Clear message boards that have finished being used
 * and sync complete if doing late sync complete */


	if(FLAME_TEST_PRINT_START_AND_END_OF_MODEL_FUNCTIONS) printf("start Firm_send_redundancies\n");
	current_xmachine_Firm_holder = Firm_011_state->agents;
	while(current_xmachine_Firm_holder)
	{
		temp_xmachine_Firm_holder = current_xmachine_Firm_holder->next;
		current_xmachine_Firm = current_xmachine_Firm_holder->agent;
		current_xmachine_Firm_next_state = Firm_03ccc_state;
		/* For backwards compatibility set current_xmachine */
		current_xmachine->xmachine_Firm = NULL;
		current_xmachine->xmachine_Household = NULL;
		current_xmachine->xmachine_Mall = NULL;
		current_xmachine->xmachine_IGFirm = NULL;
		current_xmachine->xmachine_Eurostat = NULL;
		current_xmachine->xmachine_Bank = NULL;
		current_xmachine->xmachine_Government = NULL;
		current_xmachine->xmachine_CentralBank = NULL;
		current_xmachine->xmachine_ClearingHouse = NULL;
		current_xmachine->xmachine_Firm = current_xmachine_Firm;

		if(FLAME_condition_Firm_Firm_send_redundancies_011_03ccc(current_xmachine_Firm)==1)
		{

		

			i = Firm_send_redundancies();

		

			if(i == 1)
			{
				free_Firm_agent(current_xmachine_Firm_holder, Firm_011_state);
			}
			else
			{
				transition_Firm_agent(current_xmachine_Firm_holder, Firm_011_state, Firm_03ccc_state);
			}
		}

		current_xmachine_Firm = NULL;

		current_xmachine_Firm_holder = temp_xmachine_Firm_holder;
	}
	if(FLAME_TEST_PRINT_START_AND_END_OF_MODEL_FUNCTIONS) printf("finish Firm_send_redundancies\n");


	if(FLAME_TEST_PRINT_START_AND_END_OF_MODEL_FUNCTIONS) printf("start Firm_idle\n");
	current_xmachine_Firm_holder = Firm_011_state->agents;
	while(current_xmachine_Firm_holder)
	{
		temp_xmachine_Firm_holder = current_xmachine_Firm_holder->next;
		current_xmachine_Firm = current_xmachine_Firm_holder->agent;
		current_xmachine_Firm_next_state = Firm_03ccc_state;
		/* For backwards compatibility set current_xmachine */
		current_xmachine->xmachine_Firm = NULL;
		current_xmachine->xmachine_Household = NULL;
		current_xmachine->xmachine_Mall = NULL;
		current_xmachine->xmachine_IGFirm = NULL;
		current_xmachine->xmachine_Eurostat = NULL;
		current_xmachine->xmachine_Bank = NULL;
		current_xmachine->xmachine_Government = NULL;
		current_xmachine->xmachine_CentralBank = NULL;
		current_xmachine->xmachine_ClearingHouse = NULL;
		current_xmachine->xmachine_Firm = current_xmachine_Firm;

		if(FLAME_condition_Firm_Firm_idle_011_03ccc(current_xmachine_Firm)==1)
		{

		

			i = Firm_idle();

		

			if(i == 1)
			{
				free_Firm_agent(current_xmachine_Firm_holder, Firm_011_state);
			}
			else
			{
				transition_Firm_agent(current_xmachine_Firm_holder, Firm_011_state, Firm_03ccc_state);
			}
		}

		current_xmachine_Firm = NULL;

		current_xmachine_Firm_holder = temp_xmachine_Firm_holder;
	}
	if(FLAME_TEST_PRINT_START_AND_END_OF_MODEL_FUNCTIONS) printf("finish Firm_idle\n");


/* End of layer number 44 */

/* Clear message boards that have finished being used
 * and sync complete if doing late sync complete */


	if(FLAME_TEST_PRINT_START_AND_END_OF_MODEL_FUNCTIONS) printf("start Firm_send_random_redundancies\n");
	current_xmachine_Firm_holder = Firm_03ccc_state->agents;
	while(current_xmachine_Firm_holder)
	{
		temp_xmachine_Firm_holder = current_xmachine_Firm_holder->next;
		current_xmachine_Firm = current_xmachine_Firm_holder->agent;
		current_xmachine_Firm_next_state = Firm_04ccc_state;
		/* For backwards compatibility set current_xmachine */
		current_xmachine->xmachine_Firm = NULL;
		current_xmachine->xmachine_Household = NULL;
		current_xmachine->xmachine_Mall = NULL;
		current_xmachine->xmachine_IGFirm = NULL;
		current_xmachine->xmachine_Eurostat = NULL;
		current_xmachine->xmachine_Bank = NULL;
		current_xmachine->xmachine_Government = NULL;
		current_xmachine->xmachine_CentralBank = NULL;
		current_xmachine->xmachine_ClearingHouse = NULL;
		current_xmachine->xmachine_Firm = current_xmachine_Firm;

		

		

			i = Firm_send_random_redundancies();

		

			if(i == 1)
			{
				free_Firm_agent(current_xmachine_Firm_holder, Firm_03ccc_state);
			}
			else
			{
				transition_Firm_agent(current_xmachine_Firm_holder, Firm_03ccc_state, Firm_04ccc_state);
			}
		

		current_xmachine_Firm = NULL;

		current_xmachine_Firm_holder = temp_xmachine_Firm_holder;
	}
	if(FLAME_TEST_PRINT_START_AND_END_OF_MODEL_FUNCTIONS) printf("finish Firm_send_random_redundancies\n");

	if(FLAME_firing_message_board_write == 1)
	{

		if(FLAME_TEST_PRINT_START_AND_END_OF_LIBMBOARD_CALLS) printf("start MB_SyncStart(b_firing)\n");
		rc = MB_SyncStart(b_firing);
		if(FLAME_TEST_PRINT_START_AND_END_OF_LIBMBOARD_CALLS) printf("finish MB_SyncStart(b_firing)\n");
		#ifdef ERRCHECK
		if (rc != MB_SUCCESS)
		{
		   fprintf(stderr, "ERROR: Could not start sync of 'firing' board\n");
		   switch(rc) {
			   case MB_ERR_INVALID:
				   fprintf(stderr, "\t reason: 'firing' board is invalid\n");
				   break;
			   case MB_ERR_LOCKED:
				   fprintf(stderr, "\t reason: 'firing' board is locked\n");
				   break;
			   case MB_ERR_MEMALLOC:
				   fprintf(stderr, "\t reason: out of memory\n");
				   break;
			   case MB_ERR_INTERNAL:
				   fprintf(stderr, "\t reason: internal error. Recompile libmoard in debug mode for more info \n");
				   break;
			   default:
				   fprintf(stderr, "\t MB_SyncStart returned error code: %d (see libmboard docs for details)\n", rc);
				   break;
		   }

			
			exit(rc);
		}
		#endif
    }
    


/* End of layer number 45 */

/* Clear message boards that have finished being used
 * and sync complete if doing late sync complete */


	if(FLAME_TEST_PRINT_START_AND_END_OF_MODEL_FUNCTIONS) printf("start Firm_send_vacancies\n");
	current_xmachine_Firm_holder = Firm_04ccc_state->agents;
	while(current_xmachine_Firm_holder)
	{
		temp_xmachine_Firm_holder = current_xmachine_Firm_holder->next;
		current_xmachine_Firm = current_xmachine_Firm_holder->agent;
		current_xmachine_Firm_next_state = Firm_03_state;
		/* For backwards compatibility set current_xmachine */
		current_xmachine->xmachine_Firm = NULL;
		current_xmachine->xmachine_Household = NULL;
		current_xmachine->xmachine_Mall = NULL;
		current_xmachine->xmachine_IGFirm = NULL;
		current_xmachine->xmachine_Eurostat = NULL;
		current_xmachine->xmachine_Bank = NULL;
		current_xmachine->xmachine_Government = NULL;
		current_xmachine->xmachine_CentralBank = NULL;
		current_xmachine->xmachine_ClearingHouse = NULL;
		current_xmachine->xmachine_Firm = current_xmachine_Firm;

		if(FLAME_condition_Firm_Firm_send_vacancies_04ccc_03(current_xmachine_Firm)==1)
		{

		

			i = Firm_send_vacancies();

		

			if(i == 1)
			{
				free_Firm_agent(current_xmachine_Firm_holder, Firm_04ccc_state);
			}
			else
			{
				transition_Firm_agent(current_xmachine_Firm_holder, Firm_04ccc_state, Firm_03_state);
			}
		}

		current_xmachine_Firm = NULL;

		current_xmachine_Firm_holder = temp_xmachine_Firm_holder;
	}
	if(FLAME_TEST_PRINT_START_AND_END_OF_MODEL_FUNCTIONS) printf("finish Firm_send_vacancies\n");

	if(FLAME_vacancies_r_and_d_employees_message_board_write == 1)
	{

		if(FLAME_TEST_PRINT_START_AND_END_OF_LIBMBOARD_CALLS) printf("start MB_SyncStart(b_vacancies_r_and_d_employees)\n");
		rc = MB_SyncStart(b_vacancies_r_and_d_employees);
		if(FLAME_TEST_PRINT_START_AND_END_OF_LIBMBOARD_CALLS) printf("finish MB_SyncStart(b_vacancies_r_and_d_employees)\n");
		#ifdef ERRCHECK
		if (rc != MB_SUCCESS)
		{
		   fprintf(stderr, "ERROR: Could not start sync of 'vacancies_r_and_d_employees' board\n");
		   switch(rc) {
			   case MB_ERR_INVALID:
				   fprintf(stderr, "\t reason: 'vacancies_r_and_d_employees' board is invalid\n");
				   break;
			   case MB_ERR_LOCKED:
				   fprintf(stderr, "\t reason: 'vacancies_r_and_d_employees' board is locked\n");
				   break;
			   case MB_ERR_MEMALLOC:
				   fprintf(stderr, "\t reason: out of memory\n");
				   break;
			   case MB_ERR_INTERNAL:
				   fprintf(stderr, "\t reason: internal error. Recompile libmoard in debug mode for more info \n");
				   break;
			   default:
				   fprintf(stderr, "\t MB_SyncStart returned error code: %d (see libmboard docs for details)\n", rc);
				   break;
		   }

			
			exit(rc);
		}
		#endif
    }
    

	if(FLAME_vacancies_message_board_write == 1)
	{

		if(FLAME_TEST_PRINT_START_AND_END_OF_LIBMBOARD_CALLS) printf("start MB_SyncStart(b_vacancies)\n");
		rc = MB_SyncStart(b_vacancies);
		if(FLAME_TEST_PRINT_START_AND_END_OF_LIBMBOARD_CALLS) printf("finish MB_SyncStart(b_vacancies)\n");
		#ifdef ERRCHECK
		if (rc != MB_SUCCESS)
		{
		   fprintf(stderr, "ERROR: Could not start sync of 'vacancies' board\n");
		   switch(rc) {
			   case MB_ERR_INVALID:
				   fprintf(stderr, "\t reason: 'vacancies' board is invalid\n");
				   break;
			   case MB_ERR_LOCKED:
				   fprintf(stderr, "\t reason: 'vacancies' board is locked\n");
				   break;
			   case MB_ERR_MEMALLOC:
				   fprintf(stderr, "\t reason: out of memory\n");
				   break;
			   case MB_ERR_INTERNAL:
				   fprintf(stderr, "\t reason: internal error. Recompile libmoard in debug mode for more info \n");
				   break;
			   default:
				   fprintf(stderr, "\t MB_SyncStart returned error code: %d (see libmboard docs for details)\n", rc);
				   break;
		   }

			
			exit(rc);
		}
		#endif
    }
    


	if(FLAME_TEST_PRINT_START_AND_END_OF_MODEL_FUNCTIONS) printf("start idle\n");
	current_xmachine_Firm_holder = Firm_04ccc_state->agents;
	while(current_xmachine_Firm_holder)
	{
		temp_xmachine_Firm_holder = current_xmachine_Firm_holder->next;
		current_xmachine_Firm = current_xmachine_Firm_holder->agent;
		current_xmachine_Firm_next_state = Firm_03c_state;
		/* For backwards compatibility set current_xmachine */
		current_xmachine->xmachine_Firm = NULL;
		current_xmachine->xmachine_Household = NULL;
		current_xmachine->xmachine_Mall = NULL;
		current_xmachine->xmachine_IGFirm = NULL;
		current_xmachine->xmachine_Eurostat = NULL;
		current_xmachine->xmachine_Bank = NULL;
		current_xmachine->xmachine_Government = NULL;
		current_xmachine->xmachine_CentralBank = NULL;
		current_xmachine->xmachine_ClearingHouse = NULL;
		current_xmachine->xmachine_Firm = current_xmachine_Firm;

		if(FLAME_condition_Firm_idle_04ccc_03c(current_xmachine_Firm)==1)
		{

		

			i = idle();

		

			if(i == 1)
			{
				free_Firm_agent(current_xmachine_Firm_holder, Firm_04ccc_state);
			}
			else
			{
				transition_Firm_agent(current_xmachine_Firm_holder, Firm_04ccc_state, Firm_03c_state);
			}
		}

		current_xmachine_Firm = NULL;

		current_xmachine_Firm_holder = temp_xmachine_Firm_holder;
	}
	if(FLAME_TEST_PRINT_START_AND_END_OF_MODEL_FUNCTIONS) printf("finish idle\n");


	/* If mb is not read then leave sync complete until last possible moment */
	if(FLAME_firing_message_board_read == 1)
	{
		if(FLAME_TEST_PRINT_START_AND_END_OF_LIBMBOARD_CALLS) printf("start MB_SyncComplete(b_firing)\n");
		rc = MB_SyncComplete(b_firing);
		if(FLAME_TEST_PRINT_START_AND_END_OF_LIBMBOARD_CALLS) printf("finsh MB_SyncComplete(b_firing)\n");
		#ifdef ERRCHECK
		if (rc != MB_SUCCESS)
		{
		   fprintf(stderr, "ERROR: Could not complete sync of 'firing' board\n");
		   switch(rc) {
				case MB_ERR_INVALID:
				   fprintf(stderr, "\t reason: 'firing' board is invalid\n");
				   break;
			   case MB_ERR_MEMALLOC:
				   fprintf(stderr, "\t reason: out of memory\n");
				   break;
			   case MB_ERR_INTERNAL:
				   fprintf(stderr, "\t reason: internal error. Recompile libmoard in debug mode for more info \n");
				   break;
			   default:
				   fprintf(stderr, "\t MB_SyncComplete returned error code: %d (see libmboard docs for details)\n", rc);
				   break;
		   }
	
		   
		   exit(rc);
		}
		#endif
    
	}
	
	if(FLAME_TEST_PRINT_START_AND_END_OF_MODEL_FUNCTIONS) printf("start Household_read_firing_messages\n");
	current_xmachine_Household_holder = Household_Household_Start_Labour_Role_state->agents;
	while(current_xmachine_Household_holder)
	{
		temp_xmachine_Household_holder = current_xmachine_Household_holder->next;
		current_xmachine_Household = current_xmachine_Household_holder->agent;
		current_xmachine_Household_next_state = Household_01d_state;
		/* For backwards compatibility set current_xmachine */
		current_xmachine->xmachine_Firm = NULL;
		current_xmachine->xmachine_Household = NULL;
		current_xmachine->xmachine_Mall = NULL;
		current_xmachine->xmachine_IGFirm = NULL;
		current_xmachine->xmachine_Eurostat = NULL;
		current_xmachine->xmachine_Bank = NULL;
		current_xmachine->xmachine_Government = NULL;
		current_xmachine->xmachine_CentralBank = NULL;
		current_xmachine->xmachine_ClearingHouse = NULL;
		current_xmachine->xmachine_Household = current_xmachine_Household;

		if(FLAME_condition_Household_Household_read_firing_messages_Household_Start_Labour_Role_01d(current_xmachine_Household)==1)
		{

		
		rc = MB_Iterator_CreateFiltered(b_firing, &i_firing, &FLAME_filter_Household_Household_read_firing_messages_Household_Start_Labour_Role_01d_firing, current_xmachine_Household);
		
		#ifdef ERRCHECK
		if (rc != MB_SUCCESS)
		{
		   fprintf(stderr, "ERROR: Could not create Iterator for 'firing'\n");
		   switch(rc) {
		       case MB_ERR_INVALID:
		           fprintf(stderr, "\t reason: 'firing' board is invalid\n");
		           break;
		       case MB_ERR_LOCKED:
	               fprintf(stderr, "\t reason: 'firing' board is locked\n");
	               break;
	           case MB_ERR_MEMALLOC:
	               fprintf(stderr, "\t reason: out of memory\n");
	               break;
	           case MB_ERR_INTERNAL:
	               fprintf(stderr, "\t reason: internal error. Recompile libmoard in debug mode for more info \n");
	               break;
	           default:
	           
                   fprintf(stderr, "\t MB_Iterator_CreateFiltered returned error code: %d (see libmboard docs for details)\n", rc);
               
               
                   break;
		   }

		   
           exit(rc);
		}
		#endif
		
		

			i = Household_read_firing_messages();

		
		    rc = MB_Iterator_Delete(&i_firing);
		    #ifdef ERRCHECK
		    if (rc != MB_SUCCESS)
		    {
		       fprintf(stderr, "ERROR: Could not delete 'firing' iterator\n");
		       switch(rc) {
		           case MB_ERR_INVALID:
		               fprintf(stderr, "\t reason: 'firing' iterator is invalid\n");
		               break;
		           case MB_ERR_INTERNAL:
		               fprintf(stderr, "\t reason: internal error. Recompile libmoard in debug mode for more info \n");
		               break;
		           default:
                       fprintf(stderr, "\t MB_Iterator_Delete returned error code: %d (see libmboard docs for details)\n", rc);
                       break;
		       }

		       
               exit(rc);
		    }
		    #endif
		

			if(i == 1)
			{
				free_Household_agent(current_xmachine_Household_holder, Household_Household_Start_Labour_Role_state);
			}
			else
			{
				transition_Household_agent(current_xmachine_Household_holder, Household_Household_Start_Labour_Role_state, Household_01d_state);
			}
		}

		current_xmachine_Household = NULL;

		current_xmachine_Household_holder = temp_xmachine_Household_holder;
	}
	if(FLAME_TEST_PRINT_START_AND_END_OF_MODEL_FUNCTIONS) printf("finish Household_read_firing_messages\n");


/* End of layer number 46 */

/* Clear message boards that have finished being used
 * and sync complete if doing late sync complete */

if(FLAME_firing_message_board_read == 0)
{
	/*printf("%d> firing message board sync complete late as no agents reading any messages of this type\n", node_number);*/
	
	if(FLAME_TEST_PRINT_START_AND_END_OF_LIBMBOARD_CALLS) printf("start MB_SyncComplete(b_firing)\n");
	rc = MB_SyncComplete(b_firing);
	if(FLAME_TEST_PRINT_START_AND_END_OF_LIBMBOARD_CALLS) printf("finsh MB_SyncComplete(b_firing)\n");
	#ifdef ERRCHECK
	if (rc != MB_SUCCESS)
	{
	   fprintf(stderr, "ERROR: Could not complete sync of 'firing' board\n");
	   switch(rc) {
			case MB_ERR_INVALID:
			   fprintf(stderr, "\t reason: 'firing' board is invalid\n");
			   break;
		   case MB_ERR_MEMALLOC:
			   fprintf(stderr, "\t reason: out of memory\n");
			   break;
		   case MB_ERR_INTERNAL:
			   fprintf(stderr, "\t reason: internal error. Recompile libmoard in debug mode for more info \n");
			   break;
		   default:
			   fprintf(stderr, "\t MB_SyncComplete returned error code: %d (see libmboard docs for details)\n", rc);
			   break;
	   }

	   
	   exit(rc);
	}
	#endif
}

    rc = MB_Clear(b_firing);
    #ifdef ERRCHECK
    if (rc != MB_SUCCESS)
    {
       fprintf(stderr, "ERROR: Could not clear 'firing' board\n");
       switch(rc) {
           case MB_ERR_INVALID:
               fprintf(stderr, "\t reason: 'firing' board is invalid\n");
               break;
           case MB_ERR_LOCKED:
               fprintf(stderr, "\t reason: 'firing' board is locked\n");
               break;
           case MB_ERR_INTERNAL:
               fprintf(stderr, "\t reason: internal error. Recompile libmoard in debug mode for more info \n");
               break;
           default:
               fprintf(stderr, "\t MB_Clear returned error code: %d (see libmboard docs for details)\n", rc);
               break;

       }

       
       exit(rc);
    }
    #endif


	if(FLAME_TEST_PRINT_START_AND_END_OF_MODEL_FUNCTIONS) printf("start Household_idle\n");
	current_xmachine_Household_holder = Household_01d_state->agents;
	while(current_xmachine_Household_holder)
	{
		temp_xmachine_Household_holder = current_xmachine_Household_holder->next;
		current_xmachine_Household = current_xmachine_Household_holder->agent;
		current_xmachine_Household_next_state = Household_06_state;
		/* For backwards compatibility set current_xmachine */
		current_xmachine->xmachine_Firm = NULL;
		current_xmachine->xmachine_Household = NULL;
		current_xmachine->xmachine_Mall = NULL;
		current_xmachine->xmachine_IGFirm = NULL;
		current_xmachine->xmachine_Eurostat = NULL;
		current_xmachine->xmachine_Bank = NULL;
		current_xmachine->xmachine_Government = NULL;
		current_xmachine->xmachine_CentralBank = NULL;
		current_xmachine->xmachine_ClearingHouse = NULL;
		current_xmachine->xmachine_Household = current_xmachine_Household;

		if(FLAME_condition_Household_Household_idle_01d_06(current_xmachine_Household)==1)
		{

		

			i = Household_idle();

		

			if(i == 1)
			{
				free_Household_agent(current_xmachine_Household_holder, Household_01d_state);
			}
			else
			{
				transition_Household_agent(current_xmachine_Household_holder, Household_01d_state, Household_06_state);
			}
		}

		current_xmachine_Household = NULL;

		current_xmachine_Household_holder = temp_xmachine_Household_holder;
	}
	if(FLAME_TEST_PRINT_START_AND_END_OF_MODEL_FUNCTIONS) printf("finish Household_idle\n");


	if(FLAME_TEST_PRINT_START_AND_END_OF_MODEL_FUNCTIONS) printf("start Household_idle\n");
	current_xmachine_Household_holder = Household_01d_state->agents;
	while(current_xmachine_Household_holder)
	{
		temp_xmachine_Household_holder = current_xmachine_Household_holder->next;
		current_xmachine_Household = current_xmachine_Household_holder->agent;
		current_xmachine_Household_next_state = Household_01a_state;
		/* For backwards compatibility set current_xmachine */
		current_xmachine->xmachine_Firm = NULL;
		current_xmachine->xmachine_Household = NULL;
		current_xmachine->xmachine_Mall = NULL;
		current_xmachine->xmachine_IGFirm = NULL;
		current_xmachine->xmachine_Eurostat = NULL;
		current_xmachine->xmachine_Bank = NULL;
		current_xmachine->xmachine_Government = NULL;
		current_xmachine->xmachine_CentralBank = NULL;
		current_xmachine->xmachine_ClearingHouse = NULL;
		current_xmachine->xmachine_Household = current_xmachine_Household;

		if(FLAME_condition_Household_Household_idle_01d_01a(current_xmachine_Household)==1)
		{

		

			i = Household_idle();

		

			if(i == 1)
			{
				free_Household_agent(current_xmachine_Household_holder, Household_01d_state);
			}
			else
			{
				transition_Household_agent(current_xmachine_Household_holder, Household_01d_state, Household_01a_state);
			}
		}

		current_xmachine_Household = NULL;

		current_xmachine_Household_holder = temp_xmachine_Household_holder;
	}
	if(FLAME_TEST_PRINT_START_AND_END_OF_MODEL_FUNCTIONS) printf("finish Household_idle\n");


/* End of layer number 47 */

/* Clear message boards that have finished being used
 * and sync complete if doing late sync complete */


	/* If mb is not read then leave sync complete until last possible moment */
	if(FLAME_vacancies_r_and_d_employees_message_board_read == 1)
	{
		if(FLAME_TEST_PRINT_START_AND_END_OF_LIBMBOARD_CALLS) printf("start MB_SyncComplete(b_vacancies_r_and_d_employees)\n");
		rc = MB_SyncComplete(b_vacancies_r_and_d_employees);
		if(FLAME_TEST_PRINT_START_AND_END_OF_LIBMBOARD_CALLS) printf("finsh MB_SyncComplete(b_vacancies_r_and_d_employees)\n");
		#ifdef ERRCHECK
		if (rc != MB_SUCCESS)
		{
		   fprintf(stderr, "ERROR: Could not complete sync of 'vacancies_r_and_d_employees' board\n");
		   switch(rc) {
				case MB_ERR_INVALID:
				   fprintf(stderr, "\t reason: 'vacancies_r_and_d_employees' board is invalid\n");
				   break;
			   case MB_ERR_MEMALLOC:
				   fprintf(stderr, "\t reason: out of memory\n");
				   break;
			   case MB_ERR_INTERNAL:
				   fprintf(stderr, "\t reason: internal error. Recompile libmoard in debug mode for more info \n");
				   break;
			   default:
				   fprintf(stderr, "\t MB_SyncComplete returned error code: %d (see libmboard docs for details)\n", rc);
				   break;
		   }
	
		   
		   exit(rc);
		}
		#endif
    
	}
	
	/* If mb is not read then leave sync complete until last possible moment */
	if(FLAME_vacancies_message_board_read == 1)
	{
		if(FLAME_TEST_PRINT_START_AND_END_OF_LIBMBOARD_CALLS) printf("start MB_SyncComplete(b_vacancies)\n");
		rc = MB_SyncComplete(b_vacancies);
		if(FLAME_TEST_PRINT_START_AND_END_OF_LIBMBOARD_CALLS) printf("finsh MB_SyncComplete(b_vacancies)\n");
		#ifdef ERRCHECK
		if (rc != MB_SUCCESS)
		{
		   fprintf(stderr, "ERROR: Could not complete sync of 'vacancies' board\n");
		   switch(rc) {
				case MB_ERR_INVALID:
				   fprintf(stderr, "\t reason: 'vacancies' board is invalid\n");
				   break;
			   case MB_ERR_MEMALLOC:
				   fprintf(stderr, "\t reason: out of memory\n");
				   break;
			   case MB_ERR_INTERNAL:
				   fprintf(stderr, "\t reason: internal error. Recompile libmoard in debug mode for more info \n");
				   break;
			   default:
				   fprintf(stderr, "\t MB_SyncComplete returned error code: %d (see libmboard docs for details)\n", rc);
				   break;
		   }
	
		   
		   exit(rc);
		}
		#endif
    
	}
	
	if(FLAME_TEST_PRINT_START_AND_END_OF_MODEL_FUNCTIONS) printf("start Household_UNEMPLOYED_read_job_vacancies_and_send_applications\n");
	current_xmachine_Household_holder = Household_01a_state->agents;
	while(current_xmachine_Household_holder)
	{
		temp_xmachine_Household_holder = current_xmachine_Household_holder->next;
		current_xmachine_Household = current_xmachine_Household_holder->agent;
		current_xmachine_Household_next_state = Household_01_state;
		/* For backwards compatibility set current_xmachine */
		current_xmachine->xmachine_Firm = NULL;
		current_xmachine->xmachine_Household = NULL;
		current_xmachine->xmachine_Mall = NULL;
		current_xmachine->xmachine_IGFirm = NULL;
		current_xmachine->xmachine_Eurostat = NULL;
		current_xmachine->xmachine_Bank = NULL;
		current_xmachine->xmachine_Government = NULL;
		current_xmachine->xmachine_CentralBank = NULL;
		current_xmachine->xmachine_ClearingHouse = NULL;
		current_xmachine->xmachine_Household = current_xmachine_Household;

		

		
		
		rc = MB_Iterator_Create(b_vacancies, &i_vacancies);
		#ifdef ERRCHECK
		if (rc != MB_SUCCESS)
		{
		   fprintf(stderr, "ERROR: Could not create Iterator for 'vacancies'\n");
		   switch(rc) {
		       case MB_ERR_INVALID:
		           fprintf(stderr, "\t reason: 'vacancies' board is invalid\n");
		           break;
		       case MB_ERR_LOCKED:
	               fprintf(stderr, "\t reason: 'vacancies' board is locked\n");
	               break;
	           case MB_ERR_MEMALLOC:
	               fprintf(stderr, "\t reason: out of memory\n");
	               break;
	           case MB_ERR_INTERNAL:
	               fprintf(stderr, "\t reason: internal error. Recompile libmoard in debug mode for more info \n");
	               break;
	           default:
	           
               
                   fprintf(stderr, "\t MB_Iterator_Create returned error code: %d (see libmboard docs for details)\n", rc);
               
                   break;
		   }

		   
           exit(rc);
		}
		#endif
		
		
		rc = MB_Iterator_CreateFiltered(b_vacancies_r_and_d_employees, &i_vacancies_r_and_d_employees, &FLAME_filter_Household_Household_UNEMPLOYED_read_job_vacancies_and_send_applications_01a_01_vacancies_r_and_d_employees, current_xmachine_Household);
		
		#ifdef ERRCHECK
		if (rc != MB_SUCCESS)
		{
		   fprintf(stderr, "ERROR: Could not create Iterator for 'vacancies_r_and_d_employees'\n");
		   switch(rc) {
		       case MB_ERR_INVALID:
		           fprintf(stderr, "\t reason: 'vacancies_r_and_d_employees' board is invalid\n");
		           break;
		       case MB_ERR_LOCKED:
	               fprintf(stderr, "\t reason: 'vacancies_r_and_d_employees' board is locked\n");
	               break;
	           case MB_ERR_MEMALLOC:
	               fprintf(stderr, "\t reason: out of memory\n");
	               break;
	           case MB_ERR_INTERNAL:
	               fprintf(stderr, "\t reason: internal error. Recompile libmoard in debug mode for more info \n");
	               break;
	           default:
	           
                   fprintf(stderr, "\t MB_Iterator_CreateFiltered returned error code: %d (see libmboard docs for details)\n", rc);
               
               
                   break;
		   }

		   
           exit(rc);
		}
		#endif
		
		

			i = Household_UNEMPLOYED_read_job_vacancies_and_send_applications();

		
		    rc = MB_Iterator_Delete(&i_vacancies);
		    #ifdef ERRCHECK
		    if (rc != MB_SUCCESS)
		    {
		       fprintf(stderr, "ERROR: Could not delete 'vacancies' iterator\n");
		       switch(rc) {
		           case MB_ERR_INVALID:
		               fprintf(stderr, "\t reason: 'vacancies' iterator is invalid\n");
		               break;
		           case MB_ERR_INTERNAL:
		               fprintf(stderr, "\t reason: internal error. Recompile libmoard in debug mode for more info \n");
		               break;
		           default:
                       fprintf(stderr, "\t MB_Iterator_Delete returned error code: %d (see libmboard docs for details)\n", rc);
                       break;
		       }

		       
               exit(rc);
		    }
		    #endif
		
		    rc = MB_Iterator_Delete(&i_vacancies_r_and_d_employees);
		    #ifdef ERRCHECK
		    if (rc != MB_SUCCESS)
		    {
		       fprintf(stderr, "ERROR: Could not delete 'vacancies_r_and_d_employees' iterator\n");
		       switch(rc) {
		           case MB_ERR_INVALID:
		               fprintf(stderr, "\t reason: 'vacancies_r_and_d_employees' iterator is invalid\n");
		               break;
		           case MB_ERR_INTERNAL:
		               fprintf(stderr, "\t reason: internal error. Recompile libmoard in debug mode for more info \n");
		               break;
		           default:
                       fprintf(stderr, "\t MB_Iterator_Delete returned error code: %d (see libmboard docs for details)\n", rc);
                       break;
		       }

		       
               exit(rc);
		    }
		    #endif
		

			if(i == 1)
			{
				free_Household_agent(current_xmachine_Household_holder, Household_01a_state);
			}
			else
			{
				transition_Household_agent(current_xmachine_Household_holder, Household_01a_state, Household_01_state);
			}
		

		current_xmachine_Household = NULL;

		current_xmachine_Household_holder = temp_xmachine_Household_holder;
	}
	if(FLAME_TEST_PRINT_START_AND_END_OF_MODEL_FUNCTIONS) printf("finish Household_UNEMPLOYED_read_job_vacancies_and_send_applications\n");

	if(FLAME_job_application_message_board_write == 1)
	{

		if(FLAME_TEST_PRINT_START_AND_END_OF_LIBMBOARD_CALLS) printf("start MB_SyncStart(b_job_application)\n");
		rc = MB_SyncStart(b_job_application);
		if(FLAME_TEST_PRINT_START_AND_END_OF_LIBMBOARD_CALLS) printf("finish MB_SyncStart(b_job_application)\n");
		#ifdef ERRCHECK
		if (rc != MB_SUCCESS)
		{
		   fprintf(stderr, "ERROR: Could not start sync of 'job_application' board\n");
		   switch(rc) {
			   case MB_ERR_INVALID:
				   fprintf(stderr, "\t reason: 'job_application' board is invalid\n");
				   break;
			   case MB_ERR_LOCKED:
				   fprintf(stderr, "\t reason: 'job_application' board is locked\n");
				   break;
			   case MB_ERR_MEMALLOC:
				   fprintf(stderr, "\t reason: out of memory\n");
				   break;
			   case MB_ERR_INTERNAL:
				   fprintf(stderr, "\t reason: internal error. Recompile libmoard in debug mode for more info \n");
				   break;
			   default:
				   fprintf(stderr, "\t MB_SyncStart returned error code: %d (see libmboard docs for details)\n", rc);
				   break;
		   }

			
			exit(rc);
		}
		#endif
    }
    


/* End of layer number 48 */

/* Clear message boards that have finished being used
 * and sync complete if doing late sync complete */

if(FLAME_vacancies_message_board_read == 0)
{
	/*printf("%d> vacancies message board sync complete late as no agents reading any messages of this type\n", node_number);*/
	
	if(FLAME_TEST_PRINT_START_AND_END_OF_LIBMBOARD_CALLS) printf("start MB_SyncComplete(b_vacancies)\n");
	rc = MB_SyncComplete(b_vacancies);
	if(FLAME_TEST_PRINT_START_AND_END_OF_LIBMBOARD_CALLS) printf("finsh MB_SyncComplete(b_vacancies)\n");
	#ifdef ERRCHECK
	if (rc != MB_SUCCESS)
	{
	   fprintf(stderr, "ERROR: Could not complete sync of 'vacancies' board\n");
	   switch(rc) {
			case MB_ERR_INVALID:
			   fprintf(stderr, "\t reason: 'vacancies' board is invalid\n");
			   break;
		   case MB_ERR_MEMALLOC:
			   fprintf(stderr, "\t reason: out of memory\n");
			   break;
		   case MB_ERR_INTERNAL:
			   fprintf(stderr, "\t reason: internal error. Recompile libmoard in debug mode for more info \n");
			   break;
		   default:
			   fprintf(stderr, "\t MB_SyncComplete returned error code: %d (see libmboard docs for details)\n", rc);
			   break;
	   }

	   
	   exit(rc);
	}
	#endif
}

    rc = MB_Clear(b_vacancies);
    #ifdef ERRCHECK
    if (rc != MB_SUCCESS)
    {
       fprintf(stderr, "ERROR: Could not clear 'vacancies' board\n");
       switch(rc) {
           case MB_ERR_INVALID:
               fprintf(stderr, "\t reason: 'vacancies' board is invalid\n");
               break;
           case MB_ERR_LOCKED:
               fprintf(stderr, "\t reason: 'vacancies' board is locked\n");
               break;
           case MB_ERR_INTERNAL:
               fprintf(stderr, "\t reason: internal error. Recompile libmoard in debug mode for more info \n");
               break;
           default:
               fprintf(stderr, "\t MB_Clear returned error code: %d (see libmboard docs for details)\n", rc);
               break;

       }

       
       exit(rc);
    }
    #endif

if(FLAME_vacancies_r_and_d_employees_message_board_read == 0)
{
	/*printf("%d> vacancies_r_and_d_employees message board sync complete late as no agents reading any messages of this type\n", node_number);*/
	
	if(FLAME_TEST_PRINT_START_AND_END_OF_LIBMBOARD_CALLS) printf("start MB_SyncComplete(b_vacancies_r_and_d_employees)\n");
	rc = MB_SyncComplete(b_vacancies_r_and_d_employees);
	if(FLAME_TEST_PRINT_START_AND_END_OF_LIBMBOARD_CALLS) printf("finsh MB_SyncComplete(b_vacancies_r_and_d_employees)\n");
	#ifdef ERRCHECK
	if (rc != MB_SUCCESS)
	{
	   fprintf(stderr, "ERROR: Could not complete sync of 'vacancies_r_and_d_employees' board\n");
	   switch(rc) {
			case MB_ERR_INVALID:
			   fprintf(stderr, "\t reason: 'vacancies_r_and_d_employees' board is invalid\n");
			   break;
		   case MB_ERR_MEMALLOC:
			   fprintf(stderr, "\t reason: out of memory\n");
			   break;
		   case MB_ERR_INTERNAL:
			   fprintf(stderr, "\t reason: internal error. Recompile libmoard in debug mode for more info \n");
			   break;
		   default:
			   fprintf(stderr, "\t MB_SyncComplete returned error code: %d (see libmboard docs for details)\n", rc);
			   break;
	   }

	   
	   exit(rc);
	}
	#endif
}

    rc = MB_Clear(b_vacancies_r_and_d_employees);
    #ifdef ERRCHECK
    if (rc != MB_SUCCESS)
    {
       fprintf(stderr, "ERROR: Could not clear 'vacancies_r_and_d_employees' board\n");
       switch(rc) {
           case MB_ERR_INVALID:
               fprintf(stderr, "\t reason: 'vacancies_r_and_d_employees' board is invalid\n");
               break;
           case MB_ERR_LOCKED:
               fprintf(stderr, "\t reason: 'vacancies_r_and_d_employees' board is locked\n");
               break;
           case MB_ERR_INTERNAL:
               fprintf(stderr, "\t reason: internal error. Recompile libmoard in debug mode for more info \n");
               break;
           default:
               fprintf(stderr, "\t MB_Clear returned error code: %d (see libmboard docs for details)\n", rc);
               break;

       }

       
       exit(rc);
    }
    #endif


	/* If mb is not read then leave sync complete until last possible moment */
	if(FLAME_job_application_message_board_read == 1)
	{
		if(FLAME_TEST_PRINT_START_AND_END_OF_LIBMBOARD_CALLS) printf("start MB_SyncComplete(b_job_application)\n");
		rc = MB_SyncComplete(b_job_application);
		if(FLAME_TEST_PRINT_START_AND_END_OF_LIBMBOARD_CALLS) printf("finsh MB_SyncComplete(b_job_application)\n");
		#ifdef ERRCHECK
		if (rc != MB_SUCCESS)
		{
		   fprintf(stderr, "ERROR: Could not complete sync of 'job_application' board\n");
		   switch(rc) {
				case MB_ERR_INVALID:
				   fprintf(stderr, "\t reason: 'job_application' board is invalid\n");
				   break;
			   case MB_ERR_MEMALLOC:
				   fprintf(stderr, "\t reason: out of memory\n");
				   break;
			   case MB_ERR_INTERNAL:
				   fprintf(stderr, "\t reason: internal error. Recompile libmoard in debug mode for more info \n");
				   break;
			   default:
				   fprintf(stderr, "\t MB_SyncComplete returned error code: %d (see libmboard docs for details)\n", rc);
				   break;
		   }
	
		   
		   exit(rc);
		}
		#endif
    
	}
	
	if(FLAME_TEST_PRINT_START_AND_END_OF_MODEL_FUNCTIONS) printf("start Firm_read_job_applications_send_job_offer_or_rejection\n");
	current_xmachine_Firm_holder = Firm_03_state->agents;
	while(current_xmachine_Firm_holder)
	{
		temp_xmachine_Firm_holder = current_xmachine_Firm_holder->next;
		current_xmachine_Firm = current_xmachine_Firm_holder->agent;
		current_xmachine_Firm_next_state = Firm_04_state;
		/* For backwards compatibility set current_xmachine */
		current_xmachine->xmachine_Firm = NULL;
		current_xmachine->xmachine_Household = NULL;
		current_xmachine->xmachine_Mall = NULL;
		current_xmachine->xmachine_IGFirm = NULL;
		current_xmachine->xmachine_Eurostat = NULL;
		current_xmachine->xmachine_Bank = NULL;
		current_xmachine->xmachine_Government = NULL;
		current_xmachine->xmachine_CentralBank = NULL;
		current_xmachine->xmachine_ClearingHouse = NULL;
		current_xmachine->xmachine_Firm = current_xmachine_Firm;

		

		
		rc = MB_Iterator_CreateFiltered(b_job_application, &i_job_application, &FLAME_filter_Firm_Firm_read_job_applications_send_job_offer_or_rejection_03_04_job_application, current_xmachine_Firm);
		
		#ifdef ERRCHECK
		if (rc != MB_SUCCESS)
		{
		   fprintf(stderr, "ERROR: Could not create Iterator for 'job_application'\n");
		   switch(rc) {
		       case MB_ERR_INVALID:
		           fprintf(stderr, "\t reason: 'job_application' board is invalid\n");
		           break;
		       case MB_ERR_LOCKED:
	               fprintf(stderr, "\t reason: 'job_application' board is locked\n");
	               break;
	           case MB_ERR_MEMALLOC:
	               fprintf(stderr, "\t reason: out of memory\n");
	               break;
	           case MB_ERR_INTERNAL:
	               fprintf(stderr, "\t reason: internal error. Recompile libmoard in debug mode for more info \n");
	               break;
	           default:
	           
                   fprintf(stderr, "\t MB_Iterator_CreateFiltered returned error code: %d (see libmboard docs for details)\n", rc);
               
               
                   break;
		   }

		   
           exit(rc);
		}
		#endif
		
		

			i = Firm_read_job_applications_send_job_offer_or_rejection();

		
		    rc = MB_Iterator_Delete(&i_job_application);
		    #ifdef ERRCHECK
		    if (rc != MB_SUCCESS)
		    {
		       fprintf(stderr, "ERROR: Could not delete 'job_application' iterator\n");
		       switch(rc) {
		           case MB_ERR_INVALID:
		               fprintf(stderr, "\t reason: 'job_application' iterator is invalid\n");
		               break;
		           case MB_ERR_INTERNAL:
		               fprintf(stderr, "\t reason: internal error. Recompile libmoard in debug mode for more info \n");
		               break;
		           default:
                       fprintf(stderr, "\t MB_Iterator_Delete returned error code: %d (see libmboard docs for details)\n", rc);
                       break;
		       }

		       
               exit(rc);
		    }
		    #endif
		

			if(i == 1)
			{
				free_Firm_agent(current_xmachine_Firm_holder, Firm_03_state);
			}
			else
			{
				transition_Firm_agent(current_xmachine_Firm_holder, Firm_03_state, Firm_04_state);
			}
		

		current_xmachine_Firm = NULL;

		current_xmachine_Firm_holder = temp_xmachine_Firm_holder;
	}
	if(FLAME_TEST_PRINT_START_AND_END_OF_MODEL_FUNCTIONS) printf("finish Firm_read_job_applications_send_job_offer_or_rejection\n");

	if(FLAME_job_offer_message_board_write == 1)
	{

		if(FLAME_TEST_PRINT_START_AND_END_OF_LIBMBOARD_CALLS) printf("start MB_SyncStart(b_job_offer)\n");
		rc = MB_SyncStart(b_job_offer);
		if(FLAME_TEST_PRINT_START_AND_END_OF_LIBMBOARD_CALLS) printf("finish MB_SyncStart(b_job_offer)\n");
		#ifdef ERRCHECK
		if (rc != MB_SUCCESS)
		{
		   fprintf(stderr, "ERROR: Could not start sync of 'job_offer' board\n");
		   switch(rc) {
			   case MB_ERR_INVALID:
				   fprintf(stderr, "\t reason: 'job_offer' board is invalid\n");
				   break;
			   case MB_ERR_LOCKED:
				   fprintf(stderr, "\t reason: 'job_offer' board is locked\n");
				   break;
			   case MB_ERR_MEMALLOC:
				   fprintf(stderr, "\t reason: out of memory\n");
				   break;
			   case MB_ERR_INTERNAL:
				   fprintf(stderr, "\t reason: internal error. Recompile libmoard in debug mode for more info \n");
				   break;
			   default:
				   fprintf(stderr, "\t MB_SyncStart returned error code: %d (see libmboard docs for details)\n", rc);
				   break;
		   }

			
			exit(rc);
		}
		#endif
    }
    


/* End of layer number 49 */

/* Clear message boards that have finished being used
 * and sync complete if doing late sync complete */

if(FLAME_job_application_message_board_read == 0)
{
	/*printf("%d> job_application message board sync complete late as no agents reading any messages of this type\n", node_number);*/
	
	if(FLAME_TEST_PRINT_START_AND_END_OF_LIBMBOARD_CALLS) printf("start MB_SyncComplete(b_job_application)\n");
	rc = MB_SyncComplete(b_job_application);
	if(FLAME_TEST_PRINT_START_AND_END_OF_LIBMBOARD_CALLS) printf("finsh MB_SyncComplete(b_job_application)\n");
	#ifdef ERRCHECK
	if (rc != MB_SUCCESS)
	{
	   fprintf(stderr, "ERROR: Could not complete sync of 'job_application' board\n");
	   switch(rc) {
			case MB_ERR_INVALID:
			   fprintf(stderr, "\t reason: 'job_application' board is invalid\n");
			   break;
		   case MB_ERR_MEMALLOC:
			   fprintf(stderr, "\t reason: out of memory\n");
			   break;
		   case MB_ERR_INTERNAL:
			   fprintf(stderr, "\t reason: internal error. Recompile libmoard in debug mode for more info \n");
			   break;
		   default:
			   fprintf(stderr, "\t MB_SyncComplete returned error code: %d (see libmboard docs for details)\n", rc);
			   break;
	   }

	   
	   exit(rc);
	}
	#endif
}

    rc = MB_Clear(b_job_application);
    #ifdef ERRCHECK
    if (rc != MB_SUCCESS)
    {
       fprintf(stderr, "ERROR: Could not clear 'job_application' board\n");
       switch(rc) {
           case MB_ERR_INVALID:
               fprintf(stderr, "\t reason: 'job_application' board is invalid\n");
               break;
           case MB_ERR_LOCKED:
               fprintf(stderr, "\t reason: 'job_application' board is locked\n");
               break;
           case MB_ERR_INTERNAL:
               fprintf(stderr, "\t reason: internal error. Recompile libmoard in debug mode for more info \n");
               break;
           default:
               fprintf(stderr, "\t MB_Clear returned error code: %d (see libmboard docs for details)\n", rc);
               break;

       }

       
       exit(rc);
    }
    #endif


	/* If mb is not read then leave sync complete until last possible moment */
	if(FLAME_job_offer_message_board_read == 1)
	{
		if(FLAME_TEST_PRINT_START_AND_END_OF_LIBMBOARD_CALLS) printf("start MB_SyncComplete(b_job_offer)\n");
		rc = MB_SyncComplete(b_job_offer);
		if(FLAME_TEST_PRINT_START_AND_END_OF_LIBMBOARD_CALLS) printf("finsh MB_SyncComplete(b_job_offer)\n");
		#ifdef ERRCHECK
		if (rc != MB_SUCCESS)
		{
		   fprintf(stderr, "ERROR: Could not complete sync of 'job_offer' board\n");
		   switch(rc) {
				case MB_ERR_INVALID:
				   fprintf(stderr, "\t reason: 'job_offer' board is invalid\n");
				   break;
			   case MB_ERR_MEMALLOC:
				   fprintf(stderr, "\t reason: out of memory\n");
				   break;
			   case MB_ERR_INTERNAL:
				   fprintf(stderr, "\t reason: internal error. Recompile libmoard in debug mode for more info \n");
				   break;
			   default:
				   fprintf(stderr, "\t MB_SyncComplete returned error code: %d (see libmboard docs for details)\n", rc);
				   break;
		   }
	
		   
		   exit(rc);
		}
		#endif
    
	}
	
	if(FLAME_TEST_PRINT_START_AND_END_OF_MODEL_FUNCTIONS) printf("start Household_read_job_offers_send_response\n");
	current_xmachine_Household_holder = Household_01_state->agents;
	while(current_xmachine_Household_holder)
	{
		temp_xmachine_Household_holder = current_xmachine_Household_holder->next;
		current_xmachine_Household = current_xmachine_Household_holder->agent;
		current_xmachine_Household_next_state = Household_02_state;
		/* For backwards compatibility set current_xmachine */
		current_xmachine->xmachine_Firm = NULL;
		current_xmachine->xmachine_Household = NULL;
		current_xmachine->xmachine_Mall = NULL;
		current_xmachine->xmachine_IGFirm = NULL;
		current_xmachine->xmachine_Eurostat = NULL;
		current_xmachine->xmachine_Bank = NULL;
		current_xmachine->xmachine_Government = NULL;
		current_xmachine->xmachine_CentralBank = NULL;
		current_xmachine->xmachine_ClearingHouse = NULL;
		current_xmachine->xmachine_Household = current_xmachine_Household;

		

		
		rc = MB_Iterator_CreateFiltered(b_job_offer, &i_job_offer, &FLAME_filter_Household_Household_read_job_offers_send_response_01_02_job_offer, current_xmachine_Household);
		
		#ifdef ERRCHECK
		if (rc != MB_SUCCESS)
		{
		   fprintf(stderr, "ERROR: Could not create Iterator for 'job_offer'\n");
		   switch(rc) {
		       case MB_ERR_INVALID:
		           fprintf(stderr, "\t reason: 'job_offer' board is invalid\n");
		           break;
		       case MB_ERR_LOCKED:
	               fprintf(stderr, "\t reason: 'job_offer' board is locked\n");
	               break;
	           case MB_ERR_MEMALLOC:
	               fprintf(stderr, "\t reason: out of memory\n");
	               break;
	           case MB_ERR_INTERNAL:
	               fprintf(stderr, "\t reason: internal error. Recompile libmoard in debug mode for more info \n");
	               break;
	           default:
	           
                   fprintf(stderr, "\t MB_Iterator_CreateFiltered returned error code: %d (see libmboard docs for details)\n", rc);
               
               
                   break;
		   }

		   
           exit(rc);
		}
		#endif
		
		

			i = Household_read_job_offers_send_response();

		
		    rc = MB_Iterator_Delete(&i_job_offer);
		    #ifdef ERRCHECK
		    if (rc != MB_SUCCESS)
		    {
		       fprintf(stderr, "ERROR: Could not delete 'job_offer' iterator\n");
		       switch(rc) {
		           case MB_ERR_INVALID:
		               fprintf(stderr, "\t reason: 'job_offer' iterator is invalid\n");
		               break;
		           case MB_ERR_INTERNAL:
		               fprintf(stderr, "\t reason: internal error. Recompile libmoard in debug mode for more info \n");
		               break;
		           default:
                       fprintf(stderr, "\t MB_Iterator_Delete returned error code: %d (see libmboard docs for details)\n", rc);
                       break;
		       }

		       
               exit(rc);
		    }
		    #endif
		

			if(i == 1)
			{
				free_Household_agent(current_xmachine_Household_holder, Household_01_state);
			}
			else
			{
				transition_Household_agent(current_xmachine_Household_holder, Household_01_state, Household_02_state);
			}
		

		current_xmachine_Household = NULL;

		current_xmachine_Household_holder = temp_xmachine_Household_holder;
	}
	if(FLAME_TEST_PRINT_START_AND_END_OF_MODEL_FUNCTIONS) printf("finish Household_read_job_offers_send_response\n");

	if(FLAME_quitting_message_board_write == 1)
	{

		if(FLAME_TEST_PRINT_START_AND_END_OF_LIBMBOARD_CALLS) printf("start MB_SyncStart(b_quitting)\n");
		rc = MB_SyncStart(b_quitting);
		if(FLAME_TEST_PRINT_START_AND_END_OF_LIBMBOARD_CALLS) printf("finish MB_SyncStart(b_quitting)\n");
		#ifdef ERRCHECK
		if (rc != MB_SUCCESS)
		{
		   fprintf(stderr, "ERROR: Could not start sync of 'quitting' board\n");
		   switch(rc) {
			   case MB_ERR_INVALID:
				   fprintf(stderr, "\t reason: 'quitting' board is invalid\n");
				   break;
			   case MB_ERR_LOCKED:
				   fprintf(stderr, "\t reason: 'quitting' board is locked\n");
				   break;
			   case MB_ERR_MEMALLOC:
				   fprintf(stderr, "\t reason: out of memory\n");
				   break;
			   case MB_ERR_INTERNAL:
				   fprintf(stderr, "\t reason: internal error. Recompile libmoard in debug mode for more info \n");
				   break;
			   default:
				   fprintf(stderr, "\t MB_SyncStart returned error code: %d (see libmboard docs for details)\n", rc);
				   break;
		   }

			
			exit(rc);
		}
		#endif
    }
    

	if(FLAME_job_acceptance_message_board_write == 1)
	{

		if(FLAME_TEST_PRINT_START_AND_END_OF_LIBMBOARD_CALLS) printf("start MB_SyncStart(b_job_acceptance)\n");
		rc = MB_SyncStart(b_job_acceptance);
		if(FLAME_TEST_PRINT_START_AND_END_OF_LIBMBOARD_CALLS) printf("finish MB_SyncStart(b_job_acceptance)\n");
		#ifdef ERRCHECK
		if (rc != MB_SUCCESS)
		{
		   fprintf(stderr, "ERROR: Could not start sync of 'job_acceptance' board\n");
		   switch(rc) {
			   case MB_ERR_INVALID:
				   fprintf(stderr, "\t reason: 'job_acceptance' board is invalid\n");
				   break;
			   case MB_ERR_LOCKED:
				   fprintf(stderr, "\t reason: 'job_acceptance' board is locked\n");
				   break;
			   case MB_ERR_MEMALLOC:
				   fprintf(stderr, "\t reason: out of memory\n");
				   break;
			   case MB_ERR_INTERNAL:
				   fprintf(stderr, "\t reason: internal error. Recompile libmoard in debug mode for more info \n");
				   break;
			   default:
				   fprintf(stderr, "\t MB_SyncStart returned error code: %d (see libmboard docs for details)\n", rc);
				   break;
		   }

			
			exit(rc);
		}
		#endif
    }
    


/* End of layer number 50 */

/* Clear message boards that have finished being used
 * and sync complete if doing late sync complete */

if(FLAME_job_offer_message_board_read == 0)
{
	/*printf("%d> job_offer message board sync complete late as no agents reading any messages of this type\n", node_number);*/
	
	if(FLAME_TEST_PRINT_START_AND_END_OF_LIBMBOARD_CALLS) printf("start MB_SyncComplete(b_job_offer)\n");
	rc = MB_SyncComplete(b_job_offer);
	if(FLAME_TEST_PRINT_START_AND_END_OF_LIBMBOARD_CALLS) printf("finsh MB_SyncComplete(b_job_offer)\n");
	#ifdef ERRCHECK
	if (rc != MB_SUCCESS)
	{
	   fprintf(stderr, "ERROR: Could not complete sync of 'job_offer' board\n");
	   switch(rc) {
			case MB_ERR_INVALID:
			   fprintf(stderr, "\t reason: 'job_offer' board is invalid\n");
			   break;
		   case MB_ERR_MEMALLOC:
			   fprintf(stderr, "\t reason: out of memory\n");
			   break;
		   case MB_ERR_INTERNAL:
			   fprintf(stderr, "\t reason: internal error. Recompile libmoard in debug mode for more info \n");
			   break;
		   default:
			   fprintf(stderr, "\t MB_SyncComplete returned error code: %d (see libmboard docs for details)\n", rc);
			   break;
	   }

	   
	   exit(rc);
	}
	#endif
}

    rc = MB_Clear(b_job_offer);
    #ifdef ERRCHECK
    if (rc != MB_SUCCESS)
    {
       fprintf(stderr, "ERROR: Could not clear 'job_offer' board\n");
       switch(rc) {
           case MB_ERR_INVALID:
               fprintf(stderr, "\t reason: 'job_offer' board is invalid\n");
               break;
           case MB_ERR_LOCKED:
               fprintf(stderr, "\t reason: 'job_offer' board is locked\n");
               break;
           case MB_ERR_INTERNAL:
               fprintf(stderr, "\t reason: internal error. Recompile libmoard in debug mode for more info \n");
               break;
           default:
               fprintf(stderr, "\t MB_Clear returned error code: %d (see libmboard docs for details)\n", rc);
               break;

       }

       
       exit(rc);
    }
    #endif


	if(FLAME_TEST_PRINT_START_AND_END_OF_MODEL_FUNCTIONS) printf("start Household_read_application_rejection_update_wage_reservation\n");
	current_xmachine_Household_holder = Household_02_state->agents;
	while(current_xmachine_Household_holder)
	{
		temp_xmachine_Household_holder = current_xmachine_Household_holder->next;
		current_xmachine_Household = current_xmachine_Household_holder->agent;
		current_xmachine_Household_next_state = Household_03_state;
		/* For backwards compatibility set current_xmachine */
		current_xmachine->xmachine_Firm = NULL;
		current_xmachine->xmachine_Household = NULL;
		current_xmachine->xmachine_Mall = NULL;
		current_xmachine->xmachine_IGFirm = NULL;
		current_xmachine->xmachine_Eurostat = NULL;
		current_xmachine->xmachine_Bank = NULL;
		current_xmachine->xmachine_Government = NULL;
		current_xmachine->xmachine_CentralBank = NULL;
		current_xmachine->xmachine_ClearingHouse = NULL;
		current_xmachine->xmachine_Household = current_xmachine_Household;

		if(FLAME_condition_Household_Household_read_application_rejection_update_wage_reservation_02_03(current_xmachine_Household)==1)
		{

		

			i = Household_read_application_rejection_update_wage_reservation();

		

			if(i == 1)
			{
				free_Household_agent(current_xmachine_Household_holder, Household_02_state);
			}
			else
			{
				transition_Household_agent(current_xmachine_Household_holder, Household_02_state, Household_03_state);
			}
		}

		current_xmachine_Household = NULL;

		current_xmachine_Household_holder = temp_xmachine_Household_holder;
	}
	if(FLAME_TEST_PRINT_START_AND_END_OF_MODEL_FUNCTIONS) printf("finish Household_read_application_rejection_update_wage_reservation\n");


	if(FLAME_TEST_PRINT_START_AND_END_OF_MODEL_FUNCTIONS) printf("start Household_finish_labour_market\n");
	current_xmachine_Household_holder = Household_02_state->agents;
	while(current_xmachine_Household_holder)
	{
		temp_xmachine_Household_holder = current_xmachine_Household_holder->next;
		current_xmachine_Household = current_xmachine_Household_holder->agent;
		current_xmachine_Household_next_state = Household_06_state;
		/* For backwards compatibility set current_xmachine */
		current_xmachine->xmachine_Firm = NULL;
		current_xmachine->xmachine_Household = NULL;
		current_xmachine->xmachine_Mall = NULL;
		current_xmachine->xmachine_IGFirm = NULL;
		current_xmachine->xmachine_Eurostat = NULL;
		current_xmachine->xmachine_Bank = NULL;
		current_xmachine->xmachine_Government = NULL;
		current_xmachine->xmachine_CentralBank = NULL;
		current_xmachine->xmachine_ClearingHouse = NULL;
		current_xmachine->xmachine_Household = current_xmachine_Household;

		if(FLAME_condition_Household_Household_finish_labour_market_02_06(current_xmachine_Household)==1)
		{

		

			i = Household_finish_labour_market();

		

			if(i == 1)
			{
				free_Household_agent(current_xmachine_Household_holder, Household_02_state);
			}
			else
			{
				transition_Household_agent(current_xmachine_Household_holder, Household_02_state, Household_06_state);
			}
		}

		current_xmachine_Household = NULL;

		current_xmachine_Household_holder = temp_xmachine_Household_holder;
	}
	if(FLAME_TEST_PRINT_START_AND_END_OF_MODEL_FUNCTIONS) printf("finish Household_finish_labour_market\n");


	/* If mb is not read then leave sync complete until last possible moment */
	if(FLAME_job_acceptance_message_board_read == 1)
	{
		if(FLAME_TEST_PRINT_START_AND_END_OF_LIBMBOARD_CALLS) printf("start MB_SyncComplete(b_job_acceptance)\n");
		rc = MB_SyncComplete(b_job_acceptance);
		if(FLAME_TEST_PRINT_START_AND_END_OF_LIBMBOARD_CALLS) printf("finsh MB_SyncComplete(b_job_acceptance)\n");
		#ifdef ERRCHECK
		if (rc != MB_SUCCESS)
		{
		   fprintf(stderr, "ERROR: Could not complete sync of 'job_acceptance' board\n");
		   switch(rc) {
				case MB_ERR_INVALID:
				   fprintf(stderr, "\t reason: 'job_acceptance' board is invalid\n");
				   break;
			   case MB_ERR_MEMALLOC:
				   fprintf(stderr, "\t reason: out of memory\n");
				   break;
			   case MB_ERR_INTERNAL:
				   fprintf(stderr, "\t reason: internal error. Recompile libmoard in debug mode for more info \n");
				   break;
			   default:
				   fprintf(stderr, "\t MB_SyncComplete returned error code: %d (see libmboard docs for details)\n", rc);
				   break;
		   }
	
		   
		   exit(rc);
		}
		#endif
    
	}
	
	if(FLAME_TEST_PRINT_START_AND_END_OF_MODEL_FUNCTIONS) printf("start Firm_read_job_responses\n");
	current_xmachine_Firm_holder = Firm_04_state->agents;
	while(current_xmachine_Firm_holder)
	{
		temp_xmachine_Firm_holder = current_xmachine_Firm_holder->next;
		current_xmachine_Firm = current_xmachine_Firm_holder->agent;
		current_xmachine_Firm_next_state = Firm_05a_state;
		/* For backwards compatibility set current_xmachine */
		current_xmachine->xmachine_Firm = NULL;
		current_xmachine->xmachine_Household = NULL;
		current_xmachine->xmachine_Mall = NULL;
		current_xmachine->xmachine_IGFirm = NULL;
		current_xmachine->xmachine_Eurostat = NULL;
		current_xmachine->xmachine_Bank = NULL;
		current_xmachine->xmachine_Government = NULL;
		current_xmachine->xmachine_CentralBank = NULL;
		current_xmachine->xmachine_ClearingHouse = NULL;
		current_xmachine->xmachine_Firm = current_xmachine_Firm;

		

		
		rc = MB_Iterator_CreateFiltered(b_job_acceptance, &i_job_acceptance, &FLAME_filter_Firm_Firm_read_job_responses_04_05a_job_acceptance, current_xmachine_Firm);
		
		#ifdef ERRCHECK
		if (rc != MB_SUCCESS)
		{
		   fprintf(stderr, "ERROR: Could not create Iterator for 'job_acceptance'\n");
		   switch(rc) {
		       case MB_ERR_INVALID:
		           fprintf(stderr, "\t reason: 'job_acceptance' board is invalid\n");
		           break;
		       case MB_ERR_LOCKED:
	               fprintf(stderr, "\t reason: 'job_acceptance' board is locked\n");
	               break;
	           case MB_ERR_MEMALLOC:
	               fprintf(stderr, "\t reason: out of memory\n");
	               break;
	           case MB_ERR_INTERNAL:
	               fprintf(stderr, "\t reason: internal error. Recompile libmoard in debug mode for more info \n");
	               break;
	           default:
	           
                   fprintf(stderr, "\t MB_Iterator_CreateFiltered returned error code: %d (see libmboard docs for details)\n", rc);
               
               
                   break;
		   }

		   
           exit(rc);
		}
		#endif
		
		

			i = Firm_read_job_responses();

		
		    rc = MB_Iterator_Delete(&i_job_acceptance);
		    #ifdef ERRCHECK
		    if (rc != MB_SUCCESS)
		    {
		       fprintf(stderr, "ERROR: Could not delete 'job_acceptance' iterator\n");
		       switch(rc) {
		           case MB_ERR_INVALID:
		               fprintf(stderr, "\t reason: 'job_acceptance' iterator is invalid\n");
		               break;
		           case MB_ERR_INTERNAL:
		               fprintf(stderr, "\t reason: internal error. Recompile libmoard in debug mode for more info \n");
		               break;
		           default:
                       fprintf(stderr, "\t MB_Iterator_Delete returned error code: %d (see libmboard docs for details)\n", rc);
                       break;
		       }

		       
               exit(rc);
		    }
		    #endif
		

			if(i == 1)
			{
				free_Firm_agent(current_xmachine_Firm_holder, Firm_04_state);
			}
			else
			{
				transition_Firm_agent(current_xmachine_Firm_holder, Firm_04_state, Firm_05a_state);
			}
		

		current_xmachine_Firm = NULL;

		current_xmachine_Firm_holder = temp_xmachine_Firm_holder;
	}
	if(FLAME_TEST_PRINT_START_AND_END_OF_MODEL_FUNCTIONS) printf("finish Firm_read_job_responses\n");


	/* If mb is not read then leave sync complete until last possible moment */
	if(FLAME_quitting_message_board_read == 1)
	{
		if(FLAME_TEST_PRINT_START_AND_END_OF_LIBMBOARD_CALLS) printf("start MB_SyncComplete(b_quitting)\n");
		rc = MB_SyncComplete(b_quitting);
		if(FLAME_TEST_PRINT_START_AND_END_OF_LIBMBOARD_CALLS) printf("finsh MB_SyncComplete(b_quitting)\n");
		#ifdef ERRCHECK
		if (rc != MB_SUCCESS)
		{
		   fprintf(stderr, "ERROR: Could not complete sync of 'quitting' board\n");
		   switch(rc) {
				case MB_ERR_INVALID:
				   fprintf(stderr, "\t reason: 'quitting' board is invalid\n");
				   break;
			   case MB_ERR_MEMALLOC:
				   fprintf(stderr, "\t reason: out of memory\n");
				   break;
			   case MB_ERR_INTERNAL:
				   fprintf(stderr, "\t reason: internal error. Recompile libmoard in debug mode for more info \n");
				   break;
			   default:
				   fprintf(stderr, "\t MB_SyncComplete returned error code: %d (see libmboard docs for details)\n", rc);
				   break;
		   }
	
		   
		   exit(rc);
		}
		#endif
    
	}
	
	if(FLAME_TEST_PRINT_START_AND_END_OF_MODEL_FUNCTIONS) printf("start Firm_read_job_quitting\n");
	current_xmachine_Firm_holder = Firm_00b_state->agents;
	while(current_xmachine_Firm_holder)
	{
		temp_xmachine_Firm_holder = current_xmachine_Firm_holder->next;
		current_xmachine_Firm = current_xmachine_Firm_holder->agent;
		current_xmachine_Firm_next_state = Firm_09c_state;
		/* For backwards compatibility set current_xmachine */
		current_xmachine->xmachine_Firm = NULL;
		current_xmachine->xmachine_Household = NULL;
		current_xmachine->xmachine_Mall = NULL;
		current_xmachine->xmachine_IGFirm = NULL;
		current_xmachine->xmachine_Eurostat = NULL;
		current_xmachine->xmachine_Bank = NULL;
		current_xmachine->xmachine_Government = NULL;
		current_xmachine->xmachine_CentralBank = NULL;
		current_xmachine->xmachine_ClearingHouse = NULL;
		current_xmachine->xmachine_Firm = current_xmachine_Firm;

		

		
		
		rc = MB_Iterator_Create(b_quitting, &i_quitting);
		#ifdef ERRCHECK
		if (rc != MB_SUCCESS)
		{
		   fprintf(stderr, "ERROR: Could not create Iterator for 'quitting'\n");
		   switch(rc) {
		       case MB_ERR_INVALID:
		           fprintf(stderr, "\t reason: 'quitting' board is invalid\n");
		           break;
		       case MB_ERR_LOCKED:
	               fprintf(stderr, "\t reason: 'quitting' board is locked\n");
	               break;
	           case MB_ERR_MEMALLOC:
	               fprintf(stderr, "\t reason: out of memory\n");
	               break;
	           case MB_ERR_INTERNAL:
	               fprintf(stderr, "\t reason: internal error. Recompile libmoard in debug mode for more info \n");
	               break;
	           default:
	           
               
                   fprintf(stderr, "\t MB_Iterator_Create returned error code: %d (see libmboard docs for details)\n", rc);
               
                   break;
		   }

		   
           exit(rc);
		}
		#endif
		
		

			i = Firm_read_job_quitting();

		
		    rc = MB_Iterator_Delete(&i_quitting);
		    #ifdef ERRCHECK
		    if (rc != MB_SUCCESS)
		    {
		       fprintf(stderr, "ERROR: Could not delete 'quitting' iterator\n");
		       switch(rc) {
		           case MB_ERR_INVALID:
		               fprintf(stderr, "\t reason: 'quitting' iterator is invalid\n");
		               break;
		           case MB_ERR_INTERNAL:
		               fprintf(stderr, "\t reason: internal error. Recompile libmoard in debug mode for more info \n");
		               break;
		           default:
                       fprintf(stderr, "\t MB_Iterator_Delete returned error code: %d (see libmboard docs for details)\n", rc);
                       break;
		       }

		       
               exit(rc);
		    }
		    #endif
		

			if(i == 1)
			{
				free_Firm_agent(current_xmachine_Firm_holder, Firm_00b_state);
			}
			else
			{
				transition_Firm_agent(current_xmachine_Firm_holder, Firm_00b_state, Firm_09c_state);
			}
		

		current_xmachine_Firm = NULL;

		current_xmachine_Firm_holder = temp_xmachine_Firm_holder;
	}
	if(FLAME_TEST_PRINT_START_AND_END_OF_MODEL_FUNCTIONS) printf("finish Firm_read_job_quitting\n");


	if(FLAME_TEST_PRINT_START_AND_END_OF_MODEL_FUNCTIONS) printf("start Firm_read_job_quitting\n");
	current_xmachine_Firm_holder = Firm_03c_state->agents;
	while(current_xmachine_Firm_holder)
	{
		temp_xmachine_Firm_holder = current_xmachine_Firm_holder->next;
		current_xmachine_Firm = current_xmachine_Firm_holder->agent;
		current_xmachine_Firm_next_state = Firm_03d_state;
		/* For backwards compatibility set current_xmachine */
		current_xmachine->xmachine_Firm = NULL;
		current_xmachine->xmachine_Household = NULL;
		current_xmachine->xmachine_Mall = NULL;
		current_xmachine->xmachine_IGFirm = NULL;
		current_xmachine->xmachine_Eurostat = NULL;
		current_xmachine->xmachine_Bank = NULL;
		current_xmachine->xmachine_Government = NULL;
		current_xmachine->xmachine_CentralBank = NULL;
		current_xmachine->xmachine_ClearingHouse = NULL;
		current_xmachine->xmachine_Firm = current_xmachine_Firm;

		

		
		
		rc = MB_Iterator_Create(b_quitting, &i_quitting);
		#ifdef ERRCHECK
		if (rc != MB_SUCCESS)
		{
		   fprintf(stderr, "ERROR: Could not create Iterator for 'quitting'\n");
		   switch(rc) {
		       case MB_ERR_INVALID:
		           fprintf(stderr, "\t reason: 'quitting' board is invalid\n");
		           break;
		       case MB_ERR_LOCKED:
	               fprintf(stderr, "\t reason: 'quitting' board is locked\n");
	               break;
	           case MB_ERR_MEMALLOC:
	               fprintf(stderr, "\t reason: out of memory\n");
	               break;
	           case MB_ERR_INTERNAL:
	               fprintf(stderr, "\t reason: internal error. Recompile libmoard in debug mode for more info \n");
	               break;
	           default:
	           
               
                   fprintf(stderr, "\t MB_Iterator_Create returned error code: %d (see libmboard docs for details)\n", rc);
               
                   break;
		   }

		   
           exit(rc);
		}
		#endif
		
		

			i = Firm_read_job_quitting();

		
		    rc = MB_Iterator_Delete(&i_quitting);
		    #ifdef ERRCHECK
		    if (rc != MB_SUCCESS)
		    {
		       fprintf(stderr, "ERROR: Could not delete 'quitting' iterator\n");
		       switch(rc) {
		           case MB_ERR_INVALID:
		               fprintf(stderr, "\t reason: 'quitting' iterator is invalid\n");
		               break;
		           case MB_ERR_INTERNAL:
		               fprintf(stderr, "\t reason: internal error. Recompile libmoard in debug mode for more info \n");
		               break;
		           default:
                       fprintf(stderr, "\t MB_Iterator_Delete returned error code: %d (see libmboard docs for details)\n", rc);
                       break;
		       }

		       
               exit(rc);
		    }
		    #endif
		

			if(i == 1)
			{
				free_Firm_agent(current_xmachine_Firm_holder, Firm_03c_state);
			}
			else
			{
				transition_Firm_agent(current_xmachine_Firm_holder, Firm_03c_state, Firm_03d_state);
			}
		

		current_xmachine_Firm = NULL;

		current_xmachine_Firm_holder = temp_xmachine_Firm_holder;
	}
	if(FLAME_TEST_PRINT_START_AND_END_OF_MODEL_FUNCTIONS) printf("finish Firm_read_job_quitting\n");


/* End of layer number 51 */

/* Clear message boards that have finished being used
 * and sync complete if doing late sync complete */

if(FLAME_job_acceptance_message_board_read == 0)
{
	/*printf("%d> job_acceptance message board sync complete late as no agents reading any messages of this type\n", node_number);*/
	
	if(FLAME_TEST_PRINT_START_AND_END_OF_LIBMBOARD_CALLS) printf("start MB_SyncComplete(b_job_acceptance)\n");
	rc = MB_SyncComplete(b_job_acceptance);
	if(FLAME_TEST_PRINT_START_AND_END_OF_LIBMBOARD_CALLS) printf("finsh MB_SyncComplete(b_job_acceptance)\n");
	#ifdef ERRCHECK
	if (rc != MB_SUCCESS)
	{
	   fprintf(stderr, "ERROR: Could not complete sync of 'job_acceptance' board\n");
	   switch(rc) {
			case MB_ERR_INVALID:
			   fprintf(stderr, "\t reason: 'job_acceptance' board is invalid\n");
			   break;
		   case MB_ERR_MEMALLOC:
			   fprintf(stderr, "\t reason: out of memory\n");
			   break;
		   case MB_ERR_INTERNAL:
			   fprintf(stderr, "\t reason: internal error. Recompile libmoard in debug mode for more info \n");
			   break;
		   default:
			   fprintf(stderr, "\t MB_SyncComplete returned error code: %d (see libmboard docs for details)\n", rc);
			   break;
	   }

	   
	   exit(rc);
	}
	#endif
}

    rc = MB_Clear(b_job_acceptance);
    #ifdef ERRCHECK
    if (rc != MB_SUCCESS)
    {
       fprintf(stderr, "ERROR: Could not clear 'job_acceptance' board\n");
       switch(rc) {
           case MB_ERR_INVALID:
               fprintf(stderr, "\t reason: 'job_acceptance' board is invalid\n");
               break;
           case MB_ERR_LOCKED:
               fprintf(stderr, "\t reason: 'job_acceptance' board is locked\n");
               break;
           case MB_ERR_INTERNAL:
               fprintf(stderr, "\t reason: internal error. Recompile libmoard in debug mode for more info \n");
               break;
           default:
               fprintf(stderr, "\t MB_Clear returned error code: %d (see libmboard docs for details)\n", rc);
               break;

       }

       
       exit(rc);
    }
    #endif


	if(FLAME_TEST_PRINT_START_AND_END_OF_MODEL_FUNCTIONS) printf("start Firm_start_labour_market\n");
	current_xmachine_Firm_holder = Firm_03d_state->agents;
	while(current_xmachine_Firm_holder)
	{
		temp_xmachine_Firm_holder = current_xmachine_Firm_holder->next;
		current_xmachine_Firm = current_xmachine_Firm_holder->agent;
		current_xmachine_Firm_next_state = Firm_06_state;
		/* For backwards compatibility set current_xmachine */
		current_xmachine->xmachine_Firm = NULL;
		current_xmachine->xmachine_Household = NULL;
		current_xmachine->xmachine_Mall = NULL;
		current_xmachine->xmachine_IGFirm = NULL;
		current_xmachine->xmachine_Eurostat = NULL;
		current_xmachine->xmachine_Bank = NULL;
		current_xmachine->xmachine_Government = NULL;
		current_xmachine->xmachine_CentralBank = NULL;
		current_xmachine->xmachine_ClearingHouse = NULL;
		current_xmachine->xmachine_Firm = current_xmachine_Firm;

		

		

			i = Firm_start_labour_market();

		

			if(i == 1)
			{
				free_Firm_agent(current_xmachine_Firm_holder, Firm_03d_state);
			}
			else
			{
				transition_Firm_agent(current_xmachine_Firm_holder, Firm_03d_state, Firm_06_state);
			}
		

		current_xmachine_Firm = NULL;

		current_xmachine_Firm_holder = temp_xmachine_Firm_holder;
	}
	if(FLAME_TEST_PRINT_START_AND_END_OF_MODEL_FUNCTIONS) printf("finish Firm_start_labour_market\n");


	if(FLAME_TEST_PRINT_START_AND_END_OF_MODEL_FUNCTIONS) printf("start Firm_read_job_quitting\n");
	current_xmachine_Firm_holder = Firm_05a_state->agents;
	while(current_xmachine_Firm_holder)
	{
		temp_xmachine_Firm_holder = current_xmachine_Firm_holder->next;
		current_xmachine_Firm = current_xmachine_Firm_holder->agent;
		current_xmachine_Firm_next_state = Firm_05b_state;
		/* For backwards compatibility set current_xmachine */
		current_xmachine->xmachine_Firm = NULL;
		current_xmachine->xmachine_Household = NULL;
		current_xmachine->xmachine_Mall = NULL;
		current_xmachine->xmachine_IGFirm = NULL;
		current_xmachine->xmachine_Eurostat = NULL;
		current_xmachine->xmachine_Bank = NULL;
		current_xmachine->xmachine_Government = NULL;
		current_xmachine->xmachine_CentralBank = NULL;
		current_xmachine->xmachine_ClearingHouse = NULL;
		current_xmachine->xmachine_Firm = current_xmachine_Firm;

		

		
		
		rc = MB_Iterator_Create(b_quitting, &i_quitting);
		#ifdef ERRCHECK
		if (rc != MB_SUCCESS)
		{
		   fprintf(stderr, "ERROR: Could not create Iterator for 'quitting'\n");
		   switch(rc) {
		       case MB_ERR_INVALID:
		           fprintf(stderr, "\t reason: 'quitting' board is invalid\n");
		           break;
		       case MB_ERR_LOCKED:
	               fprintf(stderr, "\t reason: 'quitting' board is locked\n");
	               break;
	           case MB_ERR_MEMALLOC:
	               fprintf(stderr, "\t reason: out of memory\n");
	               break;
	           case MB_ERR_INTERNAL:
	               fprintf(stderr, "\t reason: internal error. Recompile libmoard in debug mode for more info \n");
	               break;
	           default:
	           
               
                   fprintf(stderr, "\t MB_Iterator_Create returned error code: %d (see libmboard docs for details)\n", rc);
               
                   break;
		   }

		   
           exit(rc);
		}
		#endif
		
		

			i = Firm_read_job_quitting();

		
		    rc = MB_Iterator_Delete(&i_quitting);
		    #ifdef ERRCHECK
		    if (rc != MB_SUCCESS)
		    {
		       fprintf(stderr, "ERROR: Could not delete 'quitting' iterator\n");
		       switch(rc) {
		           case MB_ERR_INVALID:
		               fprintf(stderr, "\t reason: 'quitting' iterator is invalid\n");
		               break;
		           case MB_ERR_INTERNAL:
		               fprintf(stderr, "\t reason: internal error. Recompile libmoard in debug mode for more info \n");
		               break;
		           default:
                       fprintf(stderr, "\t MB_Iterator_Delete returned error code: %d (see libmboard docs for details)\n", rc);
                       break;
		       }

		       
               exit(rc);
		    }
		    #endif
		

			if(i == 1)
			{
				free_Firm_agent(current_xmachine_Firm_holder, Firm_05a_state);
			}
			else
			{
				transition_Firm_agent(current_xmachine_Firm_holder, Firm_05a_state, Firm_05b_state);
			}
		

		current_xmachine_Firm = NULL;

		current_xmachine_Firm_holder = temp_xmachine_Firm_holder;
	}
	if(FLAME_TEST_PRINT_START_AND_END_OF_MODEL_FUNCTIONS) printf("finish Firm_read_job_quitting\n");


/* End of layer number 52 */

/* Clear message boards that have finished being used
 * and sync complete if doing late sync complete */

if(FLAME_quitting_message_board_read == 0)
{
	/*printf("%d> quitting message board sync complete late as no agents reading any messages of this type\n", node_number);*/
	
	if(FLAME_TEST_PRINT_START_AND_END_OF_LIBMBOARD_CALLS) printf("start MB_SyncComplete(b_quitting)\n");
	rc = MB_SyncComplete(b_quitting);
	if(FLAME_TEST_PRINT_START_AND_END_OF_LIBMBOARD_CALLS) printf("finsh MB_SyncComplete(b_quitting)\n");
	#ifdef ERRCHECK
	if (rc != MB_SUCCESS)
	{
	   fprintf(stderr, "ERROR: Could not complete sync of 'quitting' board\n");
	   switch(rc) {
			case MB_ERR_INVALID:
			   fprintf(stderr, "\t reason: 'quitting' board is invalid\n");
			   break;
		   case MB_ERR_MEMALLOC:
			   fprintf(stderr, "\t reason: out of memory\n");
			   break;
		   case MB_ERR_INTERNAL:
			   fprintf(stderr, "\t reason: internal error. Recompile libmoard in debug mode for more info \n");
			   break;
		   default:
			   fprintf(stderr, "\t MB_SyncComplete returned error code: %d (see libmboard docs for details)\n", rc);
			   break;
	   }

	   
	   exit(rc);
	}
	#endif
}

    rc = MB_Clear(b_quitting);
    #ifdef ERRCHECK
    if (rc != MB_SUCCESS)
    {
       fprintf(stderr, "ERROR: Could not clear 'quitting' board\n");
       switch(rc) {
           case MB_ERR_INVALID:
               fprintf(stderr, "\t reason: 'quitting' board is invalid\n");
               break;
           case MB_ERR_LOCKED:
               fprintf(stderr, "\t reason: 'quitting' board is locked\n");
               break;
           case MB_ERR_INTERNAL:
               fprintf(stderr, "\t reason: internal error. Recompile libmoard in debug mode for more info \n");
               break;
           default:
               fprintf(stderr, "\t MB_Clear returned error code: %d (see libmboard docs for details)\n", rc);
               break;

       }

       
       exit(rc);
    }
    #endif


	if(FLAME_TEST_PRINT_START_AND_END_OF_MODEL_FUNCTIONS) printf("start Firm_update_wage_offer\n");
	current_xmachine_Firm_holder = Firm_05b_state->agents;
	while(current_xmachine_Firm_holder)
	{
		temp_xmachine_Firm_holder = current_xmachine_Firm_holder->next;
		current_xmachine_Firm = current_xmachine_Firm_holder->agent;
		current_xmachine_Firm_next_state = Firm_06_state;
		/* For backwards compatibility set current_xmachine */
		current_xmachine->xmachine_Firm = NULL;
		current_xmachine->xmachine_Household = NULL;
		current_xmachine->xmachine_Mall = NULL;
		current_xmachine->xmachine_IGFirm = NULL;
		current_xmachine->xmachine_Eurostat = NULL;
		current_xmachine->xmachine_Bank = NULL;
		current_xmachine->xmachine_Government = NULL;
		current_xmachine->xmachine_CentralBank = NULL;
		current_xmachine->xmachine_ClearingHouse = NULL;
		current_xmachine->xmachine_Firm = current_xmachine_Firm;

		if(FLAME_condition_Firm_Firm_update_wage_offer_05b_06(current_xmachine_Firm)==1)
		{

		

			i = Firm_update_wage_offer();

		

			if(i == 1)
			{
				free_Firm_agent(current_xmachine_Firm_holder, Firm_05b_state);
			}
			else
			{
				transition_Firm_agent(current_xmachine_Firm_holder, Firm_05b_state, Firm_06_state);
			}
		}

		current_xmachine_Firm = NULL;

		current_xmachine_Firm_holder = temp_xmachine_Firm_holder;
	}
	if(FLAME_TEST_PRINT_START_AND_END_OF_MODEL_FUNCTIONS) printf("finish Firm_update_wage_offer\n");


	if(FLAME_TEST_PRINT_START_AND_END_OF_MODEL_FUNCTIONS) printf("start Firm_finish_labour_market_first_round\n");
	current_xmachine_Firm_holder = Firm_05b_state->agents;
	while(current_xmachine_Firm_holder)
	{
		temp_xmachine_Firm_holder = current_xmachine_Firm_holder->next;
		current_xmachine_Firm = current_xmachine_Firm_holder->agent;
		current_xmachine_Firm_next_state = Firm_09a_state;
		/* For backwards compatibility set current_xmachine */
		current_xmachine->xmachine_Firm = NULL;
		current_xmachine->xmachine_Household = NULL;
		current_xmachine->xmachine_Mall = NULL;
		current_xmachine->xmachine_IGFirm = NULL;
		current_xmachine->xmachine_Eurostat = NULL;
		current_xmachine->xmachine_Bank = NULL;
		current_xmachine->xmachine_Government = NULL;
		current_xmachine->xmachine_CentralBank = NULL;
		current_xmachine->xmachine_ClearingHouse = NULL;
		current_xmachine->xmachine_Firm = current_xmachine_Firm;

		if(FLAME_condition_Firm_Firm_finish_labour_market_first_round_05b_09a(current_xmachine_Firm)==1)
		{

		

			i = Firm_finish_labour_market_first_round();

		

			if(i == 1)
			{
				free_Firm_agent(current_xmachine_Firm_holder, Firm_05b_state);
			}
			else
			{
				transition_Firm_agent(current_xmachine_Firm_holder, Firm_05b_state, Firm_09a_state);
			}
		}

		current_xmachine_Firm = NULL;

		current_xmachine_Firm_holder = temp_xmachine_Firm_holder;
	}
	if(FLAME_TEST_PRINT_START_AND_END_OF_MODEL_FUNCTIONS) printf("finish Firm_finish_labour_market_first_round\n");


/* End of layer number 53 */

/* Clear message boards that have finished being used
 * and sync complete if doing late sync complete */


	if(FLAME_TEST_PRINT_START_AND_END_OF_MODEL_FUNCTIONS) printf("start Firm_send_vacancies_2\n");
	current_xmachine_Firm_holder = Firm_06_state->agents;
	while(current_xmachine_Firm_holder)
	{
		temp_xmachine_Firm_holder = current_xmachine_Firm_holder->next;
		current_xmachine_Firm = current_xmachine_Firm_holder->agent;
		current_xmachine_Firm_next_state = Firm_07_state;
		/* For backwards compatibility set current_xmachine */
		current_xmachine->xmachine_Firm = NULL;
		current_xmachine->xmachine_Household = NULL;
		current_xmachine->xmachine_Mall = NULL;
		current_xmachine->xmachine_IGFirm = NULL;
		current_xmachine->xmachine_Eurostat = NULL;
		current_xmachine->xmachine_Bank = NULL;
		current_xmachine->xmachine_Government = NULL;
		current_xmachine->xmachine_CentralBank = NULL;
		current_xmachine->xmachine_ClearingHouse = NULL;
		current_xmachine->xmachine_Firm = current_xmachine_Firm;

		

		

			i = Firm_send_vacancies_2();

		

			if(i == 1)
			{
				free_Firm_agent(current_xmachine_Firm_holder, Firm_06_state);
			}
			else
			{
				transition_Firm_agent(current_xmachine_Firm_holder, Firm_06_state, Firm_07_state);
			}
		

		current_xmachine_Firm = NULL;

		current_xmachine_Firm_holder = temp_xmachine_Firm_holder;
	}
	if(FLAME_TEST_PRINT_START_AND_END_OF_MODEL_FUNCTIONS) printf("finish Firm_send_vacancies_2\n");

	if(FLAME_vacancies_r_and_d_employees2_message_board_write == 1)
	{

		if(FLAME_TEST_PRINT_START_AND_END_OF_LIBMBOARD_CALLS) printf("start MB_SyncStart(b_vacancies_r_and_d_employees2)\n");
		rc = MB_SyncStart(b_vacancies_r_and_d_employees2);
		if(FLAME_TEST_PRINT_START_AND_END_OF_LIBMBOARD_CALLS) printf("finish MB_SyncStart(b_vacancies_r_and_d_employees2)\n");
		#ifdef ERRCHECK
		if (rc != MB_SUCCESS)
		{
		   fprintf(stderr, "ERROR: Could not start sync of 'vacancies_r_and_d_employees2' board\n");
		   switch(rc) {
			   case MB_ERR_INVALID:
				   fprintf(stderr, "\t reason: 'vacancies_r_and_d_employees2' board is invalid\n");
				   break;
			   case MB_ERR_LOCKED:
				   fprintf(stderr, "\t reason: 'vacancies_r_and_d_employees2' board is locked\n");
				   break;
			   case MB_ERR_MEMALLOC:
				   fprintf(stderr, "\t reason: out of memory\n");
				   break;
			   case MB_ERR_INTERNAL:
				   fprintf(stderr, "\t reason: internal error. Recompile libmoard in debug mode for more info \n");
				   break;
			   default:
				   fprintf(stderr, "\t MB_SyncStart returned error code: %d (see libmboard docs for details)\n", rc);
				   break;
		   }

			
			exit(rc);
		}
		#endif
    }
    

	if(FLAME_vacancies2_message_board_write == 1)
	{

		if(FLAME_TEST_PRINT_START_AND_END_OF_LIBMBOARD_CALLS) printf("start MB_SyncStart(b_vacancies2)\n");
		rc = MB_SyncStart(b_vacancies2);
		if(FLAME_TEST_PRINT_START_AND_END_OF_LIBMBOARD_CALLS) printf("finish MB_SyncStart(b_vacancies2)\n");
		#ifdef ERRCHECK
		if (rc != MB_SUCCESS)
		{
		   fprintf(stderr, "ERROR: Could not start sync of 'vacancies2' board\n");
		   switch(rc) {
			   case MB_ERR_INVALID:
				   fprintf(stderr, "\t reason: 'vacancies2' board is invalid\n");
				   break;
			   case MB_ERR_LOCKED:
				   fprintf(stderr, "\t reason: 'vacancies2' board is locked\n");
				   break;
			   case MB_ERR_MEMALLOC:
				   fprintf(stderr, "\t reason: out of memory\n");
				   break;
			   case MB_ERR_INTERNAL:
				   fprintf(stderr, "\t reason: internal error. Recompile libmoard in debug mode for more info \n");
				   break;
			   default:
				   fprintf(stderr, "\t MB_SyncStart returned error code: %d (see libmboard docs for details)\n", rc);
				   break;
		   }

			
			exit(rc);
		}
		#endif
    }
    


/* End of layer number 54 */

/* Clear message boards that have finished being used
 * and sync complete if doing late sync complete */


	/* If mb is not read then leave sync complete until last possible moment */
	if(FLAME_vacancies_r_and_d_employees2_message_board_read == 1)
	{
		if(FLAME_TEST_PRINT_START_AND_END_OF_LIBMBOARD_CALLS) printf("start MB_SyncComplete(b_vacancies_r_and_d_employees2)\n");
		rc = MB_SyncComplete(b_vacancies_r_and_d_employees2);
		if(FLAME_TEST_PRINT_START_AND_END_OF_LIBMBOARD_CALLS) printf("finsh MB_SyncComplete(b_vacancies_r_and_d_employees2)\n");
		#ifdef ERRCHECK
		if (rc != MB_SUCCESS)
		{
		   fprintf(stderr, "ERROR: Could not complete sync of 'vacancies_r_and_d_employees2' board\n");
		   switch(rc) {
				case MB_ERR_INVALID:
				   fprintf(stderr, "\t reason: 'vacancies_r_and_d_employees2' board is invalid\n");
				   break;
			   case MB_ERR_MEMALLOC:
				   fprintf(stderr, "\t reason: out of memory\n");
				   break;
			   case MB_ERR_INTERNAL:
				   fprintf(stderr, "\t reason: internal error. Recompile libmoard in debug mode for more info \n");
				   break;
			   default:
				   fprintf(stderr, "\t MB_SyncComplete returned error code: %d (see libmboard docs for details)\n", rc);
				   break;
		   }
	
		   
		   exit(rc);
		}
		#endif
    
	}
	
	/* If mb is not read then leave sync complete until last possible moment */
	if(FLAME_vacancies2_message_board_read == 1)
	{
		if(FLAME_TEST_PRINT_START_AND_END_OF_LIBMBOARD_CALLS) printf("start MB_SyncComplete(b_vacancies2)\n");
		rc = MB_SyncComplete(b_vacancies2);
		if(FLAME_TEST_PRINT_START_AND_END_OF_LIBMBOARD_CALLS) printf("finsh MB_SyncComplete(b_vacancies2)\n");
		#ifdef ERRCHECK
		if (rc != MB_SUCCESS)
		{
		   fprintf(stderr, "ERROR: Could not complete sync of 'vacancies2' board\n");
		   switch(rc) {
				case MB_ERR_INVALID:
				   fprintf(stderr, "\t reason: 'vacancies2' board is invalid\n");
				   break;
			   case MB_ERR_MEMALLOC:
				   fprintf(stderr, "\t reason: out of memory\n");
				   break;
			   case MB_ERR_INTERNAL:
				   fprintf(stderr, "\t reason: internal error. Recompile libmoard in debug mode for more info \n");
				   break;
			   default:
				   fprintf(stderr, "\t MB_SyncComplete returned error code: %d (see libmboard docs for details)\n", rc);
				   break;
		   }
	
		   
		   exit(rc);
		}
		#endif
    
	}
	
	if(FLAME_TEST_PRINT_START_AND_END_OF_MODEL_FUNCTIONS) printf("start Household_UNEMPLOYED_read_job_vacancies_and_send_applications_2\n");
	current_xmachine_Household_holder = Household_03_state->agents;
	while(current_xmachine_Household_holder)
	{
		temp_xmachine_Household_holder = current_xmachine_Household_holder->next;
		current_xmachine_Household = current_xmachine_Household_holder->agent;
		current_xmachine_Household_next_state = Household_04_state;
		/* For backwards compatibility set current_xmachine */
		current_xmachine->xmachine_Firm = NULL;
		current_xmachine->xmachine_Household = NULL;
		current_xmachine->xmachine_Mall = NULL;
		current_xmachine->xmachine_IGFirm = NULL;
		current_xmachine->xmachine_Eurostat = NULL;
		current_xmachine->xmachine_Bank = NULL;
		current_xmachine->xmachine_Government = NULL;
		current_xmachine->xmachine_CentralBank = NULL;
		current_xmachine->xmachine_ClearingHouse = NULL;
		current_xmachine->xmachine_Household = current_xmachine_Household;

		

		
		
		rc = MB_Iterator_Create(b_vacancies2, &i_vacancies2);
		#ifdef ERRCHECK
		if (rc != MB_SUCCESS)
		{
		   fprintf(stderr, "ERROR: Could not create Iterator for 'vacancies2'\n");
		   switch(rc) {
		       case MB_ERR_INVALID:
		           fprintf(stderr, "\t reason: 'vacancies2' board is invalid\n");
		           break;
		       case MB_ERR_LOCKED:
	               fprintf(stderr, "\t reason: 'vacancies2' board is locked\n");
	               break;
	           case MB_ERR_MEMALLOC:
	               fprintf(stderr, "\t reason: out of memory\n");
	               break;
	           case MB_ERR_INTERNAL:
	               fprintf(stderr, "\t reason: internal error. Recompile libmoard in debug mode for more info \n");
	               break;
	           default:
	           
               
                   fprintf(stderr, "\t MB_Iterator_Create returned error code: %d (see libmboard docs for details)\n", rc);
               
                   break;
		   }

		   
           exit(rc);
		}
		#endif
		
		
		rc = MB_Iterator_CreateFiltered(b_vacancies_r_and_d_employees2, &i_vacancies_r_and_d_employees2, &FLAME_filter_Household_Household_UNEMPLOYED_read_job_vacancies_and_send_applications_2_03_04_vacancies_r_and_d_employees2, current_xmachine_Household);
		
		#ifdef ERRCHECK
		if (rc != MB_SUCCESS)
		{
		   fprintf(stderr, "ERROR: Could not create Iterator for 'vacancies_r_and_d_employees2'\n");
		   switch(rc) {
		       case MB_ERR_INVALID:
		           fprintf(stderr, "\t reason: 'vacancies_r_and_d_employees2' board is invalid\n");
		           break;
		       case MB_ERR_LOCKED:
	               fprintf(stderr, "\t reason: 'vacancies_r_and_d_employees2' board is locked\n");
	               break;
	           case MB_ERR_MEMALLOC:
	               fprintf(stderr, "\t reason: out of memory\n");
	               break;
	           case MB_ERR_INTERNAL:
	               fprintf(stderr, "\t reason: internal error. Recompile libmoard in debug mode for more info \n");
	               break;
	           default:
	           
                   fprintf(stderr, "\t MB_Iterator_CreateFiltered returned error code: %d (see libmboard docs for details)\n", rc);
               
               
                   break;
		   }

		   
           exit(rc);
		}
		#endif
		
		

			i = Household_UNEMPLOYED_read_job_vacancies_and_send_applications_2();

		
		    rc = MB_Iterator_Delete(&i_vacancies2);
		    #ifdef ERRCHECK
		    if (rc != MB_SUCCESS)
		    {
		       fprintf(stderr, "ERROR: Could not delete 'vacancies2' iterator\n");
		       switch(rc) {
		           case MB_ERR_INVALID:
		               fprintf(stderr, "\t reason: 'vacancies2' iterator is invalid\n");
		               break;
		           case MB_ERR_INTERNAL:
		               fprintf(stderr, "\t reason: internal error. Recompile libmoard in debug mode for more info \n");
		               break;
		           default:
                       fprintf(stderr, "\t MB_Iterator_Delete returned error code: %d (see libmboard docs for details)\n", rc);
                       break;
		       }

		       
               exit(rc);
		    }
		    #endif
		
		    rc = MB_Iterator_Delete(&i_vacancies_r_and_d_employees2);
		    #ifdef ERRCHECK
		    if (rc != MB_SUCCESS)
		    {
		       fprintf(stderr, "ERROR: Could not delete 'vacancies_r_and_d_employees2' iterator\n");
		       switch(rc) {
		           case MB_ERR_INVALID:
		               fprintf(stderr, "\t reason: 'vacancies_r_and_d_employees2' iterator is invalid\n");
		               break;
		           case MB_ERR_INTERNAL:
		               fprintf(stderr, "\t reason: internal error. Recompile libmoard in debug mode for more info \n");
		               break;
		           default:
                       fprintf(stderr, "\t MB_Iterator_Delete returned error code: %d (see libmboard docs for details)\n", rc);
                       break;
		       }

		       
               exit(rc);
		    }
		    #endif
		

			if(i == 1)
			{
				free_Household_agent(current_xmachine_Household_holder, Household_03_state);
			}
			else
			{
				transition_Household_agent(current_xmachine_Household_holder, Household_03_state, Household_04_state);
			}
		

		current_xmachine_Household = NULL;

		current_xmachine_Household_holder = temp_xmachine_Household_holder;
	}
	if(FLAME_TEST_PRINT_START_AND_END_OF_MODEL_FUNCTIONS) printf("finish Household_UNEMPLOYED_read_job_vacancies_and_send_applications_2\n");

	if(FLAME_job_application2_message_board_write == 1)
	{

		if(FLAME_TEST_PRINT_START_AND_END_OF_LIBMBOARD_CALLS) printf("start MB_SyncStart(b_job_application2)\n");
		rc = MB_SyncStart(b_job_application2);
		if(FLAME_TEST_PRINT_START_AND_END_OF_LIBMBOARD_CALLS) printf("finish MB_SyncStart(b_job_application2)\n");
		#ifdef ERRCHECK
		if (rc != MB_SUCCESS)
		{
		   fprintf(stderr, "ERROR: Could not start sync of 'job_application2' board\n");
		   switch(rc) {
			   case MB_ERR_INVALID:
				   fprintf(stderr, "\t reason: 'job_application2' board is invalid\n");
				   break;
			   case MB_ERR_LOCKED:
				   fprintf(stderr, "\t reason: 'job_application2' board is locked\n");
				   break;
			   case MB_ERR_MEMALLOC:
				   fprintf(stderr, "\t reason: out of memory\n");
				   break;
			   case MB_ERR_INTERNAL:
				   fprintf(stderr, "\t reason: internal error. Recompile libmoard in debug mode for more info \n");
				   break;
			   default:
				   fprintf(stderr, "\t MB_SyncStart returned error code: %d (see libmboard docs for details)\n", rc);
				   break;
		   }

			
			exit(rc);
		}
		#endif
    }
    


/* End of layer number 55 */

/* Clear message boards that have finished being used
 * and sync complete if doing late sync complete */

if(FLAME_vacancies2_message_board_read == 0)
{
	/*printf("%d> vacancies2 message board sync complete late as no agents reading any messages of this type\n", node_number);*/
	
	if(FLAME_TEST_PRINT_START_AND_END_OF_LIBMBOARD_CALLS) printf("start MB_SyncComplete(b_vacancies2)\n");
	rc = MB_SyncComplete(b_vacancies2);
	if(FLAME_TEST_PRINT_START_AND_END_OF_LIBMBOARD_CALLS) printf("finsh MB_SyncComplete(b_vacancies2)\n");
	#ifdef ERRCHECK
	if (rc != MB_SUCCESS)
	{
	   fprintf(stderr, "ERROR: Could not complete sync of 'vacancies2' board\n");
	   switch(rc) {
			case MB_ERR_INVALID:
			   fprintf(stderr, "\t reason: 'vacancies2' board is invalid\n");
			   break;
		   case MB_ERR_MEMALLOC:
			   fprintf(stderr, "\t reason: out of memory\n");
			   break;
		   case MB_ERR_INTERNAL:
			   fprintf(stderr, "\t reason: internal error. Recompile libmoard in debug mode for more info \n");
			   break;
		   default:
			   fprintf(stderr, "\t MB_SyncComplete returned error code: %d (see libmboard docs for details)\n", rc);
			   break;
	   }

	   
	   exit(rc);
	}
	#endif
}

    rc = MB_Clear(b_vacancies2);
    #ifdef ERRCHECK
    if (rc != MB_SUCCESS)
    {
       fprintf(stderr, "ERROR: Could not clear 'vacancies2' board\n");
       switch(rc) {
           case MB_ERR_INVALID:
               fprintf(stderr, "\t reason: 'vacancies2' board is invalid\n");
               break;
           case MB_ERR_LOCKED:
               fprintf(stderr, "\t reason: 'vacancies2' board is locked\n");
               break;
           case MB_ERR_INTERNAL:
               fprintf(stderr, "\t reason: internal error. Recompile libmoard in debug mode for more info \n");
               break;
           default:
               fprintf(stderr, "\t MB_Clear returned error code: %d (see libmboard docs for details)\n", rc);
               break;

       }

       
       exit(rc);
    }
    #endif

if(FLAME_vacancies_r_and_d_employees2_message_board_read == 0)
{
	/*printf("%d> vacancies_r_and_d_employees2 message board sync complete late as no agents reading any messages of this type\n", node_number);*/
	
	if(FLAME_TEST_PRINT_START_AND_END_OF_LIBMBOARD_CALLS) printf("start MB_SyncComplete(b_vacancies_r_and_d_employees2)\n");
	rc = MB_SyncComplete(b_vacancies_r_and_d_employees2);
	if(FLAME_TEST_PRINT_START_AND_END_OF_LIBMBOARD_CALLS) printf("finsh MB_SyncComplete(b_vacancies_r_and_d_employees2)\n");
	#ifdef ERRCHECK
	if (rc != MB_SUCCESS)
	{
	   fprintf(stderr, "ERROR: Could not complete sync of 'vacancies_r_and_d_employees2' board\n");
	   switch(rc) {
			case MB_ERR_INVALID:
			   fprintf(stderr, "\t reason: 'vacancies_r_and_d_employees2' board is invalid\n");
			   break;
		   case MB_ERR_MEMALLOC:
			   fprintf(stderr, "\t reason: out of memory\n");
			   break;
		   case MB_ERR_INTERNAL:
			   fprintf(stderr, "\t reason: internal error. Recompile libmoard in debug mode for more info \n");
			   break;
		   default:
			   fprintf(stderr, "\t MB_SyncComplete returned error code: %d (see libmboard docs for details)\n", rc);
			   break;
	   }

	   
	   exit(rc);
	}
	#endif
}

    rc = MB_Clear(b_vacancies_r_and_d_employees2);
    #ifdef ERRCHECK
    if (rc != MB_SUCCESS)
    {
       fprintf(stderr, "ERROR: Could not clear 'vacancies_r_and_d_employees2' board\n");
       switch(rc) {
           case MB_ERR_INVALID:
               fprintf(stderr, "\t reason: 'vacancies_r_and_d_employees2' board is invalid\n");
               break;
           case MB_ERR_LOCKED:
               fprintf(stderr, "\t reason: 'vacancies_r_and_d_employees2' board is locked\n");
               break;
           case MB_ERR_INTERNAL:
               fprintf(stderr, "\t reason: internal error. Recompile libmoard in debug mode for more info \n");
               break;
           default:
               fprintf(stderr, "\t MB_Clear returned error code: %d (see libmboard docs for details)\n", rc);
               break;

       }

       
       exit(rc);
    }
    #endif


	/* If mb is not read then leave sync complete until last possible moment */
	if(FLAME_job_application2_message_board_read == 1)
	{
		if(FLAME_TEST_PRINT_START_AND_END_OF_LIBMBOARD_CALLS) printf("start MB_SyncComplete(b_job_application2)\n");
		rc = MB_SyncComplete(b_job_application2);
		if(FLAME_TEST_PRINT_START_AND_END_OF_LIBMBOARD_CALLS) printf("finsh MB_SyncComplete(b_job_application2)\n");
		#ifdef ERRCHECK
		if (rc != MB_SUCCESS)
		{
		   fprintf(stderr, "ERROR: Could not complete sync of 'job_application2' board\n");
		   switch(rc) {
				case MB_ERR_INVALID:
				   fprintf(stderr, "\t reason: 'job_application2' board is invalid\n");
				   break;
			   case MB_ERR_MEMALLOC:
				   fprintf(stderr, "\t reason: out of memory\n");
				   break;
			   case MB_ERR_INTERNAL:
				   fprintf(stderr, "\t reason: internal error. Recompile libmoard in debug mode for more info \n");
				   break;
			   default:
				   fprintf(stderr, "\t MB_SyncComplete returned error code: %d (see libmboard docs for details)\n", rc);
				   break;
		   }
	
		   
		   exit(rc);
		}
		#endif
    
	}
	
	if(FLAME_TEST_PRINT_START_AND_END_OF_MODEL_FUNCTIONS) printf("start Firm_read_job_applications_send_job_offer_or_rejection_2\n");
	current_xmachine_Firm_holder = Firm_07_state->agents;
	while(current_xmachine_Firm_holder)
	{
		temp_xmachine_Firm_holder = current_xmachine_Firm_holder->next;
		current_xmachine_Firm = current_xmachine_Firm_holder->agent;
		current_xmachine_Firm_next_state = Firm_08_state;
		/* For backwards compatibility set current_xmachine */
		current_xmachine->xmachine_Firm = NULL;
		current_xmachine->xmachine_Household = NULL;
		current_xmachine->xmachine_Mall = NULL;
		current_xmachine->xmachine_IGFirm = NULL;
		current_xmachine->xmachine_Eurostat = NULL;
		current_xmachine->xmachine_Bank = NULL;
		current_xmachine->xmachine_Government = NULL;
		current_xmachine->xmachine_CentralBank = NULL;
		current_xmachine->xmachine_ClearingHouse = NULL;
		current_xmachine->xmachine_Firm = current_xmachine_Firm;

		

		
		rc = MB_Iterator_CreateFiltered(b_job_application2, &i_job_application2, &FLAME_filter_Firm_Firm_read_job_applications_send_job_offer_or_rejection_2_07_08_job_application2, current_xmachine_Firm);
		
		#ifdef ERRCHECK
		if (rc != MB_SUCCESS)
		{
		   fprintf(stderr, "ERROR: Could not create Iterator for 'job_application2'\n");
		   switch(rc) {
		       case MB_ERR_INVALID:
		           fprintf(stderr, "\t reason: 'job_application2' board is invalid\n");
		           break;
		       case MB_ERR_LOCKED:
	               fprintf(stderr, "\t reason: 'job_application2' board is locked\n");
	               break;
	           case MB_ERR_MEMALLOC:
	               fprintf(stderr, "\t reason: out of memory\n");
	               break;
	           case MB_ERR_INTERNAL:
	               fprintf(stderr, "\t reason: internal error. Recompile libmoard in debug mode for more info \n");
	               break;
	           default:
	           
                   fprintf(stderr, "\t MB_Iterator_CreateFiltered returned error code: %d (see libmboard docs for details)\n", rc);
               
               
                   break;
		   }

		   
           exit(rc);
		}
		#endif
		
		

			i = Firm_read_job_applications_send_job_offer_or_rejection_2();

		
		    rc = MB_Iterator_Delete(&i_job_application2);
		    #ifdef ERRCHECK
		    if (rc != MB_SUCCESS)
		    {
		       fprintf(stderr, "ERROR: Could not delete 'job_application2' iterator\n");
		       switch(rc) {
		           case MB_ERR_INVALID:
		               fprintf(stderr, "\t reason: 'job_application2' iterator is invalid\n");
		               break;
		           case MB_ERR_INTERNAL:
		               fprintf(stderr, "\t reason: internal error. Recompile libmoard in debug mode for more info \n");
		               break;
		           default:
                       fprintf(stderr, "\t MB_Iterator_Delete returned error code: %d (see libmboard docs for details)\n", rc);
                       break;
		       }

		       
               exit(rc);
		    }
		    #endif
		

			if(i == 1)
			{
				free_Firm_agent(current_xmachine_Firm_holder, Firm_07_state);
			}
			else
			{
				transition_Firm_agent(current_xmachine_Firm_holder, Firm_07_state, Firm_08_state);
			}
		

		current_xmachine_Firm = NULL;

		current_xmachine_Firm_holder = temp_xmachine_Firm_holder;
	}
	if(FLAME_TEST_PRINT_START_AND_END_OF_MODEL_FUNCTIONS) printf("finish Firm_read_job_applications_send_job_offer_or_rejection_2\n");

	if(FLAME_job_offer2_message_board_write == 1)
	{

		if(FLAME_TEST_PRINT_START_AND_END_OF_LIBMBOARD_CALLS) printf("start MB_SyncStart(b_job_offer2)\n");
		rc = MB_SyncStart(b_job_offer2);
		if(FLAME_TEST_PRINT_START_AND_END_OF_LIBMBOARD_CALLS) printf("finish MB_SyncStart(b_job_offer2)\n");
		#ifdef ERRCHECK
		if (rc != MB_SUCCESS)
		{
		   fprintf(stderr, "ERROR: Could not start sync of 'job_offer2' board\n");
		   switch(rc) {
			   case MB_ERR_INVALID:
				   fprintf(stderr, "\t reason: 'job_offer2' board is invalid\n");
				   break;
			   case MB_ERR_LOCKED:
				   fprintf(stderr, "\t reason: 'job_offer2' board is locked\n");
				   break;
			   case MB_ERR_MEMALLOC:
				   fprintf(stderr, "\t reason: out of memory\n");
				   break;
			   case MB_ERR_INTERNAL:
				   fprintf(stderr, "\t reason: internal error. Recompile libmoard in debug mode for more info \n");
				   break;
			   default:
				   fprintf(stderr, "\t MB_SyncStart returned error code: %d (see libmboard docs for details)\n", rc);
				   break;
		   }

			
			exit(rc);
		}
		#endif
    }
    


/* End of layer number 56 */

/* Clear message boards that have finished being used
 * and sync complete if doing late sync complete */

if(FLAME_job_application2_message_board_read == 0)
{
	/*printf("%d> job_application2 message board sync complete late as no agents reading any messages of this type\n", node_number);*/
	
	if(FLAME_TEST_PRINT_START_AND_END_OF_LIBMBOARD_CALLS) printf("start MB_SyncComplete(b_job_application2)\n");
	rc = MB_SyncComplete(b_job_application2);
	if(FLAME_TEST_PRINT_START_AND_END_OF_LIBMBOARD_CALLS) printf("finsh MB_SyncComplete(b_job_application2)\n");
	#ifdef ERRCHECK
	if (rc != MB_SUCCESS)
	{
	   fprintf(stderr, "ERROR: Could not complete sync of 'job_application2' board\n");
	   switch(rc) {
			case MB_ERR_INVALID:
			   fprintf(stderr, "\t reason: 'job_application2' board is invalid\n");
			   break;
		   case MB_ERR_MEMALLOC:
			   fprintf(stderr, "\t reason: out of memory\n");
			   break;
		   case MB_ERR_INTERNAL:
			   fprintf(stderr, "\t reason: internal error. Recompile libmoard in debug mode for more info \n");
			   break;
		   default:
			   fprintf(stderr, "\t MB_SyncComplete returned error code: %d (see libmboard docs for details)\n", rc);
			   break;
	   }

	   
	   exit(rc);
	}
	#endif
}

    rc = MB_Clear(b_job_application2);
    #ifdef ERRCHECK
    if (rc != MB_SUCCESS)
    {
       fprintf(stderr, "ERROR: Could not clear 'job_application2' board\n");
       switch(rc) {
           case MB_ERR_INVALID:
               fprintf(stderr, "\t reason: 'job_application2' board is invalid\n");
               break;
           case MB_ERR_LOCKED:
               fprintf(stderr, "\t reason: 'job_application2' board is locked\n");
               break;
           case MB_ERR_INTERNAL:
               fprintf(stderr, "\t reason: internal error. Recompile libmoard in debug mode for more info \n");
               break;
           default:
               fprintf(stderr, "\t MB_Clear returned error code: %d (see libmboard docs for details)\n", rc);
               break;

       }

       
       exit(rc);
    }
    #endif


	/* If mb is not read then leave sync complete until last possible moment */
	if(FLAME_job_offer2_message_board_read == 1)
	{
		if(FLAME_TEST_PRINT_START_AND_END_OF_LIBMBOARD_CALLS) printf("start MB_SyncComplete(b_job_offer2)\n");
		rc = MB_SyncComplete(b_job_offer2);
		if(FLAME_TEST_PRINT_START_AND_END_OF_LIBMBOARD_CALLS) printf("finsh MB_SyncComplete(b_job_offer2)\n");
		#ifdef ERRCHECK
		if (rc != MB_SUCCESS)
		{
		   fprintf(stderr, "ERROR: Could not complete sync of 'job_offer2' board\n");
		   switch(rc) {
				case MB_ERR_INVALID:
				   fprintf(stderr, "\t reason: 'job_offer2' board is invalid\n");
				   break;
			   case MB_ERR_MEMALLOC:
				   fprintf(stderr, "\t reason: out of memory\n");
				   break;
			   case MB_ERR_INTERNAL:
				   fprintf(stderr, "\t reason: internal error. Recompile libmoard in debug mode for more info \n");
				   break;
			   default:
				   fprintf(stderr, "\t MB_SyncComplete returned error code: %d (see libmboard docs for details)\n", rc);
				   break;
		   }
	
		   
		   exit(rc);
		}
		#endif
    
	}
	
	if(FLAME_TEST_PRINT_START_AND_END_OF_MODEL_FUNCTIONS) printf("start Household_read_job_offers_send_response_2\n");
	current_xmachine_Household_holder = Household_04_state->agents;
	while(current_xmachine_Household_holder)
	{
		temp_xmachine_Household_holder = current_xmachine_Household_holder->next;
		current_xmachine_Household = current_xmachine_Household_holder->agent;
		current_xmachine_Household_next_state = Household_05_state;
		/* For backwards compatibility set current_xmachine */
		current_xmachine->xmachine_Firm = NULL;
		current_xmachine->xmachine_Household = NULL;
		current_xmachine->xmachine_Mall = NULL;
		current_xmachine->xmachine_IGFirm = NULL;
		current_xmachine->xmachine_Eurostat = NULL;
		current_xmachine->xmachine_Bank = NULL;
		current_xmachine->xmachine_Government = NULL;
		current_xmachine->xmachine_CentralBank = NULL;
		current_xmachine->xmachine_ClearingHouse = NULL;
		current_xmachine->xmachine_Household = current_xmachine_Household;

		

		
		rc = MB_Iterator_CreateFiltered(b_job_offer2, &i_job_offer2, &FLAME_filter_Household_Household_read_job_offers_send_response_2_04_05_job_offer2, current_xmachine_Household);
		
		#ifdef ERRCHECK
		if (rc != MB_SUCCESS)
		{
		   fprintf(stderr, "ERROR: Could not create Iterator for 'job_offer2'\n");
		   switch(rc) {
		       case MB_ERR_INVALID:
		           fprintf(stderr, "\t reason: 'job_offer2' board is invalid\n");
		           break;
		       case MB_ERR_LOCKED:
	               fprintf(stderr, "\t reason: 'job_offer2' board is locked\n");
	               break;
	           case MB_ERR_MEMALLOC:
	               fprintf(stderr, "\t reason: out of memory\n");
	               break;
	           case MB_ERR_INTERNAL:
	               fprintf(stderr, "\t reason: internal error. Recompile libmoard in debug mode for more info \n");
	               break;
	           default:
	           
                   fprintf(stderr, "\t MB_Iterator_CreateFiltered returned error code: %d (see libmboard docs for details)\n", rc);
               
               
                   break;
		   }

		   
           exit(rc);
		}
		#endif
		
		

			i = Household_read_job_offers_send_response_2();

		
		    rc = MB_Iterator_Delete(&i_job_offer2);
		    #ifdef ERRCHECK
		    if (rc != MB_SUCCESS)
		    {
		       fprintf(stderr, "ERROR: Could not delete 'job_offer2' iterator\n");
		       switch(rc) {
		           case MB_ERR_INVALID:
		               fprintf(stderr, "\t reason: 'job_offer2' iterator is invalid\n");
		               break;
		           case MB_ERR_INTERNAL:
		               fprintf(stderr, "\t reason: internal error. Recompile libmoard in debug mode for more info \n");
		               break;
		           default:
                       fprintf(stderr, "\t MB_Iterator_Delete returned error code: %d (see libmboard docs for details)\n", rc);
                       break;
		       }

		       
               exit(rc);
		    }
		    #endif
		

			if(i == 1)
			{
				free_Household_agent(current_xmachine_Household_holder, Household_04_state);
			}
			else
			{
				transition_Household_agent(current_xmachine_Household_holder, Household_04_state, Household_05_state);
			}
		

		current_xmachine_Household = NULL;

		current_xmachine_Household_holder = temp_xmachine_Household_holder;
	}
	if(FLAME_TEST_PRINT_START_AND_END_OF_MODEL_FUNCTIONS) printf("finish Household_read_job_offers_send_response_2\n");

	if(FLAME_quitting2_message_board_write == 1)
	{

		if(FLAME_TEST_PRINT_START_AND_END_OF_LIBMBOARD_CALLS) printf("start MB_SyncStart(b_quitting2)\n");
		rc = MB_SyncStart(b_quitting2);
		if(FLAME_TEST_PRINT_START_AND_END_OF_LIBMBOARD_CALLS) printf("finish MB_SyncStart(b_quitting2)\n");
		#ifdef ERRCHECK
		if (rc != MB_SUCCESS)
		{
		   fprintf(stderr, "ERROR: Could not start sync of 'quitting2' board\n");
		   switch(rc) {
			   case MB_ERR_INVALID:
				   fprintf(stderr, "\t reason: 'quitting2' board is invalid\n");
				   break;
			   case MB_ERR_LOCKED:
				   fprintf(stderr, "\t reason: 'quitting2' board is locked\n");
				   break;
			   case MB_ERR_MEMALLOC:
				   fprintf(stderr, "\t reason: out of memory\n");
				   break;
			   case MB_ERR_INTERNAL:
				   fprintf(stderr, "\t reason: internal error. Recompile libmoard in debug mode for more info \n");
				   break;
			   default:
				   fprintf(stderr, "\t MB_SyncStart returned error code: %d (see libmboard docs for details)\n", rc);
				   break;
		   }

			
			exit(rc);
		}
		#endif
    }
    

	if(FLAME_job_acceptance2_message_board_write == 1)
	{

		if(FLAME_TEST_PRINT_START_AND_END_OF_LIBMBOARD_CALLS) printf("start MB_SyncStart(b_job_acceptance2)\n");
		rc = MB_SyncStart(b_job_acceptance2);
		if(FLAME_TEST_PRINT_START_AND_END_OF_LIBMBOARD_CALLS) printf("finish MB_SyncStart(b_job_acceptance2)\n");
		#ifdef ERRCHECK
		if (rc != MB_SUCCESS)
		{
		   fprintf(stderr, "ERROR: Could not start sync of 'job_acceptance2' board\n");
		   switch(rc) {
			   case MB_ERR_INVALID:
				   fprintf(stderr, "\t reason: 'job_acceptance2' board is invalid\n");
				   break;
			   case MB_ERR_LOCKED:
				   fprintf(stderr, "\t reason: 'job_acceptance2' board is locked\n");
				   break;
			   case MB_ERR_MEMALLOC:
				   fprintf(stderr, "\t reason: out of memory\n");
				   break;
			   case MB_ERR_INTERNAL:
				   fprintf(stderr, "\t reason: internal error. Recompile libmoard in debug mode for more info \n");
				   break;
			   default:
				   fprintf(stderr, "\t MB_SyncStart returned error code: %d (see libmboard docs for details)\n", rc);
				   break;
		   }

			
			exit(rc);
		}
		#endif
    }
    


/* End of layer number 57 */

/* Clear message boards that have finished being used
 * and sync complete if doing late sync complete */

if(FLAME_job_offer2_message_board_read == 0)
{
	/*printf("%d> job_offer2 message board sync complete late as no agents reading any messages of this type\n", node_number);*/
	
	if(FLAME_TEST_PRINT_START_AND_END_OF_LIBMBOARD_CALLS) printf("start MB_SyncComplete(b_job_offer2)\n");
	rc = MB_SyncComplete(b_job_offer2);
	if(FLAME_TEST_PRINT_START_AND_END_OF_LIBMBOARD_CALLS) printf("finsh MB_SyncComplete(b_job_offer2)\n");
	#ifdef ERRCHECK
	if (rc != MB_SUCCESS)
	{
	   fprintf(stderr, "ERROR: Could not complete sync of 'job_offer2' board\n");
	   switch(rc) {
			case MB_ERR_INVALID:
			   fprintf(stderr, "\t reason: 'job_offer2' board is invalid\n");
			   break;
		   case MB_ERR_MEMALLOC:
			   fprintf(stderr, "\t reason: out of memory\n");
			   break;
		   case MB_ERR_INTERNAL:
			   fprintf(stderr, "\t reason: internal error. Recompile libmoard in debug mode for more info \n");
			   break;
		   default:
			   fprintf(stderr, "\t MB_SyncComplete returned error code: %d (see libmboard docs for details)\n", rc);
			   break;
	   }

	   
	   exit(rc);
	}
	#endif
}

    rc = MB_Clear(b_job_offer2);
    #ifdef ERRCHECK
    if (rc != MB_SUCCESS)
    {
       fprintf(stderr, "ERROR: Could not clear 'job_offer2' board\n");
       switch(rc) {
           case MB_ERR_INVALID:
               fprintf(stderr, "\t reason: 'job_offer2' board is invalid\n");
               break;
           case MB_ERR_LOCKED:
               fprintf(stderr, "\t reason: 'job_offer2' board is locked\n");
               break;
           case MB_ERR_INTERNAL:
               fprintf(stderr, "\t reason: internal error. Recompile libmoard in debug mode for more info \n");
               break;
           default:
               fprintf(stderr, "\t MB_Clear returned error code: %d (see libmboard docs for details)\n", rc);
               break;

       }

       
       exit(rc);
    }
    #endif


	if(FLAME_TEST_PRINT_START_AND_END_OF_MODEL_FUNCTIONS) printf("start Household_idle\n");
	current_xmachine_Household_holder = Household_05_state->agents;
	while(current_xmachine_Household_holder)
	{
		temp_xmachine_Household_holder = current_xmachine_Household_holder->next;
		current_xmachine_Household = current_xmachine_Household_holder->agent;
		current_xmachine_Household_next_state = Household_06_state;
		/* For backwards compatibility set current_xmachine */
		current_xmachine->xmachine_Firm = NULL;
		current_xmachine->xmachine_Household = NULL;
		current_xmachine->xmachine_Mall = NULL;
		current_xmachine->xmachine_IGFirm = NULL;
		current_xmachine->xmachine_Eurostat = NULL;
		current_xmachine->xmachine_Bank = NULL;
		current_xmachine->xmachine_Government = NULL;
		current_xmachine->xmachine_CentralBank = NULL;
		current_xmachine->xmachine_ClearingHouse = NULL;
		current_xmachine->xmachine_Household = current_xmachine_Household;

		if(FLAME_condition_Household_Household_idle_05_06(current_xmachine_Household)==1)
		{

		

			i = Household_idle();

		

			if(i == 1)
			{
				free_Household_agent(current_xmachine_Household_holder, Household_05_state);
			}
			else
			{
				transition_Household_agent(current_xmachine_Household_holder, Household_05_state, Household_06_state);
			}
		}

		current_xmachine_Household = NULL;

		current_xmachine_Household_holder = temp_xmachine_Household_holder;
	}
	if(FLAME_TEST_PRINT_START_AND_END_OF_MODEL_FUNCTIONS) printf("finish Household_idle\n");


	if(FLAME_TEST_PRINT_START_AND_END_OF_MODEL_FUNCTIONS) printf("start Household_read_application_rejection_update_wage_reservation_2\n");
	current_xmachine_Household_holder = Household_05_state->agents;
	while(current_xmachine_Household_holder)
	{
		temp_xmachine_Household_holder = current_xmachine_Household_holder->next;
		current_xmachine_Household = current_xmachine_Household_holder->agent;
		current_xmachine_Household_next_state = Household_06_state;
		/* For backwards compatibility set current_xmachine */
		current_xmachine->xmachine_Firm = NULL;
		current_xmachine->xmachine_Household = NULL;
		current_xmachine->xmachine_Mall = NULL;
		current_xmachine->xmachine_IGFirm = NULL;
		current_xmachine->xmachine_Eurostat = NULL;
		current_xmachine->xmachine_Bank = NULL;
		current_xmachine->xmachine_Government = NULL;
		current_xmachine->xmachine_CentralBank = NULL;
		current_xmachine->xmachine_ClearingHouse = NULL;
		current_xmachine->xmachine_Household = current_xmachine_Household;

		if(FLAME_condition_Household_Household_read_application_rejection_update_wage_reservation_2_05_06(current_xmachine_Household)==1)
		{

		

			i = Household_read_application_rejection_update_wage_reservation_2();

		

			if(i == 1)
			{
				free_Household_agent(current_xmachine_Household_holder, Household_05_state);
			}
			else
			{
				transition_Household_agent(current_xmachine_Household_holder, Household_05_state, Household_06_state);
			}
		}

		current_xmachine_Household = NULL;

		current_xmachine_Household_holder = temp_xmachine_Household_holder;
	}
	if(FLAME_TEST_PRINT_START_AND_END_OF_MODEL_FUNCTIONS) printf("finish Household_read_application_rejection_update_wage_reservation_2\n");


	/* If mb is not read then leave sync complete until last possible moment */
	if(FLAME_job_acceptance2_message_board_read == 1)
	{
		if(FLAME_TEST_PRINT_START_AND_END_OF_LIBMBOARD_CALLS) printf("start MB_SyncComplete(b_job_acceptance2)\n");
		rc = MB_SyncComplete(b_job_acceptance2);
		if(FLAME_TEST_PRINT_START_AND_END_OF_LIBMBOARD_CALLS) printf("finsh MB_SyncComplete(b_job_acceptance2)\n");
		#ifdef ERRCHECK
		if (rc != MB_SUCCESS)
		{
		   fprintf(stderr, "ERROR: Could not complete sync of 'job_acceptance2' board\n");
		   switch(rc) {
				case MB_ERR_INVALID:
				   fprintf(stderr, "\t reason: 'job_acceptance2' board is invalid\n");
				   break;
			   case MB_ERR_MEMALLOC:
				   fprintf(stderr, "\t reason: out of memory\n");
				   break;
			   case MB_ERR_INTERNAL:
				   fprintf(stderr, "\t reason: internal error. Recompile libmoard in debug mode for more info \n");
				   break;
			   default:
				   fprintf(stderr, "\t MB_SyncComplete returned error code: %d (see libmboard docs for details)\n", rc);
				   break;
		   }
	
		   
		   exit(rc);
		}
		#endif
    
	}
	
	if(FLAME_TEST_PRINT_START_AND_END_OF_MODEL_FUNCTIONS) printf("start Firm_read_job_responses_2\n");
	current_xmachine_Firm_holder = Firm_08_state->agents;
	while(current_xmachine_Firm_holder)
	{
		temp_xmachine_Firm_holder = current_xmachine_Firm_holder->next;
		current_xmachine_Firm = current_xmachine_Firm_holder->agent;
		current_xmachine_Firm_next_state = Firm_09a_state;
		/* For backwards compatibility set current_xmachine */
		current_xmachine->xmachine_Firm = NULL;
		current_xmachine->xmachine_Household = NULL;
		current_xmachine->xmachine_Mall = NULL;
		current_xmachine->xmachine_IGFirm = NULL;
		current_xmachine->xmachine_Eurostat = NULL;
		current_xmachine->xmachine_Bank = NULL;
		current_xmachine->xmachine_Government = NULL;
		current_xmachine->xmachine_CentralBank = NULL;
		current_xmachine->xmachine_ClearingHouse = NULL;
		current_xmachine->xmachine_Firm = current_xmachine_Firm;

		

		
		rc = MB_Iterator_CreateFiltered(b_job_acceptance2, &i_job_acceptance2, &FLAME_filter_Firm_Firm_read_job_responses_2_08_09a_job_acceptance2, current_xmachine_Firm);
		
		#ifdef ERRCHECK
		if (rc != MB_SUCCESS)
		{
		   fprintf(stderr, "ERROR: Could not create Iterator for 'job_acceptance2'\n");
		   switch(rc) {
		       case MB_ERR_INVALID:
		           fprintf(stderr, "\t reason: 'job_acceptance2' board is invalid\n");
		           break;
		       case MB_ERR_LOCKED:
	               fprintf(stderr, "\t reason: 'job_acceptance2' board is locked\n");
	               break;
	           case MB_ERR_MEMALLOC:
	               fprintf(stderr, "\t reason: out of memory\n");
	               break;
	           case MB_ERR_INTERNAL:
	               fprintf(stderr, "\t reason: internal error. Recompile libmoard in debug mode for more info \n");
	               break;
	           default:
	           
                   fprintf(stderr, "\t MB_Iterator_CreateFiltered returned error code: %d (see libmboard docs for details)\n", rc);
               
               
                   break;
		   }

		   
           exit(rc);
		}
		#endif
		
		

			i = Firm_read_job_responses_2();

		
		    rc = MB_Iterator_Delete(&i_job_acceptance2);
		    #ifdef ERRCHECK
		    if (rc != MB_SUCCESS)
		    {
		       fprintf(stderr, "ERROR: Could not delete 'job_acceptance2' iterator\n");
		       switch(rc) {
		           case MB_ERR_INVALID:
		               fprintf(stderr, "\t reason: 'job_acceptance2' iterator is invalid\n");
		               break;
		           case MB_ERR_INTERNAL:
		               fprintf(stderr, "\t reason: internal error. Recompile libmoard in debug mode for more info \n");
		               break;
		           default:
                       fprintf(stderr, "\t MB_Iterator_Delete returned error code: %d (see libmboard docs for details)\n", rc);
                       break;
		       }

		       
               exit(rc);
		    }
		    #endif
		

			if(i == 1)
			{
				free_Firm_agent(current_xmachine_Firm_holder, Firm_08_state);
			}
			else
			{
				transition_Firm_agent(current_xmachine_Firm_holder, Firm_08_state, Firm_09a_state);
			}
		

		current_xmachine_Firm = NULL;

		current_xmachine_Firm_holder = temp_xmachine_Firm_holder;
	}
	if(FLAME_TEST_PRINT_START_AND_END_OF_MODEL_FUNCTIONS) printf("finish Firm_read_job_responses_2\n");


	/* If mb is not read then leave sync complete until last possible moment */
	if(FLAME_quitting2_message_board_read == 1)
	{
		if(FLAME_TEST_PRINT_START_AND_END_OF_LIBMBOARD_CALLS) printf("start MB_SyncComplete(b_quitting2)\n");
		rc = MB_SyncComplete(b_quitting2);
		if(FLAME_TEST_PRINT_START_AND_END_OF_LIBMBOARD_CALLS) printf("finsh MB_SyncComplete(b_quitting2)\n");
		#ifdef ERRCHECK
		if (rc != MB_SUCCESS)
		{
		   fprintf(stderr, "ERROR: Could not complete sync of 'quitting2' board\n");
		   switch(rc) {
				case MB_ERR_INVALID:
				   fprintf(stderr, "\t reason: 'quitting2' board is invalid\n");
				   break;
			   case MB_ERR_MEMALLOC:
				   fprintf(stderr, "\t reason: out of memory\n");
				   break;
			   case MB_ERR_INTERNAL:
				   fprintf(stderr, "\t reason: internal error. Recompile libmoard in debug mode for more info \n");
				   break;
			   default:
				   fprintf(stderr, "\t MB_SyncComplete returned error code: %d (see libmboard docs for details)\n", rc);
				   break;
		   }
	
		   
		   exit(rc);
		}
		#endif
    
	}
	
	if(FLAME_TEST_PRINT_START_AND_END_OF_MODEL_FUNCTIONS) printf("start Firm_read_job_quitting_2\n");
	current_xmachine_Firm_holder = Firm_09c_state->agents;
	while(current_xmachine_Firm_holder)
	{
		temp_xmachine_Firm_holder = current_xmachine_Firm_holder->next;
		current_xmachine_Firm = current_xmachine_Firm_holder->agent;
		current_xmachine_Firm_next_state = Firm_Firm_Start_Seller_Role_state;
		/* For backwards compatibility set current_xmachine */
		current_xmachine->xmachine_Firm = NULL;
		current_xmachine->xmachine_Household = NULL;
		current_xmachine->xmachine_Mall = NULL;
		current_xmachine->xmachine_IGFirm = NULL;
		current_xmachine->xmachine_Eurostat = NULL;
		current_xmachine->xmachine_Bank = NULL;
		current_xmachine->xmachine_Government = NULL;
		current_xmachine->xmachine_CentralBank = NULL;
		current_xmachine->xmachine_ClearingHouse = NULL;
		current_xmachine->xmachine_Firm = current_xmachine_Firm;

		

		
		
		rc = MB_Iterator_Create(b_quitting2, &i_quitting2);
		#ifdef ERRCHECK
		if (rc != MB_SUCCESS)
		{
		   fprintf(stderr, "ERROR: Could not create Iterator for 'quitting2'\n");
		   switch(rc) {
		       case MB_ERR_INVALID:
		           fprintf(stderr, "\t reason: 'quitting2' board is invalid\n");
		           break;
		       case MB_ERR_LOCKED:
	               fprintf(stderr, "\t reason: 'quitting2' board is locked\n");
	               break;
	           case MB_ERR_MEMALLOC:
	               fprintf(stderr, "\t reason: out of memory\n");
	               break;
	           case MB_ERR_INTERNAL:
	               fprintf(stderr, "\t reason: internal error. Recompile libmoard in debug mode for more info \n");
	               break;
	           default:
	           
               
                   fprintf(stderr, "\t MB_Iterator_Create returned error code: %d (see libmboard docs for details)\n", rc);
               
                   break;
		   }

		   
           exit(rc);
		}
		#endif
		
		

			i = Firm_read_job_quitting_2();

		
		    rc = MB_Iterator_Delete(&i_quitting2);
		    #ifdef ERRCHECK
		    if (rc != MB_SUCCESS)
		    {
		       fprintf(stderr, "ERROR: Could not delete 'quitting2' iterator\n");
		       switch(rc) {
		           case MB_ERR_INVALID:
		               fprintf(stderr, "\t reason: 'quitting2' iterator is invalid\n");
		               break;
		           case MB_ERR_INTERNAL:
		               fprintf(stderr, "\t reason: internal error. Recompile libmoard in debug mode for more info \n");
		               break;
		           default:
                       fprintf(stderr, "\t MB_Iterator_Delete returned error code: %d (see libmboard docs for details)\n", rc);
                       break;
		       }

		       
               exit(rc);
		    }
		    #endif
		

			if(i == 1)
			{
				free_Firm_agent(current_xmachine_Firm_holder, Firm_09c_state);
			}
			else
			{
				transition_Firm_agent(current_xmachine_Firm_holder, Firm_09c_state, Firm_Firm_Start_Seller_Role_state);
			}
		

		current_xmachine_Firm = NULL;

		current_xmachine_Firm_holder = temp_xmachine_Firm_holder;
	}
	if(FLAME_TEST_PRINT_START_AND_END_OF_MODEL_FUNCTIONS) printf("finish Firm_read_job_quitting_2\n");


/* End of layer number 58 */

/* Clear message boards that have finished being used
 * and sync complete if doing late sync complete */

if(FLAME_job_acceptance2_message_board_read == 0)
{
	/*printf("%d> job_acceptance2 message board sync complete late as no agents reading any messages of this type\n", node_number);*/
	
	if(FLAME_TEST_PRINT_START_AND_END_OF_LIBMBOARD_CALLS) printf("start MB_SyncComplete(b_job_acceptance2)\n");
	rc = MB_SyncComplete(b_job_acceptance2);
	if(FLAME_TEST_PRINT_START_AND_END_OF_LIBMBOARD_CALLS) printf("finsh MB_SyncComplete(b_job_acceptance2)\n");
	#ifdef ERRCHECK
	if (rc != MB_SUCCESS)
	{
	   fprintf(stderr, "ERROR: Could not complete sync of 'job_acceptance2' board\n");
	   switch(rc) {
			case MB_ERR_INVALID:
			   fprintf(stderr, "\t reason: 'job_acceptance2' board is invalid\n");
			   break;
		   case MB_ERR_MEMALLOC:
			   fprintf(stderr, "\t reason: out of memory\n");
			   break;
		   case MB_ERR_INTERNAL:
			   fprintf(stderr, "\t reason: internal error. Recompile libmoard in debug mode for more info \n");
			   break;
		   default:
			   fprintf(stderr, "\t MB_SyncComplete returned error code: %d (see libmboard docs for details)\n", rc);
			   break;
	   }

	   
	   exit(rc);
	}
	#endif
}

    rc = MB_Clear(b_job_acceptance2);
    #ifdef ERRCHECK
    if (rc != MB_SUCCESS)
    {
       fprintf(stderr, "ERROR: Could not clear 'job_acceptance2' board\n");
       switch(rc) {
           case MB_ERR_INVALID:
               fprintf(stderr, "\t reason: 'job_acceptance2' board is invalid\n");
               break;
           case MB_ERR_LOCKED:
               fprintf(stderr, "\t reason: 'job_acceptance2' board is locked\n");
               break;
           case MB_ERR_INTERNAL:
               fprintf(stderr, "\t reason: internal error. Recompile libmoard in debug mode for more info \n");
               break;
           default:
               fprintf(stderr, "\t MB_Clear returned error code: %d (see libmboard docs for details)\n", rc);
               break;

       }

       
       exit(rc);
    }
    #endif


	if(FLAME_TEST_PRINT_START_AND_END_OF_MODEL_FUNCTIONS) printf("start Household_receive_dividends_dummy\n");
	current_xmachine_Household_holder = Household_06_state->agents;
	while(current_xmachine_Household_holder)
	{
		temp_xmachine_Household_holder = current_xmachine_Household_holder->next;
		current_xmachine_Household = current_xmachine_Household_holder->agent;
		current_xmachine_Household_next_state = Household_06b_state;
		/* For backwards compatibility set current_xmachine */
		current_xmachine->xmachine_Firm = NULL;
		current_xmachine->xmachine_Household = NULL;
		current_xmachine->xmachine_Mall = NULL;
		current_xmachine->xmachine_IGFirm = NULL;
		current_xmachine->xmachine_Eurostat = NULL;
		current_xmachine->xmachine_Bank = NULL;
		current_xmachine->xmachine_Government = NULL;
		current_xmachine->xmachine_CentralBank = NULL;
		current_xmachine->xmachine_ClearingHouse = NULL;
		current_xmachine->xmachine_Household = current_xmachine_Household;

		

		

			i = Household_receive_dividends_dummy();

		

			if(i == 1)
			{
				free_Household_agent(current_xmachine_Household_holder, Household_06_state);
			}
			else
			{
				transition_Household_agent(current_xmachine_Household_holder, Household_06_state, Household_06b_state);
			}
		

		current_xmachine_Household = NULL;

		current_xmachine_Household_holder = temp_xmachine_Household_holder;
	}
	if(FLAME_TEST_PRINT_START_AND_END_OF_MODEL_FUNCTIONS) printf("finish Household_receive_dividends_dummy\n");


	if(FLAME_TEST_PRINT_START_AND_END_OF_MODEL_FUNCTIONS) printf("start Firm_read_job_quitting_2\n");
	current_xmachine_Firm_holder = Firm_09a_state->agents;
	while(current_xmachine_Firm_holder)
	{
		temp_xmachine_Firm_holder = current_xmachine_Firm_holder->next;
		current_xmachine_Firm = current_xmachine_Firm_holder->agent;
		current_xmachine_Firm_next_state = Firm_09b_state;
		/* For backwards compatibility set current_xmachine */
		current_xmachine->xmachine_Firm = NULL;
		current_xmachine->xmachine_Household = NULL;
		current_xmachine->xmachine_Mall = NULL;
		current_xmachine->xmachine_IGFirm = NULL;
		current_xmachine->xmachine_Eurostat = NULL;
		current_xmachine->xmachine_Bank = NULL;
		current_xmachine->xmachine_Government = NULL;
		current_xmachine->xmachine_CentralBank = NULL;
		current_xmachine->xmachine_ClearingHouse = NULL;
		current_xmachine->xmachine_Firm = current_xmachine_Firm;

		

		
		
		rc = MB_Iterator_Create(b_quitting2, &i_quitting2);
		#ifdef ERRCHECK
		if (rc != MB_SUCCESS)
		{
		   fprintf(stderr, "ERROR: Could not create Iterator for 'quitting2'\n");
		   switch(rc) {
		       case MB_ERR_INVALID:
		           fprintf(stderr, "\t reason: 'quitting2' board is invalid\n");
		           break;
		       case MB_ERR_LOCKED:
	               fprintf(stderr, "\t reason: 'quitting2' board is locked\n");
	               break;
	           case MB_ERR_MEMALLOC:
	               fprintf(stderr, "\t reason: out of memory\n");
	               break;
	           case MB_ERR_INTERNAL:
	               fprintf(stderr, "\t reason: internal error. Recompile libmoard in debug mode for more info \n");
	               break;
	           default:
	           
               
                   fprintf(stderr, "\t MB_Iterator_Create returned error code: %d (see libmboard docs for details)\n", rc);
               
                   break;
		   }

		   
           exit(rc);
		}
		#endif
		
		

			i = Firm_read_job_quitting_2();

		
		    rc = MB_Iterator_Delete(&i_quitting2);
		    #ifdef ERRCHECK
		    if (rc != MB_SUCCESS)
		    {
		       fprintf(stderr, "ERROR: Could not delete 'quitting2' iterator\n");
		       switch(rc) {
		           case MB_ERR_INVALID:
		               fprintf(stderr, "\t reason: 'quitting2' iterator is invalid\n");
		               break;
		           case MB_ERR_INTERNAL:
		               fprintf(stderr, "\t reason: internal error. Recompile libmoard in debug mode for more info \n");
		               break;
		           default:
                       fprintf(stderr, "\t MB_Iterator_Delete returned error code: %d (see libmboard docs for details)\n", rc);
                       break;
		       }

		       
               exit(rc);
		    }
		    #endif
		

			if(i == 1)
			{
				free_Firm_agent(current_xmachine_Firm_holder, Firm_09a_state);
			}
			else
			{
				transition_Firm_agent(current_xmachine_Firm_holder, Firm_09a_state, Firm_09b_state);
			}
		

		current_xmachine_Firm = NULL;

		current_xmachine_Firm_holder = temp_xmachine_Firm_holder;
	}
	if(FLAME_TEST_PRINT_START_AND_END_OF_MODEL_FUNCTIONS) printf("finish Firm_read_job_quitting_2\n");


/* End of layer number 59 */

/* Clear message boards that have finished being used
 * and sync complete if doing late sync complete */

if(FLAME_quitting2_message_board_read == 0)
{
	/*printf("%d> quitting2 message board sync complete late as no agents reading any messages of this type\n", node_number);*/
	
	if(FLAME_TEST_PRINT_START_AND_END_OF_LIBMBOARD_CALLS) printf("start MB_SyncComplete(b_quitting2)\n");
	rc = MB_SyncComplete(b_quitting2);
	if(FLAME_TEST_PRINT_START_AND_END_OF_LIBMBOARD_CALLS) printf("finsh MB_SyncComplete(b_quitting2)\n");
	#ifdef ERRCHECK
	if (rc != MB_SUCCESS)
	{
	   fprintf(stderr, "ERROR: Could not complete sync of 'quitting2' board\n");
	   switch(rc) {
			case MB_ERR_INVALID:
			   fprintf(stderr, "\t reason: 'quitting2' board is invalid\n");
			   break;
		   case MB_ERR_MEMALLOC:
			   fprintf(stderr, "\t reason: out of memory\n");
			   break;
		   case MB_ERR_INTERNAL:
			   fprintf(stderr, "\t reason: internal error. Recompile libmoard in debug mode for more info \n");
			   break;
		   default:
			   fprintf(stderr, "\t MB_SyncComplete returned error code: %d (see libmboard docs for details)\n", rc);
			   break;
	   }

	   
	   exit(rc);
	}
	#endif
}

    rc = MB_Clear(b_quitting2);
    #ifdef ERRCHECK
    if (rc != MB_SUCCESS)
    {
       fprintf(stderr, "ERROR: Could not clear 'quitting2' board\n");
       switch(rc) {
           case MB_ERR_INVALID:
               fprintf(stderr, "\t reason: 'quitting2' board is invalid\n");
               break;
           case MB_ERR_LOCKED:
               fprintf(stderr, "\t reason: 'quitting2' board is locked\n");
               break;
           case MB_ERR_INTERNAL:
               fprintf(stderr, "\t reason: internal error. Recompile libmoard in debug mode for more info \n");
               break;
           default:
               fprintf(stderr, "\t MB_Clear returned error code: %d (see libmboard docs for details)\n", rc);
               break;

       }

       
       exit(rc);
    }
    #endif


	if(FLAME_TEST_PRINT_START_AND_END_OF_MODEL_FUNCTIONS) printf("start Household_idle\n");
	current_xmachine_Household_holder = Household_06b_state->agents;
	while(current_xmachine_Household_holder)
	{
		temp_xmachine_Household_holder = current_xmachine_Household_holder->next;
		current_xmachine_Household = current_xmachine_Household_holder->agent;
		current_xmachine_Household_next_state = Household_06c_state;
		/* For backwards compatibility set current_xmachine */
		current_xmachine->xmachine_Firm = NULL;
		current_xmachine->xmachine_Household = NULL;
		current_xmachine->xmachine_Mall = NULL;
		current_xmachine->xmachine_IGFirm = NULL;
		current_xmachine->xmachine_Eurostat = NULL;
		current_xmachine->xmachine_Bank = NULL;
		current_xmachine->xmachine_Government = NULL;
		current_xmachine->xmachine_CentralBank = NULL;
		current_xmachine->xmachine_ClearingHouse = NULL;
		current_xmachine->xmachine_Household = current_xmachine_Household;

		if(FLAME_condition_Household_Household_idle_06b_06c(current_xmachine_Household)==1)
		{

		

			i = Household_idle();

		

			if(i == 1)
			{
				free_Household_agent(current_xmachine_Household_holder, Household_06b_state);
			}
			else
			{
				transition_Household_agent(current_xmachine_Household_holder, Household_06b_state, Household_06c_state);
			}
		}

		current_xmachine_Household = NULL;

		current_xmachine_Household_holder = temp_xmachine_Household_holder;
	}
	if(FLAME_TEST_PRINT_START_AND_END_OF_MODEL_FUNCTIONS) printf("finish Household_idle\n");


	if(FLAME_TEST_PRINT_START_AND_END_OF_MODEL_FUNCTIONS) printf("start Household_idle\n");
	current_xmachine_Household_holder = Household_06b_state->agents;
	while(current_xmachine_Household_holder)
	{
		temp_xmachine_Household_holder = current_xmachine_Household_holder->next;
		current_xmachine_Household = current_xmachine_Household_holder->agent;
		current_xmachine_Household_next_state = Household_09_state;
		/* For backwards compatibility set current_xmachine */
		current_xmachine->xmachine_Firm = NULL;
		current_xmachine->xmachine_Household = NULL;
		current_xmachine->xmachine_Mall = NULL;
		current_xmachine->xmachine_IGFirm = NULL;
		current_xmachine->xmachine_Eurostat = NULL;
		current_xmachine->xmachine_Bank = NULL;
		current_xmachine->xmachine_Government = NULL;
		current_xmachine->xmachine_CentralBank = NULL;
		current_xmachine->xmachine_ClearingHouse = NULL;
		current_xmachine->xmachine_Household = current_xmachine_Household;

		if(FLAME_condition_Household_Household_idle_06b_09(current_xmachine_Household)==1)
		{

		

			i = Household_idle();

		

			if(i == 1)
			{
				free_Household_agent(current_xmachine_Household_holder, Household_06b_state);
			}
			else
			{
				transition_Household_agent(current_xmachine_Household_holder, Household_06b_state, Household_09_state);
			}
		}

		current_xmachine_Household = NULL;

		current_xmachine_Household_holder = temp_xmachine_Household_holder;
	}
	if(FLAME_TEST_PRINT_START_AND_END_OF_MODEL_FUNCTIONS) printf("finish Household_idle\n");


	if(FLAME_TEST_PRINT_START_AND_END_OF_MODEL_FUNCTIONS) printf("start Firm_idle\n");
	current_xmachine_Firm_holder = Firm_09b_state->agents;
	while(current_xmachine_Firm_holder)
	{
		temp_xmachine_Firm_holder = current_xmachine_Firm_holder->next;
		current_xmachine_Firm = current_xmachine_Firm_holder->agent;
		current_xmachine_Firm_next_state = Firm_10_state;
		/* For backwards compatibility set current_xmachine */
		current_xmachine->xmachine_Firm = NULL;
		current_xmachine->xmachine_Household = NULL;
		current_xmachine->xmachine_Mall = NULL;
		current_xmachine->xmachine_IGFirm = NULL;
		current_xmachine->xmachine_Eurostat = NULL;
		current_xmachine->xmachine_Bank = NULL;
		current_xmachine->xmachine_Government = NULL;
		current_xmachine->xmachine_CentralBank = NULL;
		current_xmachine->xmachine_ClearingHouse = NULL;
		current_xmachine->xmachine_Firm = current_xmachine_Firm;

		if(FLAME_condition_Firm_Firm_idle_09b_10(current_xmachine_Firm)==1)
		{

		

			i = Firm_idle();

		

			if(i == 1)
			{
				free_Firm_agent(current_xmachine_Firm_holder, Firm_09b_state);
			}
			else
			{
				transition_Firm_agent(current_xmachine_Firm_holder, Firm_09b_state, Firm_10_state);
			}
		}

		current_xmachine_Firm = NULL;

		current_xmachine_Firm_holder = temp_xmachine_Firm_holder;
	}
	if(FLAME_TEST_PRINT_START_AND_END_OF_MODEL_FUNCTIONS) printf("finish Firm_idle\n");


	if(FLAME_TEST_PRINT_START_AND_END_OF_MODEL_FUNCTIONS) printf("start Firm_update_wage_offer_2\n");
	current_xmachine_Firm_holder = Firm_09b_state->agents;
	while(current_xmachine_Firm_holder)
	{
		temp_xmachine_Firm_holder = current_xmachine_Firm_holder->next;
		current_xmachine_Firm = current_xmachine_Firm_holder->agent;
		current_xmachine_Firm_next_state = Firm_10_state;
		/* For backwards compatibility set current_xmachine */
		current_xmachine->xmachine_Firm = NULL;
		current_xmachine->xmachine_Household = NULL;
		current_xmachine->xmachine_Mall = NULL;
		current_xmachine->xmachine_IGFirm = NULL;
		current_xmachine->xmachine_Eurostat = NULL;
		current_xmachine->xmachine_Bank = NULL;
		current_xmachine->xmachine_Government = NULL;
		current_xmachine->xmachine_CentralBank = NULL;
		current_xmachine->xmachine_ClearingHouse = NULL;
		current_xmachine->xmachine_Firm = current_xmachine_Firm;

		if(FLAME_condition_Firm_Firm_update_wage_offer_2_09b_10(current_xmachine_Firm)==1)
		{

		

			i = Firm_update_wage_offer_2();

		

			if(i == 1)
			{
				free_Firm_agent(current_xmachine_Firm_holder, Firm_09b_state);
			}
			else
			{
				transition_Firm_agent(current_xmachine_Firm_holder, Firm_09b_state, Firm_10_state);
			}
		}

		current_xmachine_Firm = NULL;

		current_xmachine_Firm_holder = temp_xmachine_Firm_holder;
	}
	if(FLAME_TEST_PRINT_START_AND_END_OF_MODEL_FUNCTIONS) printf("finish Firm_update_wage_offer_2\n");


/* End of layer number 60 */

/* Clear message boards that have finished being used
 * and sync complete if doing late sync complete */


	if(FLAME_TEST_PRINT_START_AND_END_OF_MODEL_FUNCTIONS) printf("start Household_send_subsidy_notification\n");
	current_xmachine_Household_holder = Household_06c_state->agents;
	while(current_xmachine_Household_holder)
	{
		temp_xmachine_Household_holder = current_xmachine_Household_holder->next;
		current_xmachine_Household = current_xmachine_Household_holder->agent;
		current_xmachine_Household_next_state = Household_06d_state;
		/* For backwards compatibility set current_xmachine */
		current_xmachine->xmachine_Firm = NULL;
		current_xmachine->xmachine_Household = NULL;
		current_xmachine->xmachine_Mall = NULL;
		current_xmachine->xmachine_IGFirm = NULL;
		current_xmachine->xmachine_Eurostat = NULL;
		current_xmachine->xmachine_Bank = NULL;
		current_xmachine->xmachine_Government = NULL;
		current_xmachine->xmachine_CentralBank = NULL;
		current_xmachine->xmachine_ClearingHouse = NULL;
		current_xmachine->xmachine_Household = current_xmachine_Household;

		

		

			i = Household_send_subsidy_notification();

		

			if(i == 1)
			{
				free_Household_agent(current_xmachine_Household_holder, Household_06c_state);
			}
			else
			{
				transition_Household_agent(current_xmachine_Household_holder, Household_06c_state, Household_06d_state);
			}
		

		current_xmachine_Household = NULL;

		current_xmachine_Household_holder = temp_xmachine_Household_holder;
	}
	if(FLAME_TEST_PRINT_START_AND_END_OF_MODEL_FUNCTIONS) printf("finish Household_send_subsidy_notification\n");

	if(FLAME_hh_subsidy_notification_message_board_write == 1)
	{

		if(FLAME_TEST_PRINT_START_AND_END_OF_LIBMBOARD_CALLS) printf("start MB_SyncStart(b_hh_subsidy_notification)\n");
		rc = MB_SyncStart(b_hh_subsidy_notification);
		if(FLAME_TEST_PRINT_START_AND_END_OF_LIBMBOARD_CALLS) printf("finish MB_SyncStart(b_hh_subsidy_notification)\n");
		#ifdef ERRCHECK
		if (rc != MB_SUCCESS)
		{
		   fprintf(stderr, "ERROR: Could not start sync of 'hh_subsidy_notification' board\n");
		   switch(rc) {
			   case MB_ERR_INVALID:
				   fprintf(stderr, "\t reason: 'hh_subsidy_notification' board is invalid\n");
				   break;
			   case MB_ERR_LOCKED:
				   fprintf(stderr, "\t reason: 'hh_subsidy_notification' board is locked\n");
				   break;
			   case MB_ERR_MEMALLOC:
				   fprintf(stderr, "\t reason: out of memory\n");
				   break;
			   case MB_ERR_INTERNAL:
				   fprintf(stderr, "\t reason: internal error. Recompile libmoard in debug mode for more info \n");
				   break;
			   default:
				   fprintf(stderr, "\t MB_SyncStart returned error code: %d (see libmboard docs for details)\n", rc);
				   break;
		   }

			
			exit(rc);
		}
		#endif
    }
    


	if(FLAME_TEST_PRINT_START_AND_END_OF_MODEL_FUNCTIONS) printf("start Firm_compute_mean_wage_specific_skills\n");
	current_xmachine_Firm_holder = Firm_10_state->agents;
	while(current_xmachine_Firm_holder)
	{
		temp_xmachine_Firm_holder = current_xmachine_Firm_holder->next;
		current_xmachine_Firm = current_xmachine_Firm_holder->agent;
		current_xmachine_Firm_next_state = Firm_Firm_End_Labour_Role_state;
		/* For backwards compatibility set current_xmachine */
		current_xmachine->xmachine_Firm = NULL;
		current_xmachine->xmachine_Household = NULL;
		current_xmachine->xmachine_Mall = NULL;
		current_xmachine->xmachine_IGFirm = NULL;
		current_xmachine->xmachine_Eurostat = NULL;
		current_xmachine->xmachine_Bank = NULL;
		current_xmachine->xmachine_Government = NULL;
		current_xmachine->xmachine_CentralBank = NULL;
		current_xmachine->xmachine_ClearingHouse = NULL;
		current_xmachine->xmachine_Firm = current_xmachine_Firm;

		

		

			i = Firm_compute_mean_wage_specific_skills();

		

			if(i == 1)
			{
				free_Firm_agent(current_xmachine_Firm_holder, Firm_10_state);
			}
			else
			{
				transition_Firm_agent(current_xmachine_Firm_holder, Firm_10_state, Firm_Firm_End_Labour_Role_state);
			}
		

		current_xmachine_Firm = NULL;

		current_xmachine_Firm_holder = temp_xmachine_Firm_holder;
	}
	if(FLAME_TEST_PRINT_START_AND_END_OF_MODEL_FUNCTIONS) printf("finish Firm_compute_mean_wage_specific_skills\n");


/* End of layer number 61 */

/* Clear message boards that have finished being used
 * and sync complete if doing late sync complete */


	if(FLAME_TEST_PRINT_START_AND_END_OF_MODEL_FUNCTIONS) printf("start Firm_send_capital_demand\n");
	current_xmachine_Firm_holder = Firm_Firm_End_Labour_Role_state->agents;
	while(current_xmachine_Firm_holder)
	{
		temp_xmachine_Firm_holder = current_xmachine_Firm_holder->next;
		current_xmachine_Firm = current_xmachine_Firm_holder->agent;
		current_xmachine_Firm_next_state = Firm_11a_state;
		/* For backwards compatibility set current_xmachine */
		current_xmachine->xmachine_Firm = NULL;
		current_xmachine->xmachine_Household = NULL;
		current_xmachine->xmachine_Mall = NULL;
		current_xmachine->xmachine_IGFirm = NULL;
		current_xmachine->xmachine_Eurostat = NULL;
		current_xmachine->xmachine_Bank = NULL;
		current_xmachine->xmachine_Government = NULL;
		current_xmachine->xmachine_CentralBank = NULL;
		current_xmachine->xmachine_ClearingHouse = NULL;
		current_xmachine->xmachine_Firm = current_xmachine_Firm;

		

		

			i = Firm_send_capital_demand();

		

			if(i == 1)
			{
				free_Firm_agent(current_xmachine_Firm_holder, Firm_Firm_End_Labour_Role_state);
			}
			else
			{
				transition_Firm_agent(current_xmachine_Firm_holder, Firm_Firm_End_Labour_Role_state, Firm_11a_state);
			}
		

		current_xmachine_Firm = NULL;

		current_xmachine_Firm_holder = temp_xmachine_Firm_holder;
	}
	if(FLAME_TEST_PRINT_START_AND_END_OF_MODEL_FUNCTIONS) printf("finish Firm_send_capital_demand\n");

	if(FLAME_capital_good_request_message_board_write == 1)
	{

		if(FLAME_TEST_PRINT_START_AND_END_OF_LIBMBOARD_CALLS) printf("start MB_SyncStart(b_capital_good_request)\n");
		rc = MB_SyncStart(b_capital_good_request);
		if(FLAME_TEST_PRINT_START_AND_END_OF_LIBMBOARD_CALLS) printf("finish MB_SyncStart(b_capital_good_request)\n");
		#ifdef ERRCHECK
		if (rc != MB_SUCCESS)
		{
		   fprintf(stderr, "ERROR: Could not start sync of 'capital_good_request' board\n");
		   switch(rc) {
			   case MB_ERR_INVALID:
				   fprintf(stderr, "\t reason: 'capital_good_request' board is invalid\n");
				   break;
			   case MB_ERR_LOCKED:
				   fprintf(stderr, "\t reason: 'capital_good_request' board is locked\n");
				   break;
			   case MB_ERR_MEMALLOC:
				   fprintf(stderr, "\t reason: out of memory\n");
				   break;
			   case MB_ERR_INTERNAL:
				   fprintf(stderr, "\t reason: internal error. Recompile libmoard in debug mode for more info \n");
				   break;
			   default:
				   fprintf(stderr, "\t MB_SyncStart returned error code: %d (see libmboard docs for details)\n", rc);
				   break;
		   }

			
			exit(rc);
		}
		#endif
    }
    


	if(FLAME_TEST_PRINT_START_AND_END_OF_MODEL_FUNCTIONS) printf("start Household_send_transfer_notification\n");
	current_xmachine_Household_holder = Household_06d_state->agents;
	while(current_xmachine_Household_holder)
	{
		temp_xmachine_Household_holder = current_xmachine_Household_holder->next;
		current_xmachine_Household = current_xmachine_Household_holder->agent;
		current_xmachine_Household_next_state = Household_06e_state;
		/* For backwards compatibility set current_xmachine */
		current_xmachine->xmachine_Firm = NULL;
		current_xmachine->xmachine_Household = NULL;
		current_xmachine->xmachine_Mall = NULL;
		current_xmachine->xmachine_IGFirm = NULL;
		current_xmachine->xmachine_Eurostat = NULL;
		current_xmachine->xmachine_Bank = NULL;
		current_xmachine->xmachine_Government = NULL;
		current_xmachine->xmachine_CentralBank = NULL;
		current_xmachine->xmachine_ClearingHouse = NULL;
		current_xmachine->xmachine_Household = current_xmachine_Household;

		

		

			i = Household_send_transfer_notification();

		

			if(i == 1)
			{
				free_Household_agent(current_xmachine_Household_holder, Household_06d_state);
			}
			else
			{
				transition_Household_agent(current_xmachine_Household_holder, Household_06d_state, Household_06e_state);
			}
		

		current_xmachine_Household = NULL;

		current_xmachine_Household_holder = temp_xmachine_Household_holder;
	}
	if(FLAME_TEST_PRINT_START_AND_END_OF_MODEL_FUNCTIONS) printf("finish Household_send_transfer_notification\n");

	if(FLAME_hh_transfer_notification_message_board_write == 1)
	{

		if(FLAME_TEST_PRINT_START_AND_END_OF_LIBMBOARD_CALLS) printf("start MB_SyncStart(b_hh_transfer_notification)\n");
		rc = MB_SyncStart(b_hh_transfer_notification);
		if(FLAME_TEST_PRINT_START_AND_END_OF_LIBMBOARD_CALLS) printf("finish MB_SyncStart(b_hh_transfer_notification)\n");
		#ifdef ERRCHECK
		if (rc != MB_SUCCESS)
		{
		   fprintf(stderr, "ERROR: Could not start sync of 'hh_transfer_notification' board\n");
		   switch(rc) {
			   case MB_ERR_INVALID:
				   fprintf(stderr, "\t reason: 'hh_transfer_notification' board is invalid\n");
				   break;
			   case MB_ERR_LOCKED:
				   fprintf(stderr, "\t reason: 'hh_transfer_notification' board is locked\n");
				   break;
			   case MB_ERR_MEMALLOC:
				   fprintf(stderr, "\t reason: out of memory\n");
				   break;
			   case MB_ERR_INTERNAL:
				   fprintf(stderr, "\t reason: internal error. Recompile libmoard in debug mode for more info \n");
				   break;
			   default:
				   fprintf(stderr, "\t MB_SyncStart returned error code: %d (see libmboard docs for details)\n", rc);
				   break;
		   }

			
			exit(rc);
		}
		#endif
    }
    


/* End of layer number 62 */

/* Clear message boards that have finished being used
 * and sync complete if doing late sync complete */


	/* If mb is not read then leave sync complete until last possible moment */
	if(FLAME_capital_good_request_message_board_read == 1)
	{
		if(FLAME_TEST_PRINT_START_AND_END_OF_LIBMBOARD_CALLS) printf("start MB_SyncComplete(b_capital_good_request)\n");
		rc = MB_SyncComplete(b_capital_good_request);
		if(FLAME_TEST_PRINT_START_AND_END_OF_LIBMBOARD_CALLS) printf("finsh MB_SyncComplete(b_capital_good_request)\n");
		#ifdef ERRCHECK
		if (rc != MB_SUCCESS)
		{
		   fprintf(stderr, "ERROR: Could not complete sync of 'capital_good_request' board\n");
		   switch(rc) {
				case MB_ERR_INVALID:
				   fprintf(stderr, "\t reason: 'capital_good_request' board is invalid\n");
				   break;
			   case MB_ERR_MEMALLOC:
				   fprintf(stderr, "\t reason: out of memory\n");
				   break;
			   case MB_ERR_INTERNAL:
				   fprintf(stderr, "\t reason: internal error. Recompile libmoard in debug mode for more info \n");
				   break;
			   default:
				   fprintf(stderr, "\t MB_SyncComplete returned error code: %d (see libmboard docs for details)\n", rc);
				   break;
		   }
	
		   
		   exit(rc);
		}
		#endif
    
	}
	
	if(FLAME_TEST_PRINT_START_AND_END_OF_MODEL_FUNCTIONS) printf("start IGFirm_receive_order_delivers_capital_goods\n");
	current_xmachine_IGFirm_holder = IGFirm_02_state->agents;
	while(current_xmachine_IGFirm_holder)
	{
		temp_xmachine_IGFirm_holder = current_xmachine_IGFirm_holder->next;
		current_xmachine_IGFirm = current_xmachine_IGFirm_holder->agent;
		current_xmachine_IGFirm_next_state = IGFirm_03_state;
		/* For backwards compatibility set current_xmachine */
		current_xmachine->xmachine_Firm = NULL;
		current_xmachine->xmachine_Household = NULL;
		current_xmachine->xmachine_Mall = NULL;
		current_xmachine->xmachine_IGFirm = NULL;
		current_xmachine->xmachine_Eurostat = NULL;
		current_xmachine->xmachine_Bank = NULL;
		current_xmachine->xmachine_Government = NULL;
		current_xmachine->xmachine_CentralBank = NULL;
		current_xmachine->xmachine_ClearingHouse = NULL;
		current_xmachine->xmachine_IGFirm = current_xmachine_IGFirm;

		

		
		
		rc = MB_Iterator_Create(b_capital_good_request, &i_capital_good_request);
		#ifdef ERRCHECK
		if (rc != MB_SUCCESS)
		{
		   fprintf(stderr, "ERROR: Could not create Iterator for 'capital_good_request'\n");
		   switch(rc) {
		       case MB_ERR_INVALID:
		           fprintf(stderr, "\t reason: 'capital_good_request' board is invalid\n");
		           break;
		       case MB_ERR_LOCKED:
	               fprintf(stderr, "\t reason: 'capital_good_request' board is locked\n");
	               break;
	           case MB_ERR_MEMALLOC:
	               fprintf(stderr, "\t reason: out of memory\n");
	               break;
	           case MB_ERR_INTERNAL:
	               fprintf(stderr, "\t reason: internal error. Recompile libmoard in debug mode for more info \n");
	               break;
	           default:
	           
               
                   fprintf(stderr, "\t MB_Iterator_Create returned error code: %d (see libmboard docs for details)\n", rc);
               
                   break;
		   }

		   
           exit(rc);
		}
		#endif
		
		

			i = IGFirm_receive_order_delivers_capital_goods();

		
		    rc = MB_Iterator_Delete(&i_capital_good_request);
		    #ifdef ERRCHECK
		    if (rc != MB_SUCCESS)
		    {
		       fprintf(stderr, "ERROR: Could not delete 'capital_good_request' iterator\n");
		       switch(rc) {
		           case MB_ERR_INVALID:
		               fprintf(stderr, "\t reason: 'capital_good_request' iterator is invalid\n");
		               break;
		           case MB_ERR_INTERNAL:
		               fprintf(stderr, "\t reason: internal error. Recompile libmoard in debug mode for more info \n");
		               break;
		           default:
                       fprintf(stderr, "\t MB_Iterator_Delete returned error code: %d (see libmboard docs for details)\n", rc);
                       break;
		       }

		       
               exit(rc);
		    }
		    #endif
		

			if(i == 1)
			{
				free_IGFirm_agent(current_xmachine_IGFirm_holder, IGFirm_02_state);
			}
			else
			{
				transition_IGFirm_agent(current_xmachine_IGFirm_holder, IGFirm_02_state, IGFirm_03_state);
			}
		

		current_xmachine_IGFirm = NULL;

		current_xmachine_IGFirm_holder = temp_xmachine_IGFirm_holder;
	}
	if(FLAME_TEST_PRINT_START_AND_END_OF_MODEL_FUNCTIONS) printf("finish IGFirm_receive_order_delivers_capital_goods\n");

	if(FLAME_capital_good_delivery_message_board_write == 1)
	{

		if(FLAME_TEST_PRINT_START_AND_END_OF_LIBMBOARD_CALLS) printf("start MB_SyncStart(b_capital_good_delivery)\n");
		rc = MB_SyncStart(b_capital_good_delivery);
		if(FLAME_TEST_PRINT_START_AND_END_OF_LIBMBOARD_CALLS) printf("finish MB_SyncStart(b_capital_good_delivery)\n");
		#ifdef ERRCHECK
		if (rc != MB_SUCCESS)
		{
		   fprintf(stderr, "ERROR: Could not start sync of 'capital_good_delivery' board\n");
		   switch(rc) {
			   case MB_ERR_INVALID:
				   fprintf(stderr, "\t reason: 'capital_good_delivery' board is invalid\n");
				   break;
			   case MB_ERR_LOCKED:
				   fprintf(stderr, "\t reason: 'capital_good_delivery' board is locked\n");
				   break;
			   case MB_ERR_MEMALLOC:
				   fprintf(stderr, "\t reason: out of memory\n");
				   break;
			   case MB_ERR_INTERNAL:
				   fprintf(stderr, "\t reason: internal error. Recompile libmoard in debug mode for more info \n");
				   break;
			   default:
				   fprintf(stderr, "\t MB_SyncStart returned error code: %d (see libmboard docs for details)\n", rc);
				   break;
		   }

			
			exit(rc);
		}
		#endif
    }
    


	if(FLAME_TEST_PRINT_START_AND_END_OF_MODEL_FUNCTIONS) printf("start Household_send_unemployment_benefit_notification\n");
	current_xmachine_Household_holder = Household_06e_state->agents;
	while(current_xmachine_Household_holder)
	{
		temp_xmachine_Household_holder = current_xmachine_Household_holder->next;
		current_xmachine_Household = current_xmachine_Household_holder->agent;
		current_xmachine_Household_next_state = Household_08_state;
		/* For backwards compatibility set current_xmachine */
		current_xmachine->xmachine_Firm = NULL;
		current_xmachine->xmachine_Household = NULL;
		current_xmachine->xmachine_Mall = NULL;
		current_xmachine->xmachine_IGFirm = NULL;
		current_xmachine->xmachine_Eurostat = NULL;
		current_xmachine->xmachine_Bank = NULL;
		current_xmachine->xmachine_Government = NULL;
		current_xmachine->xmachine_CentralBank = NULL;
		current_xmachine->xmachine_ClearingHouse = NULL;
		current_xmachine->xmachine_Household = current_xmachine_Household;

		if(FLAME_condition_Household_Household_send_unemployment_benefit_notification_06e_08(current_xmachine_Household)==1)
		{

		

			i = Household_send_unemployment_benefit_notification();

		

			if(i == 1)
			{
				free_Household_agent(current_xmachine_Household_holder, Household_06e_state);
			}
			else
			{
				transition_Household_agent(current_xmachine_Household_holder, Household_06e_state, Household_08_state);
			}
		}

		current_xmachine_Household = NULL;

		current_xmachine_Household_holder = temp_xmachine_Household_holder;
	}
	if(FLAME_TEST_PRINT_START_AND_END_OF_MODEL_FUNCTIONS) printf("finish Household_send_unemployment_benefit_notification\n");

	if(FLAME_unemployment_notification_message_board_write == 1)
	{

		if(FLAME_TEST_PRINT_START_AND_END_OF_LIBMBOARD_CALLS) printf("start MB_SyncStart(b_unemployment_notification)\n");
		rc = MB_SyncStart(b_unemployment_notification);
		if(FLAME_TEST_PRINT_START_AND_END_OF_LIBMBOARD_CALLS) printf("finish MB_SyncStart(b_unemployment_notification)\n");
		#ifdef ERRCHECK
		if (rc != MB_SUCCESS)
		{
		   fprintf(stderr, "ERROR: Could not start sync of 'unemployment_notification' board\n");
		   switch(rc) {
			   case MB_ERR_INVALID:
				   fprintf(stderr, "\t reason: 'unemployment_notification' board is invalid\n");
				   break;
			   case MB_ERR_LOCKED:
				   fprintf(stderr, "\t reason: 'unemployment_notification' board is locked\n");
				   break;
			   case MB_ERR_MEMALLOC:
				   fprintf(stderr, "\t reason: out of memory\n");
				   break;
			   case MB_ERR_INTERNAL:
				   fprintf(stderr, "\t reason: internal error. Recompile libmoard in debug mode for more info \n");
				   break;
			   default:
				   fprintf(stderr, "\t MB_SyncStart returned error code: %d (see libmboard docs for details)\n", rc);
				   break;
		   }

			
			exit(rc);
		}
		#endif
    }
    


/* End of layer number 63 */

/* Clear message boards that have finished being used
 * and sync complete if doing late sync complete */

if(FLAME_capital_good_request_message_board_read == 0)
{
	/*printf("%d> capital_good_request message board sync complete late as no agents reading any messages of this type\n", node_number);*/
	
	if(FLAME_TEST_PRINT_START_AND_END_OF_LIBMBOARD_CALLS) printf("start MB_SyncComplete(b_capital_good_request)\n");
	rc = MB_SyncComplete(b_capital_good_request);
	if(FLAME_TEST_PRINT_START_AND_END_OF_LIBMBOARD_CALLS) printf("finsh MB_SyncComplete(b_capital_good_request)\n");
	#ifdef ERRCHECK
	if (rc != MB_SUCCESS)
	{
	   fprintf(stderr, "ERROR: Could not complete sync of 'capital_good_request' board\n");
	   switch(rc) {
			case MB_ERR_INVALID:
			   fprintf(stderr, "\t reason: 'capital_good_request' board is invalid\n");
			   break;
		   case MB_ERR_MEMALLOC:
			   fprintf(stderr, "\t reason: out of memory\n");
			   break;
		   case MB_ERR_INTERNAL:
			   fprintf(stderr, "\t reason: internal error. Recompile libmoard in debug mode for more info \n");
			   break;
		   default:
			   fprintf(stderr, "\t MB_SyncComplete returned error code: %d (see libmboard docs for details)\n", rc);
			   break;
	   }

	   
	   exit(rc);
	}
	#endif
}

    rc = MB_Clear(b_capital_good_request);
    #ifdef ERRCHECK
    if (rc != MB_SUCCESS)
    {
       fprintf(stderr, "ERROR: Could not clear 'capital_good_request' board\n");
       switch(rc) {
           case MB_ERR_INVALID:
               fprintf(stderr, "\t reason: 'capital_good_request' board is invalid\n");
               break;
           case MB_ERR_LOCKED:
               fprintf(stderr, "\t reason: 'capital_good_request' board is locked\n");
               break;
           case MB_ERR_INTERNAL:
               fprintf(stderr, "\t reason: internal error. Recompile libmoard in debug mode for more info \n");
               break;
           default:
               fprintf(stderr, "\t MB_Clear returned error code: %d (see libmboard docs for details)\n", rc);
               break;

       }

       
       exit(rc);
    }
    #endif


	/* If mb is not read then leave sync complete until last possible moment */
	if(FLAME_capital_good_delivery_message_board_read == 1)
	{
		if(FLAME_TEST_PRINT_START_AND_END_OF_LIBMBOARD_CALLS) printf("start MB_SyncComplete(b_capital_good_delivery)\n");
		rc = MB_SyncComplete(b_capital_good_delivery);
		if(FLAME_TEST_PRINT_START_AND_END_OF_LIBMBOARD_CALLS) printf("finsh MB_SyncComplete(b_capital_good_delivery)\n");
		#ifdef ERRCHECK
		if (rc != MB_SUCCESS)
		{
		   fprintf(stderr, "ERROR: Could not complete sync of 'capital_good_delivery' board\n");
		   switch(rc) {
				case MB_ERR_INVALID:
				   fprintf(stderr, "\t reason: 'capital_good_delivery' board is invalid\n");
				   break;
			   case MB_ERR_MEMALLOC:
				   fprintf(stderr, "\t reason: out of memory\n");
				   break;
			   case MB_ERR_INTERNAL:
				   fprintf(stderr, "\t reason: internal error. Recompile libmoard in debug mode for more info \n");
				   break;
			   default:
				   fprintf(stderr, "\t MB_SyncComplete returned error code: %d (see libmboard docs for details)\n", rc);
				   break;
		   }
	
		   
		   exit(rc);
		}
		#endif
    
	}
	
	if(FLAME_TEST_PRINT_START_AND_END_OF_MODEL_FUNCTIONS) printf("start Firm_receive_capital_goods\n");
	current_xmachine_Firm_holder = Firm_11a_state->agents;
	while(current_xmachine_Firm_holder)
	{
		temp_xmachine_Firm_holder = current_xmachine_Firm_holder->next;
		current_xmachine_Firm = current_xmachine_Firm_holder->agent;
		current_xmachine_Firm_next_state = Firm_11b_state;
		/* For backwards compatibility set current_xmachine */
		current_xmachine->xmachine_Firm = NULL;
		current_xmachine->xmachine_Household = NULL;
		current_xmachine->xmachine_Mall = NULL;
		current_xmachine->xmachine_IGFirm = NULL;
		current_xmachine->xmachine_Eurostat = NULL;
		current_xmachine->xmachine_Bank = NULL;
		current_xmachine->xmachine_Government = NULL;
		current_xmachine->xmachine_CentralBank = NULL;
		current_xmachine->xmachine_ClearingHouse = NULL;
		current_xmachine->xmachine_Firm = current_xmachine_Firm;

		

		
		rc = MB_Iterator_CreateFiltered(b_capital_good_delivery, &i_capital_good_delivery, &FLAME_filter_Firm_Firm_receive_capital_goods_11a_11b_capital_good_delivery, current_xmachine_Firm);
		
		#ifdef ERRCHECK
		if (rc != MB_SUCCESS)
		{
		   fprintf(stderr, "ERROR: Could not create Iterator for 'capital_good_delivery'\n");
		   switch(rc) {
		       case MB_ERR_INVALID:
		           fprintf(stderr, "\t reason: 'capital_good_delivery' board is invalid\n");
		           break;
		       case MB_ERR_LOCKED:
	               fprintf(stderr, "\t reason: 'capital_good_delivery' board is locked\n");
	               break;
	           case MB_ERR_MEMALLOC:
	               fprintf(stderr, "\t reason: out of memory\n");
	               break;
	           case MB_ERR_INTERNAL:
	               fprintf(stderr, "\t reason: internal error. Recompile libmoard in debug mode for more info \n");
	               break;
	           default:
	           
                   fprintf(stderr, "\t MB_Iterator_CreateFiltered returned error code: %d (see libmboard docs for details)\n", rc);
               
               
                   break;
		   }

		   
           exit(rc);
		}
		#endif
		
		

			i = Firm_receive_capital_goods();

		
		    rc = MB_Iterator_Delete(&i_capital_good_delivery);
		    #ifdef ERRCHECK
		    if (rc != MB_SUCCESS)
		    {
		       fprintf(stderr, "ERROR: Could not delete 'capital_good_delivery' iterator\n");
		       switch(rc) {
		           case MB_ERR_INVALID:
		               fprintf(stderr, "\t reason: 'capital_good_delivery' iterator is invalid\n");
		               break;
		           case MB_ERR_INTERNAL:
		               fprintf(stderr, "\t reason: internal error. Recompile libmoard in debug mode for more info \n");
		               break;
		           default:
                       fprintf(stderr, "\t MB_Iterator_Delete returned error code: %d (see libmboard docs for details)\n", rc);
                       break;
		       }

		       
               exit(rc);
		    }
		    #endif
		

			if(i == 1)
			{
				free_Firm_agent(current_xmachine_Firm_holder, Firm_11a_state);
			}
			else
			{
				transition_Firm_agent(current_xmachine_Firm_holder, Firm_11a_state, Firm_11b_state);
			}
		

		current_xmachine_Firm = NULL;

		current_xmachine_Firm_holder = temp_xmachine_Firm_holder;
	}
	if(FLAME_TEST_PRINT_START_AND_END_OF_MODEL_FUNCTIONS) printf("finish Firm_receive_capital_goods\n");


/* End of layer number 64 */

/* Clear message boards that have finished being used
 * and sync complete if doing late sync complete */

if(FLAME_capital_good_delivery_message_board_read == 0)
{
	/*printf("%d> capital_good_delivery message board sync complete late as no agents reading any messages of this type\n", node_number);*/
	
	if(FLAME_TEST_PRINT_START_AND_END_OF_LIBMBOARD_CALLS) printf("start MB_SyncComplete(b_capital_good_delivery)\n");
	rc = MB_SyncComplete(b_capital_good_delivery);
	if(FLAME_TEST_PRINT_START_AND_END_OF_LIBMBOARD_CALLS) printf("finsh MB_SyncComplete(b_capital_good_delivery)\n");
	#ifdef ERRCHECK
	if (rc != MB_SUCCESS)
	{
	   fprintf(stderr, "ERROR: Could not complete sync of 'capital_good_delivery' board\n");
	   switch(rc) {
			case MB_ERR_INVALID:
			   fprintf(stderr, "\t reason: 'capital_good_delivery' board is invalid\n");
			   break;
		   case MB_ERR_MEMALLOC:
			   fprintf(stderr, "\t reason: out of memory\n");
			   break;
		   case MB_ERR_INTERNAL:
			   fprintf(stderr, "\t reason: internal error. Recompile libmoard in debug mode for more info \n");
			   break;
		   default:
			   fprintf(stderr, "\t MB_SyncComplete returned error code: %d (see libmboard docs for details)\n", rc);
			   break;
	   }

	   
	   exit(rc);
	}
	#endif
}

    rc = MB_Clear(b_capital_good_delivery);
    #ifdef ERRCHECK
    if (rc != MB_SUCCESS)
    {
       fprintf(stderr, "ERROR: Could not clear 'capital_good_delivery' board\n");
       switch(rc) {
           case MB_ERR_INVALID:
               fprintf(stderr, "\t reason: 'capital_good_delivery' board is invalid\n");
               break;
           case MB_ERR_LOCKED:
               fprintf(stderr, "\t reason: 'capital_good_delivery' board is locked\n");
               break;
           case MB_ERR_INTERNAL:
               fprintf(stderr, "\t reason: internal error. Recompile libmoard in debug mode for more info \n");
               break;
           default:
               fprintf(stderr, "\t MB_Clear returned error code: %d (see libmboard docs for details)\n", rc);
               break;

       }

       
       exit(rc);
    }
    #endif


	if(FLAME_TEST_PRINT_START_AND_END_OF_MODEL_FUNCTIONS) printf("start Firm_execute_production\n");
	current_xmachine_Firm_holder = Firm_11b_state->agents;
	while(current_xmachine_Firm_holder)
	{
		temp_xmachine_Firm_holder = current_xmachine_Firm_holder->next;
		current_xmachine_Firm = current_xmachine_Firm_holder->agent;
		current_xmachine_Firm_next_state = Firm_11_state;
		/* For backwards compatibility set current_xmachine */
		current_xmachine->xmachine_Firm = NULL;
		current_xmachine->xmachine_Household = NULL;
		current_xmachine->xmachine_Mall = NULL;
		current_xmachine->xmachine_IGFirm = NULL;
		current_xmachine->xmachine_Eurostat = NULL;
		current_xmachine->xmachine_Bank = NULL;
		current_xmachine->xmachine_Government = NULL;
		current_xmachine->xmachine_CentralBank = NULL;
		current_xmachine->xmachine_ClearingHouse = NULL;
		current_xmachine->xmachine_Firm = current_xmachine_Firm;

		

		

			i = Firm_execute_production();

		

			if(i == 1)
			{
				free_Firm_agent(current_xmachine_Firm_holder, Firm_11b_state);
			}
			else
			{
				transition_Firm_agent(current_xmachine_Firm_holder, Firm_11b_state, Firm_11_state);
			}
		

		current_xmachine_Firm = NULL;

		current_xmachine_Firm_holder = temp_xmachine_Firm_holder;
	}
	if(FLAME_TEST_PRINT_START_AND_END_OF_MODEL_FUNCTIONS) printf("finish Firm_execute_production\n");


/* End of layer number 65 */

/* Clear message boards that have finished being used
 * and sync complete if doing late sync complete */


	if(FLAME_TEST_PRINT_START_AND_END_OF_MODEL_FUNCTIONS) printf("start Firm_calc_pay_costs\n");
	current_xmachine_Firm_holder = Firm_11_state->agents;
	while(current_xmachine_Firm_holder)
	{
		temp_xmachine_Firm_holder = current_xmachine_Firm_holder->next;
		current_xmachine_Firm = current_xmachine_Firm_holder->agent;
		current_xmachine_Firm_next_state = Firm_12_state;
		/* For backwards compatibility set current_xmachine */
		current_xmachine->xmachine_Firm = NULL;
		current_xmachine->xmachine_Household = NULL;
		current_xmachine->xmachine_Mall = NULL;
		current_xmachine->xmachine_IGFirm = NULL;
		current_xmachine->xmachine_Eurostat = NULL;
		current_xmachine->xmachine_Bank = NULL;
		current_xmachine->xmachine_Government = NULL;
		current_xmachine->xmachine_CentralBank = NULL;
		current_xmachine->xmachine_ClearingHouse = NULL;
		current_xmachine->xmachine_Firm = current_xmachine_Firm;

		

		

			i = Firm_calc_pay_costs();

		

			if(i == 1)
			{
				free_Firm_agent(current_xmachine_Firm_holder, Firm_11_state);
			}
			else
			{
				transition_Firm_agent(current_xmachine_Firm_holder, Firm_11_state, Firm_12_state);
			}
		

		current_xmachine_Firm = NULL;

		current_xmachine_Firm_holder = temp_xmachine_Firm_holder;
	}
	if(FLAME_TEST_PRINT_START_AND_END_OF_MODEL_FUNCTIONS) printf("finish Firm_calc_pay_costs\n");

	if(FLAME_pay_capital_goods_message_board_write == 1)
	{

		if(FLAME_TEST_PRINT_START_AND_END_OF_LIBMBOARD_CALLS) printf("start MB_SyncStart(b_pay_capital_goods)\n");
		rc = MB_SyncStart(b_pay_capital_goods);
		if(FLAME_TEST_PRINT_START_AND_END_OF_LIBMBOARD_CALLS) printf("finish MB_SyncStart(b_pay_capital_goods)\n");
		#ifdef ERRCHECK
		if (rc != MB_SUCCESS)
		{
		   fprintf(stderr, "ERROR: Could not start sync of 'pay_capital_goods' board\n");
		   switch(rc) {
			   case MB_ERR_INVALID:
				   fprintf(stderr, "\t reason: 'pay_capital_goods' board is invalid\n");
				   break;
			   case MB_ERR_LOCKED:
				   fprintf(stderr, "\t reason: 'pay_capital_goods' board is locked\n");
				   break;
			   case MB_ERR_MEMALLOC:
				   fprintf(stderr, "\t reason: out of memory\n");
				   break;
			   case MB_ERR_INTERNAL:
				   fprintf(stderr, "\t reason: internal error. Recompile libmoard in debug mode for more info \n");
				   break;
			   default:
				   fprintf(stderr, "\t MB_SyncStart returned error code: %d (see libmboard docs for details)\n", rc);
				   break;
		   }

			
			exit(rc);
		}
		#endif
    }
    

	if(FLAME_wage_payment_message_board_write == 1)
	{

		if(FLAME_TEST_PRINT_START_AND_END_OF_LIBMBOARD_CALLS) printf("start MB_SyncStart(b_wage_payment)\n");
		rc = MB_SyncStart(b_wage_payment);
		if(FLAME_TEST_PRINT_START_AND_END_OF_LIBMBOARD_CALLS) printf("finish MB_SyncStart(b_wage_payment)\n");
		#ifdef ERRCHECK
		if (rc != MB_SUCCESS)
		{
		   fprintf(stderr, "ERROR: Could not start sync of 'wage_payment' board\n");
		   switch(rc) {
			   case MB_ERR_INVALID:
				   fprintf(stderr, "\t reason: 'wage_payment' board is invalid\n");
				   break;
			   case MB_ERR_LOCKED:
				   fprintf(stderr, "\t reason: 'wage_payment' board is locked\n");
				   break;
			   case MB_ERR_MEMALLOC:
				   fprintf(stderr, "\t reason: out of memory\n");
				   break;
			   case MB_ERR_INTERNAL:
				   fprintf(stderr, "\t reason: internal error. Recompile libmoard in debug mode for more info \n");
				   break;
			   default:
				   fprintf(stderr, "\t MB_SyncStart returned error code: %d (see libmboard docs for details)\n", rc);
				   break;
		   }

			
			exit(rc);
		}
		#endif
    }
    


/* End of layer number 66 */

/* Clear message boards that have finished being used
 * and sync complete if doing late sync complete */


	if(FLAME_TEST_PRINT_START_AND_END_OF_MODEL_FUNCTIONS) printf("start Firm_send_goods_to_mall\n");
	current_xmachine_Firm_holder = Firm_12_state->agents;
	while(current_xmachine_Firm_holder)
	{
		temp_xmachine_Firm_holder = current_xmachine_Firm_holder->next;
		current_xmachine_Firm = current_xmachine_Firm_holder->agent;
		current_xmachine_Firm_next_state = Firm_Firm_Start_Seller_Role_state;
		/* For backwards compatibility set current_xmachine */
		current_xmachine->xmachine_Firm = NULL;
		current_xmachine->xmachine_Household = NULL;
		current_xmachine->xmachine_Mall = NULL;
		current_xmachine->xmachine_IGFirm = NULL;
		current_xmachine->xmachine_Eurostat = NULL;
		current_xmachine->xmachine_Bank = NULL;
		current_xmachine->xmachine_Government = NULL;
		current_xmachine->xmachine_CentralBank = NULL;
		current_xmachine->xmachine_ClearingHouse = NULL;
		current_xmachine->xmachine_Firm = current_xmachine_Firm;

		

		

			i = Firm_send_goods_to_mall();

		

			if(i == 1)
			{
				free_Firm_agent(current_xmachine_Firm_holder, Firm_12_state);
			}
			else
			{
				transition_Firm_agent(current_xmachine_Firm_holder, Firm_12_state, Firm_Firm_Start_Seller_Role_state);
			}
		

		current_xmachine_Firm = NULL;

		current_xmachine_Firm_holder = temp_xmachine_Firm_holder;
	}
	if(FLAME_TEST_PRINT_START_AND_END_OF_MODEL_FUNCTIONS) printf("finish Firm_send_goods_to_mall\n");

	if(FLAME_update_mall_stock_message_board_write == 1)
	{

		if(FLAME_TEST_PRINT_START_AND_END_OF_LIBMBOARD_CALLS) printf("start MB_SyncStart(b_update_mall_stock)\n");
		rc = MB_SyncStart(b_update_mall_stock);
		if(FLAME_TEST_PRINT_START_AND_END_OF_LIBMBOARD_CALLS) printf("finish MB_SyncStart(b_update_mall_stock)\n");
		#ifdef ERRCHECK
		if (rc != MB_SUCCESS)
		{
		   fprintf(stderr, "ERROR: Could not start sync of 'update_mall_stock' board\n");
		   switch(rc) {
			   case MB_ERR_INVALID:
				   fprintf(stderr, "\t reason: 'update_mall_stock' board is invalid\n");
				   break;
			   case MB_ERR_LOCKED:
				   fprintf(stderr, "\t reason: 'update_mall_stock' board is locked\n");
				   break;
			   case MB_ERR_MEMALLOC:
				   fprintf(stderr, "\t reason: out of memory\n");
				   break;
			   case MB_ERR_INTERNAL:
				   fprintf(stderr, "\t reason: internal error. Recompile libmoard in debug mode for more info \n");
				   break;
			   default:
				   fprintf(stderr, "\t MB_SyncStart returned error code: %d (see libmboard docs for details)\n", rc);
				   break;
		   }

			
			exit(rc);
		}
		#endif
    }
    


	/* If mb is not read then leave sync complete until last possible moment */
	if(FLAME_wage_payment_message_board_read == 1)
	{
		if(FLAME_TEST_PRINT_START_AND_END_OF_LIBMBOARD_CALLS) printf("start MB_SyncComplete(b_wage_payment)\n");
		rc = MB_SyncComplete(b_wage_payment);
		if(FLAME_TEST_PRINT_START_AND_END_OF_LIBMBOARD_CALLS) printf("finsh MB_SyncComplete(b_wage_payment)\n");
		#ifdef ERRCHECK
		if (rc != MB_SUCCESS)
		{
		   fprintf(stderr, "ERROR: Could not complete sync of 'wage_payment' board\n");
		   switch(rc) {
				case MB_ERR_INVALID:
				   fprintf(stderr, "\t reason: 'wage_payment' board is invalid\n");
				   break;
			   case MB_ERR_MEMALLOC:
				   fprintf(stderr, "\t reason: out of memory\n");
				   break;
			   case MB_ERR_INTERNAL:
				   fprintf(stderr, "\t reason: internal error. Recompile libmoard in debug mode for more info \n");
				   break;
			   default:
				   fprintf(stderr, "\t MB_SyncComplete returned error code: %d (see libmboard docs for details)\n", rc);
				   break;
		   }
	
		   
		   exit(rc);
		}
		#endif
    
	}
	
	if(FLAME_TEST_PRINT_START_AND_END_OF_MODEL_FUNCTIONS) printf("start Household_receive_wage\n");
	current_xmachine_Household_holder = Household_06e_state->agents;
	while(current_xmachine_Household_holder)
	{
		temp_xmachine_Household_holder = current_xmachine_Household_holder->next;
		current_xmachine_Household = current_xmachine_Household_holder->agent;
		current_xmachine_Household_next_state = Household_07_state;
		/* For backwards compatibility set current_xmachine */
		current_xmachine->xmachine_Firm = NULL;
		current_xmachine->xmachine_Household = NULL;
		current_xmachine->xmachine_Mall = NULL;
		current_xmachine->xmachine_IGFirm = NULL;
		current_xmachine->xmachine_Eurostat = NULL;
		current_xmachine->xmachine_Bank = NULL;
		current_xmachine->xmachine_Government = NULL;
		current_xmachine->xmachine_CentralBank = NULL;
		current_xmachine->xmachine_ClearingHouse = NULL;
		current_xmachine->xmachine_Household = current_xmachine_Household;

		if(FLAME_condition_Household_Household_receive_wage_06e_07(current_xmachine_Household)==1)
		{

		
		rc = MB_Iterator_CreateFiltered(b_wage_payment, &i_wage_payment, &FLAME_filter_Household_Household_receive_wage_06e_07_wage_payment, current_xmachine_Household);
		
		#ifdef ERRCHECK
		if (rc != MB_SUCCESS)
		{
		   fprintf(stderr, "ERROR: Could not create Iterator for 'wage_payment'\n");
		   switch(rc) {
		       case MB_ERR_INVALID:
		           fprintf(stderr, "\t reason: 'wage_payment' board is invalid\n");
		           break;
		       case MB_ERR_LOCKED:
	               fprintf(stderr, "\t reason: 'wage_payment' board is locked\n");
	               break;
	           case MB_ERR_MEMALLOC:
	               fprintf(stderr, "\t reason: out of memory\n");
	               break;
	           case MB_ERR_INTERNAL:
	               fprintf(stderr, "\t reason: internal error. Recompile libmoard in debug mode for more info \n");
	               break;
	           default:
	           
                   fprintf(stderr, "\t MB_Iterator_CreateFiltered returned error code: %d (see libmboard docs for details)\n", rc);
               
               
                   break;
		   }

		   
           exit(rc);
		}
		#endif
		
		

			i = Household_receive_wage();

		
		    rc = MB_Iterator_Delete(&i_wage_payment);
		    #ifdef ERRCHECK
		    if (rc != MB_SUCCESS)
		    {
		       fprintf(stderr, "ERROR: Could not delete 'wage_payment' iterator\n");
		       switch(rc) {
		           case MB_ERR_INVALID:
		               fprintf(stderr, "\t reason: 'wage_payment' iterator is invalid\n");
		               break;
		           case MB_ERR_INTERNAL:
		               fprintf(stderr, "\t reason: internal error. Recompile libmoard in debug mode for more info \n");
		               break;
		           default:
                       fprintf(stderr, "\t MB_Iterator_Delete returned error code: %d (see libmboard docs for details)\n", rc);
                       break;
		       }

		       
               exit(rc);
		    }
		    #endif
		

			if(i == 1)
			{
				free_Household_agent(current_xmachine_Household_holder, Household_06e_state);
			}
			else
			{
				transition_Household_agent(current_xmachine_Household_holder, Household_06e_state, Household_07_state);
			}
		}

		current_xmachine_Household = NULL;

		current_xmachine_Household_holder = temp_xmachine_Household_holder;
	}
	if(FLAME_TEST_PRINT_START_AND_END_OF_MODEL_FUNCTIONS) printf("finish Household_receive_wage\n");


	/* If mb is not read then leave sync complete until last possible moment */
	if(FLAME_pay_capital_goods_message_board_read == 1)
	{
		if(FLAME_TEST_PRINT_START_AND_END_OF_LIBMBOARD_CALLS) printf("start MB_SyncComplete(b_pay_capital_goods)\n");
		rc = MB_SyncComplete(b_pay_capital_goods);
		if(FLAME_TEST_PRINT_START_AND_END_OF_LIBMBOARD_CALLS) printf("finsh MB_SyncComplete(b_pay_capital_goods)\n");
		#ifdef ERRCHECK
		if (rc != MB_SUCCESS)
		{
		   fprintf(stderr, "ERROR: Could not complete sync of 'pay_capital_goods' board\n");
		   switch(rc) {
				case MB_ERR_INVALID:
				   fprintf(stderr, "\t reason: 'pay_capital_goods' board is invalid\n");
				   break;
			   case MB_ERR_MEMALLOC:
				   fprintf(stderr, "\t reason: out of memory\n");
				   break;
			   case MB_ERR_INTERNAL:
				   fprintf(stderr, "\t reason: internal error. Recompile libmoard in debug mode for more info \n");
				   break;
			   default:
				   fprintf(stderr, "\t MB_SyncComplete returned error code: %d (see libmboard docs for details)\n", rc);
				   break;
		   }
	
		   
		   exit(rc);
		}
		#endif
    
	}
	
	if(FLAME_TEST_PRINT_START_AND_END_OF_MODEL_FUNCTIONS) printf("start IGFirm_calc_revenue\n");
	current_xmachine_IGFirm_holder = IGFirm_03_state->agents;
	while(current_xmachine_IGFirm_holder)
	{
		temp_xmachine_IGFirm_holder = current_xmachine_IGFirm_holder->next;
		current_xmachine_IGFirm = current_xmachine_IGFirm_holder->agent;
		current_xmachine_IGFirm_next_state = IGFirm_IGFirm_Start_Financial_Management_Role_state;
		/* For backwards compatibility set current_xmachine */
		current_xmachine->xmachine_Firm = NULL;
		current_xmachine->xmachine_Household = NULL;
		current_xmachine->xmachine_Mall = NULL;
		current_xmachine->xmachine_IGFirm = NULL;
		current_xmachine->xmachine_Eurostat = NULL;
		current_xmachine->xmachine_Bank = NULL;
		current_xmachine->xmachine_Government = NULL;
		current_xmachine->xmachine_CentralBank = NULL;
		current_xmachine->xmachine_ClearingHouse = NULL;
		current_xmachine->xmachine_IGFirm = current_xmachine_IGFirm;

		

		
		
		rc = MB_Iterator_Create(b_pay_capital_goods, &i_pay_capital_goods);
		#ifdef ERRCHECK
		if (rc != MB_SUCCESS)
		{
		   fprintf(stderr, "ERROR: Could not create Iterator for 'pay_capital_goods'\n");
		   switch(rc) {
		       case MB_ERR_INVALID:
		           fprintf(stderr, "\t reason: 'pay_capital_goods' board is invalid\n");
		           break;
		       case MB_ERR_LOCKED:
	               fprintf(stderr, "\t reason: 'pay_capital_goods' board is locked\n");
	               break;
	           case MB_ERR_MEMALLOC:
	               fprintf(stderr, "\t reason: out of memory\n");
	               break;
	           case MB_ERR_INTERNAL:
	               fprintf(stderr, "\t reason: internal error. Recompile libmoard in debug mode for more info \n");
	               break;
	           default:
	           
               
                   fprintf(stderr, "\t MB_Iterator_Create returned error code: %d (see libmboard docs for details)\n", rc);
               
                   break;
		   }

		   
           exit(rc);
		}
		#endif
		
		

			i = IGFirm_calc_revenue();

		
		    rc = MB_Iterator_Delete(&i_pay_capital_goods);
		    #ifdef ERRCHECK
		    if (rc != MB_SUCCESS)
		    {
		       fprintf(stderr, "ERROR: Could not delete 'pay_capital_goods' iterator\n");
		       switch(rc) {
		           case MB_ERR_INVALID:
		               fprintf(stderr, "\t reason: 'pay_capital_goods' iterator is invalid\n");
		               break;
		           case MB_ERR_INTERNAL:
		               fprintf(stderr, "\t reason: internal error. Recompile libmoard in debug mode for more info \n");
		               break;
		           default:
                       fprintf(stderr, "\t MB_Iterator_Delete returned error code: %d (see libmboard docs for details)\n", rc);
                       break;
		       }

		       
               exit(rc);
		    }
		    #endif
		

			if(i == 1)
			{
				free_IGFirm_agent(current_xmachine_IGFirm_holder, IGFirm_03_state);
			}
			else
			{
				transition_IGFirm_agent(current_xmachine_IGFirm_holder, IGFirm_03_state, IGFirm_IGFirm_Start_Financial_Management_Role_state);
			}
		

		current_xmachine_IGFirm = NULL;

		current_xmachine_IGFirm_holder = temp_xmachine_IGFirm_holder;
	}
	if(FLAME_TEST_PRINT_START_AND_END_OF_MODEL_FUNCTIONS) printf("finish IGFirm_calc_revenue\n");


/* End of layer number 67 */

/* Clear message boards that have finished being used
 * and sync complete if doing late sync complete */

if(FLAME_wage_payment_message_board_read == 0)
{
	/*printf("%d> wage_payment message board sync complete late as no agents reading any messages of this type\n", node_number);*/
	
	if(FLAME_TEST_PRINT_START_AND_END_OF_LIBMBOARD_CALLS) printf("start MB_SyncComplete(b_wage_payment)\n");
	rc = MB_SyncComplete(b_wage_payment);
	if(FLAME_TEST_PRINT_START_AND_END_OF_LIBMBOARD_CALLS) printf("finsh MB_SyncComplete(b_wage_payment)\n");
	#ifdef ERRCHECK
	if (rc != MB_SUCCESS)
	{
	   fprintf(stderr, "ERROR: Could not complete sync of 'wage_payment' board\n");
	   switch(rc) {
			case MB_ERR_INVALID:
			   fprintf(stderr, "\t reason: 'wage_payment' board is invalid\n");
			   break;
		   case MB_ERR_MEMALLOC:
			   fprintf(stderr, "\t reason: out of memory\n");
			   break;
		   case MB_ERR_INTERNAL:
			   fprintf(stderr, "\t reason: internal error. Recompile libmoard in debug mode for more info \n");
			   break;
		   default:
			   fprintf(stderr, "\t MB_SyncComplete returned error code: %d (see libmboard docs for details)\n", rc);
			   break;
	   }

	   
	   exit(rc);
	}
	#endif
}

    rc = MB_Clear(b_wage_payment);
    #ifdef ERRCHECK
    if (rc != MB_SUCCESS)
    {
       fprintf(stderr, "ERROR: Could not clear 'wage_payment' board\n");
       switch(rc) {
           case MB_ERR_INVALID:
               fprintf(stderr, "\t reason: 'wage_payment' board is invalid\n");
               break;
           case MB_ERR_LOCKED:
               fprintf(stderr, "\t reason: 'wage_payment' board is locked\n");
               break;
           case MB_ERR_INTERNAL:
               fprintf(stderr, "\t reason: internal error. Recompile libmoard in debug mode for more info \n");
               break;
           default:
               fprintf(stderr, "\t MB_Clear returned error code: %d (see libmboard docs for details)\n", rc);
               break;

       }

       
       exit(rc);
    }
    #endif

if(FLAME_pay_capital_goods_message_board_read == 0)
{
	/*printf("%d> pay_capital_goods message board sync complete late as no agents reading any messages of this type\n", node_number);*/
	
	if(FLAME_TEST_PRINT_START_AND_END_OF_LIBMBOARD_CALLS) printf("start MB_SyncComplete(b_pay_capital_goods)\n");
	rc = MB_SyncComplete(b_pay_capital_goods);
	if(FLAME_TEST_PRINT_START_AND_END_OF_LIBMBOARD_CALLS) printf("finsh MB_SyncComplete(b_pay_capital_goods)\n");
	#ifdef ERRCHECK
	if (rc != MB_SUCCESS)
	{
	   fprintf(stderr, "ERROR: Could not complete sync of 'pay_capital_goods' board\n");
	   switch(rc) {
			case MB_ERR_INVALID:
			   fprintf(stderr, "\t reason: 'pay_capital_goods' board is invalid\n");
			   break;
		   case MB_ERR_MEMALLOC:
			   fprintf(stderr, "\t reason: out of memory\n");
			   break;
		   case MB_ERR_INTERNAL:
			   fprintf(stderr, "\t reason: internal error. Recompile libmoard in debug mode for more info \n");
			   break;
		   default:
			   fprintf(stderr, "\t MB_SyncComplete returned error code: %d (see libmboard docs for details)\n", rc);
			   break;
	   }

	   
	   exit(rc);
	}
	#endif
}

    rc = MB_Clear(b_pay_capital_goods);
    #ifdef ERRCHECK
    if (rc != MB_SUCCESS)
    {
       fprintf(stderr, "ERROR: Could not clear 'pay_capital_goods' board\n");
       switch(rc) {
           case MB_ERR_INVALID:
               fprintf(stderr, "\t reason: 'pay_capital_goods' board is invalid\n");
               break;
           case MB_ERR_LOCKED:
               fprintf(stderr, "\t reason: 'pay_capital_goods' board is locked\n");
               break;
           case MB_ERR_INTERNAL:
               fprintf(stderr, "\t reason: internal error. Recompile libmoard in debug mode for more info \n");
               break;
           default:
               fprintf(stderr, "\t MB_Clear returned error code: %d (see libmboard docs for details)\n", rc);
               break;

       }

       
       exit(rc);
    }
    #endif


	if(FLAME_TEST_PRINT_START_AND_END_OF_MODEL_FUNCTIONS) printf("start Household_update_specific_skills\n");
	current_xmachine_Household_holder = Household_07_state->agents;
	while(current_xmachine_Household_holder)
	{
		temp_xmachine_Household_holder = current_xmachine_Household_holder->next;
		current_xmachine_Household = current_xmachine_Household_holder->agent;
		current_xmachine_Household_next_state = Household_08_state;
		/* For backwards compatibility set current_xmachine */
		current_xmachine->xmachine_Firm = NULL;
		current_xmachine->xmachine_Household = NULL;
		current_xmachine->xmachine_Mall = NULL;
		current_xmachine->xmachine_IGFirm = NULL;
		current_xmachine->xmachine_Eurostat = NULL;
		current_xmachine->xmachine_Bank = NULL;
		current_xmachine->xmachine_Government = NULL;
		current_xmachine->xmachine_CentralBank = NULL;
		current_xmachine->xmachine_ClearingHouse = NULL;
		current_xmachine->xmachine_Household = current_xmachine_Household;

		

		

			i = Household_update_specific_skills();

		

			if(i == 1)
			{
				free_Household_agent(current_xmachine_Household_holder, Household_07_state);
			}
			else
			{
				transition_Household_agent(current_xmachine_Household_holder, Household_07_state, Household_08_state);
			}
		

		current_xmachine_Household = NULL;

		current_xmachine_Household_holder = temp_xmachine_Household_holder;
	}
	if(FLAME_TEST_PRINT_START_AND_END_OF_MODEL_FUNCTIONS) printf("finish Household_update_specific_skills\n");

	if(FLAME_specific_skill_update_message_board_write == 1)
	{

		if(FLAME_TEST_PRINT_START_AND_END_OF_LIBMBOARD_CALLS) printf("start MB_SyncStart(b_specific_skill_update)\n");
		rc = MB_SyncStart(b_specific_skill_update);
		if(FLAME_TEST_PRINT_START_AND_END_OF_LIBMBOARD_CALLS) printf("finish MB_SyncStart(b_specific_skill_update)\n");
		#ifdef ERRCHECK
		if (rc != MB_SUCCESS)
		{
		   fprintf(stderr, "ERROR: Could not start sync of 'specific_skill_update' board\n");
		   switch(rc) {
			   case MB_ERR_INVALID:
				   fprintf(stderr, "\t reason: 'specific_skill_update' board is invalid\n");
				   break;
			   case MB_ERR_LOCKED:
				   fprintf(stderr, "\t reason: 'specific_skill_update' board is locked\n");
				   break;
			   case MB_ERR_MEMALLOC:
				   fprintf(stderr, "\t reason: out of memory\n");
				   break;
			   case MB_ERR_INTERNAL:
				   fprintf(stderr, "\t reason: internal error. Recompile libmoard in debug mode for more info \n");
				   break;
			   default:
				   fprintf(stderr, "\t MB_SyncStart returned error code: %d (see libmboard docs for details)\n", rc);
				   break;
		   }

			
			exit(rc);
		}
		#endif
    }
    


	if(FLAME_TEST_PRINT_START_AND_END_OF_MODEL_FUNCTIONS) printf("start IGFirm_send_subsidy_notification\n");
	current_xmachine_IGFirm_holder = IGFirm_IGFirm_Start_Financial_Management_Role_state->agents;
	while(current_xmachine_IGFirm_holder)
	{
		temp_xmachine_IGFirm_holder = current_xmachine_IGFirm_holder->next;
		current_xmachine_IGFirm = current_xmachine_IGFirm_holder->agent;
		current_xmachine_IGFirm_next_state = IGFirm_05_state;
		/* For backwards compatibility set current_xmachine */
		current_xmachine->xmachine_Firm = NULL;
		current_xmachine->xmachine_Household = NULL;
		current_xmachine->xmachine_Mall = NULL;
		current_xmachine->xmachine_IGFirm = NULL;
		current_xmachine->xmachine_Eurostat = NULL;
		current_xmachine->xmachine_Bank = NULL;
		current_xmachine->xmachine_Government = NULL;
		current_xmachine->xmachine_CentralBank = NULL;
		current_xmachine->xmachine_ClearingHouse = NULL;
		current_xmachine->xmachine_IGFirm = current_xmachine_IGFirm;

		if(FLAME_condition_IGFirm_IGFirm_send_subsidy_notification_IGFirm_Start_Financial_Management_Role_05(current_xmachine_IGFirm)==1)
		{

		

			i = IGFirm_send_subsidy_notification();

		

			if(i == 1)
			{
				free_IGFirm_agent(current_xmachine_IGFirm_holder, IGFirm_IGFirm_Start_Financial_Management_Role_state);
			}
			else
			{
				transition_IGFirm_agent(current_xmachine_IGFirm_holder, IGFirm_IGFirm_Start_Financial_Management_Role_state, IGFirm_05_state);
			}
		}

		current_xmachine_IGFirm = NULL;

		current_xmachine_IGFirm_holder = temp_xmachine_IGFirm_holder;
	}
	if(FLAME_TEST_PRINT_START_AND_END_OF_MODEL_FUNCTIONS) printf("finish IGFirm_send_subsidy_notification\n");


	if(FLAME_TEST_PRINT_START_AND_END_OF_MODEL_FUNCTIONS) printf("start IGFirm_idle\n");
	current_xmachine_IGFirm_holder = IGFirm_IGFirm_Start_Financial_Management_Role_state->agents;
	while(current_xmachine_IGFirm_holder)
	{
		temp_xmachine_IGFirm_holder = current_xmachine_IGFirm_holder->next;
		current_xmachine_IGFirm = current_xmachine_IGFirm_holder->agent;
		current_xmachine_IGFirm_next_state = IGFirm_IGFirm_End_Financial_Management_Role_state;
		/* For backwards compatibility set current_xmachine */
		current_xmachine->xmachine_Firm = NULL;
		current_xmachine->xmachine_Household = NULL;
		current_xmachine->xmachine_Mall = NULL;
		current_xmachine->xmachine_IGFirm = NULL;
		current_xmachine->xmachine_Eurostat = NULL;
		current_xmachine->xmachine_Bank = NULL;
		current_xmachine->xmachine_Government = NULL;
		current_xmachine->xmachine_CentralBank = NULL;
		current_xmachine->xmachine_ClearingHouse = NULL;
		current_xmachine->xmachine_IGFirm = current_xmachine_IGFirm;

		if(FLAME_condition_IGFirm_IGFirm_idle_IGFirm_Start_Financial_Management_Role_IGFirm_End_Financial_Management_Role(current_xmachine_IGFirm)==1)
		{

		

			i = IGFirm_idle();

		

			if(i == 1)
			{
				free_IGFirm_agent(current_xmachine_IGFirm_holder, IGFirm_IGFirm_Start_Financial_Management_Role_state);
			}
			else
			{
				transition_IGFirm_agent(current_xmachine_IGFirm_holder, IGFirm_IGFirm_Start_Financial_Management_Role_state, IGFirm_IGFirm_End_Financial_Management_Role_state);
			}
		}

		current_xmachine_IGFirm = NULL;

		current_xmachine_IGFirm_holder = temp_xmachine_IGFirm_holder;
	}
	if(FLAME_TEST_PRINT_START_AND_END_OF_MODEL_FUNCTIONS) printf("finish IGFirm_idle\n");


	/* If mb is not read then leave sync complete until last possible moment */
	if(FLAME_bankruptcy_illiquidity_message_board_read == 1)
	{
		if(FLAME_TEST_PRINT_START_AND_END_OF_LIBMBOARD_CALLS) printf("start MB_SyncComplete(b_bankruptcy_illiquidity)\n");
		rc = MB_SyncComplete(b_bankruptcy_illiquidity);
		if(FLAME_TEST_PRINT_START_AND_END_OF_LIBMBOARD_CALLS) printf("finsh MB_SyncComplete(b_bankruptcy_illiquidity)\n");
		#ifdef ERRCHECK
		if (rc != MB_SUCCESS)
		{
		   fprintf(stderr, "ERROR: Could not complete sync of 'bankruptcy_illiquidity' board\n");
		   switch(rc) {
				case MB_ERR_INVALID:
				   fprintf(stderr, "\t reason: 'bankruptcy_illiquidity' board is invalid\n");
				   break;
			   case MB_ERR_MEMALLOC:
				   fprintf(stderr, "\t reason: out of memory\n");
				   break;
			   case MB_ERR_INTERNAL:
				   fprintf(stderr, "\t reason: internal error. Recompile libmoard in debug mode for more info \n");
				   break;
			   default:
				   fprintf(stderr, "\t MB_SyncComplete returned error code: %d (see libmboard docs for details)\n", rc);
				   break;
		   }
	
		   
		   exit(rc);
		}
		#endif
    
	}
	
	/* If mb is not read then leave sync complete until last possible moment */
	if(FLAME_update_mall_stock_message_board_read == 1)
	{
		if(FLAME_TEST_PRINT_START_AND_END_OF_LIBMBOARD_CALLS) printf("start MB_SyncComplete(b_update_mall_stock)\n");
		rc = MB_SyncComplete(b_update_mall_stock);
		if(FLAME_TEST_PRINT_START_AND_END_OF_LIBMBOARD_CALLS) printf("finsh MB_SyncComplete(b_update_mall_stock)\n");
		#ifdef ERRCHECK
		if (rc != MB_SUCCESS)
		{
		   fprintf(stderr, "ERROR: Could not complete sync of 'update_mall_stock' board\n");
		   switch(rc) {
				case MB_ERR_INVALID:
				   fprintf(stderr, "\t reason: 'update_mall_stock' board is invalid\n");
				   break;
			   case MB_ERR_MEMALLOC:
				   fprintf(stderr, "\t reason: out of memory\n");
				   break;
			   case MB_ERR_INTERNAL:
				   fprintf(stderr, "\t reason: internal error. Recompile libmoard in debug mode for more info \n");
				   break;
			   default:
				   fprintf(stderr, "\t MB_SyncComplete returned error code: %d (see libmboard docs for details)\n", rc);
				   break;
		   }
	
		   
		   exit(rc);
		}
		#endif
    
	}
	
	if(FLAME_TEST_PRINT_START_AND_END_OF_MODEL_FUNCTIONS) printf("start Mall_update_mall_stock\n");
	current_xmachine_Mall_holder = Mall_01_state->agents;
	while(current_xmachine_Mall_holder)
	{
		temp_xmachine_Mall_holder = current_xmachine_Mall_holder->next;
		current_xmachine_Mall = current_xmachine_Mall_holder->agent;
		current_xmachine_Mall_next_state = Mall_02_state;
		/* For backwards compatibility set current_xmachine */
		current_xmachine->xmachine_Firm = NULL;
		current_xmachine->xmachine_Household = NULL;
		current_xmachine->xmachine_Mall = NULL;
		current_xmachine->xmachine_IGFirm = NULL;
		current_xmachine->xmachine_Eurostat = NULL;
		current_xmachine->xmachine_Bank = NULL;
		current_xmachine->xmachine_Government = NULL;
		current_xmachine->xmachine_CentralBank = NULL;
		current_xmachine->xmachine_ClearingHouse = NULL;
		current_xmachine->xmachine_Mall = current_xmachine_Mall;

		

		
		
		rc = MB_Iterator_Create(b_update_mall_stock, &i_update_mall_stock);
		#ifdef ERRCHECK
		if (rc != MB_SUCCESS)
		{
		   fprintf(stderr, "ERROR: Could not create Iterator for 'update_mall_stock'\n");
		   switch(rc) {
		       case MB_ERR_INVALID:
		           fprintf(stderr, "\t reason: 'update_mall_stock' board is invalid\n");
		           break;
		       case MB_ERR_LOCKED:
	               fprintf(stderr, "\t reason: 'update_mall_stock' board is locked\n");
	               break;
	           case MB_ERR_MEMALLOC:
	               fprintf(stderr, "\t reason: out of memory\n");
	               break;
	           case MB_ERR_INTERNAL:
	               fprintf(stderr, "\t reason: internal error. Recompile libmoard in debug mode for more info \n");
	               break;
	           default:
	           
               
                   fprintf(stderr, "\t MB_Iterator_Create returned error code: %d (see libmboard docs for details)\n", rc);
               
                   break;
		   }

		   
           exit(rc);
		}
		#endif
		
		
		
		rc = MB_Iterator_Create(b_bankruptcy_illiquidity, &i_bankruptcy_illiquidity);
		#ifdef ERRCHECK
		if (rc != MB_SUCCESS)
		{
		   fprintf(stderr, "ERROR: Could not create Iterator for 'bankruptcy_illiquidity'\n");
		   switch(rc) {
		       case MB_ERR_INVALID:
		           fprintf(stderr, "\t reason: 'bankruptcy_illiquidity' board is invalid\n");
		           break;
		       case MB_ERR_LOCKED:
	               fprintf(stderr, "\t reason: 'bankruptcy_illiquidity' board is locked\n");
	               break;
	           case MB_ERR_MEMALLOC:
	               fprintf(stderr, "\t reason: out of memory\n");
	               break;
	           case MB_ERR_INTERNAL:
	               fprintf(stderr, "\t reason: internal error. Recompile libmoard in debug mode for more info \n");
	               break;
	           default:
	           
               
                   fprintf(stderr, "\t MB_Iterator_Create returned error code: %d (see libmboard docs for details)\n", rc);
               
                   break;
		   }

		   
           exit(rc);
		}
		#endif
		
		

			i = Mall_update_mall_stock();

		
		    rc = MB_Iterator_Delete(&i_update_mall_stock);
		    #ifdef ERRCHECK
		    if (rc != MB_SUCCESS)
		    {
		       fprintf(stderr, "ERROR: Could not delete 'update_mall_stock' iterator\n");
		       switch(rc) {
		           case MB_ERR_INVALID:
		               fprintf(stderr, "\t reason: 'update_mall_stock' iterator is invalid\n");
		               break;
		           case MB_ERR_INTERNAL:
		               fprintf(stderr, "\t reason: internal error. Recompile libmoard in debug mode for more info \n");
		               break;
		           default:
                       fprintf(stderr, "\t MB_Iterator_Delete returned error code: %d (see libmboard docs for details)\n", rc);
                       break;
		       }

		       
               exit(rc);
		    }
		    #endif
		
		    rc = MB_Iterator_Delete(&i_bankruptcy_illiquidity);
		    #ifdef ERRCHECK
		    if (rc != MB_SUCCESS)
		    {
		       fprintf(stderr, "ERROR: Could not delete 'bankruptcy_illiquidity' iterator\n");
		       switch(rc) {
		           case MB_ERR_INVALID:
		               fprintf(stderr, "\t reason: 'bankruptcy_illiquidity' iterator is invalid\n");
		               break;
		           case MB_ERR_INTERNAL:
		               fprintf(stderr, "\t reason: internal error. Recompile libmoard in debug mode for more info \n");
		               break;
		           default:
                       fprintf(stderr, "\t MB_Iterator_Delete returned error code: %d (see libmboard docs for details)\n", rc);
                       break;
		       }

		       
               exit(rc);
		    }
		    #endif
		

			if(i == 1)
			{
				free_Mall_agent(current_xmachine_Mall_holder, Mall_01_state);
			}
			else
			{
				transition_Mall_agent(current_xmachine_Mall_holder, Mall_01_state, Mall_02_state);
			}
		

		current_xmachine_Mall = NULL;

		current_xmachine_Mall_holder = temp_xmachine_Mall_holder;
	}
	if(FLAME_TEST_PRINT_START_AND_END_OF_MODEL_FUNCTIONS) printf("finish Mall_update_mall_stock\n");


/* End of layer number 68 */

/* Clear message boards that have finished being used
 * and sync complete if doing late sync complete */

if(FLAME_update_mall_stock_message_board_read == 0)
{
	/*printf("%d> update_mall_stock message board sync complete late as no agents reading any messages of this type\n", node_number);*/
	
	if(FLAME_TEST_PRINT_START_AND_END_OF_LIBMBOARD_CALLS) printf("start MB_SyncComplete(b_update_mall_stock)\n");
	rc = MB_SyncComplete(b_update_mall_stock);
	if(FLAME_TEST_PRINT_START_AND_END_OF_LIBMBOARD_CALLS) printf("finsh MB_SyncComplete(b_update_mall_stock)\n");
	#ifdef ERRCHECK
	if (rc != MB_SUCCESS)
	{
	   fprintf(stderr, "ERROR: Could not complete sync of 'update_mall_stock' board\n");
	   switch(rc) {
			case MB_ERR_INVALID:
			   fprintf(stderr, "\t reason: 'update_mall_stock' board is invalid\n");
			   break;
		   case MB_ERR_MEMALLOC:
			   fprintf(stderr, "\t reason: out of memory\n");
			   break;
		   case MB_ERR_INTERNAL:
			   fprintf(stderr, "\t reason: internal error. Recompile libmoard in debug mode for more info \n");
			   break;
		   default:
			   fprintf(stderr, "\t MB_SyncComplete returned error code: %d (see libmboard docs for details)\n", rc);
			   break;
	   }

	   
	   exit(rc);
	}
	#endif
}

    rc = MB_Clear(b_update_mall_stock);
    #ifdef ERRCHECK
    if (rc != MB_SUCCESS)
    {
       fprintf(stderr, "ERROR: Could not clear 'update_mall_stock' board\n");
       switch(rc) {
           case MB_ERR_INVALID:
               fprintf(stderr, "\t reason: 'update_mall_stock' board is invalid\n");
               break;
           case MB_ERR_LOCKED:
               fprintf(stderr, "\t reason: 'update_mall_stock' board is locked\n");
               break;
           case MB_ERR_INTERNAL:
               fprintf(stderr, "\t reason: internal error. Recompile libmoard in debug mode for more info \n");
               break;
           default:
               fprintf(stderr, "\t MB_Clear returned error code: %d (see libmboard docs for details)\n", rc);
               break;

       }

       
       exit(rc);
    }
    #endif


	if(FLAME_TEST_PRINT_START_AND_END_OF_MODEL_FUNCTIONS) printf("start Mall_send_quality_price_info_1\n");
	current_xmachine_Mall_holder = Mall_02_state->agents;
	while(current_xmachine_Mall_holder)
	{
		temp_xmachine_Mall_holder = current_xmachine_Mall_holder->next;
		current_xmachine_Mall = current_xmachine_Mall_holder->agent;
		current_xmachine_Mall_next_state = Mall_03_state;
		/* For backwards compatibility set current_xmachine */
		current_xmachine->xmachine_Firm = NULL;
		current_xmachine->xmachine_Household = NULL;
		current_xmachine->xmachine_Mall = NULL;
		current_xmachine->xmachine_IGFirm = NULL;
		current_xmachine->xmachine_Eurostat = NULL;
		current_xmachine->xmachine_Bank = NULL;
		current_xmachine->xmachine_Government = NULL;
		current_xmachine->xmachine_CentralBank = NULL;
		current_xmachine->xmachine_ClearingHouse = NULL;
		current_xmachine->xmachine_Mall = current_xmachine_Mall;

		

		

			i = Mall_send_quality_price_info_1();

		

			if(i == 1)
			{
				free_Mall_agent(current_xmachine_Mall_holder, Mall_02_state);
			}
			else
			{
				transition_Mall_agent(current_xmachine_Mall_holder, Mall_02_state, Mall_03_state);
			}
		

		current_xmachine_Mall = NULL;

		current_xmachine_Mall_holder = temp_xmachine_Mall_holder;
	}
	if(FLAME_TEST_PRINT_START_AND_END_OF_MODEL_FUNCTIONS) printf("finish Mall_send_quality_price_info_1\n");

	if(FLAME_quality_price_info_1_message_board_write == 1)
	{

		if(FLAME_TEST_PRINT_START_AND_END_OF_LIBMBOARD_CALLS) printf("start MB_SyncStart(b_quality_price_info_1)\n");
		rc = MB_SyncStart(b_quality_price_info_1);
		if(FLAME_TEST_PRINT_START_AND_END_OF_LIBMBOARD_CALLS) printf("finish MB_SyncStart(b_quality_price_info_1)\n");
		#ifdef ERRCHECK
		if (rc != MB_SUCCESS)
		{
		   fprintf(stderr, "ERROR: Could not start sync of 'quality_price_info_1' board\n");
		   switch(rc) {
			   case MB_ERR_INVALID:
				   fprintf(stderr, "\t reason: 'quality_price_info_1' board is invalid\n");
				   break;
			   case MB_ERR_LOCKED:
				   fprintf(stderr, "\t reason: 'quality_price_info_1' board is locked\n");
				   break;
			   case MB_ERR_MEMALLOC:
				   fprintf(stderr, "\t reason: out of memory\n");
				   break;
			   case MB_ERR_INTERNAL:
				   fprintf(stderr, "\t reason: internal error. Recompile libmoard in debug mode for more info \n");
				   break;
			   default:
				   fprintf(stderr, "\t MB_SyncStart returned error code: %d (see libmboard docs for details)\n", rc);
				   break;
		   }

			
			exit(rc);
		}
		#endif
    }
    


	if(FLAME_TEST_PRINT_START_AND_END_OF_MODEL_FUNCTIONS) printf("start IGFirm_send_transfer_notification\n");
	current_xmachine_IGFirm_holder = IGFirm_05_state->agents;
	while(current_xmachine_IGFirm_holder)
	{
		temp_xmachine_IGFirm_holder = current_xmachine_IGFirm_holder->next;
		current_xmachine_IGFirm = current_xmachine_IGFirm_holder->agent;
		current_xmachine_IGFirm_next_state = IGFirm_IGFirm_End_Public_Sector_Role_state;
		/* For backwards compatibility set current_xmachine */
		current_xmachine->xmachine_Firm = NULL;
		current_xmachine->xmachine_Household = NULL;
		current_xmachine->xmachine_Mall = NULL;
		current_xmachine->xmachine_IGFirm = NULL;
		current_xmachine->xmachine_Eurostat = NULL;
		current_xmachine->xmachine_Bank = NULL;
		current_xmachine->xmachine_Government = NULL;
		current_xmachine->xmachine_CentralBank = NULL;
		current_xmachine->xmachine_ClearingHouse = NULL;
		current_xmachine->xmachine_IGFirm = current_xmachine_IGFirm;

		

		

			i = IGFirm_send_transfer_notification();

		

			if(i == 1)
			{
				free_IGFirm_agent(current_xmachine_IGFirm_holder, IGFirm_05_state);
			}
			else
			{
				transition_IGFirm_agent(current_xmachine_IGFirm_holder, IGFirm_05_state, IGFirm_IGFirm_End_Public_Sector_Role_state);
			}
		

		current_xmachine_IGFirm = NULL;

		current_xmachine_IGFirm_holder = temp_xmachine_IGFirm_holder;
	}
	if(FLAME_TEST_PRINT_START_AND_END_OF_MODEL_FUNCTIONS) printf("finish IGFirm_send_transfer_notification\n");


	if(FLAME_TEST_PRINT_START_AND_END_OF_MODEL_FUNCTIONS) printf("start Household_send_tax_payment\n");
	current_xmachine_Household_holder = Household_08_state->agents;
	while(current_xmachine_Household_holder)
	{
		temp_xmachine_Household_holder = current_xmachine_Household_holder->next;
		current_xmachine_Household = current_xmachine_Household_holder->agent;
		current_xmachine_Household_next_state = Household_08b_state;
		/* For backwards compatibility set current_xmachine */
		current_xmachine->xmachine_Firm = NULL;
		current_xmachine->xmachine_Household = NULL;
		current_xmachine->xmachine_Mall = NULL;
		current_xmachine->xmachine_IGFirm = NULL;
		current_xmachine->xmachine_Eurostat = NULL;
		current_xmachine->xmachine_Bank = NULL;
		current_xmachine->xmachine_Government = NULL;
		current_xmachine->xmachine_CentralBank = NULL;
		current_xmachine->xmachine_ClearingHouse = NULL;
		current_xmachine->xmachine_Household = current_xmachine_Household;

		

		

			i = Household_send_tax_payment();

		

			if(i == 1)
			{
				free_Household_agent(current_xmachine_Household_holder, Household_08_state);
			}
			else
			{
				transition_Household_agent(current_xmachine_Household_holder, Household_08_state, Household_08b_state);
			}
		

		current_xmachine_Household = NULL;

		current_xmachine_Household_holder = temp_xmachine_Household_holder;
	}
	if(FLAME_TEST_PRINT_START_AND_END_OF_MODEL_FUNCTIONS) printf("finish Household_send_tax_payment\n");

	if(FLAME_unemployment_benefit_restitution_message_board_write == 1)
	{

		if(FLAME_TEST_PRINT_START_AND_END_OF_LIBMBOARD_CALLS) printf("start MB_SyncStart(b_unemployment_benefit_restitution)\n");
		rc = MB_SyncStart(b_unemployment_benefit_restitution);
		if(FLAME_TEST_PRINT_START_AND_END_OF_LIBMBOARD_CALLS) printf("finish MB_SyncStart(b_unemployment_benefit_restitution)\n");
		#ifdef ERRCHECK
		if (rc != MB_SUCCESS)
		{
		   fprintf(stderr, "ERROR: Could not start sync of 'unemployment_benefit_restitution' board\n");
		   switch(rc) {
			   case MB_ERR_INVALID:
				   fprintf(stderr, "\t reason: 'unemployment_benefit_restitution' board is invalid\n");
				   break;
			   case MB_ERR_LOCKED:
				   fprintf(stderr, "\t reason: 'unemployment_benefit_restitution' board is locked\n");
				   break;
			   case MB_ERR_MEMALLOC:
				   fprintf(stderr, "\t reason: out of memory\n");
				   break;
			   case MB_ERR_INTERNAL:
				   fprintf(stderr, "\t reason: internal error. Recompile libmoard in debug mode for more info \n");
				   break;
			   default:
				   fprintf(stderr, "\t MB_SyncStart returned error code: %d (see libmboard docs for details)\n", rc);
				   break;
		   }

			
			exit(rc);
		}
		#endif
    }
    


/* End of layer number 69 */

/* Clear message boards that have finished being used
 * and sync complete if doing late sync complete */


	/* If mb is not read then leave sync complete until last possible moment */
	if(FLAME_quality_price_info_1_message_board_read == 1)
	{
		if(FLAME_TEST_PRINT_START_AND_END_OF_LIBMBOARD_CALLS) printf("start MB_SyncComplete(b_quality_price_info_1)\n");
		rc = MB_SyncComplete(b_quality_price_info_1);
		if(FLAME_TEST_PRINT_START_AND_END_OF_LIBMBOARD_CALLS) printf("finsh MB_SyncComplete(b_quality_price_info_1)\n");
		#ifdef ERRCHECK
		if (rc != MB_SUCCESS)
		{
		   fprintf(stderr, "ERROR: Could not complete sync of 'quality_price_info_1' board\n");
		   switch(rc) {
				case MB_ERR_INVALID:
				   fprintf(stderr, "\t reason: 'quality_price_info_1' board is invalid\n");
				   break;
			   case MB_ERR_MEMALLOC:
				   fprintf(stderr, "\t reason: out of memory\n");
				   break;
			   case MB_ERR_INTERNAL:
				   fprintf(stderr, "\t reason: internal error. Recompile libmoard in debug mode for more info \n");
				   break;
			   default:
				   fprintf(stderr, "\t MB_SyncComplete returned error code: %d (see libmboard docs for details)\n", rc);
				   break;
		   }
	
		   
		   exit(rc);
		}
		#endif
    
	}
	
	if(FLAME_TEST_PRINT_START_AND_END_OF_MODEL_FUNCTIONS) printf("start Government_rank_and_buy_goods_1\n");
	current_xmachine_Government_holder = Government_Gov_Cons_1_state->agents;
	while(current_xmachine_Government_holder)
	{
		temp_xmachine_Government_holder = current_xmachine_Government_holder->next;
		current_xmachine_Government = current_xmachine_Government_holder->agent;
		current_xmachine_Government_next_state = Government_Gov_Cons_2_state;
		/* For backwards compatibility set current_xmachine */
		current_xmachine->xmachine_Firm = NULL;
		current_xmachine->xmachine_Household = NULL;
		current_xmachine->xmachine_Mall = NULL;
		current_xmachine->xmachine_IGFirm = NULL;
		current_xmachine->xmachine_Eurostat = NULL;
		current_xmachine->xmachine_Bank = NULL;
		current_xmachine->xmachine_Government = NULL;
		current_xmachine->xmachine_CentralBank = NULL;
		current_xmachine->xmachine_ClearingHouse = NULL;
		current_xmachine->xmachine_Government = current_xmachine_Government;

		

		
		rc = MB_Iterator_CreateFiltered(b_quality_price_info_1, &i_quality_price_info_1, &FLAME_filter_Government_Government_rank_and_buy_goods_1_Gov_Cons_1_Gov_Cons_2_quality_price_info_1, current_xmachine_Government);
		
		#ifdef ERRCHECK
		if (rc != MB_SUCCESS)
		{
		   fprintf(stderr, "ERROR: Could not create Iterator for 'quality_price_info_1'\n");
		   switch(rc) {
		       case MB_ERR_INVALID:
		           fprintf(stderr, "\t reason: 'quality_price_info_1' board is invalid\n");
		           break;
		       case MB_ERR_LOCKED:
	               fprintf(stderr, "\t reason: 'quality_price_info_1' board is locked\n");
	               break;
	           case MB_ERR_MEMALLOC:
	               fprintf(stderr, "\t reason: out of memory\n");
	               break;
	           case MB_ERR_INTERNAL:
	               fprintf(stderr, "\t reason: internal error. Recompile libmoard in debug mode for more info \n");
	               break;
	           default:
	           
                   fprintf(stderr, "\t MB_Iterator_CreateFiltered returned error code: %d (see libmboard docs for details)\n", rc);
               
               
                   break;
		   }

		   
           exit(rc);
		}
		#endif
		
		

			i = Government_rank_and_buy_goods_1();

		
		    rc = MB_Iterator_Delete(&i_quality_price_info_1);
		    #ifdef ERRCHECK
		    if (rc != MB_SUCCESS)
		    {
		       fprintf(stderr, "ERROR: Could not delete 'quality_price_info_1' iterator\n");
		       switch(rc) {
		           case MB_ERR_INVALID:
		               fprintf(stderr, "\t reason: 'quality_price_info_1' iterator is invalid\n");
		               break;
		           case MB_ERR_INTERNAL:
		               fprintf(stderr, "\t reason: internal error. Recompile libmoard in debug mode for more info \n");
		               break;
		           default:
                       fprintf(stderr, "\t MB_Iterator_Delete returned error code: %d (see libmboard docs for details)\n", rc);
                       break;
		       }

		       
               exit(rc);
		    }
		    #endif
		

			if(i == 1)
			{
				free_Government_agent(current_xmachine_Government_holder, Government_Gov_Cons_1_state);
			}
			else
			{
				transition_Government_agent(current_xmachine_Government_holder, Government_Gov_Cons_1_state, Government_Gov_Cons_2_state);
			}
		

		current_xmachine_Government = NULL;

		current_xmachine_Government_holder = temp_xmachine_Government_holder;
	}
	if(FLAME_TEST_PRINT_START_AND_END_OF_MODEL_FUNCTIONS) printf("finish Government_rank_and_buy_goods_1\n");


	if(FLAME_TEST_PRINT_START_AND_END_OF_MODEL_FUNCTIONS) printf("start IGFirm_compute_income_statement\n");
	current_xmachine_IGFirm_holder = IGFirm_IGFirm_End_Public_Sector_Role_state->agents;
	while(current_xmachine_IGFirm_holder)
	{
		temp_xmachine_IGFirm_holder = current_xmachine_IGFirm_holder->next;
		current_xmachine_IGFirm = current_xmachine_IGFirm_holder->agent;
		current_xmachine_IGFirm_next_state = IGFirm_002_state;
		/* For backwards compatibility set current_xmachine */
		current_xmachine->xmachine_Firm = NULL;
		current_xmachine->xmachine_Household = NULL;
		current_xmachine->xmachine_Mall = NULL;
		current_xmachine->xmachine_IGFirm = NULL;
		current_xmachine->xmachine_Eurostat = NULL;
		current_xmachine->xmachine_Bank = NULL;
		current_xmachine->xmachine_Government = NULL;
		current_xmachine->xmachine_CentralBank = NULL;
		current_xmachine->xmachine_ClearingHouse = NULL;
		current_xmachine->xmachine_IGFirm = current_xmachine_IGFirm;

		

		

			i = IGFirm_compute_income_statement();

		

			if(i == 1)
			{
				free_IGFirm_agent(current_xmachine_IGFirm_holder, IGFirm_IGFirm_End_Public_Sector_Role_state);
			}
			else
			{
				transition_IGFirm_agent(current_xmachine_IGFirm_holder, IGFirm_IGFirm_End_Public_Sector_Role_state, IGFirm_002_state);
			}
		

		current_xmachine_IGFirm = NULL;

		current_xmachine_IGFirm_holder = temp_xmachine_IGFirm_holder;
	}
	if(FLAME_TEST_PRINT_START_AND_END_OF_MODEL_FUNCTIONS) printf("finish IGFirm_compute_income_statement\n");


	if(FLAME_TEST_PRINT_START_AND_END_OF_MODEL_FUNCTIONS) printf("start Household_determine_consumption_budget\n");
	current_xmachine_Household_holder = Household_08b_state->agents;
	while(current_xmachine_Household_holder)
	{
		temp_xmachine_Household_holder = current_xmachine_Household_holder->next;
		current_xmachine_Household = current_xmachine_Household_holder->agent;
		current_xmachine_Household_next_state = Household_09_state;
		/* For backwards compatibility set current_xmachine */
		current_xmachine->xmachine_Firm = NULL;
		current_xmachine->xmachine_Household = NULL;
		current_xmachine->xmachine_Mall = NULL;
		current_xmachine->xmachine_IGFirm = NULL;
		current_xmachine->xmachine_Eurostat = NULL;
		current_xmachine->xmachine_Bank = NULL;
		current_xmachine->xmachine_Government = NULL;
		current_xmachine->xmachine_CentralBank = NULL;
		current_xmachine->xmachine_ClearingHouse = NULL;
		current_xmachine->xmachine_Household = current_xmachine_Household;

		

		

			i = Household_determine_consumption_budget();

		

			if(i == 1)
			{
				free_Household_agent(current_xmachine_Household_holder, Household_08b_state);
			}
			else
			{
				transition_Household_agent(current_xmachine_Household_holder, Household_08b_state, Household_09_state);
			}
		

		current_xmachine_Household = NULL;

		current_xmachine_Household_holder = temp_xmachine_Household_holder;
	}
	if(FLAME_TEST_PRINT_START_AND_END_OF_MODEL_FUNCTIONS) printf("finish Household_determine_consumption_budget\n");


/* End of layer number 70 */

/* Clear message boards that have finished being used
 * and sync complete if doing late sync complete */


	if(FLAME_TEST_PRINT_START_AND_END_OF_MODEL_FUNCTIONS) printf("start IGFirm_compute_dividends\n");
	current_xmachine_IGFirm_holder = IGFirm_002_state->agents;
	while(current_xmachine_IGFirm_holder)
	{
		temp_xmachine_IGFirm_holder = current_xmachine_IGFirm_holder->next;
		current_xmachine_IGFirm = current_xmachine_IGFirm_holder->agent;
		current_xmachine_IGFirm_next_state = IGFirm_003_state;
		/* For backwards compatibility set current_xmachine */
		current_xmachine->xmachine_Firm = NULL;
		current_xmachine->xmachine_Household = NULL;
		current_xmachine->xmachine_Mall = NULL;
		current_xmachine->xmachine_IGFirm = NULL;
		current_xmachine->xmachine_Eurostat = NULL;
		current_xmachine->xmachine_Bank = NULL;
		current_xmachine->xmachine_Government = NULL;
		current_xmachine->xmachine_CentralBank = NULL;
		current_xmachine->xmachine_ClearingHouse = NULL;
		current_xmachine->xmachine_IGFirm = current_xmachine_IGFirm;

		

		

			i = IGFirm_compute_dividends();

		

			if(i == 1)
			{
				free_IGFirm_agent(current_xmachine_IGFirm_holder, IGFirm_002_state);
			}
			else
			{
				transition_IGFirm_agent(current_xmachine_IGFirm_holder, IGFirm_002_state, IGFirm_003_state);
			}
		

		current_xmachine_IGFirm = NULL;

		current_xmachine_IGFirm_holder = temp_xmachine_IGFirm_holder;
	}
	if(FLAME_TEST_PRINT_START_AND_END_OF_MODEL_FUNCTIONS) printf("finish IGFirm_compute_dividends\n");


	if(FLAME_TEST_PRINT_START_AND_END_OF_MODEL_FUNCTIONS) printf("start Household_idle\n");
	current_xmachine_Household_holder = Household_09_state->agents;
	while(current_xmachine_Household_holder)
	{
		temp_xmachine_Household_holder = current_xmachine_Household_holder->next;
		current_xmachine_Household = current_xmachine_Household_holder->agent;
		current_xmachine_Household_next_state = Household_15_state;
		/* For backwards compatibility set current_xmachine */
		current_xmachine->xmachine_Firm = NULL;
		current_xmachine->xmachine_Household = NULL;
		current_xmachine->xmachine_Mall = NULL;
		current_xmachine->xmachine_IGFirm = NULL;
		current_xmachine->xmachine_Eurostat = NULL;
		current_xmachine->xmachine_Bank = NULL;
		current_xmachine->xmachine_Government = NULL;
		current_xmachine->xmachine_CentralBank = NULL;
		current_xmachine->xmachine_ClearingHouse = NULL;
		current_xmachine->xmachine_Household = current_xmachine_Household;

		if(FLAME_condition_Household_Household_idle_09_15(current_xmachine_Household)==1)
		{

		

			i = Household_idle();

		

			if(i == 1)
			{
				free_Household_agent(current_xmachine_Household_holder, Household_09_state);
			}
			else
			{
				transition_Household_agent(current_xmachine_Household_holder, Household_09_state, Household_15_state);
			}
		}

		current_xmachine_Household = NULL;

		current_xmachine_Household_holder = temp_xmachine_Household_holder;
	}
	if(FLAME_TEST_PRINT_START_AND_END_OF_MODEL_FUNCTIONS) printf("finish Household_idle\n");


	if(FLAME_TEST_PRINT_START_AND_END_OF_MODEL_FUNCTIONS) printf("start Household_rank_and_buy_goods_1\n");
	current_xmachine_Household_holder = Household_09_state->agents;
	while(current_xmachine_Household_holder)
	{
		temp_xmachine_Household_holder = current_xmachine_Household_holder->next;
		current_xmachine_Household = current_xmachine_Household_holder->agent;
		current_xmachine_Household_next_state = Household_10_state;
		/* For backwards compatibility set current_xmachine */
		current_xmachine->xmachine_Firm = NULL;
		current_xmachine->xmachine_Household = NULL;
		current_xmachine->xmachine_Mall = NULL;
		current_xmachine->xmachine_IGFirm = NULL;
		current_xmachine->xmachine_Eurostat = NULL;
		current_xmachine->xmachine_Bank = NULL;
		current_xmachine->xmachine_Government = NULL;
		current_xmachine->xmachine_CentralBank = NULL;
		current_xmachine->xmachine_ClearingHouse = NULL;
		current_xmachine->xmachine_Household = current_xmachine_Household;

		if(FLAME_condition_Household_Household_rank_and_buy_goods_1_09_10(current_xmachine_Household)==1)
		{

		
		rc = MB_Iterator_CreateFiltered(b_quality_price_info_1, &i_quality_price_info_1, &FLAME_filter_Household_Household_rank_and_buy_goods_1_09_10_quality_price_info_1, current_xmachine_Household);
		
		#ifdef ERRCHECK
		if (rc != MB_SUCCESS)
		{
		   fprintf(stderr, "ERROR: Could not create Iterator for 'quality_price_info_1'\n");
		   switch(rc) {
		       case MB_ERR_INVALID:
		           fprintf(stderr, "\t reason: 'quality_price_info_1' board is invalid\n");
		           break;
		       case MB_ERR_LOCKED:
	               fprintf(stderr, "\t reason: 'quality_price_info_1' board is locked\n");
	               break;
	           case MB_ERR_MEMALLOC:
	               fprintf(stderr, "\t reason: out of memory\n");
	               break;
	           case MB_ERR_INTERNAL:
	               fprintf(stderr, "\t reason: internal error. Recompile libmoard in debug mode for more info \n");
	               break;
	           default:
	           
                   fprintf(stderr, "\t MB_Iterator_CreateFiltered returned error code: %d (see libmboard docs for details)\n", rc);
               
               
                   break;
		   }

		   
           exit(rc);
		}
		#endif
		
		

			i = Household_rank_and_buy_goods_1();

		
		    rc = MB_Iterator_Delete(&i_quality_price_info_1);
		    #ifdef ERRCHECK
		    if (rc != MB_SUCCESS)
		    {
		       fprintf(stderr, "ERROR: Could not delete 'quality_price_info_1' iterator\n");
		       switch(rc) {
		           case MB_ERR_INVALID:
		               fprintf(stderr, "\t reason: 'quality_price_info_1' iterator is invalid\n");
		               break;
		           case MB_ERR_INTERNAL:
		               fprintf(stderr, "\t reason: internal error. Recompile libmoard in debug mode for more info \n");
		               break;
		           default:
                       fprintf(stderr, "\t MB_Iterator_Delete returned error code: %d (see libmboard docs for details)\n", rc);
                       break;
		       }

		       
               exit(rc);
		    }
		    #endif
		

			if(i == 1)
			{
				free_Household_agent(current_xmachine_Household_holder, Household_09_state);
			}
			else
			{
				transition_Household_agent(current_xmachine_Household_holder, Household_09_state, Household_10_state);
			}
		}

		current_xmachine_Household = NULL;

		current_xmachine_Household_holder = temp_xmachine_Household_holder;
	}
	if(FLAME_TEST_PRINT_START_AND_END_OF_MODEL_FUNCTIONS) printf("finish Household_rank_and_buy_goods_1\n");

	if(FLAME_consumption_request_1_message_board_write == 1)
	{

		if(FLAME_TEST_PRINT_START_AND_END_OF_LIBMBOARD_CALLS) printf("start MB_SyncStart(b_consumption_request_1)\n");
		rc = MB_SyncStart(b_consumption_request_1);
		if(FLAME_TEST_PRINT_START_AND_END_OF_LIBMBOARD_CALLS) printf("finish MB_SyncStart(b_consumption_request_1)\n");
		#ifdef ERRCHECK
		if (rc != MB_SUCCESS)
		{
		   fprintf(stderr, "ERROR: Could not start sync of 'consumption_request_1' board\n");
		   switch(rc) {
			   case MB_ERR_INVALID:
				   fprintf(stderr, "\t reason: 'consumption_request_1' board is invalid\n");
				   break;
			   case MB_ERR_LOCKED:
				   fprintf(stderr, "\t reason: 'consumption_request_1' board is locked\n");
				   break;
			   case MB_ERR_MEMALLOC:
				   fprintf(stderr, "\t reason: out of memory\n");
				   break;
			   case MB_ERR_INTERNAL:
				   fprintf(stderr, "\t reason: internal error. Recompile libmoard in debug mode for more info \n");
				   break;
			   default:
				   fprintf(stderr, "\t MB_SyncStart returned error code: %d (see libmboard docs for details)\n", rc);
				   break;
		   }

			
			exit(rc);
		}
		#endif
    }
    


/* End of layer number 71 */

/* Clear message boards that have finished being used
 * and sync complete if doing late sync complete */

if(FLAME_quality_price_info_1_message_board_read == 0)
{
	/*printf("%d> quality_price_info_1 message board sync complete late as no agents reading any messages of this type\n", node_number);*/
	
	if(FLAME_TEST_PRINT_START_AND_END_OF_LIBMBOARD_CALLS) printf("start MB_SyncComplete(b_quality_price_info_1)\n");
	rc = MB_SyncComplete(b_quality_price_info_1);
	if(FLAME_TEST_PRINT_START_AND_END_OF_LIBMBOARD_CALLS) printf("finsh MB_SyncComplete(b_quality_price_info_1)\n");
	#ifdef ERRCHECK
	if (rc != MB_SUCCESS)
	{
	   fprintf(stderr, "ERROR: Could not complete sync of 'quality_price_info_1' board\n");
	   switch(rc) {
			case MB_ERR_INVALID:
			   fprintf(stderr, "\t reason: 'quality_price_info_1' board is invalid\n");
			   break;
		   case MB_ERR_MEMALLOC:
			   fprintf(stderr, "\t reason: out of memory\n");
			   break;
		   case MB_ERR_INTERNAL:
			   fprintf(stderr, "\t reason: internal error. Recompile libmoard in debug mode for more info \n");
			   break;
		   default:
			   fprintf(stderr, "\t MB_SyncComplete returned error code: %d (see libmboard docs for details)\n", rc);
			   break;
	   }

	   
	   exit(rc);
	}
	#endif
}

    rc = MB_Clear(b_quality_price_info_1);
    #ifdef ERRCHECK
    if (rc != MB_SUCCESS)
    {
       fprintf(stderr, "ERROR: Could not clear 'quality_price_info_1' board\n");
       switch(rc) {
           case MB_ERR_INVALID:
               fprintf(stderr, "\t reason: 'quality_price_info_1' board is invalid\n");
               break;
           case MB_ERR_LOCKED:
               fprintf(stderr, "\t reason: 'quality_price_info_1' board is locked\n");
               break;
           case MB_ERR_INTERNAL:
               fprintf(stderr, "\t reason: internal error. Recompile libmoard in debug mode for more info \n");
               break;
           default:
               fprintf(stderr, "\t MB_Clear returned error code: %d (see libmboard docs for details)\n", rc);
               break;

       }

       
       exit(rc);
    }
    #endif


	/* If mb is not read then leave sync complete until last possible moment */
	if(FLAME_consumption_request_1_message_board_read == 1)
	{
		if(FLAME_TEST_PRINT_START_AND_END_OF_LIBMBOARD_CALLS) printf("start MB_SyncComplete(b_consumption_request_1)\n");
		rc = MB_SyncComplete(b_consumption_request_1);
		if(FLAME_TEST_PRINT_START_AND_END_OF_LIBMBOARD_CALLS) printf("finsh MB_SyncComplete(b_consumption_request_1)\n");
		#ifdef ERRCHECK
		if (rc != MB_SUCCESS)
		{
		   fprintf(stderr, "ERROR: Could not complete sync of 'consumption_request_1' board\n");
		   switch(rc) {
				case MB_ERR_INVALID:
				   fprintf(stderr, "\t reason: 'consumption_request_1' board is invalid\n");
				   break;
			   case MB_ERR_MEMALLOC:
				   fprintf(stderr, "\t reason: out of memory\n");
				   break;
			   case MB_ERR_INTERNAL:
				   fprintf(stderr, "\t reason: internal error. Recompile libmoard in debug mode for more info \n");
				   break;
			   default:
				   fprintf(stderr, "\t MB_SyncComplete returned error code: %d (see libmboard docs for details)\n", rc);
				   break;
		   }
	
		   
		   exit(rc);
		}
		#endif
    
	}
	
	if(FLAME_TEST_PRINT_START_AND_END_OF_MODEL_FUNCTIONS) printf("start Mall_update_mall_stocks_sales_rationing_1\n");
	current_xmachine_Mall_holder = Mall_03_state->agents;
	while(current_xmachine_Mall_holder)
	{
		temp_xmachine_Mall_holder = current_xmachine_Mall_holder->next;
		current_xmachine_Mall = current_xmachine_Mall_holder->agent;
		current_xmachine_Mall_next_state = Mall_04_state;
		/* For backwards compatibility set current_xmachine */
		current_xmachine->xmachine_Firm = NULL;
		current_xmachine->xmachine_Household = NULL;
		current_xmachine->xmachine_Mall = NULL;
		current_xmachine->xmachine_IGFirm = NULL;
		current_xmachine->xmachine_Eurostat = NULL;
		current_xmachine->xmachine_Bank = NULL;
		current_xmachine->xmachine_Government = NULL;
		current_xmachine->xmachine_CentralBank = NULL;
		current_xmachine->xmachine_ClearingHouse = NULL;
		current_xmachine->xmachine_Mall = current_xmachine_Mall;

		

		
		rc = MB_Iterator_CreateFiltered(b_consumption_request_1, &i_consumption_request_1, &FLAME_filter_Mall_Mall_update_mall_stocks_sales_rationing_1_03_04_consumption_request_1, current_xmachine_Mall);
		
		#ifdef ERRCHECK
		if (rc != MB_SUCCESS)
		{
		   fprintf(stderr, "ERROR: Could not create Iterator for 'consumption_request_1'\n");
		   switch(rc) {
		       case MB_ERR_INVALID:
		           fprintf(stderr, "\t reason: 'consumption_request_1' board is invalid\n");
		           break;
		       case MB_ERR_LOCKED:
	               fprintf(stderr, "\t reason: 'consumption_request_1' board is locked\n");
	               break;
	           case MB_ERR_MEMALLOC:
	               fprintf(stderr, "\t reason: out of memory\n");
	               break;
	           case MB_ERR_INTERNAL:
	               fprintf(stderr, "\t reason: internal error. Recompile libmoard in debug mode for more info \n");
	               break;
	           default:
	           
                   fprintf(stderr, "\t MB_Iterator_CreateFiltered returned error code: %d (see libmboard docs for details)\n", rc);
               
               
                   break;
		   }

		   
           exit(rc);
		}
		#endif
		
		

			i = Mall_update_mall_stocks_sales_rationing_1();

		
		    rc = MB_Iterator_Delete(&i_consumption_request_1);
		    #ifdef ERRCHECK
		    if (rc != MB_SUCCESS)
		    {
		       fprintf(stderr, "ERROR: Could not delete 'consumption_request_1' iterator\n");
		       switch(rc) {
		           case MB_ERR_INVALID:
		               fprintf(stderr, "\t reason: 'consumption_request_1' iterator is invalid\n");
		               break;
		           case MB_ERR_INTERNAL:
		               fprintf(stderr, "\t reason: internal error. Recompile libmoard in debug mode for more info \n");
		               break;
		           default:
                       fprintf(stderr, "\t MB_Iterator_Delete returned error code: %d (see libmboard docs for details)\n", rc);
                       break;
		       }

		       
               exit(rc);
		    }
		    #endif
		

			if(i == 1)
			{
				free_Mall_agent(current_xmachine_Mall_holder, Mall_03_state);
			}
			else
			{
				transition_Mall_agent(current_xmachine_Mall_holder, Mall_03_state, Mall_04_state);
			}
		

		current_xmachine_Mall = NULL;

		current_xmachine_Mall_holder = temp_xmachine_Mall_holder;
	}
	if(FLAME_TEST_PRINT_START_AND_END_OF_MODEL_FUNCTIONS) printf("finish Mall_update_mall_stocks_sales_rationing_1\n");

	if(FLAME_accepted_consumption_1_message_board_write == 1)
	{

		if(FLAME_TEST_PRINT_START_AND_END_OF_LIBMBOARD_CALLS) printf("start MB_SyncStart(b_accepted_consumption_1)\n");
		rc = MB_SyncStart(b_accepted_consumption_1);
		if(FLAME_TEST_PRINT_START_AND_END_OF_LIBMBOARD_CALLS) printf("finish MB_SyncStart(b_accepted_consumption_1)\n");
		#ifdef ERRCHECK
		if (rc != MB_SUCCESS)
		{
		   fprintf(stderr, "ERROR: Could not start sync of 'accepted_consumption_1' board\n");
		   switch(rc) {
			   case MB_ERR_INVALID:
				   fprintf(stderr, "\t reason: 'accepted_consumption_1' board is invalid\n");
				   break;
			   case MB_ERR_LOCKED:
				   fprintf(stderr, "\t reason: 'accepted_consumption_1' board is locked\n");
				   break;
			   case MB_ERR_MEMALLOC:
				   fprintf(stderr, "\t reason: out of memory\n");
				   break;
			   case MB_ERR_INTERNAL:
				   fprintf(stderr, "\t reason: internal error. Recompile libmoard in debug mode for more info \n");
				   break;
			   default:
				   fprintf(stderr, "\t MB_SyncStart returned error code: %d (see libmboard docs for details)\n", rc);
				   break;
		   }

			
			exit(rc);
		}
		#endif
    }
    

	if(FLAME_quality_price_info_2_message_board_write == 1)
	{

		if(FLAME_TEST_PRINT_START_AND_END_OF_LIBMBOARD_CALLS) printf("start MB_SyncStart(b_quality_price_info_2)\n");
		rc = MB_SyncStart(b_quality_price_info_2);
		if(FLAME_TEST_PRINT_START_AND_END_OF_LIBMBOARD_CALLS) printf("finish MB_SyncStart(b_quality_price_info_2)\n");
		#ifdef ERRCHECK
		if (rc != MB_SUCCESS)
		{
		   fprintf(stderr, "ERROR: Could not start sync of 'quality_price_info_2' board\n");
		   switch(rc) {
			   case MB_ERR_INVALID:
				   fprintf(stderr, "\t reason: 'quality_price_info_2' board is invalid\n");
				   break;
			   case MB_ERR_LOCKED:
				   fprintf(stderr, "\t reason: 'quality_price_info_2' board is locked\n");
				   break;
			   case MB_ERR_MEMALLOC:
				   fprintf(stderr, "\t reason: out of memory\n");
				   break;
			   case MB_ERR_INTERNAL:
				   fprintf(stderr, "\t reason: internal error. Recompile libmoard in debug mode for more info \n");
				   break;
			   default:
				   fprintf(stderr, "\t MB_SyncStart returned error code: %d (see libmboard docs for details)\n", rc);
				   break;
		   }

			
			exit(rc);
		}
		#endif
    }
    


	if(FLAME_TEST_PRINT_START_AND_END_OF_MODEL_FUNCTIONS) printf("start IGFirm_compute_total_financial_payments\n");
	current_xmachine_IGFirm_holder = IGFirm_003_state->agents;
	while(current_xmachine_IGFirm_holder)
	{
		temp_xmachine_IGFirm_holder = current_xmachine_IGFirm_holder->next;
		current_xmachine_IGFirm = current_xmachine_IGFirm_holder->agent;
		current_xmachine_IGFirm_next_state = IGFirm_004_state;
		/* For backwards compatibility set current_xmachine */
		current_xmachine->xmachine_Firm = NULL;
		current_xmachine->xmachine_Household = NULL;
		current_xmachine->xmachine_Mall = NULL;
		current_xmachine->xmachine_IGFirm = NULL;
		current_xmachine->xmachine_Eurostat = NULL;
		current_xmachine->xmachine_Bank = NULL;
		current_xmachine->xmachine_Government = NULL;
		current_xmachine->xmachine_CentralBank = NULL;
		current_xmachine->xmachine_ClearingHouse = NULL;
		current_xmachine->xmachine_IGFirm = current_xmachine_IGFirm;

		

		

			i = IGFirm_compute_total_financial_payments();

		

			if(i == 1)
			{
				free_IGFirm_agent(current_xmachine_IGFirm_holder, IGFirm_003_state);
			}
			else
			{
				transition_IGFirm_agent(current_xmachine_IGFirm_holder, IGFirm_003_state, IGFirm_004_state);
			}
		

		current_xmachine_IGFirm = NULL;

		current_xmachine_IGFirm_holder = temp_xmachine_IGFirm_holder;
	}
	if(FLAME_TEST_PRINT_START_AND_END_OF_MODEL_FUNCTIONS) printf("finish IGFirm_compute_total_financial_payments\n");


/* End of layer number 72 */

/* Clear message boards that have finished being used
 * and sync complete if doing late sync complete */

if(FLAME_consumption_request_1_message_board_read == 0)
{
	/*printf("%d> consumption_request_1 message board sync complete late as no agents reading any messages of this type\n", node_number);*/
	
	if(FLAME_TEST_PRINT_START_AND_END_OF_LIBMBOARD_CALLS) printf("start MB_SyncComplete(b_consumption_request_1)\n");
	rc = MB_SyncComplete(b_consumption_request_1);
	if(FLAME_TEST_PRINT_START_AND_END_OF_LIBMBOARD_CALLS) printf("finsh MB_SyncComplete(b_consumption_request_1)\n");
	#ifdef ERRCHECK
	if (rc != MB_SUCCESS)
	{
	   fprintf(stderr, "ERROR: Could not complete sync of 'consumption_request_1' board\n");
	   switch(rc) {
			case MB_ERR_INVALID:
			   fprintf(stderr, "\t reason: 'consumption_request_1' board is invalid\n");
			   break;
		   case MB_ERR_MEMALLOC:
			   fprintf(stderr, "\t reason: out of memory\n");
			   break;
		   case MB_ERR_INTERNAL:
			   fprintf(stderr, "\t reason: internal error. Recompile libmoard in debug mode for more info \n");
			   break;
		   default:
			   fprintf(stderr, "\t MB_SyncComplete returned error code: %d (see libmboard docs for details)\n", rc);
			   break;
	   }

	   
	   exit(rc);
	}
	#endif
}

    rc = MB_Clear(b_consumption_request_1);
    #ifdef ERRCHECK
    if (rc != MB_SUCCESS)
    {
       fprintf(stderr, "ERROR: Could not clear 'consumption_request_1' board\n");
       switch(rc) {
           case MB_ERR_INVALID:
               fprintf(stderr, "\t reason: 'consumption_request_1' board is invalid\n");
               break;
           case MB_ERR_LOCKED:
               fprintf(stderr, "\t reason: 'consumption_request_1' board is locked\n");
               break;
           case MB_ERR_INTERNAL:
               fprintf(stderr, "\t reason: internal error. Recompile libmoard in debug mode for more info \n");
               break;
           default:
               fprintf(stderr, "\t MB_Clear returned error code: %d (see libmboard docs for details)\n", rc);
               break;

       }

       
       exit(rc);
    }
    #endif


	if(FLAME_TEST_PRINT_START_AND_END_OF_MODEL_FUNCTIONS) printf("start IGFirm_compute_balance_sheet\n");
	current_xmachine_IGFirm_holder = IGFirm_004_state->agents;
	while(current_xmachine_IGFirm_holder)
	{
		temp_xmachine_IGFirm_holder = current_xmachine_IGFirm_holder->next;
		current_xmachine_IGFirm = current_xmachine_IGFirm_holder->agent;
		current_xmachine_IGFirm_next_state = IGFirm_IGFirm_End_Financial_Management_Role_state;
		/* For backwards compatibility set current_xmachine */
		current_xmachine->xmachine_Firm = NULL;
		current_xmachine->xmachine_Household = NULL;
		current_xmachine->xmachine_Mall = NULL;
		current_xmachine->xmachine_IGFirm = NULL;
		current_xmachine->xmachine_Eurostat = NULL;
		current_xmachine->xmachine_Bank = NULL;
		current_xmachine->xmachine_Government = NULL;
		current_xmachine->xmachine_CentralBank = NULL;
		current_xmachine->xmachine_ClearingHouse = NULL;
		current_xmachine->xmachine_IGFirm = current_xmachine_IGFirm;

		

		

			i = IGFirm_compute_balance_sheet();

		

			if(i == 1)
			{
				free_IGFirm_agent(current_xmachine_IGFirm_holder, IGFirm_004_state);
			}
			else
			{
				transition_IGFirm_agent(current_xmachine_IGFirm_holder, IGFirm_004_state, IGFirm_IGFirm_End_Financial_Management_Role_state);
			}
		

		current_xmachine_IGFirm = NULL;

		current_xmachine_IGFirm_holder = temp_xmachine_IGFirm_holder;
	}
	if(FLAME_TEST_PRINT_START_AND_END_OF_MODEL_FUNCTIONS) printf("finish IGFirm_compute_balance_sheet\n");


	/* If mb is not read then leave sync complete until last possible moment */
	if(FLAME_accepted_consumption_1_message_board_read == 1)
	{
		if(FLAME_TEST_PRINT_START_AND_END_OF_LIBMBOARD_CALLS) printf("start MB_SyncComplete(b_accepted_consumption_1)\n");
		rc = MB_SyncComplete(b_accepted_consumption_1);
		if(FLAME_TEST_PRINT_START_AND_END_OF_LIBMBOARD_CALLS) printf("finsh MB_SyncComplete(b_accepted_consumption_1)\n");
		#ifdef ERRCHECK
		if (rc != MB_SUCCESS)
		{
		   fprintf(stderr, "ERROR: Could not complete sync of 'accepted_consumption_1' board\n");
		   switch(rc) {
				case MB_ERR_INVALID:
				   fprintf(stderr, "\t reason: 'accepted_consumption_1' board is invalid\n");
				   break;
			   case MB_ERR_MEMALLOC:
				   fprintf(stderr, "\t reason: out of memory\n");
				   break;
			   case MB_ERR_INTERNAL:
				   fprintf(stderr, "\t reason: internal error. Recompile libmoard in debug mode for more info \n");
				   break;
			   default:
				   fprintf(stderr, "\t MB_SyncComplete returned error code: %d (see libmboard docs for details)\n", rc);
				   break;
		   }
	
		   
		   exit(rc);
		}
		#endif
    
	}
	
	if(FLAME_TEST_PRINT_START_AND_END_OF_MODEL_FUNCTIONS) printf("start Household_receive_goods_read_rationing\n");
	current_xmachine_Household_holder = Household_10_state->agents;
	while(current_xmachine_Household_holder)
	{
		temp_xmachine_Household_holder = current_xmachine_Household_holder->next;
		current_xmachine_Household = current_xmachine_Household_holder->agent;
		current_xmachine_Household_next_state = Household_11_state;
		/* For backwards compatibility set current_xmachine */
		current_xmachine->xmachine_Firm = NULL;
		current_xmachine->xmachine_Household = NULL;
		current_xmachine->xmachine_Mall = NULL;
		current_xmachine->xmachine_IGFirm = NULL;
		current_xmachine->xmachine_Eurostat = NULL;
		current_xmachine->xmachine_Bank = NULL;
		current_xmachine->xmachine_Government = NULL;
		current_xmachine->xmachine_CentralBank = NULL;
		current_xmachine->xmachine_ClearingHouse = NULL;
		current_xmachine->xmachine_Household = current_xmachine_Household;

		

		
		rc = MB_Iterator_CreateFiltered(b_accepted_consumption_1, &i_accepted_consumption_1, &FLAME_filter_Household_Household_receive_goods_read_rationing_10_11_accepted_consumption_1, current_xmachine_Household);
		
		#ifdef ERRCHECK
		if (rc != MB_SUCCESS)
		{
		   fprintf(stderr, "ERROR: Could not create Iterator for 'accepted_consumption_1'\n");
		   switch(rc) {
		       case MB_ERR_INVALID:
		           fprintf(stderr, "\t reason: 'accepted_consumption_1' board is invalid\n");
		           break;
		       case MB_ERR_LOCKED:
	               fprintf(stderr, "\t reason: 'accepted_consumption_1' board is locked\n");
	               break;
	           case MB_ERR_MEMALLOC:
	               fprintf(stderr, "\t reason: out of memory\n");
	               break;
	           case MB_ERR_INTERNAL:
	               fprintf(stderr, "\t reason: internal error. Recompile libmoard in debug mode for more info \n");
	               break;
	           default:
	           
                   fprintf(stderr, "\t MB_Iterator_CreateFiltered returned error code: %d (see libmboard docs for details)\n", rc);
               
               
                   break;
		   }

		   
           exit(rc);
		}
		#endif
		
		

			i = Household_receive_goods_read_rationing();

		
		    rc = MB_Iterator_Delete(&i_accepted_consumption_1);
		    #ifdef ERRCHECK
		    if (rc != MB_SUCCESS)
		    {
		       fprintf(stderr, "ERROR: Could not delete 'accepted_consumption_1' iterator\n");
		       switch(rc) {
		           case MB_ERR_INVALID:
		               fprintf(stderr, "\t reason: 'accepted_consumption_1' iterator is invalid\n");
		               break;
		           case MB_ERR_INTERNAL:
		               fprintf(stderr, "\t reason: internal error. Recompile libmoard in debug mode for more info \n");
		               break;
		           default:
                       fprintf(stderr, "\t MB_Iterator_Delete returned error code: %d (see libmboard docs for details)\n", rc);
                       break;
		       }

		       
               exit(rc);
		    }
		    #endif
		

			if(i == 1)
			{
				free_Household_agent(current_xmachine_Household_holder, Household_10_state);
			}
			else
			{
				transition_Household_agent(current_xmachine_Household_holder, Household_10_state, Household_11_state);
			}
		

		current_xmachine_Household = NULL;

		current_xmachine_Household_holder = temp_xmachine_Household_holder;
	}
	if(FLAME_TEST_PRINT_START_AND_END_OF_MODEL_FUNCTIONS) printf("finish Household_receive_goods_read_rationing\n");


	if(FLAME_TEST_PRINT_START_AND_END_OF_MODEL_FUNCTIONS) printf("start Government_receive_goods_read_rationing\n");
	current_xmachine_Government_holder = Government_Gov_Cons_2_state->agents;
	while(current_xmachine_Government_holder)
	{
		temp_xmachine_Government_holder = current_xmachine_Government_holder->next;
		current_xmachine_Government = current_xmachine_Government_holder->agent;
		current_xmachine_Government_next_state = Government_Gov_Cons_3_state;
		/* For backwards compatibility set current_xmachine */
		current_xmachine->xmachine_Firm = NULL;
		current_xmachine->xmachine_Household = NULL;
		current_xmachine->xmachine_Mall = NULL;
		current_xmachine->xmachine_IGFirm = NULL;
		current_xmachine->xmachine_Eurostat = NULL;
		current_xmachine->xmachine_Bank = NULL;
		current_xmachine->xmachine_Government = NULL;
		current_xmachine->xmachine_CentralBank = NULL;
		current_xmachine->xmachine_ClearingHouse = NULL;
		current_xmachine->xmachine_Government = current_xmachine_Government;

		

		
		rc = MB_Iterator_CreateFiltered(b_accepted_consumption_1, &i_accepted_consumption_1, &FLAME_filter_Government_Government_receive_goods_read_rationing_Gov_Cons_2_Gov_Cons_3_accepted_consumption_1, current_xmachine_Government);
		
		#ifdef ERRCHECK
		if (rc != MB_SUCCESS)
		{
		   fprintf(stderr, "ERROR: Could not create Iterator for 'accepted_consumption_1'\n");
		   switch(rc) {
		       case MB_ERR_INVALID:
		           fprintf(stderr, "\t reason: 'accepted_consumption_1' board is invalid\n");
		           break;
		       case MB_ERR_LOCKED:
	               fprintf(stderr, "\t reason: 'accepted_consumption_1' board is locked\n");
	               break;
	           case MB_ERR_MEMALLOC:
	               fprintf(stderr, "\t reason: out of memory\n");
	               break;
	           case MB_ERR_INTERNAL:
	               fprintf(stderr, "\t reason: internal error. Recompile libmoard in debug mode for more info \n");
	               break;
	           default:
	           
                   fprintf(stderr, "\t MB_Iterator_CreateFiltered returned error code: %d (see libmboard docs for details)\n", rc);
               
               
                   break;
		   }

		   
           exit(rc);
		}
		#endif
		
		

			i = Government_receive_goods_read_rationing();

		
		    rc = MB_Iterator_Delete(&i_accepted_consumption_1);
		    #ifdef ERRCHECK
		    if (rc != MB_SUCCESS)
		    {
		       fprintf(stderr, "ERROR: Could not delete 'accepted_consumption_1' iterator\n");
		       switch(rc) {
		           case MB_ERR_INVALID:
		               fprintf(stderr, "\t reason: 'accepted_consumption_1' iterator is invalid\n");
		               break;
		           case MB_ERR_INTERNAL:
		               fprintf(stderr, "\t reason: internal error. Recompile libmoard in debug mode for more info \n");
		               break;
		           default:
                       fprintf(stderr, "\t MB_Iterator_Delete returned error code: %d (see libmboard docs for details)\n", rc);
                       break;
		       }

		       
               exit(rc);
		    }
		    #endif
		

			if(i == 1)
			{
				free_Government_agent(current_xmachine_Government_holder, Government_Gov_Cons_2_state);
			}
			else
			{
				transition_Government_agent(current_xmachine_Government_holder, Government_Gov_Cons_2_state, Government_Gov_Cons_3_state);
			}
		

		current_xmachine_Government = NULL;

		current_xmachine_Government_holder = temp_xmachine_Government_holder;
	}
	if(FLAME_TEST_PRINT_START_AND_END_OF_MODEL_FUNCTIONS) printf("finish Government_receive_goods_read_rationing\n");


/* End of layer number 73 */

/* Clear message boards that have finished being used
 * and sync complete if doing late sync complete */

if(FLAME_accepted_consumption_1_message_board_read == 0)
{
	/*printf("%d> accepted_consumption_1 message board sync complete late as no agents reading any messages of this type\n", node_number);*/
	
	if(FLAME_TEST_PRINT_START_AND_END_OF_LIBMBOARD_CALLS) printf("start MB_SyncComplete(b_accepted_consumption_1)\n");
	rc = MB_SyncComplete(b_accepted_consumption_1);
	if(FLAME_TEST_PRINT_START_AND_END_OF_LIBMBOARD_CALLS) printf("finsh MB_SyncComplete(b_accepted_consumption_1)\n");
	#ifdef ERRCHECK
	if (rc != MB_SUCCESS)
	{
	   fprintf(stderr, "ERROR: Could not complete sync of 'accepted_consumption_1' board\n");
	   switch(rc) {
			case MB_ERR_INVALID:
			   fprintf(stderr, "\t reason: 'accepted_consumption_1' board is invalid\n");
			   break;
		   case MB_ERR_MEMALLOC:
			   fprintf(stderr, "\t reason: out of memory\n");
			   break;
		   case MB_ERR_INTERNAL:
			   fprintf(stderr, "\t reason: internal error. Recompile libmoard in debug mode for more info \n");
			   break;
		   default:
			   fprintf(stderr, "\t MB_SyncComplete returned error code: %d (see libmboard docs for details)\n", rc);
			   break;
	   }

	   
	   exit(rc);
	}
	#endif
}

    rc = MB_Clear(b_accepted_consumption_1);
    #ifdef ERRCHECK
    if (rc != MB_SUCCESS)
    {
       fprintf(stderr, "ERROR: Could not clear 'accepted_consumption_1' board\n");
       switch(rc) {
           case MB_ERR_INVALID:
               fprintf(stderr, "\t reason: 'accepted_consumption_1' board is invalid\n");
               break;
           case MB_ERR_LOCKED:
               fprintf(stderr, "\t reason: 'accepted_consumption_1' board is locked\n");
               break;
           case MB_ERR_INTERNAL:
               fprintf(stderr, "\t reason: internal error. Recompile libmoard in debug mode for more info \n");
               break;
           default:
               fprintf(stderr, "\t MB_Clear returned error code: %d (see libmboard docs for details)\n", rc);
               break;

       }

       
       exit(rc);
    }
    #endif


	/* If mb is not read then leave sync complete until last possible moment */
	if(FLAME_quality_price_info_2_message_board_read == 1)
	{
		if(FLAME_TEST_PRINT_START_AND_END_OF_LIBMBOARD_CALLS) printf("start MB_SyncComplete(b_quality_price_info_2)\n");
		rc = MB_SyncComplete(b_quality_price_info_2);
		if(FLAME_TEST_PRINT_START_AND_END_OF_LIBMBOARD_CALLS) printf("finsh MB_SyncComplete(b_quality_price_info_2)\n");
		#ifdef ERRCHECK
		if (rc != MB_SUCCESS)
		{
		   fprintf(stderr, "ERROR: Could not complete sync of 'quality_price_info_2' board\n");
		   switch(rc) {
				case MB_ERR_INVALID:
				   fprintf(stderr, "\t reason: 'quality_price_info_2' board is invalid\n");
				   break;
			   case MB_ERR_MEMALLOC:
				   fprintf(stderr, "\t reason: out of memory\n");
				   break;
			   case MB_ERR_INTERNAL:
				   fprintf(stderr, "\t reason: internal error. Recompile libmoard in debug mode for more info \n");
				   break;
			   default:
				   fprintf(stderr, "\t MB_SyncComplete returned error code: %d (see libmboard docs for details)\n", rc);
				   break;
		   }
	
		   
		   exit(rc);
		}
		#endif
    
	}
	
	if(FLAME_TEST_PRINT_START_AND_END_OF_MODEL_FUNCTIONS) printf("start Government_rank_and_buy_goods_2\n");
	current_xmachine_Government_holder = Government_Gov_Cons_3_state->agents;
	while(current_xmachine_Government_holder)
	{
		temp_xmachine_Government_holder = current_xmachine_Government_holder->next;
		current_xmachine_Government = current_xmachine_Government_holder->agent;
		current_xmachine_Government_next_state = Government_Gov_Cons_4_state;
		/* For backwards compatibility set current_xmachine */
		current_xmachine->xmachine_Firm = NULL;
		current_xmachine->xmachine_Household = NULL;
		current_xmachine->xmachine_Mall = NULL;
		current_xmachine->xmachine_IGFirm = NULL;
		current_xmachine->xmachine_Eurostat = NULL;
		current_xmachine->xmachine_Bank = NULL;
		current_xmachine->xmachine_Government = NULL;
		current_xmachine->xmachine_CentralBank = NULL;
		current_xmachine->xmachine_ClearingHouse = NULL;
		current_xmachine->xmachine_Government = current_xmachine_Government;

		

		
		rc = MB_Iterator_CreateFiltered(b_quality_price_info_2, &i_quality_price_info_2, &FLAME_filter_Government_Government_rank_and_buy_goods_2_Gov_Cons_3_Gov_Cons_4_quality_price_info_2, current_xmachine_Government);
		
		#ifdef ERRCHECK
		if (rc != MB_SUCCESS)
		{
		   fprintf(stderr, "ERROR: Could not create Iterator for 'quality_price_info_2'\n");
		   switch(rc) {
		       case MB_ERR_INVALID:
		           fprintf(stderr, "\t reason: 'quality_price_info_2' board is invalid\n");
		           break;
		       case MB_ERR_LOCKED:
	               fprintf(stderr, "\t reason: 'quality_price_info_2' board is locked\n");
	               break;
	           case MB_ERR_MEMALLOC:
	               fprintf(stderr, "\t reason: out of memory\n");
	               break;
	           case MB_ERR_INTERNAL:
	               fprintf(stderr, "\t reason: internal error. Recompile libmoard in debug mode for more info \n");
	               break;
	           default:
	           
                   fprintf(stderr, "\t MB_Iterator_CreateFiltered returned error code: %d (see libmboard docs for details)\n", rc);
               
               
                   break;
		   }

		   
           exit(rc);
		}
		#endif
		
		

			i = Government_rank_and_buy_goods_2();

		
		    rc = MB_Iterator_Delete(&i_quality_price_info_2);
		    #ifdef ERRCHECK
		    if (rc != MB_SUCCESS)
		    {
		       fprintf(stderr, "ERROR: Could not delete 'quality_price_info_2' iterator\n");
		       switch(rc) {
		           case MB_ERR_INVALID:
		               fprintf(stderr, "\t reason: 'quality_price_info_2' iterator is invalid\n");
		               break;
		           case MB_ERR_INTERNAL:
		               fprintf(stderr, "\t reason: internal error. Recompile libmoard in debug mode for more info \n");
		               break;
		           default:
                       fprintf(stderr, "\t MB_Iterator_Delete returned error code: %d (see libmboard docs for details)\n", rc);
                       break;
		       }

		       
               exit(rc);
		    }
		    #endif
		

			if(i == 1)
			{
				free_Government_agent(current_xmachine_Government_holder, Government_Gov_Cons_3_state);
			}
			else
			{
				transition_Government_agent(current_xmachine_Government_holder, Government_Gov_Cons_3_state, Government_Gov_Cons_4_state);
			}
		

		current_xmachine_Government = NULL;

		current_xmachine_Government_holder = temp_xmachine_Government_holder;
	}
	if(FLAME_TEST_PRINT_START_AND_END_OF_MODEL_FUNCTIONS) printf("finish Government_rank_and_buy_goods_2\n");


	if(FLAME_TEST_PRINT_START_AND_END_OF_MODEL_FUNCTIONS) printf("start idle\n");
	current_xmachine_IGFirm_holder = IGFirm_IGFirm_End_Financial_Management_Role_state->agents;
	while(current_xmachine_IGFirm_holder)
	{
		temp_xmachine_IGFirm_holder = current_xmachine_IGFirm_holder->next;
		current_xmachine_IGFirm = current_xmachine_IGFirm_holder->agent;
		current_xmachine_IGFirm_next_state = IGFirm_IGFirm_End_Branches_state;
		/* For backwards compatibility set current_xmachine */
		current_xmachine->xmachine_Firm = NULL;
		current_xmachine->xmachine_Household = NULL;
		current_xmachine->xmachine_Mall = NULL;
		current_xmachine->xmachine_IGFirm = NULL;
		current_xmachine->xmachine_Eurostat = NULL;
		current_xmachine->xmachine_Bank = NULL;
		current_xmachine->xmachine_Government = NULL;
		current_xmachine->xmachine_CentralBank = NULL;
		current_xmachine->xmachine_ClearingHouse = NULL;
		current_xmachine->xmachine_IGFirm = current_xmachine_IGFirm;

		

		

			i = idle();

		

			if(i == 1)
			{
				free_IGFirm_agent(current_xmachine_IGFirm_holder, IGFirm_IGFirm_End_Financial_Management_Role_state);
			}
			else
			{
				transition_IGFirm_agent(current_xmachine_IGFirm_holder, IGFirm_IGFirm_End_Financial_Management_Role_state, IGFirm_IGFirm_End_Branches_state);
			}
		

		current_xmachine_IGFirm = NULL;

		current_xmachine_IGFirm_holder = temp_xmachine_IGFirm_holder;
	}
	if(FLAME_TEST_PRINT_START_AND_END_OF_MODEL_FUNCTIONS) printf("finish idle\n");


	if(FLAME_TEST_PRINT_START_AND_END_OF_MODEL_FUNCTIONS) printf("start Household_set_values_zero\n");
	current_xmachine_Household_holder = Household_11_state->agents;
	while(current_xmachine_Household_holder)
	{
		temp_xmachine_Household_holder = current_xmachine_Household_holder->next;
		current_xmachine_Household = current_xmachine_Household_holder->agent;
		current_xmachine_Household_next_state = Household_14_state;
		/* For backwards compatibility set current_xmachine */
		current_xmachine->xmachine_Firm = NULL;
		current_xmachine->xmachine_Household = NULL;
		current_xmachine->xmachine_Mall = NULL;
		current_xmachine->xmachine_IGFirm = NULL;
		current_xmachine->xmachine_Eurostat = NULL;
		current_xmachine->xmachine_Bank = NULL;
		current_xmachine->xmachine_Government = NULL;
		current_xmachine->xmachine_CentralBank = NULL;
		current_xmachine->xmachine_ClearingHouse = NULL;
		current_xmachine->xmachine_Household = current_xmachine_Household;

		if(FLAME_condition_Household_Household_set_values_zero_11_14(current_xmachine_Household)==1)
		{

		

			i = Household_set_values_zero();

		

			if(i == 1)
			{
				free_Household_agent(current_xmachine_Household_holder, Household_11_state);
			}
			else
			{
				transition_Household_agent(current_xmachine_Household_holder, Household_11_state, Household_14_state);
			}
		}

		current_xmachine_Household = NULL;

		current_xmachine_Household_holder = temp_xmachine_Household_holder;
	}
	if(FLAME_TEST_PRINT_START_AND_END_OF_MODEL_FUNCTIONS) printf("finish Household_set_values_zero\n");


	if(FLAME_TEST_PRINT_START_AND_END_OF_MODEL_FUNCTIONS) printf("start Household_rank_and_buy_goods_2\n");
	current_xmachine_Household_holder = Household_11_state->agents;
	while(current_xmachine_Household_holder)
	{
		temp_xmachine_Household_holder = current_xmachine_Household_holder->next;
		current_xmachine_Household = current_xmachine_Household_holder->agent;
		current_xmachine_Household_next_state = Household_12_state;
		/* For backwards compatibility set current_xmachine */
		current_xmachine->xmachine_Firm = NULL;
		current_xmachine->xmachine_Household = NULL;
		current_xmachine->xmachine_Mall = NULL;
		current_xmachine->xmachine_IGFirm = NULL;
		current_xmachine->xmachine_Eurostat = NULL;
		current_xmachine->xmachine_Bank = NULL;
		current_xmachine->xmachine_Government = NULL;
		current_xmachine->xmachine_CentralBank = NULL;
		current_xmachine->xmachine_ClearingHouse = NULL;
		current_xmachine->xmachine_Household = current_xmachine_Household;

		if(FLAME_condition_Household_Household_rank_and_buy_goods_2_11_12(current_xmachine_Household)==1)
		{

		
		rc = MB_Iterator_CreateFiltered(b_quality_price_info_2, &i_quality_price_info_2, &FLAME_filter_Household_Household_rank_and_buy_goods_2_11_12_quality_price_info_2, current_xmachine_Household);
		
		#ifdef ERRCHECK
		if (rc != MB_SUCCESS)
		{
		   fprintf(stderr, "ERROR: Could not create Iterator for 'quality_price_info_2'\n");
		   switch(rc) {
		       case MB_ERR_INVALID:
		           fprintf(stderr, "\t reason: 'quality_price_info_2' board is invalid\n");
		           break;
		       case MB_ERR_LOCKED:
	               fprintf(stderr, "\t reason: 'quality_price_info_2' board is locked\n");
	               break;
	           case MB_ERR_MEMALLOC:
	               fprintf(stderr, "\t reason: out of memory\n");
	               break;
	           case MB_ERR_INTERNAL:
	               fprintf(stderr, "\t reason: internal error. Recompile libmoard in debug mode for more info \n");
	               break;
	           default:
	           
                   fprintf(stderr, "\t MB_Iterator_CreateFiltered returned error code: %d (see libmboard docs for details)\n", rc);
               
               
                   break;
		   }

		   
           exit(rc);
		}
		#endif
		
		

			i = Household_rank_and_buy_goods_2();

		
		    rc = MB_Iterator_Delete(&i_quality_price_info_2);
		    #ifdef ERRCHECK
		    if (rc != MB_SUCCESS)
		    {
		       fprintf(stderr, "ERROR: Could not delete 'quality_price_info_2' iterator\n");
		       switch(rc) {
		           case MB_ERR_INVALID:
		               fprintf(stderr, "\t reason: 'quality_price_info_2' iterator is invalid\n");
		               break;
		           case MB_ERR_INTERNAL:
		               fprintf(stderr, "\t reason: internal error. Recompile libmoard in debug mode for more info \n");
		               break;
		           default:
                       fprintf(stderr, "\t MB_Iterator_Delete returned error code: %d (see libmboard docs for details)\n", rc);
                       break;
		       }

		       
               exit(rc);
		    }
		    #endif
		

			if(i == 1)
			{
				free_Household_agent(current_xmachine_Household_holder, Household_11_state);
			}
			else
			{
				transition_Household_agent(current_xmachine_Household_holder, Household_11_state, Household_12_state);
			}
		}

		current_xmachine_Household = NULL;

		current_xmachine_Household_holder = temp_xmachine_Household_holder;
	}
	if(FLAME_TEST_PRINT_START_AND_END_OF_MODEL_FUNCTIONS) printf("finish Household_rank_and_buy_goods_2\n");

	if(FLAME_consumption_request_2_message_board_write == 1)
	{

		if(FLAME_TEST_PRINT_START_AND_END_OF_LIBMBOARD_CALLS) printf("start MB_SyncStart(b_consumption_request_2)\n");
		rc = MB_SyncStart(b_consumption_request_2);
		if(FLAME_TEST_PRINT_START_AND_END_OF_LIBMBOARD_CALLS) printf("finish MB_SyncStart(b_consumption_request_2)\n");
		#ifdef ERRCHECK
		if (rc != MB_SUCCESS)
		{
		   fprintf(stderr, "ERROR: Could not start sync of 'consumption_request_2' board\n");
		   switch(rc) {
			   case MB_ERR_INVALID:
				   fprintf(stderr, "\t reason: 'consumption_request_2' board is invalid\n");
				   break;
			   case MB_ERR_LOCKED:
				   fprintf(stderr, "\t reason: 'consumption_request_2' board is locked\n");
				   break;
			   case MB_ERR_MEMALLOC:
				   fprintf(stderr, "\t reason: out of memory\n");
				   break;
			   case MB_ERR_INTERNAL:
				   fprintf(stderr, "\t reason: internal error. Recompile libmoard in debug mode for more info \n");
				   break;
			   default:
				   fprintf(stderr, "\t MB_SyncStart returned error code: %d (see libmboard docs for details)\n", rc);
				   break;
		   }

			
			exit(rc);
		}
		#endif
    }
    


/* End of layer number 74 */

/* Clear message boards that have finished being used
 * and sync complete if doing late sync complete */

if(FLAME_quality_price_info_2_message_board_read == 0)
{
	/*printf("%d> quality_price_info_2 message board sync complete late as no agents reading any messages of this type\n", node_number);*/
	
	if(FLAME_TEST_PRINT_START_AND_END_OF_LIBMBOARD_CALLS) printf("start MB_SyncComplete(b_quality_price_info_2)\n");
	rc = MB_SyncComplete(b_quality_price_info_2);
	if(FLAME_TEST_PRINT_START_AND_END_OF_LIBMBOARD_CALLS) printf("finsh MB_SyncComplete(b_quality_price_info_2)\n");
	#ifdef ERRCHECK
	if (rc != MB_SUCCESS)
	{
	   fprintf(stderr, "ERROR: Could not complete sync of 'quality_price_info_2' board\n");
	   switch(rc) {
			case MB_ERR_INVALID:
			   fprintf(stderr, "\t reason: 'quality_price_info_2' board is invalid\n");
			   break;
		   case MB_ERR_MEMALLOC:
			   fprintf(stderr, "\t reason: out of memory\n");
			   break;
		   case MB_ERR_INTERNAL:
			   fprintf(stderr, "\t reason: internal error. Recompile libmoard in debug mode for more info \n");
			   break;
		   default:
			   fprintf(stderr, "\t MB_SyncComplete returned error code: %d (see libmboard docs for details)\n", rc);
			   break;
	   }

	   
	   exit(rc);
	}
	#endif
}

    rc = MB_Clear(b_quality_price_info_2);
    #ifdef ERRCHECK
    if (rc != MB_SUCCESS)
    {
       fprintf(stderr, "ERROR: Could not clear 'quality_price_info_2' board\n");
       switch(rc) {
           case MB_ERR_INVALID:
               fprintf(stderr, "\t reason: 'quality_price_info_2' board is invalid\n");
               break;
           case MB_ERR_LOCKED:
               fprintf(stderr, "\t reason: 'quality_price_info_2' board is locked\n");
               break;
           case MB_ERR_INTERNAL:
               fprintf(stderr, "\t reason: internal error. Recompile libmoard in debug mode for more info \n");
               break;
           default:
               fprintf(stderr, "\t MB_Clear returned error code: %d (see libmboard docs for details)\n", rc);
               break;

       }

       
       exit(rc);
    }
    #endif


	if(FLAME_TEST_PRINT_START_AND_END_OF_MODEL_FUNCTIONS) printf("start IGFirm_send_data_to_Eurostat\n");
	current_xmachine_IGFirm_holder = IGFirm_IGFirm_End_Branches_state->agents;
	while(current_xmachine_IGFirm_holder)
	{
		temp_xmachine_IGFirm_holder = current_xmachine_IGFirm_holder->next;
		current_xmachine_IGFirm = current_xmachine_IGFirm_holder->agent;
		current_xmachine_IGFirm_next_state = IGFirm_IGFirm_Send_Data_state;
		/* For backwards compatibility set current_xmachine */
		current_xmachine->xmachine_Firm = NULL;
		current_xmachine->xmachine_Household = NULL;
		current_xmachine->xmachine_Mall = NULL;
		current_xmachine->xmachine_IGFirm = NULL;
		current_xmachine->xmachine_Eurostat = NULL;
		current_xmachine->xmachine_Bank = NULL;
		current_xmachine->xmachine_Government = NULL;
		current_xmachine->xmachine_CentralBank = NULL;
		current_xmachine->xmachine_ClearingHouse = NULL;
		current_xmachine->xmachine_IGFirm = current_xmachine_IGFirm;

		if(FLAME_condition_IGFirm_IGFirm_send_data_to_Eurostat_IGFirm_End_Branches_IGFirm_Send_Data(current_xmachine_IGFirm)==1)
		{

		

			i = IGFirm_send_data_to_Eurostat();

		

			if(i == 1)
			{
				free_IGFirm_agent(current_xmachine_IGFirm_holder, IGFirm_IGFirm_End_Branches_state);
			}
			else
			{
				transition_IGFirm_agent(current_xmachine_IGFirm_holder, IGFirm_IGFirm_End_Branches_state, IGFirm_IGFirm_Send_Data_state);
			}
		}

		current_xmachine_IGFirm = NULL;

		current_xmachine_IGFirm_holder = temp_xmachine_IGFirm_holder;
	}
	if(FLAME_TEST_PRINT_START_AND_END_OF_MODEL_FUNCTIONS) printf("finish IGFirm_send_data_to_Eurostat\n");


	if(FLAME_TEST_PRINT_START_AND_END_OF_MODEL_FUNCTIONS) printf("start idle\n");
	current_xmachine_IGFirm_holder = IGFirm_IGFirm_End_Branches_state->agents;
	while(current_xmachine_IGFirm_holder)
	{
		temp_xmachine_IGFirm_holder = current_xmachine_IGFirm_holder->next;
		current_xmachine_IGFirm = current_xmachine_IGFirm_holder->agent;
		current_xmachine_IGFirm_next_state = IGFirm_06_state;
		/* For backwards compatibility set current_xmachine */
		current_xmachine->xmachine_Firm = NULL;
		current_xmachine->xmachine_Household = NULL;
		current_xmachine->xmachine_Mall = NULL;
		current_xmachine->xmachine_IGFirm = NULL;
		current_xmachine->xmachine_Eurostat = NULL;
		current_xmachine->xmachine_Bank = NULL;
		current_xmachine->xmachine_Government = NULL;
		current_xmachine->xmachine_CentralBank = NULL;
		current_xmachine->xmachine_ClearingHouse = NULL;
		current_xmachine->xmachine_IGFirm = current_xmachine_IGFirm;

		if(FLAME_condition_IGFirm_idle_IGFirm_End_Branches_06(current_xmachine_IGFirm)==1)
		{

		

			i = idle();

		

			if(i == 1)
			{
				free_IGFirm_agent(current_xmachine_IGFirm_holder, IGFirm_IGFirm_End_Branches_state);
			}
			else
			{
				transition_IGFirm_agent(current_xmachine_IGFirm_holder, IGFirm_IGFirm_End_Branches_state, IGFirm_06_state);
			}
		}

		current_xmachine_IGFirm = NULL;

		current_xmachine_IGFirm_holder = temp_xmachine_IGFirm_holder;
	}
	if(FLAME_TEST_PRINT_START_AND_END_OF_MODEL_FUNCTIONS) printf("finish idle\n");


	/* If mb is not read then leave sync complete until last possible moment */
	if(FLAME_consumption_request_2_message_board_read == 1)
	{
		if(FLAME_TEST_PRINT_START_AND_END_OF_LIBMBOARD_CALLS) printf("start MB_SyncComplete(b_consumption_request_2)\n");
		rc = MB_SyncComplete(b_consumption_request_2);
		if(FLAME_TEST_PRINT_START_AND_END_OF_LIBMBOARD_CALLS) printf("finsh MB_SyncComplete(b_consumption_request_2)\n");
		#ifdef ERRCHECK
		if (rc != MB_SUCCESS)
		{
		   fprintf(stderr, "ERROR: Could not complete sync of 'consumption_request_2' board\n");
		   switch(rc) {
				case MB_ERR_INVALID:
				   fprintf(stderr, "\t reason: 'consumption_request_2' board is invalid\n");
				   break;
			   case MB_ERR_MEMALLOC:
				   fprintf(stderr, "\t reason: out of memory\n");
				   break;
			   case MB_ERR_INTERNAL:
				   fprintf(stderr, "\t reason: internal error. Recompile libmoard in debug mode for more info \n");
				   break;
			   default:
				   fprintf(stderr, "\t MB_SyncComplete returned error code: %d (see libmboard docs for details)\n", rc);
				   break;
		   }
	
		   
		   exit(rc);
		}
		#endif
    
	}
	
	if(FLAME_TEST_PRINT_START_AND_END_OF_MODEL_FUNCTIONS) printf("start Mall_update_mall_stocks_sales_rationing_2\n");
	current_xmachine_Mall_holder = Mall_04_state->agents;
	while(current_xmachine_Mall_holder)
	{
		temp_xmachine_Mall_holder = current_xmachine_Mall_holder->next;
		current_xmachine_Mall = current_xmachine_Mall_holder->agent;
		current_xmachine_Mall_next_state = Mall_05_state;
		/* For backwards compatibility set current_xmachine */
		current_xmachine->xmachine_Firm = NULL;
		current_xmachine->xmachine_Household = NULL;
		current_xmachine->xmachine_Mall = NULL;
		current_xmachine->xmachine_IGFirm = NULL;
		current_xmachine->xmachine_Eurostat = NULL;
		current_xmachine->xmachine_Bank = NULL;
		current_xmachine->xmachine_Government = NULL;
		current_xmachine->xmachine_CentralBank = NULL;
		current_xmachine->xmachine_ClearingHouse = NULL;
		current_xmachine->xmachine_Mall = current_xmachine_Mall;

		

		
		rc = MB_Iterator_CreateFiltered(b_consumption_request_2, &i_consumption_request_2, &FLAME_filter_Mall_Mall_update_mall_stocks_sales_rationing_2_04_05_consumption_request_2, current_xmachine_Mall);
		
		#ifdef ERRCHECK
		if (rc != MB_SUCCESS)
		{
		   fprintf(stderr, "ERROR: Could not create Iterator for 'consumption_request_2'\n");
		   switch(rc) {
		       case MB_ERR_INVALID:
		           fprintf(stderr, "\t reason: 'consumption_request_2' board is invalid\n");
		           break;
		       case MB_ERR_LOCKED:
	               fprintf(stderr, "\t reason: 'consumption_request_2' board is locked\n");
	               break;
	           case MB_ERR_MEMALLOC:
	               fprintf(stderr, "\t reason: out of memory\n");
	               break;
	           case MB_ERR_INTERNAL:
	               fprintf(stderr, "\t reason: internal error. Recompile libmoard in debug mode for more info \n");
	               break;
	           default:
	           
                   fprintf(stderr, "\t MB_Iterator_CreateFiltered returned error code: %d (see libmboard docs for details)\n", rc);
               
               
                   break;
		   }

		   
           exit(rc);
		}
		#endif
		
		

			i = Mall_update_mall_stocks_sales_rationing_2();

		
		    rc = MB_Iterator_Delete(&i_consumption_request_2);
		    #ifdef ERRCHECK
		    if (rc != MB_SUCCESS)
		    {
		       fprintf(stderr, "ERROR: Could not delete 'consumption_request_2' iterator\n");
		       switch(rc) {
		           case MB_ERR_INVALID:
		               fprintf(stderr, "\t reason: 'consumption_request_2' iterator is invalid\n");
		               break;
		           case MB_ERR_INTERNAL:
		               fprintf(stderr, "\t reason: internal error. Recompile libmoard in debug mode for more info \n");
		               break;
		           default:
                       fprintf(stderr, "\t MB_Iterator_Delete returned error code: %d (see libmboard docs for details)\n", rc);
                       break;
		       }

		       
               exit(rc);
		    }
		    #endif
		

			if(i == 1)
			{
				free_Mall_agent(current_xmachine_Mall_holder, Mall_04_state);
			}
			else
			{
				transition_Mall_agent(current_xmachine_Mall_holder, Mall_04_state, Mall_05_state);
			}
		

		current_xmachine_Mall = NULL;

		current_xmachine_Mall_holder = temp_xmachine_Mall_holder;
	}
	if(FLAME_TEST_PRINT_START_AND_END_OF_MODEL_FUNCTIONS) printf("finish Mall_update_mall_stocks_sales_rationing_2\n");

	if(FLAME_accepted_consumption_2_message_board_write == 1)
	{

		if(FLAME_TEST_PRINT_START_AND_END_OF_LIBMBOARD_CALLS) printf("start MB_SyncStart(b_accepted_consumption_2)\n");
		rc = MB_SyncStart(b_accepted_consumption_2);
		if(FLAME_TEST_PRINT_START_AND_END_OF_LIBMBOARD_CALLS) printf("finish MB_SyncStart(b_accepted_consumption_2)\n");
		#ifdef ERRCHECK
		if (rc != MB_SUCCESS)
		{
		   fprintf(stderr, "ERROR: Could not start sync of 'accepted_consumption_2' board\n");
		   switch(rc) {
			   case MB_ERR_INVALID:
				   fprintf(stderr, "\t reason: 'accepted_consumption_2' board is invalid\n");
				   break;
			   case MB_ERR_LOCKED:
				   fprintf(stderr, "\t reason: 'accepted_consumption_2' board is locked\n");
				   break;
			   case MB_ERR_MEMALLOC:
				   fprintf(stderr, "\t reason: out of memory\n");
				   break;
			   case MB_ERR_INTERNAL:
				   fprintf(stderr, "\t reason: internal error. Recompile libmoard in debug mode for more info \n");
				   break;
			   default:
				   fprintf(stderr, "\t MB_SyncStart returned error code: %d (see libmboard docs for details)\n", rc);
				   break;
		   }

			
			exit(rc);
		}
		#endif
    }
    


/* End of layer number 75 */

/* Clear message boards that have finished being used
 * and sync complete if doing late sync complete */

if(FLAME_consumption_request_2_message_board_read == 0)
{
	/*printf("%d> consumption_request_2 message board sync complete late as no agents reading any messages of this type\n", node_number);*/
	
	if(FLAME_TEST_PRINT_START_AND_END_OF_LIBMBOARD_CALLS) printf("start MB_SyncComplete(b_consumption_request_2)\n");
	rc = MB_SyncComplete(b_consumption_request_2);
	if(FLAME_TEST_PRINT_START_AND_END_OF_LIBMBOARD_CALLS) printf("finsh MB_SyncComplete(b_consumption_request_2)\n");
	#ifdef ERRCHECK
	if (rc != MB_SUCCESS)
	{
	   fprintf(stderr, "ERROR: Could not complete sync of 'consumption_request_2' board\n");
	   switch(rc) {
			case MB_ERR_INVALID:
			   fprintf(stderr, "\t reason: 'consumption_request_2' board is invalid\n");
			   break;
		   case MB_ERR_MEMALLOC:
			   fprintf(stderr, "\t reason: out of memory\n");
			   break;
		   case MB_ERR_INTERNAL:
			   fprintf(stderr, "\t reason: internal error. Recompile libmoard in debug mode for more info \n");
			   break;
		   default:
			   fprintf(stderr, "\t MB_SyncComplete returned error code: %d (see libmboard docs for details)\n", rc);
			   break;
	   }

	   
	   exit(rc);
	}
	#endif
}

    rc = MB_Clear(b_consumption_request_2);
    #ifdef ERRCHECK
    if (rc != MB_SUCCESS)
    {
       fprintf(stderr, "ERROR: Could not clear 'consumption_request_2' board\n");
       switch(rc) {
           case MB_ERR_INVALID:
               fprintf(stderr, "\t reason: 'consumption_request_2' board is invalid\n");
               break;
           case MB_ERR_LOCKED:
               fprintf(stderr, "\t reason: 'consumption_request_2' board is locked\n");
               break;
           case MB_ERR_INTERNAL:
               fprintf(stderr, "\t reason: internal error. Recompile libmoard in debug mode for more info \n");
               break;
           default:
               fprintf(stderr, "\t MB_Clear returned error code: %d (see libmboard docs for details)\n", rc);
               break;

       }

       
       exit(rc);
    }
    #endif


	if(FLAME_TEST_PRINT_START_AND_END_OF_MODEL_FUNCTIONS) printf("start Mall_pay_firm\n");
	current_xmachine_Mall_holder = Mall_05_state->agents;
	while(current_xmachine_Mall_holder)
	{
		temp_xmachine_Mall_holder = current_xmachine_Mall_holder->next;
		current_xmachine_Mall = current_xmachine_Mall_holder->agent;
		current_xmachine_Mall_next_state = Mall_05a_state;
		/* For backwards compatibility set current_xmachine */
		current_xmachine->xmachine_Firm = NULL;
		current_xmachine->xmachine_Household = NULL;
		current_xmachine->xmachine_Mall = NULL;
		current_xmachine->xmachine_IGFirm = NULL;
		current_xmachine->xmachine_Eurostat = NULL;
		current_xmachine->xmachine_Bank = NULL;
		current_xmachine->xmachine_Government = NULL;
		current_xmachine->xmachine_CentralBank = NULL;
		current_xmachine->xmachine_ClearingHouse = NULL;
		current_xmachine->xmachine_Mall = current_xmachine_Mall;

		

		

			i = Mall_pay_firm();

		

			if(i == 1)
			{
				free_Mall_agent(current_xmachine_Mall_holder, Mall_05_state);
			}
			else
			{
				transition_Mall_agent(current_xmachine_Mall_holder, Mall_05_state, Mall_05a_state);
			}
		

		current_xmachine_Mall = NULL;

		current_xmachine_Mall_holder = temp_xmachine_Mall_holder;
	}
	if(FLAME_TEST_PRINT_START_AND_END_OF_MODEL_FUNCTIONS) printf("finish Mall_pay_firm\n");

	if(FLAME_sales_message_board_write == 1)
	{

		if(FLAME_TEST_PRINT_START_AND_END_OF_LIBMBOARD_CALLS) printf("start MB_SyncStart(b_sales)\n");
		rc = MB_SyncStart(b_sales);
		if(FLAME_TEST_PRINT_START_AND_END_OF_LIBMBOARD_CALLS) printf("finish MB_SyncStart(b_sales)\n");
		#ifdef ERRCHECK
		if (rc != MB_SUCCESS)
		{
		   fprintf(stderr, "ERROR: Could not start sync of 'sales' board\n");
		   switch(rc) {
			   case MB_ERR_INVALID:
				   fprintf(stderr, "\t reason: 'sales' board is invalid\n");
				   break;
			   case MB_ERR_LOCKED:
				   fprintf(stderr, "\t reason: 'sales' board is locked\n");
				   break;
			   case MB_ERR_MEMALLOC:
				   fprintf(stderr, "\t reason: out of memory\n");
				   break;
			   case MB_ERR_INTERNAL:
				   fprintf(stderr, "\t reason: internal error. Recompile libmoard in debug mode for more info \n");
				   break;
			   default:
				   fprintf(stderr, "\t MB_SyncStart returned error code: %d (see libmboard docs for details)\n", rc);
				   break;
		   }

			
			exit(rc);
		}
		#endif
    }
    


	if(FLAME_TEST_PRINT_START_AND_END_OF_MODEL_FUNCTIONS) printf("start IGFirm_compute_stock_flows\n");
	current_xmachine_IGFirm_holder = IGFirm_IGFirm_Send_Data_state->agents;
	while(current_xmachine_IGFirm_holder)
	{
		temp_xmachine_IGFirm_holder = current_xmachine_IGFirm_holder->next;
		current_xmachine_IGFirm = current_xmachine_IGFirm_holder->agent;
		current_xmachine_IGFirm_next_state = IGFirm_06_state;
		/* For backwards compatibility set current_xmachine */
		current_xmachine->xmachine_Firm = NULL;
		current_xmachine->xmachine_Household = NULL;
		current_xmachine->xmachine_Mall = NULL;
		current_xmachine->xmachine_IGFirm = NULL;
		current_xmachine->xmachine_Eurostat = NULL;
		current_xmachine->xmachine_Bank = NULL;
		current_xmachine->xmachine_Government = NULL;
		current_xmachine->xmachine_CentralBank = NULL;
		current_xmachine->xmachine_ClearingHouse = NULL;
		current_xmachine->xmachine_IGFirm = current_xmachine_IGFirm;

		

		

			i = IGFirm_compute_stock_flows();

		

			if(i == 1)
			{
				free_IGFirm_agent(current_xmachine_IGFirm_holder, IGFirm_IGFirm_Send_Data_state);
			}
			else
			{
				transition_IGFirm_agent(current_xmachine_IGFirm_holder, IGFirm_IGFirm_Send_Data_state, IGFirm_06_state);
			}
		

		current_xmachine_IGFirm = NULL;

		current_xmachine_IGFirm_holder = temp_xmachine_IGFirm_holder;
	}
	if(FLAME_TEST_PRINT_START_AND_END_OF_MODEL_FUNCTIONS) printf("finish IGFirm_compute_stock_flows\n");


	/* If mb is not read then leave sync complete until last possible moment */
	if(FLAME_accepted_consumption_2_message_board_read == 1)
	{
		if(FLAME_TEST_PRINT_START_AND_END_OF_LIBMBOARD_CALLS) printf("start MB_SyncComplete(b_accepted_consumption_2)\n");
		rc = MB_SyncComplete(b_accepted_consumption_2);
		if(FLAME_TEST_PRINT_START_AND_END_OF_LIBMBOARD_CALLS) printf("finsh MB_SyncComplete(b_accepted_consumption_2)\n");
		#ifdef ERRCHECK
		if (rc != MB_SUCCESS)
		{
		   fprintf(stderr, "ERROR: Could not complete sync of 'accepted_consumption_2' board\n");
		   switch(rc) {
				case MB_ERR_INVALID:
				   fprintf(stderr, "\t reason: 'accepted_consumption_2' board is invalid\n");
				   break;
			   case MB_ERR_MEMALLOC:
				   fprintf(stderr, "\t reason: out of memory\n");
				   break;
			   case MB_ERR_INTERNAL:
				   fprintf(stderr, "\t reason: internal error. Recompile libmoard in debug mode for more info \n");
				   break;
			   default:
				   fprintf(stderr, "\t MB_SyncComplete returned error code: %d (see libmboard docs for details)\n", rc);
				   break;
		   }
	
		   
		   exit(rc);
		}
		#endif
    
	}
	
	if(FLAME_TEST_PRINT_START_AND_END_OF_MODEL_FUNCTIONS) printf("start Household_receive_goods_read_rationing_2\n");
	current_xmachine_Household_holder = Household_12_state->agents;
	while(current_xmachine_Household_holder)
	{
		temp_xmachine_Household_holder = current_xmachine_Household_holder->next;
		current_xmachine_Household = current_xmachine_Household_holder->agent;
		current_xmachine_Household_next_state = Household_14_state;
		/* For backwards compatibility set current_xmachine */
		current_xmachine->xmachine_Firm = NULL;
		current_xmachine->xmachine_Household = NULL;
		current_xmachine->xmachine_Mall = NULL;
		current_xmachine->xmachine_IGFirm = NULL;
		current_xmachine->xmachine_Eurostat = NULL;
		current_xmachine->xmachine_Bank = NULL;
		current_xmachine->xmachine_Government = NULL;
		current_xmachine->xmachine_CentralBank = NULL;
		current_xmachine->xmachine_ClearingHouse = NULL;
		current_xmachine->xmachine_Household = current_xmachine_Household;

		

		
		rc = MB_Iterator_CreateFiltered(b_accepted_consumption_2, &i_accepted_consumption_2, &FLAME_filter_Household_Household_receive_goods_read_rationing_2_12_14_accepted_consumption_2, current_xmachine_Household);
		
		#ifdef ERRCHECK
		if (rc != MB_SUCCESS)
		{
		   fprintf(stderr, "ERROR: Could not create Iterator for 'accepted_consumption_2'\n");
		   switch(rc) {
		       case MB_ERR_INVALID:
		           fprintf(stderr, "\t reason: 'accepted_consumption_2' board is invalid\n");
		           break;
		       case MB_ERR_LOCKED:
	               fprintf(stderr, "\t reason: 'accepted_consumption_2' board is locked\n");
	               break;
	           case MB_ERR_MEMALLOC:
	               fprintf(stderr, "\t reason: out of memory\n");
	               break;
	           case MB_ERR_INTERNAL:
	               fprintf(stderr, "\t reason: internal error. Recompile libmoard in debug mode for more info \n");
	               break;
	           default:
	           
                   fprintf(stderr, "\t MB_Iterator_CreateFiltered returned error code: %d (see libmboard docs for details)\n", rc);
               
               
                   break;
		   }

		   
           exit(rc);
		}
		#endif
		
		

			i = Household_receive_goods_read_rationing_2();

		
		    rc = MB_Iterator_Delete(&i_accepted_consumption_2);
		    #ifdef ERRCHECK
		    if (rc != MB_SUCCESS)
		    {
		       fprintf(stderr, "ERROR: Could not delete 'accepted_consumption_2' iterator\n");
		       switch(rc) {
		           case MB_ERR_INVALID:
		               fprintf(stderr, "\t reason: 'accepted_consumption_2' iterator is invalid\n");
		               break;
		           case MB_ERR_INTERNAL:
		               fprintf(stderr, "\t reason: internal error. Recompile libmoard in debug mode for more info \n");
		               break;
		           default:
                       fprintf(stderr, "\t MB_Iterator_Delete returned error code: %d (see libmboard docs for details)\n", rc);
                       break;
		       }

		       
               exit(rc);
		    }
		    #endif
		

			if(i == 1)
			{
				free_Household_agent(current_xmachine_Household_holder, Household_12_state);
			}
			else
			{
				transition_Household_agent(current_xmachine_Household_holder, Household_12_state, Household_14_state);
			}
		

		current_xmachine_Household = NULL;

		current_xmachine_Household_holder = temp_xmachine_Household_holder;
	}
	if(FLAME_TEST_PRINT_START_AND_END_OF_MODEL_FUNCTIONS) printf("finish Household_receive_goods_read_rationing_2\n");


	if(FLAME_TEST_PRINT_START_AND_END_OF_MODEL_FUNCTIONS) printf("start Government_receive_goods_read_rationing_2\n");
	current_xmachine_Government_holder = Government_Gov_Cons_4_state->agents;
	while(current_xmachine_Government_holder)
	{
		temp_xmachine_Government_holder = current_xmachine_Government_holder->next;
		current_xmachine_Government = current_xmachine_Government_holder->agent;
		current_xmachine_Government_next_state = Government_Gov_Cons_5_state;
		/* For backwards compatibility set current_xmachine */
		current_xmachine->xmachine_Firm = NULL;
		current_xmachine->xmachine_Household = NULL;
		current_xmachine->xmachine_Mall = NULL;
		current_xmachine->xmachine_IGFirm = NULL;
		current_xmachine->xmachine_Eurostat = NULL;
		current_xmachine->xmachine_Bank = NULL;
		current_xmachine->xmachine_Government = NULL;
		current_xmachine->xmachine_CentralBank = NULL;
		current_xmachine->xmachine_ClearingHouse = NULL;
		current_xmachine->xmachine_Government = current_xmachine_Government;

		

		
		rc = MB_Iterator_CreateFiltered(b_accepted_consumption_2, &i_accepted_consumption_2, &FLAME_filter_Government_Government_receive_goods_read_rationing_2_Gov_Cons_4_Gov_Cons_5_accepted_consumption_2, current_xmachine_Government);
		
		#ifdef ERRCHECK
		if (rc != MB_SUCCESS)
		{
		   fprintf(stderr, "ERROR: Could not create Iterator for 'accepted_consumption_2'\n");
		   switch(rc) {
		       case MB_ERR_INVALID:
		           fprintf(stderr, "\t reason: 'accepted_consumption_2' board is invalid\n");
		           break;
		       case MB_ERR_LOCKED:
	               fprintf(stderr, "\t reason: 'accepted_consumption_2' board is locked\n");
	               break;
	           case MB_ERR_MEMALLOC:
	               fprintf(stderr, "\t reason: out of memory\n");
	               break;
	           case MB_ERR_INTERNAL:
	               fprintf(stderr, "\t reason: internal error. Recompile libmoard in debug mode for more info \n");
	               break;
	           default:
	           
                   fprintf(stderr, "\t MB_Iterator_CreateFiltered returned error code: %d (see libmboard docs for details)\n", rc);
               
               
                   break;
		   }

		   
           exit(rc);
		}
		#endif
		
		

			i = Government_receive_goods_read_rationing_2();

		
		    rc = MB_Iterator_Delete(&i_accepted_consumption_2);
		    #ifdef ERRCHECK
		    if (rc != MB_SUCCESS)
		    {
		       fprintf(stderr, "ERROR: Could not delete 'accepted_consumption_2' iterator\n");
		       switch(rc) {
		           case MB_ERR_INVALID:
		               fprintf(stderr, "\t reason: 'accepted_consumption_2' iterator is invalid\n");
		               break;
		           case MB_ERR_INTERNAL:
		               fprintf(stderr, "\t reason: internal error. Recompile libmoard in debug mode for more info \n");
		               break;
		           default:
                       fprintf(stderr, "\t MB_Iterator_Delete returned error code: %d (see libmboard docs for details)\n", rc);
                       break;
		       }

		       
               exit(rc);
		    }
		    #endif
		

			if(i == 1)
			{
				free_Government_agent(current_xmachine_Government_holder, Government_Gov_Cons_4_state);
			}
			else
			{
				transition_Government_agent(current_xmachine_Government_holder, Government_Gov_Cons_4_state, Government_Gov_Cons_5_state);
			}
		

		current_xmachine_Government = NULL;

		current_xmachine_Government_holder = temp_xmachine_Government_holder;
	}
	if(FLAME_TEST_PRINT_START_AND_END_OF_MODEL_FUNCTIONS) printf("finish Government_receive_goods_read_rationing_2\n");


/* End of layer number 76 */

/* Clear message boards that have finished being used
 * and sync complete if doing late sync complete */

if(FLAME_accepted_consumption_2_message_board_read == 0)
{
	/*printf("%d> accepted_consumption_2 message board sync complete late as no agents reading any messages of this type\n", node_number);*/
	
	if(FLAME_TEST_PRINT_START_AND_END_OF_LIBMBOARD_CALLS) printf("start MB_SyncComplete(b_accepted_consumption_2)\n");
	rc = MB_SyncComplete(b_accepted_consumption_2);
	if(FLAME_TEST_PRINT_START_AND_END_OF_LIBMBOARD_CALLS) printf("finsh MB_SyncComplete(b_accepted_consumption_2)\n");
	#ifdef ERRCHECK
	if (rc != MB_SUCCESS)
	{
	   fprintf(stderr, "ERROR: Could not complete sync of 'accepted_consumption_2' board\n");
	   switch(rc) {
			case MB_ERR_INVALID:
			   fprintf(stderr, "\t reason: 'accepted_consumption_2' board is invalid\n");
			   break;
		   case MB_ERR_MEMALLOC:
			   fprintf(stderr, "\t reason: out of memory\n");
			   break;
		   case MB_ERR_INTERNAL:
			   fprintf(stderr, "\t reason: internal error. Recompile libmoard in debug mode for more info \n");
			   break;
		   default:
			   fprintf(stderr, "\t MB_SyncComplete returned error code: %d (see libmboard docs for details)\n", rc);
			   break;
	   }

	   
	   exit(rc);
	}
	#endif
}

    rc = MB_Clear(b_accepted_consumption_2);
    #ifdef ERRCHECK
    if (rc != MB_SUCCESS)
    {
       fprintf(stderr, "ERROR: Could not clear 'accepted_consumption_2' board\n");
       switch(rc) {
           case MB_ERR_INVALID:
               fprintf(stderr, "\t reason: 'accepted_consumption_2' board is invalid\n");
               break;
           case MB_ERR_LOCKED:
               fprintf(stderr, "\t reason: 'accepted_consumption_2' board is locked\n");
               break;
           case MB_ERR_INTERNAL:
               fprintf(stderr, "\t reason: internal error. Recompile libmoard in debug mode for more info \n");
               break;
           default:
               fprintf(stderr, "\t MB_Clear returned error code: %d (see libmboard docs for details)\n", rc);
               break;

       }

       
       exit(rc);
    }
    #endif


	if(FLAME_TEST_PRINT_START_AND_END_OF_MODEL_FUNCTIONS) printf("start Government_handle_leftover_budget\n");
	current_xmachine_Government_holder = Government_Gov_Cons_5_state->agents;
	while(current_xmachine_Government_holder)
	{
		temp_xmachine_Government_holder = current_xmachine_Government_holder->next;
		current_xmachine_Government = current_xmachine_Government_holder->agent;
		current_xmachine_Government_next_state = Government_End_Gov_Consumer_Role_state;
		/* For backwards compatibility set current_xmachine */
		current_xmachine->xmachine_Firm = NULL;
		current_xmachine->xmachine_Household = NULL;
		current_xmachine->xmachine_Mall = NULL;
		current_xmachine->xmachine_IGFirm = NULL;
		current_xmachine->xmachine_Eurostat = NULL;
		current_xmachine->xmachine_Bank = NULL;
		current_xmachine->xmachine_Government = NULL;
		current_xmachine->xmachine_CentralBank = NULL;
		current_xmachine->xmachine_ClearingHouse = NULL;
		current_xmachine->xmachine_Government = current_xmachine_Government;

		

		

			i = Government_handle_leftover_budget();

		

			if(i == 1)
			{
				free_Government_agent(current_xmachine_Government_holder, Government_Gov_Cons_5_state);
			}
			else
			{
				transition_Government_agent(current_xmachine_Government_holder, Government_Gov_Cons_5_state, Government_End_Gov_Consumer_Role_state);
			}
		

		current_xmachine_Government = NULL;

		current_xmachine_Government_holder = temp_xmachine_Government_holder;
	}
	if(FLAME_TEST_PRINT_START_AND_END_OF_MODEL_FUNCTIONS) printf("finish Government_handle_leftover_budget\n");


	if(FLAME_TEST_PRINT_START_AND_END_OF_MODEL_FUNCTIONS) printf("start IGFirm_receive_stock_info_dummy\n");
	current_xmachine_IGFirm_holder = IGFirm_06_state->agents;
	while(current_xmachine_IGFirm_holder)
	{
		temp_xmachine_IGFirm_holder = current_xmachine_IGFirm_holder->next;
		current_xmachine_IGFirm = current_xmachine_IGFirm_holder->agent;
		current_xmachine_IGFirm_next_state = IGFirm_07_state;
		/* For backwards compatibility set current_xmachine */
		current_xmachine->xmachine_Firm = NULL;
		current_xmachine->xmachine_Household = NULL;
		current_xmachine->xmachine_Mall = NULL;
		current_xmachine->xmachine_IGFirm = NULL;
		current_xmachine->xmachine_Eurostat = NULL;
		current_xmachine->xmachine_Bank = NULL;
		current_xmachine->xmachine_Government = NULL;
		current_xmachine->xmachine_CentralBank = NULL;
		current_xmachine->xmachine_ClearingHouse = NULL;
		current_xmachine->xmachine_IGFirm = current_xmachine_IGFirm;

		

		

			i = IGFirm_receive_stock_info_dummy();

		

			if(i == 1)
			{
				free_IGFirm_agent(current_xmachine_IGFirm_holder, IGFirm_06_state);
			}
			else
			{
				transition_IGFirm_agent(current_xmachine_IGFirm_holder, IGFirm_06_state, IGFirm_07_state);
			}
		

		current_xmachine_IGFirm = NULL;

		current_xmachine_IGFirm_holder = temp_xmachine_IGFirm_holder;
	}
	if(FLAME_TEST_PRINT_START_AND_END_OF_MODEL_FUNCTIONS) printf("finish IGFirm_receive_stock_info_dummy\n");


	if(FLAME_TEST_PRINT_START_AND_END_OF_MODEL_FUNCTIONS) printf("start Household_handle_leftover_budget\n");
	current_xmachine_Household_holder = Household_14_state->agents;
	while(current_xmachine_Household_holder)
	{
		temp_xmachine_Household_holder = current_xmachine_Household_holder->next;
		current_xmachine_Household = current_xmachine_Household_holder->agent;
		current_xmachine_Household_next_state = Household_15_state;
		/* For backwards compatibility set current_xmachine */
		current_xmachine->xmachine_Firm = NULL;
		current_xmachine->xmachine_Household = NULL;
		current_xmachine->xmachine_Mall = NULL;
		current_xmachine->xmachine_IGFirm = NULL;
		current_xmachine->xmachine_Eurostat = NULL;
		current_xmachine->xmachine_Bank = NULL;
		current_xmachine->xmachine_Government = NULL;
		current_xmachine->xmachine_CentralBank = NULL;
		current_xmachine->xmachine_ClearingHouse = NULL;
		current_xmachine->xmachine_Household = current_xmachine_Household;

		

		

			i = Household_handle_leftover_budget();

		

			if(i == 1)
			{
				free_Household_agent(current_xmachine_Household_holder, Household_14_state);
			}
			else
			{
				transition_Household_agent(current_xmachine_Household_holder, Household_14_state, Household_15_state);
			}
		

		current_xmachine_Household = NULL;

		current_xmachine_Household_holder = temp_xmachine_Household_holder;
	}
	if(FLAME_TEST_PRINT_START_AND_END_OF_MODEL_FUNCTIONS) printf("finish Household_handle_leftover_budget\n");


	/* If mb is not read then leave sync complete until last possible moment */
	if(FLAME_sales_message_board_read == 1)
	{
		if(FLAME_TEST_PRINT_START_AND_END_OF_LIBMBOARD_CALLS) printf("start MB_SyncComplete(b_sales)\n");
		rc = MB_SyncComplete(b_sales);
		if(FLAME_TEST_PRINT_START_AND_END_OF_LIBMBOARD_CALLS) printf("finsh MB_SyncComplete(b_sales)\n");
		#ifdef ERRCHECK
		if (rc != MB_SUCCESS)
		{
		   fprintf(stderr, "ERROR: Could not complete sync of 'sales' board\n");
		   switch(rc) {
				case MB_ERR_INVALID:
				   fprintf(stderr, "\t reason: 'sales' board is invalid\n");
				   break;
			   case MB_ERR_MEMALLOC:
				   fprintf(stderr, "\t reason: out of memory\n");
				   break;
			   case MB_ERR_INTERNAL:
				   fprintf(stderr, "\t reason: internal error. Recompile libmoard in debug mode for more info \n");
				   break;
			   default:
				   fprintf(stderr, "\t MB_SyncComplete returned error code: %d (see libmboard docs for details)\n", rc);
				   break;
		   }
	
		   
		   exit(rc);
		}
		#endif
    
	}
	
	if(FLAME_TEST_PRINT_START_AND_END_OF_MODEL_FUNCTIONS) printf("start Firm_calc_revenue\n");
	current_xmachine_Firm_holder = Firm_Firm_Start_Seller_Role_state->agents;
	while(current_xmachine_Firm_holder)
	{
		temp_xmachine_Firm_holder = current_xmachine_Firm_holder->next;
		current_xmachine_Firm = current_xmachine_Firm_holder->agent;
		current_xmachine_Firm_next_state = Firm_Firm_End_Seller_Role_state;
		/* For backwards compatibility set current_xmachine */
		current_xmachine->xmachine_Firm = NULL;
		current_xmachine->xmachine_Household = NULL;
		current_xmachine->xmachine_Mall = NULL;
		current_xmachine->xmachine_IGFirm = NULL;
		current_xmachine->xmachine_Eurostat = NULL;
		current_xmachine->xmachine_Bank = NULL;
		current_xmachine->xmachine_Government = NULL;
		current_xmachine->xmachine_CentralBank = NULL;
		current_xmachine->xmachine_ClearingHouse = NULL;
		current_xmachine->xmachine_Firm = current_xmachine_Firm;

		

		
		rc = MB_Iterator_CreateFiltered(b_sales, &i_sales, &FLAME_filter_Firm_Firm_calc_revenue_Firm_Start_Seller_Role_Firm_End_Seller_Role_sales, current_xmachine_Firm);
		
		#ifdef ERRCHECK
		if (rc != MB_SUCCESS)
		{
		   fprintf(stderr, "ERROR: Could not create Iterator for 'sales'\n");
		   switch(rc) {
		       case MB_ERR_INVALID:
		           fprintf(stderr, "\t reason: 'sales' board is invalid\n");
		           break;
		       case MB_ERR_LOCKED:
	               fprintf(stderr, "\t reason: 'sales' board is locked\n");
	               break;
	           case MB_ERR_MEMALLOC:
	               fprintf(stderr, "\t reason: out of memory\n");
	               break;
	           case MB_ERR_INTERNAL:
	               fprintf(stderr, "\t reason: internal error. Recompile libmoard in debug mode for more info \n");
	               break;
	           default:
	           
                   fprintf(stderr, "\t MB_Iterator_CreateFiltered returned error code: %d (see libmboard docs for details)\n", rc);
               
               
                   break;
		   }

		   
           exit(rc);
		}
		#endif
		
		

			i = Firm_calc_revenue();

		
		    rc = MB_Iterator_Delete(&i_sales);
		    #ifdef ERRCHECK
		    if (rc != MB_SUCCESS)
		    {
		       fprintf(stderr, "ERROR: Could not delete 'sales' iterator\n");
		       switch(rc) {
		           case MB_ERR_INVALID:
		               fprintf(stderr, "\t reason: 'sales' iterator is invalid\n");
		               break;
		           case MB_ERR_INTERNAL:
		               fprintf(stderr, "\t reason: internal error. Recompile libmoard in debug mode for more info \n");
		               break;
		           default:
                       fprintf(stderr, "\t MB_Iterator_Delete returned error code: %d (see libmboard docs for details)\n", rc);
                       break;
		       }

		       
               exit(rc);
		    }
		    #endif
		

			if(i == 1)
			{
				free_Firm_agent(current_xmachine_Firm_holder, Firm_Firm_Start_Seller_Role_state);
			}
			else
			{
				transition_Firm_agent(current_xmachine_Firm_holder, Firm_Firm_Start_Seller_Role_state, Firm_Firm_End_Seller_Role_state);
			}
		

		current_xmachine_Firm = NULL;

		current_xmachine_Firm_holder = temp_xmachine_Firm_holder;
	}
	if(FLAME_TEST_PRINT_START_AND_END_OF_MODEL_FUNCTIONS) printf("finish Firm_calc_revenue\n");


/* End of layer number 77 */

/* Clear message boards that have finished being used
 * and sync complete if doing late sync complete */

if(FLAME_sales_message_board_read == 0)
{
	/*printf("%d> sales message board sync complete late as no agents reading any messages of this type\n", node_number);*/
	
	if(FLAME_TEST_PRINT_START_AND_END_OF_LIBMBOARD_CALLS) printf("start MB_SyncComplete(b_sales)\n");
	rc = MB_SyncComplete(b_sales);
	if(FLAME_TEST_PRINT_START_AND_END_OF_LIBMBOARD_CALLS) printf("finsh MB_SyncComplete(b_sales)\n");
	#ifdef ERRCHECK
	if (rc != MB_SUCCESS)
	{
	   fprintf(stderr, "ERROR: Could not complete sync of 'sales' board\n");
	   switch(rc) {
			case MB_ERR_INVALID:
			   fprintf(stderr, "\t reason: 'sales' board is invalid\n");
			   break;
		   case MB_ERR_MEMALLOC:
			   fprintf(stderr, "\t reason: out of memory\n");
			   break;
		   case MB_ERR_INTERNAL:
			   fprintf(stderr, "\t reason: internal error. Recompile libmoard in debug mode for more info \n");
			   break;
		   default:
			   fprintf(stderr, "\t MB_SyncComplete returned error code: %d (see libmboard docs for details)\n", rc);
			   break;
	   }

	   
	   exit(rc);
	}
	#endif
}

    rc = MB_Clear(b_sales);
    #ifdef ERRCHECK
    if (rc != MB_SUCCESS)
    {
       fprintf(stderr, "ERROR: Could not clear 'sales' board\n");
       switch(rc) {
           case MB_ERR_INVALID:
               fprintf(stderr, "\t reason: 'sales' board is invalid\n");
               break;
           case MB_ERR_LOCKED:
               fprintf(stderr, "\t reason: 'sales' board is locked\n");
               break;
           case MB_ERR_INTERNAL:
               fprintf(stderr, "\t reason: internal error. Recompile libmoard in debug mode for more info \n");
               break;
           default:
               fprintf(stderr, "\t MB_Clear returned error code: %d (see libmboard docs for details)\n", rc);
               break;

       }

       
       exit(rc);
    }
    #endif


	if(FLAME_TEST_PRINT_START_AND_END_OF_MODEL_FUNCTIONS) printf("start Household_send_account_update\n");
	current_xmachine_Household_holder = Household_15_state->agents;
	while(current_xmachine_Household_holder)
	{
		temp_xmachine_Household_holder = current_xmachine_Household_holder->next;
		current_xmachine_Household = current_xmachine_Household_holder->agent;
		current_xmachine_Household_next_state = Household_16_state;
		/* For backwards compatibility set current_xmachine */
		current_xmachine->xmachine_Firm = NULL;
		current_xmachine->xmachine_Household = NULL;
		current_xmachine->xmachine_Mall = NULL;
		current_xmachine->xmachine_IGFirm = NULL;
		current_xmachine->xmachine_Eurostat = NULL;
		current_xmachine->xmachine_Bank = NULL;
		current_xmachine->xmachine_Government = NULL;
		current_xmachine->xmachine_CentralBank = NULL;
		current_xmachine->xmachine_ClearingHouse = NULL;
		current_xmachine->xmachine_Household = current_xmachine_Household;

		

		

			i = Household_send_account_update();

		

			if(i == 1)
			{
				free_Household_agent(current_xmachine_Household_holder, Household_15_state);
			}
			else
			{
				transition_Household_agent(current_xmachine_Household_holder, Household_15_state, Household_16_state);
			}
		

		current_xmachine_Household = NULL;

		current_xmachine_Household_holder = temp_xmachine_Household_holder;
	}
	if(FLAME_TEST_PRINT_START_AND_END_OF_MODEL_FUNCTIONS) printf("finish Household_send_account_update\n");


	if(FLAME_TEST_PRINT_START_AND_END_OF_MODEL_FUNCTIONS) printf("start IGFirm_send_payments_to_bank\n");
	current_xmachine_IGFirm_holder = IGFirm_07_state->agents;
	while(current_xmachine_IGFirm_holder)
	{
		temp_xmachine_IGFirm_holder = current_xmachine_IGFirm_holder->next;
		current_xmachine_IGFirm = current_xmachine_IGFirm_holder->agent;
		current_xmachine_IGFirm_next_state = IGFirm_end_IGFirm_state;
		/* For backwards compatibility set current_xmachine */
		current_xmachine->xmachine_Firm = NULL;
		current_xmachine->xmachine_Household = NULL;
		current_xmachine->xmachine_Mall = NULL;
		current_xmachine->xmachine_IGFirm = NULL;
		current_xmachine->xmachine_Eurostat = NULL;
		current_xmachine->xmachine_Bank = NULL;
		current_xmachine->xmachine_Government = NULL;
		current_xmachine->xmachine_CentralBank = NULL;
		current_xmachine->xmachine_ClearingHouse = NULL;
		current_xmachine->xmachine_IGFirm = current_xmachine_IGFirm;

		

		

			i = IGFirm_send_payments_to_bank();

		

			if(i == 1)
			{
				free_IGFirm_agent(current_xmachine_IGFirm_holder, IGFirm_07_state);
			}
			else
			{
				transition_IGFirm_agent(current_xmachine_IGFirm_holder, IGFirm_07_state, IGFirm_end_IGFirm_state);
			}
		

		current_xmachine_IGFirm = NULL;

		current_xmachine_IGFirm_holder = temp_xmachine_IGFirm_holder;
	}
	if(FLAME_TEST_PRINT_START_AND_END_OF_MODEL_FUNCTIONS) printf("finish IGFirm_send_payments_to_bank\n");


	if(FLAME_TEST_PRINT_START_AND_END_OF_MODEL_FUNCTIONS) printf("start idle\n");
	current_xmachine_Firm_holder = Firm_Firm_End_Seller_Role_state->agents;
	while(current_xmachine_Firm_holder)
	{
		temp_xmachine_Firm_holder = current_xmachine_Firm_holder->next;
		current_xmachine_Firm = current_xmachine_Firm_holder->agent;
		current_xmachine_Firm_next_state = Firm_14_state;
		/* For backwards compatibility set current_xmachine */
		current_xmachine->xmachine_Firm = NULL;
		current_xmachine->xmachine_Household = NULL;
		current_xmachine->xmachine_Mall = NULL;
		current_xmachine->xmachine_IGFirm = NULL;
		current_xmachine->xmachine_Eurostat = NULL;
		current_xmachine->xmachine_Bank = NULL;
		current_xmachine->xmachine_Government = NULL;
		current_xmachine->xmachine_CentralBank = NULL;
		current_xmachine->xmachine_ClearingHouse = NULL;
		current_xmachine->xmachine_Firm = current_xmachine_Firm;

		if(FLAME_condition_Firm_idle_Firm_End_Seller_Role_14(current_xmachine_Firm)==1)
		{

		

			i = idle();

		

			if(i == 1)
			{
				free_Firm_agent(current_xmachine_Firm_holder, Firm_Firm_End_Seller_Role_state);
			}
			else
			{
				transition_Firm_agent(current_xmachine_Firm_holder, Firm_Firm_End_Seller_Role_state, Firm_14_state);
			}
		}

		current_xmachine_Firm = NULL;

		current_xmachine_Firm_holder = temp_xmachine_Firm_holder;
	}
	if(FLAME_TEST_PRINT_START_AND_END_OF_MODEL_FUNCTIONS) printf("finish idle\n");


	/* If mb is not read then leave sync complete until last possible moment */
	if(FLAME_specific_skill_update_message_board_read == 1)
	{
		if(FLAME_TEST_PRINT_START_AND_END_OF_LIBMBOARD_CALLS) printf("start MB_SyncComplete(b_specific_skill_update)\n");
		rc = MB_SyncComplete(b_specific_skill_update);
		if(FLAME_TEST_PRINT_START_AND_END_OF_LIBMBOARD_CALLS) printf("finsh MB_SyncComplete(b_specific_skill_update)\n");
		#ifdef ERRCHECK
		if (rc != MB_SUCCESS)
		{
		   fprintf(stderr, "ERROR: Could not complete sync of 'specific_skill_update' board\n");
		   switch(rc) {
				case MB_ERR_INVALID:
				   fprintf(stderr, "\t reason: 'specific_skill_update' board is invalid\n");
				   break;
			   case MB_ERR_MEMALLOC:
				   fprintf(stderr, "\t reason: out of memory\n");
				   break;
			   case MB_ERR_INTERNAL:
				   fprintf(stderr, "\t reason: internal error. Recompile libmoard in debug mode for more info \n");
				   break;
			   default:
				   fprintf(stderr, "\t MB_SyncComplete returned error code: %d (see libmboard docs for details)\n", rc);
				   break;
		   }
	
		   
		   exit(rc);
		}
		#endif
    
	}
	
	if(FLAME_TEST_PRINT_START_AND_END_OF_MODEL_FUNCTIONS) printf("start Firm_update_specific_skills_of_workers\n");
	current_xmachine_Firm_holder = Firm_Firm_End_Seller_Role_state->agents;
	while(current_xmachine_Firm_holder)
	{
		temp_xmachine_Firm_holder = current_xmachine_Firm_holder->next;
		current_xmachine_Firm = current_xmachine_Firm_holder->agent;
		current_xmachine_Firm_next_state = Firm_14_state;
		/* For backwards compatibility set current_xmachine */
		current_xmachine->xmachine_Firm = NULL;
		current_xmachine->xmachine_Household = NULL;
		current_xmachine->xmachine_Mall = NULL;
		current_xmachine->xmachine_IGFirm = NULL;
		current_xmachine->xmachine_Eurostat = NULL;
		current_xmachine->xmachine_Bank = NULL;
		current_xmachine->xmachine_Government = NULL;
		current_xmachine->xmachine_CentralBank = NULL;
		current_xmachine->xmachine_ClearingHouse = NULL;
		current_xmachine->xmachine_Firm = current_xmachine_Firm;

		if(FLAME_condition_Firm_Firm_update_specific_skills_of_workers_Firm_End_Seller_Role_14(current_xmachine_Firm)==1)
		{

		
		rc = MB_Iterator_CreateFiltered(b_specific_skill_update, &i_specific_skill_update, &FLAME_filter_Firm_Firm_update_specific_skills_of_workers_Firm_End_Seller_Role_14_specific_skill_update, current_xmachine_Firm);
		
		#ifdef ERRCHECK
		if (rc != MB_SUCCESS)
		{
		   fprintf(stderr, "ERROR: Could not create Iterator for 'specific_skill_update'\n");
		   switch(rc) {
		       case MB_ERR_INVALID:
		           fprintf(stderr, "\t reason: 'specific_skill_update' board is invalid\n");
		           break;
		       case MB_ERR_LOCKED:
	               fprintf(stderr, "\t reason: 'specific_skill_update' board is locked\n");
	               break;
	           case MB_ERR_MEMALLOC:
	               fprintf(stderr, "\t reason: out of memory\n");
	               break;
	           case MB_ERR_INTERNAL:
	               fprintf(stderr, "\t reason: internal error. Recompile libmoard in debug mode for more info \n");
	               break;
	           default:
	           
                   fprintf(stderr, "\t MB_Iterator_CreateFiltered returned error code: %d (see libmboard docs for details)\n", rc);
               
               
                   break;
		   }

		   
           exit(rc);
		}
		#endif
		
		

			i = Firm_update_specific_skills_of_workers();

		
		    rc = MB_Iterator_Delete(&i_specific_skill_update);
		    #ifdef ERRCHECK
		    if (rc != MB_SUCCESS)
		    {
		       fprintf(stderr, "ERROR: Could not delete 'specific_skill_update' iterator\n");
		       switch(rc) {
		           case MB_ERR_INVALID:
		               fprintf(stderr, "\t reason: 'specific_skill_update' iterator is invalid\n");
		               break;
		           case MB_ERR_INTERNAL:
		               fprintf(stderr, "\t reason: internal error. Recompile libmoard in debug mode for more info \n");
		               break;
		           default:
                       fprintf(stderr, "\t MB_Iterator_Delete returned error code: %d (see libmboard docs for details)\n", rc);
                       break;
		       }

		       
               exit(rc);
		    }
		    #endif
		

			if(i == 1)
			{
				free_Firm_agent(current_xmachine_Firm_holder, Firm_Firm_End_Seller_Role_state);
			}
			else
			{
				transition_Firm_agent(current_xmachine_Firm_holder, Firm_Firm_End_Seller_Role_state, Firm_14_state);
			}
		}

		current_xmachine_Firm = NULL;

		current_xmachine_Firm_holder = temp_xmachine_Firm_holder;
	}
	if(FLAME_TEST_PRINT_START_AND_END_OF_MODEL_FUNCTIONS) printf("finish Firm_update_specific_skills_of_workers\n");


/* End of layer number 78 */

/* Clear message boards that have finished being used
 * and sync complete if doing late sync complete */

if(FLAME_specific_skill_update_message_board_read == 0)
{
	/*printf("%d> specific_skill_update message board sync complete late as no agents reading any messages of this type\n", node_number);*/
	
	if(FLAME_TEST_PRINT_START_AND_END_OF_LIBMBOARD_CALLS) printf("start MB_SyncComplete(b_specific_skill_update)\n");
	rc = MB_SyncComplete(b_specific_skill_update);
	if(FLAME_TEST_PRINT_START_AND_END_OF_LIBMBOARD_CALLS) printf("finsh MB_SyncComplete(b_specific_skill_update)\n");
	#ifdef ERRCHECK
	if (rc != MB_SUCCESS)
	{
	   fprintf(stderr, "ERROR: Could not complete sync of 'specific_skill_update' board\n");
	   switch(rc) {
			case MB_ERR_INVALID:
			   fprintf(stderr, "\t reason: 'specific_skill_update' board is invalid\n");
			   break;
		   case MB_ERR_MEMALLOC:
			   fprintf(stderr, "\t reason: out of memory\n");
			   break;
		   case MB_ERR_INTERNAL:
			   fprintf(stderr, "\t reason: internal error. Recompile libmoard in debug mode for more info \n");
			   break;
		   default:
			   fprintf(stderr, "\t MB_SyncComplete returned error code: %d (see libmboard docs for details)\n", rc);
			   break;
	   }

	   
	   exit(rc);
	}
	#endif
}

    rc = MB_Clear(b_specific_skill_update);
    #ifdef ERRCHECK
    if (rc != MB_SUCCESS)
    {
       fprintf(stderr, "ERROR: Could not clear 'specific_skill_update' board\n");
       switch(rc) {
           case MB_ERR_INVALID:
               fprintf(stderr, "\t reason: 'specific_skill_update' board is invalid\n");
               break;
           case MB_ERR_LOCKED:
               fprintf(stderr, "\t reason: 'specific_skill_update' board is locked\n");
               break;
           case MB_ERR_INTERNAL:
               fprintf(stderr, "\t reason: internal error. Recompile libmoard in debug mode for more info \n");
               break;
           default:
               fprintf(stderr, "\t MB_Clear returned error code: %d (see libmboard docs for details)\n", rc);
               break;

       }

       
       exit(rc);
    }
    #endif


	if(FLAME_TEST_PRINT_START_AND_END_OF_MODEL_FUNCTIONS) printf("start Household_send_data_to_Eurostat\n");
	current_xmachine_Household_holder = Household_16_state->agents;
	while(current_xmachine_Household_holder)
	{
		temp_xmachine_Household_holder = current_xmachine_Household_holder->next;
		current_xmachine_Household = current_xmachine_Household_holder->agent;
		current_xmachine_Household_next_state = Household_17_state;
		/* For backwards compatibility set current_xmachine */
		current_xmachine->xmachine_Firm = NULL;
		current_xmachine->xmachine_Household = NULL;
		current_xmachine->xmachine_Mall = NULL;
		current_xmachine->xmachine_IGFirm = NULL;
		current_xmachine->xmachine_Eurostat = NULL;
		current_xmachine->xmachine_Bank = NULL;
		current_xmachine->xmachine_Government = NULL;
		current_xmachine->xmachine_CentralBank = NULL;
		current_xmachine->xmachine_ClearingHouse = NULL;
		current_xmachine->xmachine_Household = current_xmachine_Household;

		if(FLAME_condition_Household_Household_send_data_to_Eurostat_16_17(current_xmachine_Household)==1)
		{

		

			i = Household_send_data_to_Eurostat();

		

			if(i == 1)
			{
				free_Household_agent(current_xmachine_Household_holder, Household_16_state);
			}
			else
			{
				transition_Household_agent(current_xmachine_Household_holder, Household_16_state, Household_17_state);
			}
		}

		current_xmachine_Household = NULL;

		current_xmachine_Household_holder = temp_xmachine_Household_holder;
	}
	if(FLAME_TEST_PRINT_START_AND_END_OF_MODEL_FUNCTIONS) printf("finish Household_send_data_to_Eurostat\n");

	if(FLAME_household_send_data_message_board_write == 1)
	{

		if(FLAME_TEST_PRINT_START_AND_END_OF_LIBMBOARD_CALLS) printf("start MB_SyncStart(b_household_send_data)\n");
		rc = MB_SyncStart(b_household_send_data);
		if(FLAME_TEST_PRINT_START_AND_END_OF_LIBMBOARD_CALLS) printf("finish MB_SyncStart(b_household_send_data)\n");
		#ifdef ERRCHECK
		if (rc != MB_SUCCESS)
		{
		   fprintf(stderr, "ERROR: Could not start sync of 'household_send_data' board\n");
		   switch(rc) {
			   case MB_ERR_INVALID:
				   fprintf(stderr, "\t reason: 'household_send_data' board is invalid\n");
				   break;
			   case MB_ERR_LOCKED:
				   fprintf(stderr, "\t reason: 'household_send_data' board is locked\n");
				   break;
			   case MB_ERR_MEMALLOC:
				   fprintf(stderr, "\t reason: out of memory\n");
				   break;
			   case MB_ERR_INTERNAL:
				   fprintf(stderr, "\t reason: internal error. Recompile libmoard in debug mode for more info \n");
				   break;
			   default:
				   fprintf(stderr, "\t MB_SyncStart returned error code: %d (see libmboard docs for details)\n", rc);
				   break;
		   }

			
			exit(rc);
		}
		#endif
    }
    


	if(FLAME_TEST_PRINT_START_AND_END_OF_MODEL_FUNCTIONS) printf("start idle\n");
	current_xmachine_Household_holder = Household_16_state->agents;
	while(current_xmachine_Household_holder)
	{
		temp_xmachine_Household_holder = current_xmachine_Household_holder->next;
		current_xmachine_Household = current_xmachine_Household_holder->agent;
		current_xmachine_Household_next_state = Household_17_state;
		/* For backwards compatibility set current_xmachine */
		current_xmachine->xmachine_Firm = NULL;
		current_xmachine->xmachine_Household = NULL;
		current_xmachine->xmachine_Mall = NULL;
		current_xmachine->xmachine_IGFirm = NULL;
		current_xmachine->xmachine_Eurostat = NULL;
		current_xmachine->xmachine_Bank = NULL;
		current_xmachine->xmachine_Government = NULL;
		current_xmachine->xmachine_CentralBank = NULL;
		current_xmachine->xmachine_ClearingHouse = NULL;
		current_xmachine->xmachine_Household = current_xmachine_Household;

		if(FLAME_condition_Household_idle_16_17(current_xmachine_Household)==1)
		{

		

			i = idle();

		

			if(i == 1)
			{
				free_Household_agent(current_xmachine_Household_holder, Household_16_state);
			}
			else
			{
				transition_Household_agent(current_xmachine_Household_holder, Household_16_state, Household_17_state);
			}
		}

		current_xmachine_Household = NULL;

		current_xmachine_Household_holder = temp_xmachine_Household_holder;
	}
	if(FLAME_TEST_PRINT_START_AND_END_OF_MODEL_FUNCTIONS) printf("finish idle\n");


	if(FLAME_TEST_PRINT_START_AND_END_OF_MODEL_FUNCTIONS) printf("start Firm_compute_sales_statistics\n");
	current_xmachine_Firm_holder = Firm_14_state->agents;
	while(current_xmachine_Firm_holder)
	{
		temp_xmachine_Firm_holder = current_xmachine_Firm_holder->next;
		current_xmachine_Firm = current_xmachine_Firm_holder->agent;
		current_xmachine_Firm_next_state = Firm_Firm_Start_Financial_Management_Role_state;
		/* For backwards compatibility set current_xmachine */
		current_xmachine->xmachine_Firm = NULL;
		current_xmachine->xmachine_Household = NULL;
		current_xmachine->xmachine_Mall = NULL;
		current_xmachine->xmachine_IGFirm = NULL;
		current_xmachine->xmachine_Eurostat = NULL;
		current_xmachine->xmachine_Bank = NULL;
		current_xmachine->xmachine_Government = NULL;
		current_xmachine->xmachine_CentralBank = NULL;
		current_xmachine->xmachine_ClearingHouse = NULL;
		current_xmachine->xmachine_Firm = current_xmachine_Firm;

		if(FLAME_condition_Firm_Firm_compute_sales_statistics_14_Firm_Start_Financial_Management_Role(current_xmachine_Firm)==1)
		{

		

			i = Firm_compute_sales_statistics();

		

			if(i == 1)
			{
				free_Firm_agent(current_xmachine_Firm_holder, Firm_14_state);
			}
			else
			{
				transition_Firm_agent(current_xmachine_Firm_holder, Firm_14_state, Firm_Firm_Start_Financial_Management_Role_state);
			}
		}

		current_xmachine_Firm = NULL;

		current_xmachine_Firm_holder = temp_xmachine_Firm_holder;
	}
	if(FLAME_TEST_PRINT_START_AND_END_OF_MODEL_FUNCTIONS) printf("finish Firm_compute_sales_statistics\n");


	if(FLAME_TEST_PRINT_START_AND_END_OF_MODEL_FUNCTIONS) printf("start idle\n");
	current_xmachine_Firm_holder = Firm_14_state->agents;
	while(current_xmachine_Firm_holder)
	{
		temp_xmachine_Firm_holder = current_xmachine_Firm_holder->next;
		current_xmachine_Firm = current_xmachine_Firm_holder->agent;
		current_xmachine_Firm_next_state = Firm_Firm_End_Financial_Management_Role_state;
		/* For backwards compatibility set current_xmachine */
		current_xmachine->xmachine_Firm = NULL;
		current_xmachine->xmachine_Household = NULL;
		current_xmachine->xmachine_Mall = NULL;
		current_xmachine->xmachine_IGFirm = NULL;
		current_xmachine->xmachine_Eurostat = NULL;
		current_xmachine->xmachine_Bank = NULL;
		current_xmachine->xmachine_Government = NULL;
		current_xmachine->xmachine_CentralBank = NULL;
		current_xmachine->xmachine_ClearingHouse = NULL;
		current_xmachine->xmachine_Firm = current_xmachine_Firm;

		if(FLAME_condition_Firm_idle_14_Firm_End_Financial_Management_Role(current_xmachine_Firm)==1)
		{

		

			i = idle();

		

			if(i == 1)
			{
				free_Firm_agent(current_xmachine_Firm_holder, Firm_14_state);
			}
			else
			{
				transition_Firm_agent(current_xmachine_Firm_holder, Firm_14_state, Firm_Firm_End_Financial_Management_Role_state);
			}
		}

		current_xmachine_Firm = NULL;

		current_xmachine_Firm_holder = temp_xmachine_Firm_holder;
	}
	if(FLAME_TEST_PRINT_START_AND_END_OF_MODEL_FUNCTIONS) printf("finish idle\n");


/* End of layer number 79 */

/* Clear message boards that have finished being used
 * and sync complete if doing late sync complete */


	if(FLAME_TEST_PRINT_START_AND_END_OF_MODEL_FUNCTIONS) printf("start Firm_send_subsidy_notification\n");
	current_xmachine_Firm_holder = Firm_Firm_Start_Financial_Management_Role_state->agents;
	while(current_xmachine_Firm_holder)
	{
		temp_xmachine_Firm_holder = current_xmachine_Firm_holder->next;
		current_xmachine_Firm = current_xmachine_Firm_holder->agent;
		current_xmachine_Firm_next_state = Firm_005_state;
		/* For backwards compatibility set current_xmachine */
		current_xmachine->xmachine_Firm = NULL;
		current_xmachine->xmachine_Household = NULL;
		current_xmachine->xmachine_Mall = NULL;
		current_xmachine->xmachine_IGFirm = NULL;
		current_xmachine->xmachine_Eurostat = NULL;
		current_xmachine->xmachine_Bank = NULL;
		current_xmachine->xmachine_Government = NULL;
		current_xmachine->xmachine_CentralBank = NULL;
		current_xmachine->xmachine_ClearingHouse = NULL;
		current_xmachine->xmachine_Firm = current_xmachine_Firm;

		

		

			i = Firm_send_subsidy_notification();

		

			if(i == 1)
			{
				free_Firm_agent(current_xmachine_Firm_holder, Firm_Firm_Start_Financial_Management_Role_state);
			}
			else
			{
				transition_Firm_agent(current_xmachine_Firm_holder, Firm_Firm_Start_Financial_Management_Role_state, Firm_005_state);
			}
		

		current_xmachine_Firm = NULL;

		current_xmachine_Firm_holder = temp_xmachine_Firm_holder;
	}
	if(FLAME_TEST_PRINT_START_AND_END_OF_MODEL_FUNCTIONS) printf("finish Firm_send_subsidy_notification\n");

	if(FLAME_firm_subsidy_notification_message_board_write == 1)
	{

		if(FLAME_TEST_PRINT_START_AND_END_OF_LIBMBOARD_CALLS) printf("start MB_SyncStart(b_firm_subsidy_notification)\n");
		rc = MB_SyncStart(b_firm_subsidy_notification);
		if(FLAME_TEST_PRINT_START_AND_END_OF_LIBMBOARD_CALLS) printf("finish MB_SyncStart(b_firm_subsidy_notification)\n");
		#ifdef ERRCHECK
		if (rc != MB_SUCCESS)
		{
		   fprintf(stderr, "ERROR: Could not start sync of 'firm_subsidy_notification' board\n");
		   switch(rc) {
			   case MB_ERR_INVALID:
				   fprintf(stderr, "\t reason: 'firm_subsidy_notification' board is invalid\n");
				   break;
			   case MB_ERR_LOCKED:
				   fprintf(stderr, "\t reason: 'firm_subsidy_notification' board is locked\n");
				   break;
			   case MB_ERR_MEMALLOC:
				   fprintf(stderr, "\t reason: out of memory\n");
				   break;
			   case MB_ERR_INTERNAL:
				   fprintf(stderr, "\t reason: internal error. Recompile libmoard in debug mode for more info \n");
				   break;
			   default:
				   fprintf(stderr, "\t MB_SyncStart returned error code: %d (see libmboard docs for details)\n", rc);
				   break;
		   }

			
			exit(rc);
		}
		#endif
    }
    


	if(FLAME_TEST_PRINT_START_AND_END_OF_MODEL_FUNCTIONS) printf("start idle\n");
	current_xmachine_Household_holder = Household_17_state->agents;
	while(current_xmachine_Household_holder)
	{
		temp_xmachine_Household_holder = current_xmachine_Household_holder->next;
		current_xmachine_Household = current_xmachine_Household_holder->agent;
		current_xmachine_Household_next_state = Household_end_Household_state;
		/* For backwards compatibility set current_xmachine */
		current_xmachine->xmachine_Firm = NULL;
		current_xmachine->xmachine_Household = NULL;
		current_xmachine->xmachine_Mall = NULL;
		current_xmachine->xmachine_IGFirm = NULL;
		current_xmachine->xmachine_Eurostat = NULL;
		current_xmachine->xmachine_Bank = NULL;
		current_xmachine->xmachine_Government = NULL;
		current_xmachine->xmachine_CentralBank = NULL;
		current_xmachine->xmachine_ClearingHouse = NULL;
		current_xmachine->xmachine_Household = current_xmachine_Household;

		if(FLAME_condition_Household_idle_17_end_Household(current_xmachine_Household)==1)
		{

		

			i = idle();

		

			if(i == 1)
			{
				free_Household_agent(current_xmachine_Household_holder, Household_17_state);
			}
			else
			{
				transition_Household_agent(current_xmachine_Household_holder, Household_17_state, Household_end_Household_state);
			}
		}

		current_xmachine_Household = NULL;

		current_xmachine_Household_holder = temp_xmachine_Household_holder;
	}
	if(FLAME_TEST_PRINT_START_AND_END_OF_MODEL_FUNCTIONS) printf("finish idle\n");


	if(FLAME_TEST_PRINT_START_AND_END_OF_MODEL_FUNCTIONS) printf("start Household_read_data_from_Eurostat\n");
	current_xmachine_Household_holder = Household_17_state->agents;
	while(current_xmachine_Household_holder)
	{
		temp_xmachine_Household_holder = current_xmachine_Household_holder->next;
		current_xmachine_Household = current_xmachine_Household_holder->agent;
		current_xmachine_Household_next_state = Household_end_Household_state;
		/* For backwards compatibility set current_xmachine */
		current_xmachine->xmachine_Firm = NULL;
		current_xmachine->xmachine_Household = NULL;
		current_xmachine->xmachine_Mall = NULL;
		current_xmachine->xmachine_IGFirm = NULL;
		current_xmachine->xmachine_Eurostat = NULL;
		current_xmachine->xmachine_Bank = NULL;
		current_xmachine->xmachine_Government = NULL;
		current_xmachine->xmachine_CentralBank = NULL;
		current_xmachine->xmachine_ClearingHouse = NULL;
		current_xmachine->xmachine_Household = current_xmachine_Household;

		if(FLAME_condition_Household_Household_read_data_from_Eurostat_17_end_Household(current_xmachine_Household)==1)
		{

		
		rc = MB_Iterator_CreateFiltered(b_data_for_government, &i_data_for_government, &FLAME_filter_Household_Household_read_data_from_Eurostat_17_end_Household_data_for_government, current_xmachine_Household);
		
		#ifdef ERRCHECK
		if (rc != MB_SUCCESS)
		{
		   fprintf(stderr, "ERROR: Could not create Iterator for 'data_for_government'\n");
		   switch(rc) {
		       case MB_ERR_INVALID:
		           fprintf(stderr, "\t reason: 'data_for_government' board is invalid\n");
		           break;
		       case MB_ERR_LOCKED:
	               fprintf(stderr, "\t reason: 'data_for_government' board is locked\n");
	               break;
	           case MB_ERR_MEMALLOC:
	               fprintf(stderr, "\t reason: out of memory\n");
	               break;
	           case MB_ERR_INTERNAL:
	               fprintf(stderr, "\t reason: internal error. Recompile libmoard in debug mode for more info \n");
	               break;
	           default:
	           
                   fprintf(stderr, "\t MB_Iterator_CreateFiltered returned error code: %d (see libmboard docs for details)\n", rc);
               
               
                   break;
		   }

		   
           exit(rc);
		}
		#endif
		
		

			i = Household_read_data_from_Eurostat();

		
		    rc = MB_Iterator_Delete(&i_data_for_government);
		    #ifdef ERRCHECK
		    if (rc != MB_SUCCESS)
		    {
		       fprintf(stderr, "ERROR: Could not delete 'data_for_government' iterator\n");
		       switch(rc) {
		           case MB_ERR_INVALID:
		               fprintf(stderr, "\t reason: 'data_for_government' iterator is invalid\n");
		               break;
		           case MB_ERR_INTERNAL:
		               fprintf(stderr, "\t reason: internal error. Recompile libmoard in debug mode for more info \n");
		               break;
		           default:
                       fprintf(stderr, "\t MB_Iterator_Delete returned error code: %d (see libmboard docs for details)\n", rc);
                       break;
		       }

		       
               exit(rc);
		    }
		    #endif
		

			if(i == 1)
			{
				free_Household_agent(current_xmachine_Household_holder, Household_17_state);
			}
			else
			{
				transition_Household_agent(current_xmachine_Household_holder, Household_17_state, Household_end_Household_state);
			}
		}

		current_xmachine_Household = NULL;

		current_xmachine_Household_holder = temp_xmachine_Household_holder;
	}
	if(FLAME_TEST_PRINT_START_AND_END_OF_MODEL_FUNCTIONS) printf("finish Household_read_data_from_Eurostat\n");


/* End of layer number 80 */

/* Clear message boards that have finished being used
 * and sync complete if doing late sync complete */

if(FLAME_data_for_government_message_board_read == 0)
{
	/*printf("%d> data_for_government message board sync complete late as no agents reading any messages of this type\n", node_number);*/
	
	if(FLAME_TEST_PRINT_START_AND_END_OF_LIBMBOARD_CALLS) printf("start MB_SyncComplete(b_data_for_government)\n");
	rc = MB_SyncComplete(b_data_for_government);
	if(FLAME_TEST_PRINT_START_AND_END_OF_LIBMBOARD_CALLS) printf("finsh MB_SyncComplete(b_data_for_government)\n");
	#ifdef ERRCHECK
	if (rc != MB_SUCCESS)
	{
	   fprintf(stderr, "ERROR: Could not complete sync of 'data_for_government' board\n");
	   switch(rc) {
			case MB_ERR_INVALID:
			   fprintf(stderr, "\t reason: 'data_for_government' board is invalid\n");
			   break;
		   case MB_ERR_MEMALLOC:
			   fprintf(stderr, "\t reason: out of memory\n");
			   break;
		   case MB_ERR_INTERNAL:
			   fprintf(stderr, "\t reason: internal error. Recompile libmoard in debug mode for more info \n");
			   break;
		   default:
			   fprintf(stderr, "\t MB_SyncComplete returned error code: %d (see libmboard docs for details)\n", rc);
			   break;
	   }

	   
	   exit(rc);
	}
	#endif
}

    rc = MB_Clear(b_data_for_government);
    #ifdef ERRCHECK
    if (rc != MB_SUCCESS)
    {
       fprintf(stderr, "ERROR: Could not clear 'data_for_government' board\n");
       switch(rc) {
           case MB_ERR_INVALID:
               fprintf(stderr, "\t reason: 'data_for_government' board is invalid\n");
               break;
           case MB_ERR_LOCKED:
               fprintf(stderr, "\t reason: 'data_for_government' board is locked\n");
               break;
           case MB_ERR_INTERNAL:
               fprintf(stderr, "\t reason: internal error. Recompile libmoard in debug mode for more info \n");
               break;
           default:
               fprintf(stderr, "\t MB_Clear returned error code: %d (see libmboard docs for details)\n", rc);
               break;

       }

       
       exit(rc);
    }
    #endif


	if(FLAME_TEST_PRINT_START_AND_END_OF_MODEL_FUNCTIONS) printf("start Firm_send_transfer_notification\n");
	current_xmachine_Firm_holder = Firm_005_state->agents;
	while(current_xmachine_Firm_holder)
	{
		temp_xmachine_Firm_holder = current_xmachine_Firm_holder->next;
		current_xmachine_Firm = current_xmachine_Firm_holder->agent;
		current_xmachine_Firm_next_state = Firm_Firm_End_Public_Sector_Role_state;
		/* For backwards compatibility set current_xmachine */
		current_xmachine->xmachine_Firm = NULL;
		current_xmachine->xmachine_Household = NULL;
		current_xmachine->xmachine_Mall = NULL;
		current_xmachine->xmachine_IGFirm = NULL;
		current_xmachine->xmachine_Eurostat = NULL;
		current_xmachine->xmachine_Bank = NULL;
		current_xmachine->xmachine_Government = NULL;
		current_xmachine->xmachine_CentralBank = NULL;
		current_xmachine->xmachine_ClearingHouse = NULL;
		current_xmachine->xmachine_Firm = current_xmachine_Firm;

		

		

			i = Firm_send_transfer_notification();

		

			if(i == 1)
			{
				free_Firm_agent(current_xmachine_Firm_holder, Firm_005_state);
			}
			else
			{
				transition_Firm_agent(current_xmachine_Firm_holder, Firm_005_state, Firm_Firm_End_Public_Sector_Role_state);
			}
		

		current_xmachine_Firm = NULL;

		current_xmachine_Firm_holder = temp_xmachine_Firm_holder;
	}
	if(FLAME_TEST_PRINT_START_AND_END_OF_MODEL_FUNCTIONS) printf("finish Firm_send_transfer_notification\n");

	if(FLAME_firm_transfer_notification_message_board_write == 1)
	{

		if(FLAME_TEST_PRINT_START_AND_END_OF_LIBMBOARD_CALLS) printf("start MB_SyncStart(b_firm_transfer_notification)\n");
		rc = MB_SyncStart(b_firm_transfer_notification);
		if(FLAME_TEST_PRINT_START_AND_END_OF_LIBMBOARD_CALLS) printf("finish MB_SyncStart(b_firm_transfer_notification)\n");
		#ifdef ERRCHECK
		if (rc != MB_SUCCESS)
		{
		   fprintf(stderr, "ERROR: Could not start sync of 'firm_transfer_notification' board\n");
		   switch(rc) {
			   case MB_ERR_INVALID:
				   fprintf(stderr, "\t reason: 'firm_transfer_notification' board is invalid\n");
				   break;
			   case MB_ERR_LOCKED:
				   fprintf(stderr, "\t reason: 'firm_transfer_notification' board is locked\n");
				   break;
			   case MB_ERR_MEMALLOC:
				   fprintf(stderr, "\t reason: out of memory\n");
				   break;
			   case MB_ERR_INTERNAL:
				   fprintf(stderr, "\t reason: internal error. Recompile libmoard in debug mode for more info \n");
				   break;
			   default:
				   fprintf(stderr, "\t MB_SyncStart returned error code: %d (see libmboard docs for details)\n", rc);
				   break;
		   }

			
			exit(rc);
		}
		#endif
    }
    


/* End of layer number 81 */

/* Clear message boards that have finished being used
 * and sync complete if doing late sync complete */


	if(FLAME_TEST_PRINT_START_AND_END_OF_MODEL_FUNCTIONS) printf("start Firm_compute_financial_payments\n");
	current_xmachine_Firm_holder = Firm_Firm_End_Public_Sector_Role_state->agents;
	while(current_xmachine_Firm_holder)
	{
		temp_xmachine_Firm_holder = current_xmachine_Firm_holder->next;
		current_xmachine_Firm = current_xmachine_Firm_holder->agent;
		current_xmachine_Firm_next_state = Firm_001_state;
		/* For backwards compatibility set current_xmachine */
		current_xmachine->xmachine_Firm = NULL;
		current_xmachine->xmachine_Household = NULL;
		current_xmachine->xmachine_Mall = NULL;
		current_xmachine->xmachine_IGFirm = NULL;
		current_xmachine->xmachine_Eurostat = NULL;
		current_xmachine->xmachine_Bank = NULL;
		current_xmachine->xmachine_Government = NULL;
		current_xmachine->xmachine_CentralBank = NULL;
		current_xmachine->xmachine_ClearingHouse = NULL;
		current_xmachine->xmachine_Firm = current_xmachine_Firm;

		

		

			i = Firm_compute_financial_payments();

		

			if(i == 1)
			{
				free_Firm_agent(current_xmachine_Firm_holder, Firm_Firm_End_Public_Sector_Role_state);
			}
			else
			{
				transition_Firm_agent(current_xmachine_Firm_holder, Firm_Firm_End_Public_Sector_Role_state, Firm_001_state);
			}
		

		current_xmachine_Firm = NULL;

		current_xmachine_Firm_holder = temp_xmachine_Firm_holder;
	}
	if(FLAME_TEST_PRINT_START_AND_END_OF_MODEL_FUNCTIONS) printf("finish Firm_compute_financial_payments\n");


/* End of layer number 82 */

/* Clear message boards that have finished being used
 * and sync complete if doing late sync complete */


	if(FLAME_TEST_PRINT_START_AND_END_OF_MODEL_FUNCTIONS) printf("start Firm_compute_income_statement\n");
	current_xmachine_Firm_holder = Firm_001_state->agents;
	while(current_xmachine_Firm_holder)
	{
		temp_xmachine_Firm_holder = current_xmachine_Firm_holder->next;
		current_xmachine_Firm = current_xmachine_Firm_holder->agent;
		current_xmachine_Firm_next_state = Firm_002_state;
		/* For backwards compatibility set current_xmachine */
		current_xmachine->xmachine_Firm = NULL;
		current_xmachine->xmachine_Household = NULL;
		current_xmachine->xmachine_Mall = NULL;
		current_xmachine->xmachine_IGFirm = NULL;
		current_xmachine->xmachine_Eurostat = NULL;
		current_xmachine->xmachine_Bank = NULL;
		current_xmachine->xmachine_Government = NULL;
		current_xmachine->xmachine_CentralBank = NULL;
		current_xmachine->xmachine_ClearingHouse = NULL;
		current_xmachine->xmachine_Firm = current_xmachine_Firm;

		

		

			i = Firm_compute_income_statement();

		

			if(i == 1)
			{
				free_Firm_agent(current_xmachine_Firm_holder, Firm_001_state);
			}
			else
			{
				transition_Firm_agent(current_xmachine_Firm_holder, Firm_001_state, Firm_002_state);
			}
		

		current_xmachine_Firm = NULL;

		current_xmachine_Firm_holder = temp_xmachine_Firm_holder;
	}
	if(FLAME_TEST_PRINT_START_AND_END_OF_MODEL_FUNCTIONS) printf("finish Firm_compute_income_statement\n");


/* End of layer number 83 */

/* Clear message boards that have finished being used
 * and sync complete if doing late sync complete */


	if(FLAME_TEST_PRINT_START_AND_END_OF_MODEL_FUNCTIONS) printf("start Firm_compute_dividends\n");
	current_xmachine_Firm_holder = Firm_002_state->agents;
	while(current_xmachine_Firm_holder)
	{
		temp_xmachine_Firm_holder = current_xmachine_Firm_holder->next;
		current_xmachine_Firm = current_xmachine_Firm_holder->agent;
		current_xmachine_Firm_next_state = Firm_003_state;
		/* For backwards compatibility set current_xmachine */
		current_xmachine->xmachine_Firm = NULL;
		current_xmachine->xmachine_Household = NULL;
		current_xmachine->xmachine_Mall = NULL;
		current_xmachine->xmachine_IGFirm = NULL;
		current_xmachine->xmachine_Eurostat = NULL;
		current_xmachine->xmachine_Bank = NULL;
		current_xmachine->xmachine_Government = NULL;
		current_xmachine->xmachine_CentralBank = NULL;
		current_xmachine->xmachine_ClearingHouse = NULL;
		current_xmachine->xmachine_Firm = current_xmachine_Firm;

		

		

			i = Firm_compute_dividends();

		

			if(i == 1)
			{
				free_Firm_agent(current_xmachine_Firm_holder, Firm_002_state);
			}
			else
			{
				transition_Firm_agent(current_xmachine_Firm_holder, Firm_002_state, Firm_003_state);
			}
		

		current_xmachine_Firm = NULL;

		current_xmachine_Firm_holder = temp_xmachine_Firm_holder;
	}
	if(FLAME_TEST_PRINT_START_AND_END_OF_MODEL_FUNCTIONS) printf("finish Firm_compute_dividends\n");


/* End of layer number 84 */

/* Clear message boards that have finished being used
 * and sync complete if doing late sync complete */


	if(FLAME_TEST_PRINT_START_AND_END_OF_MODEL_FUNCTIONS) printf("start Firm_compute_total_financial_payments\n");
	current_xmachine_Firm_holder = Firm_003_state->agents;
	while(current_xmachine_Firm_holder)
	{
		temp_xmachine_Firm_holder = current_xmachine_Firm_holder->next;
		current_xmachine_Firm = current_xmachine_Firm_holder->agent;
		current_xmachine_Firm_next_state = Firm_004_state;
		/* For backwards compatibility set current_xmachine */
		current_xmachine->xmachine_Firm = NULL;
		current_xmachine->xmachine_Household = NULL;
		current_xmachine->xmachine_Mall = NULL;
		current_xmachine->xmachine_IGFirm = NULL;
		current_xmachine->xmachine_Eurostat = NULL;
		current_xmachine->xmachine_Bank = NULL;
		current_xmachine->xmachine_Government = NULL;
		current_xmachine->xmachine_CentralBank = NULL;
		current_xmachine->xmachine_ClearingHouse = NULL;
		current_xmachine->xmachine_Firm = current_xmachine_Firm;

		

		

			i = Firm_compute_total_financial_payments();

		

			if(i == 1)
			{
				free_Firm_agent(current_xmachine_Firm_holder, Firm_003_state);
			}
			else
			{
				transition_Firm_agent(current_xmachine_Firm_holder, Firm_003_state, Firm_004_state);
			}
		

		current_xmachine_Firm = NULL;

		current_xmachine_Firm_holder = temp_xmachine_Firm_holder;
	}
	if(FLAME_TEST_PRINT_START_AND_END_OF_MODEL_FUNCTIONS) printf("finish Firm_compute_total_financial_payments\n");


/* End of layer number 85 */

/* Clear message boards that have finished being used
 * and sync complete if doing late sync complete */


	if(FLAME_TEST_PRINT_START_AND_END_OF_MODEL_FUNCTIONS) printf("start Firm_compute_balance_sheet\n");
	current_xmachine_Firm_holder = Firm_004_state->agents;
	while(current_xmachine_Firm_holder)
	{
		temp_xmachine_Firm_holder = current_xmachine_Firm_holder->next;
		current_xmachine_Firm = current_xmachine_Firm_holder->agent;
		current_xmachine_Firm_next_state = Firm_Firm_Bankruptcy_check_state;
		/* For backwards compatibility set current_xmachine */
		current_xmachine->xmachine_Firm = NULL;
		current_xmachine->xmachine_Household = NULL;
		current_xmachine->xmachine_Mall = NULL;
		current_xmachine->xmachine_IGFirm = NULL;
		current_xmachine->xmachine_Eurostat = NULL;
		current_xmachine->xmachine_Bank = NULL;
		current_xmachine->xmachine_Government = NULL;
		current_xmachine->xmachine_CentralBank = NULL;
		current_xmachine->xmachine_ClearingHouse = NULL;
		current_xmachine->xmachine_Firm = current_xmachine_Firm;

		

		

			i = Firm_compute_balance_sheet();

		

			if(i == 1)
			{
				free_Firm_agent(current_xmachine_Firm_holder, Firm_004_state);
			}
			else
			{
				transition_Firm_agent(current_xmachine_Firm_holder, Firm_004_state, Firm_Firm_Bankruptcy_check_state);
			}
		

		current_xmachine_Firm = NULL;

		current_xmachine_Firm_holder = temp_xmachine_Firm_holder;
	}
	if(FLAME_TEST_PRINT_START_AND_END_OF_MODEL_FUNCTIONS) printf("finish Firm_compute_balance_sheet\n");


/* End of layer number 86 */

/* Clear message boards that have finished being used
 * and sync complete if doing late sync complete */


	if(FLAME_TEST_PRINT_START_AND_END_OF_MODEL_FUNCTIONS) printf("start Firm_set_bankruptcy_insolvency\n");
	current_xmachine_Firm_holder = Firm_Firm_Bankruptcy_check_state->agents;
	while(current_xmachine_Firm_holder)
	{
		temp_xmachine_Firm_holder = current_xmachine_Firm_holder->next;
		current_xmachine_Firm = current_xmachine_Firm_holder->agent;
		current_xmachine_Firm_next_state = Firm_Firm_variables_reset_state;
		/* For backwards compatibility set current_xmachine */
		current_xmachine->xmachine_Firm = NULL;
		current_xmachine->xmachine_Household = NULL;
		current_xmachine->xmachine_Mall = NULL;
		current_xmachine->xmachine_IGFirm = NULL;
		current_xmachine->xmachine_Eurostat = NULL;
		current_xmachine->xmachine_Bank = NULL;
		current_xmachine->xmachine_Government = NULL;
		current_xmachine->xmachine_CentralBank = NULL;
		current_xmachine->xmachine_ClearingHouse = NULL;
		current_xmachine->xmachine_Firm = current_xmachine_Firm;

		if(FLAME_condition_Firm_Firm_set_bankruptcy_insolvency_Firm_Bankruptcy_check_Firm_variables_reset(current_xmachine_Firm)==1)
		{

		

			i = Firm_set_bankruptcy_insolvency();

		

			if(i == 1)
			{
				free_Firm_agent(current_xmachine_Firm_holder, Firm_Firm_Bankruptcy_check_state);
			}
			else
			{
				transition_Firm_agent(current_xmachine_Firm_holder, Firm_Firm_Bankruptcy_check_state, Firm_Firm_variables_reset_state);
			}
		}

		current_xmachine_Firm = NULL;

		current_xmachine_Firm_holder = temp_xmachine_Firm_holder;
	}
	if(FLAME_TEST_PRINT_START_AND_END_OF_MODEL_FUNCTIONS) printf("finish Firm_set_bankruptcy_insolvency\n");

	if(FLAME_bankruptcy_insolvency_message_board_write == 1)
	{

		if(FLAME_TEST_PRINT_START_AND_END_OF_LIBMBOARD_CALLS) printf("start MB_SyncStart(b_bankruptcy_insolvency)\n");
		rc = MB_SyncStart(b_bankruptcy_insolvency);
		if(FLAME_TEST_PRINT_START_AND_END_OF_LIBMBOARD_CALLS) printf("finish MB_SyncStart(b_bankruptcy_insolvency)\n");
		#ifdef ERRCHECK
		if (rc != MB_SUCCESS)
		{
		   fprintf(stderr, "ERROR: Could not start sync of 'bankruptcy_insolvency' board\n");
		   switch(rc) {
			   case MB_ERR_INVALID:
				   fprintf(stderr, "\t reason: 'bankruptcy_insolvency' board is invalid\n");
				   break;
			   case MB_ERR_LOCKED:
				   fprintf(stderr, "\t reason: 'bankruptcy_insolvency' board is locked\n");
				   break;
			   case MB_ERR_MEMALLOC:
				   fprintf(stderr, "\t reason: out of memory\n");
				   break;
			   case MB_ERR_INTERNAL:
				   fprintf(stderr, "\t reason: internal error. Recompile libmoard in debug mode for more info \n");
				   break;
			   default:
				   fprintf(stderr, "\t MB_SyncStart returned error code: %d (see libmboard docs for details)\n", rc);
				   break;
		   }

			
			exit(rc);
		}
		#endif
    }
    


	if(FLAME_TEST_PRINT_START_AND_END_OF_MODEL_FUNCTIONS) printf("start idle\n");
	current_xmachine_Firm_holder = Firm_Firm_Bankruptcy_check_state->agents;
	while(current_xmachine_Firm_holder)
	{
		temp_xmachine_Firm_holder = current_xmachine_Firm_holder->next;
		current_xmachine_Firm = current_xmachine_Firm_holder->agent;
		current_xmachine_Firm_next_state = Firm_Firm_End_Financial_Management_Role_state;
		/* For backwards compatibility set current_xmachine */
		current_xmachine->xmachine_Firm = NULL;
		current_xmachine->xmachine_Household = NULL;
		current_xmachine->xmachine_Mall = NULL;
		current_xmachine->xmachine_IGFirm = NULL;
		current_xmachine->xmachine_Eurostat = NULL;
		current_xmachine->xmachine_Bank = NULL;
		current_xmachine->xmachine_Government = NULL;
		current_xmachine->xmachine_CentralBank = NULL;
		current_xmachine->xmachine_ClearingHouse = NULL;
		current_xmachine->xmachine_Firm = current_xmachine_Firm;

		if(FLAME_condition_Firm_idle_Firm_Bankruptcy_check_Firm_End_Financial_Management_Role(current_xmachine_Firm)==1)
		{

		

			i = idle();

		

			if(i == 1)
			{
				free_Firm_agent(current_xmachine_Firm_holder, Firm_Firm_Bankruptcy_check_state);
			}
			else
			{
				transition_Firm_agent(current_xmachine_Firm_holder, Firm_Firm_Bankruptcy_check_state, Firm_Firm_End_Financial_Management_Role_state);
			}
		}

		current_xmachine_Firm = NULL;

		current_xmachine_Firm_holder = temp_xmachine_Firm_holder;
	}
	if(FLAME_TEST_PRINT_START_AND_END_OF_MODEL_FUNCTIONS) printf("finish idle\n");


/* End of layer number 87 */

/* Clear message boards that have finished being used
 * and sync complete if doing late sync complete */


	if(FLAME_TEST_PRINT_START_AND_END_OF_MODEL_FUNCTIONS) printf("start Firm_bankruptcy_reset_immediately\n");
	current_xmachine_Firm_holder = Firm_Firm_variables_reset_state->agents;
	while(current_xmachine_Firm_holder)
	{
		temp_xmachine_Firm_holder = current_xmachine_Firm_holder->next;
		current_xmachine_Firm = current_xmachine_Firm_holder->agent;
		current_xmachine_Firm_next_state = Firm_Firm_End_Financial_Management_Role_state;
		/* For backwards compatibility set current_xmachine */
		current_xmachine->xmachine_Firm = NULL;
		current_xmachine->xmachine_Household = NULL;
		current_xmachine->xmachine_Mall = NULL;
		current_xmachine->xmachine_IGFirm = NULL;
		current_xmachine->xmachine_Eurostat = NULL;
		current_xmachine->xmachine_Bank = NULL;
		current_xmachine->xmachine_Government = NULL;
		current_xmachine->xmachine_CentralBank = NULL;
		current_xmachine->xmachine_ClearingHouse = NULL;
		current_xmachine->xmachine_Firm = current_xmachine_Firm;

		

		

			i = Firm_bankruptcy_reset_immediately();

		

			if(i == 1)
			{
				free_Firm_agent(current_xmachine_Firm_holder, Firm_Firm_variables_reset_state);
			}
			else
			{
				transition_Firm_agent(current_xmachine_Firm_holder, Firm_Firm_variables_reset_state, Firm_Firm_End_Financial_Management_Role_state);
			}
		

		current_xmachine_Firm = NULL;

		current_xmachine_Firm_holder = temp_xmachine_Firm_holder;
	}
	if(FLAME_TEST_PRINT_START_AND_END_OF_MODEL_FUNCTIONS) printf("finish Firm_bankruptcy_reset_immediately\n");


	/* If mb is not read then leave sync complete until last possible moment */
	if(FLAME_bankruptcy_insolvency_message_board_read == 1)
	{
		if(FLAME_TEST_PRINT_START_AND_END_OF_LIBMBOARD_CALLS) printf("start MB_SyncComplete(b_bankruptcy_insolvency)\n");
		rc = MB_SyncComplete(b_bankruptcy_insolvency);
		if(FLAME_TEST_PRINT_START_AND_END_OF_LIBMBOARD_CALLS) printf("finsh MB_SyncComplete(b_bankruptcy_insolvency)\n");
		#ifdef ERRCHECK
		if (rc != MB_SUCCESS)
		{
		   fprintf(stderr, "ERROR: Could not complete sync of 'bankruptcy_insolvency' board\n");
		   switch(rc) {
				case MB_ERR_INVALID:
				   fprintf(stderr, "\t reason: 'bankruptcy_insolvency' board is invalid\n");
				   break;
			   case MB_ERR_MEMALLOC:
				   fprintf(stderr, "\t reason: out of memory\n");
				   break;
			   case MB_ERR_INTERNAL:
				   fprintf(stderr, "\t reason: internal error. Recompile libmoard in debug mode for more info \n");
				   break;
			   default:
				   fprintf(stderr, "\t MB_SyncComplete returned error code: %d (see libmboard docs for details)\n", rc);
				   break;
		   }
	
		   
		   exit(rc);
		}
		#endif
    
	}
	
	if(FLAME_TEST_PRINT_START_AND_END_OF_MODEL_FUNCTIONS) printf("start Mall_read_insolvency_bankruptcy\n");
	current_xmachine_Mall_holder = Mall_05a_state->agents;
	while(current_xmachine_Mall_holder)
	{
		temp_xmachine_Mall_holder = current_xmachine_Mall_holder->next;
		current_xmachine_Mall = current_xmachine_Mall_holder->agent;
		current_xmachine_Mall_next_state = Mall_06_state;
		/* For backwards compatibility set current_xmachine */
		current_xmachine->xmachine_Firm = NULL;
		current_xmachine->xmachine_Household = NULL;
		current_xmachine->xmachine_Mall = NULL;
		current_xmachine->xmachine_IGFirm = NULL;
		current_xmachine->xmachine_Eurostat = NULL;
		current_xmachine->xmachine_Bank = NULL;
		current_xmachine->xmachine_Government = NULL;
		current_xmachine->xmachine_CentralBank = NULL;
		current_xmachine->xmachine_ClearingHouse = NULL;
		current_xmachine->xmachine_Mall = current_xmachine_Mall;

		

		
		
		rc = MB_Iterator_Create(b_bankruptcy_insolvency, &i_bankruptcy_insolvency);
		#ifdef ERRCHECK
		if (rc != MB_SUCCESS)
		{
		   fprintf(stderr, "ERROR: Could not create Iterator for 'bankruptcy_insolvency'\n");
		   switch(rc) {
		       case MB_ERR_INVALID:
		           fprintf(stderr, "\t reason: 'bankruptcy_insolvency' board is invalid\n");
		           break;
		       case MB_ERR_LOCKED:
	               fprintf(stderr, "\t reason: 'bankruptcy_insolvency' board is locked\n");
	               break;
	           case MB_ERR_MEMALLOC:
	               fprintf(stderr, "\t reason: out of memory\n");
	               break;
	           case MB_ERR_INTERNAL:
	               fprintf(stderr, "\t reason: internal error. Recompile libmoard in debug mode for more info \n");
	               break;
	           default:
	           
               
                   fprintf(stderr, "\t MB_Iterator_Create returned error code: %d (see libmboard docs for details)\n", rc);
               
                   break;
		   }

		   
           exit(rc);
		}
		#endif
		
		

			i = Mall_read_insolvency_bankruptcy();

		
		    rc = MB_Iterator_Delete(&i_bankruptcy_insolvency);
		    #ifdef ERRCHECK
		    if (rc != MB_SUCCESS)
		    {
		       fprintf(stderr, "ERROR: Could not delete 'bankruptcy_insolvency' iterator\n");
		       switch(rc) {
		           case MB_ERR_INVALID:
		               fprintf(stderr, "\t reason: 'bankruptcy_insolvency' iterator is invalid\n");
		               break;
		           case MB_ERR_INTERNAL:
		               fprintf(stderr, "\t reason: internal error. Recompile libmoard in debug mode for more info \n");
		               break;
		           default:
                       fprintf(stderr, "\t MB_Iterator_Delete returned error code: %d (see libmboard docs for details)\n", rc);
                       break;
		       }

		       
               exit(rc);
		    }
		    #endif
		

			if(i == 1)
			{
				free_Mall_agent(current_xmachine_Mall_holder, Mall_05a_state);
			}
			else
			{
				transition_Mall_agent(current_xmachine_Mall_holder, Mall_05a_state, Mall_06_state);
			}
		

		current_xmachine_Mall = NULL;

		current_xmachine_Mall_holder = temp_xmachine_Mall_holder;
	}
	if(FLAME_TEST_PRINT_START_AND_END_OF_MODEL_FUNCTIONS) printf("finish Mall_read_insolvency_bankruptcy\n");


/* End of layer number 88 */

/* Clear message boards that have finished being used
 * and sync complete if doing late sync complete */


	if(FLAME_TEST_PRINT_START_AND_END_OF_MODEL_FUNCTIONS) printf("start Mall_send_export_data\n");
	current_xmachine_Mall_holder = Mall_06_state->agents;
	while(current_xmachine_Mall_holder)
	{
		temp_xmachine_Mall_holder = current_xmachine_Mall_holder->next;
		current_xmachine_Mall = current_xmachine_Mall_holder->agent;
		current_xmachine_Mall_next_state = Mall_end_Mall_state;
		/* For backwards compatibility set current_xmachine */
		current_xmachine->xmachine_Firm = NULL;
		current_xmachine->xmachine_Household = NULL;
		current_xmachine->xmachine_Mall = NULL;
		current_xmachine->xmachine_IGFirm = NULL;
		current_xmachine->xmachine_Eurostat = NULL;
		current_xmachine->xmachine_Bank = NULL;
		current_xmachine->xmachine_Government = NULL;
		current_xmachine->xmachine_CentralBank = NULL;
		current_xmachine->xmachine_ClearingHouse = NULL;
		current_xmachine->xmachine_Mall = current_xmachine_Mall;

		if(FLAME_condition_Mall_Mall_send_export_data_06_end_Mall(current_xmachine_Mall)==1)
		{

		

			i = Mall_send_export_data();

		

			if(i == 1)
			{
				free_Mall_agent(current_xmachine_Mall_holder, Mall_06_state);
			}
			else
			{
				transition_Mall_agent(current_xmachine_Mall_holder, Mall_06_state, Mall_end_Mall_state);
			}
		}

		current_xmachine_Mall = NULL;

		current_xmachine_Mall_holder = temp_xmachine_Mall_holder;
	}
	if(FLAME_TEST_PRINT_START_AND_END_OF_MODEL_FUNCTIONS) printf("finish Mall_send_export_data\n");

	if(FLAME_mall_data_message_board_write == 1)
	{

		if(FLAME_TEST_PRINT_START_AND_END_OF_LIBMBOARD_CALLS) printf("start MB_SyncStart(b_mall_data)\n");
		rc = MB_SyncStart(b_mall_data);
		if(FLAME_TEST_PRINT_START_AND_END_OF_LIBMBOARD_CALLS) printf("finish MB_SyncStart(b_mall_data)\n");
		#ifdef ERRCHECK
		if (rc != MB_SUCCESS)
		{
		   fprintf(stderr, "ERROR: Could not start sync of 'mall_data' board\n");
		   switch(rc) {
			   case MB_ERR_INVALID:
				   fprintf(stderr, "\t reason: 'mall_data' board is invalid\n");
				   break;
			   case MB_ERR_LOCKED:
				   fprintf(stderr, "\t reason: 'mall_data' board is locked\n");
				   break;
			   case MB_ERR_MEMALLOC:
				   fprintf(stderr, "\t reason: out of memory\n");
				   break;
			   case MB_ERR_INTERNAL:
				   fprintf(stderr, "\t reason: internal error. Recompile libmoard in debug mode for more info \n");
				   break;
			   default:
				   fprintf(stderr, "\t MB_SyncStart returned error code: %d (see libmboard docs for details)\n", rc);
				   break;
		   }

			
			exit(rc);
		}
		#endif
    }
    


	if(FLAME_TEST_PRINT_START_AND_END_OF_MODEL_FUNCTIONS) printf("start idle\n");
	current_xmachine_Mall_holder = Mall_06_state->agents;
	while(current_xmachine_Mall_holder)
	{
		temp_xmachine_Mall_holder = current_xmachine_Mall_holder->next;
		current_xmachine_Mall = current_xmachine_Mall_holder->agent;
		current_xmachine_Mall_next_state = Mall_end_Mall_state;
		/* For backwards compatibility set current_xmachine */
		current_xmachine->xmachine_Firm = NULL;
		current_xmachine->xmachine_Household = NULL;
		current_xmachine->xmachine_Mall = NULL;
		current_xmachine->xmachine_IGFirm = NULL;
		current_xmachine->xmachine_Eurostat = NULL;
		current_xmachine->xmachine_Bank = NULL;
		current_xmachine->xmachine_Government = NULL;
		current_xmachine->xmachine_CentralBank = NULL;
		current_xmachine->xmachine_ClearingHouse = NULL;
		current_xmachine->xmachine_Mall = current_xmachine_Mall;

		if(FLAME_condition_Mall_idle_06_end_Mall(current_xmachine_Mall)==1)
		{

		

			i = idle();

		

			if(i == 1)
			{
				free_Mall_agent(current_xmachine_Mall_holder, Mall_06_state);
			}
			else
			{
				transition_Mall_agent(current_xmachine_Mall_holder, Mall_06_state, Mall_end_Mall_state);
			}
		}

		current_xmachine_Mall = NULL;

		current_xmachine_Mall_holder = temp_xmachine_Mall_holder;
	}
	if(FLAME_TEST_PRINT_START_AND_END_OF_MODEL_FUNCTIONS) printf("finish idle\n");


	if(FLAME_TEST_PRINT_START_AND_END_OF_MODEL_FUNCTIONS) printf("start idle\n");
	current_xmachine_Firm_holder = Firm_Firm_End_Financial_Management_Role_state->agents;
	while(current_xmachine_Firm_holder)
	{
		temp_xmachine_Firm_holder = current_xmachine_Firm_holder->next;
		current_xmachine_Firm = current_xmachine_Firm_holder->agent;
		current_xmachine_Firm_next_state = Firm_Firm_End_Branches_state;
		/* For backwards compatibility set current_xmachine */
		current_xmachine->xmachine_Firm = NULL;
		current_xmachine->xmachine_Household = NULL;
		current_xmachine->xmachine_Mall = NULL;
		current_xmachine->xmachine_IGFirm = NULL;
		current_xmachine->xmachine_Eurostat = NULL;
		current_xmachine->xmachine_Bank = NULL;
		current_xmachine->xmachine_Government = NULL;
		current_xmachine->xmachine_CentralBank = NULL;
		current_xmachine->xmachine_ClearingHouse = NULL;
		current_xmachine->xmachine_Firm = current_xmachine_Firm;

		

		

			i = idle();

		

			if(i == 1)
			{
				free_Firm_agent(current_xmachine_Firm_holder, Firm_Firm_End_Financial_Management_Role_state);
			}
			else
			{
				transition_Firm_agent(current_xmachine_Firm_holder, Firm_Firm_End_Financial_Management_Role_state, Firm_Firm_End_Branches_state);
			}
		

		current_xmachine_Firm = NULL;

		current_xmachine_Firm_holder = temp_xmachine_Firm_holder;
	}
	if(FLAME_TEST_PRINT_START_AND_END_OF_MODEL_FUNCTIONS) printf("finish idle\n");


/* End of layer number 89 */

/* Clear message boards that have finished being used
 * and sync complete if doing late sync complete */


	if(FLAME_TEST_PRINT_START_AND_END_OF_MODEL_FUNCTIONS) printf("start Firm_send_data_to_Eurostat\n");
	current_xmachine_Firm_holder = Firm_Firm_End_Branches_state->agents;
	while(current_xmachine_Firm_holder)
	{
		temp_xmachine_Firm_holder = current_xmachine_Firm_holder->next;
		current_xmachine_Firm = current_xmachine_Firm_holder->agent;
		current_xmachine_Firm_next_state = Firm_Firm_Send_Data_state;
		/* For backwards compatibility set current_xmachine */
		current_xmachine->xmachine_Firm = NULL;
		current_xmachine->xmachine_Household = NULL;
		current_xmachine->xmachine_Mall = NULL;
		current_xmachine->xmachine_IGFirm = NULL;
		current_xmachine->xmachine_Eurostat = NULL;
		current_xmachine->xmachine_Bank = NULL;
		current_xmachine->xmachine_Government = NULL;
		current_xmachine->xmachine_CentralBank = NULL;
		current_xmachine->xmachine_ClearingHouse = NULL;
		current_xmachine->xmachine_Firm = current_xmachine_Firm;

		if(FLAME_condition_Firm_Firm_send_data_to_Eurostat_Firm_End_Branches_Firm_Send_Data(current_xmachine_Firm)==1)
		{

		

			i = Firm_send_data_to_Eurostat();

		

			if(i == 1)
			{
				free_Firm_agent(current_xmachine_Firm_holder, Firm_Firm_End_Branches_state);
			}
			else
			{
				transition_Firm_agent(current_xmachine_Firm_holder, Firm_Firm_End_Branches_state, Firm_Firm_Send_Data_state);
			}
		}

		current_xmachine_Firm = NULL;

		current_xmachine_Firm_holder = temp_xmachine_Firm_holder;
	}
	if(FLAME_TEST_PRINT_START_AND_END_OF_MODEL_FUNCTIONS) printf("finish Firm_send_data_to_Eurostat\n");

	if(FLAME_firm_send_data_message_board_write == 1)
	{

		if(FLAME_TEST_PRINT_START_AND_END_OF_LIBMBOARD_CALLS) printf("start MB_SyncStart(b_firm_send_data)\n");
		rc = MB_SyncStart(b_firm_send_data);
		if(FLAME_TEST_PRINT_START_AND_END_OF_LIBMBOARD_CALLS) printf("finish MB_SyncStart(b_firm_send_data)\n");
		#ifdef ERRCHECK
		if (rc != MB_SUCCESS)
		{
		   fprintf(stderr, "ERROR: Could not start sync of 'firm_send_data' board\n");
		   switch(rc) {
			   case MB_ERR_INVALID:
				   fprintf(stderr, "\t reason: 'firm_send_data' board is invalid\n");
				   break;
			   case MB_ERR_LOCKED:
				   fprintf(stderr, "\t reason: 'firm_send_data' board is locked\n");
				   break;
			   case MB_ERR_MEMALLOC:
				   fprintf(stderr, "\t reason: out of memory\n");
				   break;
			   case MB_ERR_INTERNAL:
				   fprintf(stderr, "\t reason: internal error. Recompile libmoard in debug mode for more info \n");
				   break;
			   default:
				   fprintf(stderr, "\t MB_SyncStart returned error code: %d (see libmboard docs for details)\n", rc);
				   break;
		   }

			
			exit(rc);
		}
		#endif
    }
    


	if(FLAME_TEST_PRINT_START_AND_END_OF_MODEL_FUNCTIONS) printf("start idle\n");
	current_xmachine_Firm_holder = Firm_Firm_End_Branches_state->agents;
	while(current_xmachine_Firm_holder)
	{
		temp_xmachine_Firm_holder = current_xmachine_Firm_holder->next;
		current_xmachine_Firm = current_xmachine_Firm_holder->agent;
		current_xmachine_Firm_next_state = Firm_15_state;
		/* For backwards compatibility set current_xmachine */
		current_xmachine->xmachine_Firm = NULL;
		current_xmachine->xmachine_Household = NULL;
		current_xmachine->xmachine_Mall = NULL;
		current_xmachine->xmachine_IGFirm = NULL;
		current_xmachine->xmachine_Eurostat = NULL;
		current_xmachine->xmachine_Bank = NULL;
		current_xmachine->xmachine_Government = NULL;
		current_xmachine->xmachine_CentralBank = NULL;
		current_xmachine->xmachine_ClearingHouse = NULL;
		current_xmachine->xmachine_Firm = current_xmachine_Firm;

		if(FLAME_condition_Firm_idle_Firm_End_Branches_15(current_xmachine_Firm)==1)
		{

		

			i = idle();

		

			if(i == 1)
			{
				free_Firm_agent(current_xmachine_Firm_holder, Firm_Firm_End_Branches_state);
			}
			else
			{
				transition_Firm_agent(current_xmachine_Firm_holder, Firm_Firm_End_Branches_state, Firm_15_state);
			}
		}

		current_xmachine_Firm = NULL;

		current_xmachine_Firm_holder = temp_xmachine_Firm_holder;
	}
	if(FLAME_TEST_PRINT_START_AND_END_OF_MODEL_FUNCTIONS) printf("finish idle\n");


/* End of layer number 90 */

/* Clear message boards that have finished being used
 * and sync complete if doing late sync complete */


	if(FLAME_TEST_PRINT_START_AND_END_OF_MODEL_FUNCTIONS) printf("start Firm_compute_stock_flows\n");
	current_xmachine_Firm_holder = Firm_Firm_Send_Data_state->agents;
	while(current_xmachine_Firm_holder)
	{
		temp_xmachine_Firm_holder = current_xmachine_Firm_holder->next;
		current_xmachine_Firm = current_xmachine_Firm_holder->agent;
		current_xmachine_Firm_next_state = Firm_15_state;
		/* For backwards compatibility set current_xmachine */
		current_xmachine->xmachine_Firm = NULL;
		current_xmachine->xmachine_Household = NULL;
		current_xmachine->xmachine_Mall = NULL;
		current_xmachine->xmachine_IGFirm = NULL;
		current_xmachine->xmachine_Eurostat = NULL;
		current_xmachine->xmachine_Bank = NULL;
		current_xmachine->xmachine_Government = NULL;
		current_xmachine->xmachine_CentralBank = NULL;
		current_xmachine->xmachine_ClearingHouse = NULL;
		current_xmachine->xmachine_Firm = current_xmachine_Firm;

		

		

			i = Firm_compute_stock_flows();

		

			if(i == 1)
			{
				free_Firm_agent(current_xmachine_Firm_holder, Firm_Firm_Send_Data_state);
			}
			else
			{
				transition_Firm_agent(current_xmachine_Firm_holder, Firm_Firm_Send_Data_state, Firm_15_state);
			}
		

		current_xmachine_Firm = NULL;

		current_xmachine_Firm_holder = temp_xmachine_Firm_holder;
	}
	if(FLAME_TEST_PRINT_START_AND_END_OF_MODEL_FUNCTIONS) printf("finish Firm_compute_stock_flows\n");


/* End of layer number 91 */

/* Clear message boards that have finished being used
 * and sync complete if doing late sync complete */


	if(FLAME_TEST_PRINT_START_AND_END_OF_MODEL_FUNCTIONS) printf("start Firm_set_minsky_state_bankruptcy\n");
	current_xmachine_Firm_holder = Firm_15_state->agents;
	while(current_xmachine_Firm_holder)
	{
		temp_xmachine_Firm_holder = current_xmachine_Firm_holder->next;
		current_xmachine_Firm = current_xmachine_Firm_holder->agent;
		current_xmachine_Firm_next_state = Firm_16_state;
		/* For backwards compatibility set current_xmachine */
		current_xmachine->xmachine_Firm = NULL;
		current_xmachine->xmachine_Household = NULL;
		current_xmachine->xmachine_Mall = NULL;
		current_xmachine->xmachine_IGFirm = NULL;
		current_xmachine->xmachine_Eurostat = NULL;
		current_xmachine->xmachine_Bank = NULL;
		current_xmachine->xmachine_Government = NULL;
		current_xmachine->xmachine_CentralBank = NULL;
		current_xmachine->xmachine_ClearingHouse = NULL;
		current_xmachine->xmachine_Firm = current_xmachine_Firm;

		

		

			i = Firm_set_minsky_state_bankruptcy();

		

			if(i == 1)
			{
				free_Firm_agent(current_xmachine_Firm_holder, Firm_15_state);
			}
			else
			{
				transition_Firm_agent(current_xmachine_Firm_holder, Firm_15_state, Firm_16_state);
			}
		

		current_xmachine_Firm = NULL;

		current_xmachine_Firm_holder = temp_xmachine_Firm_holder;
	}
	if(FLAME_TEST_PRINT_START_AND_END_OF_MODEL_FUNCTIONS) printf("finish Firm_set_minsky_state_bankruptcy\n");


/* End of layer number 92 */

/* Clear message boards that have finished being used
 * and sync complete if doing late sync complete */


	if(FLAME_TEST_PRINT_START_AND_END_OF_MODEL_FUNCTIONS) printf("start Firm_send_payments_to_bank\n");
	current_xmachine_Firm_holder = Firm_16_state->agents;
	while(current_xmachine_Firm_holder)
	{
		temp_xmachine_Firm_holder = current_xmachine_Firm_holder->next;
		current_xmachine_Firm = current_xmachine_Firm_holder->agent;
		current_xmachine_Firm_next_state = Firm_end_Firm_state;
		/* For backwards compatibility set current_xmachine */
		current_xmachine->xmachine_Firm = NULL;
		current_xmachine->xmachine_Household = NULL;
		current_xmachine->xmachine_Mall = NULL;
		current_xmachine->xmachine_IGFirm = NULL;
		current_xmachine->xmachine_Eurostat = NULL;
		current_xmachine->xmachine_Bank = NULL;
		current_xmachine->xmachine_Government = NULL;
		current_xmachine->xmachine_CentralBank = NULL;
		current_xmachine->xmachine_ClearingHouse = NULL;
		current_xmachine->xmachine_Firm = current_xmachine_Firm;

		

		

			i = Firm_send_payments_to_bank();

		

			if(i == 1)
			{
				free_Firm_agent(current_xmachine_Firm_holder, Firm_16_state);
			}
			else
			{
				transition_Firm_agent(current_xmachine_Firm_holder, Firm_16_state, Firm_end_Firm_state);
			}
		

		current_xmachine_Firm = NULL;

		current_xmachine_Firm_holder = temp_xmachine_Firm_holder;
	}
	if(FLAME_TEST_PRINT_START_AND_END_OF_MODEL_FUNCTIONS) printf("finish Firm_send_payments_to_bank\n");

	if(FLAME_credit_var_update_message_board_write == 1)
	{

		if(FLAME_TEST_PRINT_START_AND_END_OF_LIBMBOARD_CALLS) printf("start MB_SyncStart(b_credit_var_update)\n");
		rc = MB_SyncStart(b_credit_var_update);
		if(FLAME_TEST_PRINT_START_AND_END_OF_LIBMBOARD_CALLS) printf("finish MB_SyncStart(b_credit_var_update)\n");
		#ifdef ERRCHECK
		if (rc != MB_SUCCESS)
		{
		   fprintf(stderr, "ERROR: Could not start sync of 'credit_var_update' board\n");
		   switch(rc) {
			   case MB_ERR_INVALID:
				   fprintf(stderr, "\t reason: 'credit_var_update' board is invalid\n");
				   break;
			   case MB_ERR_LOCKED:
				   fprintf(stderr, "\t reason: 'credit_var_update' board is locked\n");
				   break;
			   case MB_ERR_MEMALLOC:
				   fprintf(stderr, "\t reason: out of memory\n");
				   break;
			   case MB_ERR_INTERNAL:
				   fprintf(stderr, "\t reason: internal error. Recompile libmoard in debug mode for more info \n");
				   break;
			   default:
				   fprintf(stderr, "\t MB_SyncStart returned error code: %d (see libmboard docs for details)\n", rc);
				   break;
		   }

			
			exit(rc);
		}
		#endif
    }
    

	if(FLAME_bank_account_update_message_board_write == 1)
	{

		if(FLAME_TEST_PRINT_START_AND_END_OF_LIBMBOARD_CALLS) printf("start MB_SyncStart(b_bank_account_update)\n");
		rc = MB_SyncStart(b_bank_account_update);
		if(FLAME_TEST_PRINT_START_AND_END_OF_LIBMBOARD_CALLS) printf("finish MB_SyncStart(b_bank_account_update)\n");
		#ifdef ERRCHECK
		if (rc != MB_SUCCESS)
		{
		   fprintf(stderr, "ERROR: Could not start sync of 'bank_account_update' board\n");
		   switch(rc) {
			   case MB_ERR_INVALID:
				   fprintf(stderr, "\t reason: 'bank_account_update' board is invalid\n");
				   break;
			   case MB_ERR_LOCKED:
				   fprintf(stderr, "\t reason: 'bank_account_update' board is locked\n");
				   break;
			   case MB_ERR_MEMALLOC:
				   fprintf(stderr, "\t reason: out of memory\n");
				   break;
			   case MB_ERR_INTERNAL:
				   fprintf(stderr, "\t reason: internal error. Recompile libmoard in debug mode for more info \n");
				   break;
			   default:
				   fprintf(stderr, "\t MB_SyncStart returned error code: %d (see libmboard docs for details)\n", rc);
				   break;
		   }

			
			exit(rc);
		}
		#endif
    }
    


/* End of layer number 93 */

/* Clear message boards that have finished being used
 * and sync complete if doing late sync complete */


	/* If mb is not read then leave sync complete until last possible moment */
	if(FLAME_credit_var_update_message_board_read == 1)
	{
		if(FLAME_TEST_PRINT_START_AND_END_OF_LIBMBOARD_CALLS) printf("start MB_SyncComplete(b_credit_var_update)\n");
		rc = MB_SyncComplete(b_credit_var_update);
		if(FLAME_TEST_PRINT_START_AND_END_OF_LIBMBOARD_CALLS) printf("finsh MB_SyncComplete(b_credit_var_update)\n");
		#ifdef ERRCHECK
		if (rc != MB_SUCCESS)
		{
		   fprintf(stderr, "ERROR: Could not complete sync of 'credit_var_update' board\n");
		   switch(rc) {
				case MB_ERR_INVALID:
				   fprintf(stderr, "\t reason: 'credit_var_update' board is invalid\n");
				   break;
			   case MB_ERR_MEMALLOC:
				   fprintf(stderr, "\t reason: out of memory\n");
				   break;
			   case MB_ERR_INTERNAL:
				   fprintf(stderr, "\t reason: internal error. Recompile libmoard in debug mode for more info \n");
				   break;
			   default:
				   fprintf(stderr, "\t MB_SyncComplete returned error code: %d (see libmboard docs for details)\n", rc);
				   break;
		   }
	
		   
		   exit(rc);
		}
		#endif
    
	}
	
	/* If mb is not read then leave sync complete until last possible moment */
	if(FLAME_bank_account_update_message_board_read == 1)
	{
		if(FLAME_TEST_PRINT_START_AND_END_OF_LIBMBOARD_CALLS) printf("start MB_SyncComplete(b_bank_account_update)\n");
		rc = MB_SyncComplete(b_bank_account_update);
		if(FLAME_TEST_PRINT_START_AND_END_OF_LIBMBOARD_CALLS) printf("finsh MB_SyncComplete(b_bank_account_update)\n");
		#ifdef ERRCHECK
		if (rc != MB_SUCCESS)
		{
		   fprintf(stderr, "ERROR: Could not complete sync of 'bank_account_update' board\n");
		   switch(rc) {
				case MB_ERR_INVALID:
				   fprintf(stderr, "\t reason: 'bank_account_update' board is invalid\n");
				   break;
			   case MB_ERR_MEMALLOC:
				   fprintf(stderr, "\t reason: out of memory\n");
				   break;
			   case MB_ERR_INTERNAL:
				   fprintf(stderr, "\t reason: internal error. Recompile libmoard in debug mode for more info \n");
				   break;
			   default:
				   fprintf(stderr, "\t MB_SyncComplete returned error code: %d (see libmboard docs for details)\n", rc);
				   break;
		   }
	
		   
		   exit(rc);
		}
		#endif
    
	}
	
	if(FLAME_TEST_PRINT_START_AND_END_OF_MODEL_FUNCTIONS) printf("start Bank_account_update_deposits\n");
	current_xmachine_Bank_holder = Bank_Bank_05_state->agents;
	while(current_xmachine_Bank_holder)
	{
		temp_xmachine_Bank_holder = current_xmachine_Bank_holder->next;
		current_xmachine_Bank = current_xmachine_Bank_holder->agent;
		current_xmachine_Bank_next_state = Bank_Bank_06_state;
		/* For backwards compatibility set current_xmachine */
		current_xmachine->xmachine_Firm = NULL;
		current_xmachine->xmachine_Household = NULL;
		current_xmachine->xmachine_Mall = NULL;
		current_xmachine->xmachine_IGFirm = NULL;
		current_xmachine->xmachine_Eurostat = NULL;
		current_xmachine->xmachine_Bank = NULL;
		current_xmachine->xmachine_Government = NULL;
		current_xmachine->xmachine_CentralBank = NULL;
		current_xmachine->xmachine_ClearingHouse = NULL;
		current_xmachine->xmachine_Bank = current_xmachine_Bank;

		

		
		rc = MB_Iterator_CreateFiltered(b_bank_account_update, &i_bank_account_update, &FLAME_filter_Bank_Bank_account_update_deposits_Bank_05_Bank_06_bank_account_update, current_xmachine_Bank);
		
		#ifdef ERRCHECK
		if (rc != MB_SUCCESS)
		{
		   fprintf(stderr, "ERROR: Could not create Iterator for 'bank_account_update'\n");
		   switch(rc) {
		       case MB_ERR_INVALID:
		           fprintf(stderr, "\t reason: 'bank_account_update' board is invalid\n");
		           break;
		       case MB_ERR_LOCKED:
	               fprintf(stderr, "\t reason: 'bank_account_update' board is locked\n");
	               break;
	           case MB_ERR_MEMALLOC:
	               fprintf(stderr, "\t reason: out of memory\n");
	               break;
	           case MB_ERR_INTERNAL:
	               fprintf(stderr, "\t reason: internal error. Recompile libmoard in debug mode for more info \n");
	               break;
	           default:
	           
                   fprintf(stderr, "\t MB_Iterator_CreateFiltered returned error code: %d (see libmboard docs for details)\n", rc);
               
               
                   break;
		   }

		   
           exit(rc);
		}
		#endif
		
		
		rc = MB_Iterator_CreateFiltered(b_credit_var_update, &i_credit_var_update, &FLAME_filter_Bank_Bank_account_update_deposits_Bank_05_Bank_06_credit_var_update, current_xmachine_Bank);
		
		#ifdef ERRCHECK
		if (rc != MB_SUCCESS)
		{
		   fprintf(stderr, "ERROR: Could not create Iterator for 'credit_var_update'\n");
		   switch(rc) {
		       case MB_ERR_INVALID:
		           fprintf(stderr, "\t reason: 'credit_var_update' board is invalid\n");
		           break;
		       case MB_ERR_LOCKED:
	               fprintf(stderr, "\t reason: 'credit_var_update' board is locked\n");
	               break;
	           case MB_ERR_MEMALLOC:
	               fprintf(stderr, "\t reason: out of memory\n");
	               break;
	           case MB_ERR_INTERNAL:
	               fprintf(stderr, "\t reason: internal error. Recompile libmoard in debug mode for more info \n");
	               break;
	           default:
	           
                   fprintf(stderr, "\t MB_Iterator_CreateFiltered returned error code: %d (see libmboard docs for details)\n", rc);
               
               
                   break;
		   }

		   
           exit(rc);
		}
		#endif
		
		

			i = Bank_account_update_deposits();

		
		    rc = MB_Iterator_Delete(&i_bank_account_update);
		    #ifdef ERRCHECK
		    if (rc != MB_SUCCESS)
		    {
		       fprintf(stderr, "ERROR: Could not delete 'bank_account_update' iterator\n");
		       switch(rc) {
		           case MB_ERR_INVALID:
		               fprintf(stderr, "\t reason: 'bank_account_update' iterator is invalid\n");
		               break;
		           case MB_ERR_INTERNAL:
		               fprintf(stderr, "\t reason: internal error. Recompile libmoard in debug mode for more info \n");
		               break;
		           default:
                       fprintf(stderr, "\t MB_Iterator_Delete returned error code: %d (see libmboard docs for details)\n", rc);
                       break;
		       }

		       
               exit(rc);
		    }
		    #endif
		
		    rc = MB_Iterator_Delete(&i_credit_var_update);
		    #ifdef ERRCHECK
		    if (rc != MB_SUCCESS)
		    {
		       fprintf(stderr, "ERROR: Could not delete 'credit_var_update' iterator\n");
		       switch(rc) {
		           case MB_ERR_INVALID:
		               fprintf(stderr, "\t reason: 'credit_var_update' iterator is invalid\n");
		               break;
		           case MB_ERR_INTERNAL:
		               fprintf(stderr, "\t reason: internal error. Recompile libmoard in debug mode for more info \n");
		               break;
		           default:
                       fprintf(stderr, "\t MB_Iterator_Delete returned error code: %d (see libmboard docs for details)\n", rc);
                       break;
		       }

		       
               exit(rc);
		    }
		    #endif
		

			if(i == 1)
			{
				free_Bank_agent(current_xmachine_Bank_holder, Bank_Bank_05_state);
			}
			else
			{
				transition_Bank_agent(current_xmachine_Bank_holder, Bank_Bank_05_state, Bank_Bank_06_state);
			}
		

		current_xmachine_Bank = NULL;

		current_xmachine_Bank_holder = temp_xmachine_Bank_holder;
	}
	if(FLAME_TEST_PRINT_START_AND_END_OF_MODEL_FUNCTIONS) printf("finish Bank_account_update_deposits\n");


/* End of layer number 94 */

/* Clear message boards that have finished being used
 * and sync complete if doing late sync complete */

if(FLAME_bank_account_update_message_board_read == 0)
{
	/*printf("%d> bank_account_update message board sync complete late as no agents reading any messages of this type\n", node_number);*/
	
	if(FLAME_TEST_PRINT_START_AND_END_OF_LIBMBOARD_CALLS) printf("start MB_SyncComplete(b_bank_account_update)\n");
	rc = MB_SyncComplete(b_bank_account_update);
	if(FLAME_TEST_PRINT_START_AND_END_OF_LIBMBOARD_CALLS) printf("finsh MB_SyncComplete(b_bank_account_update)\n");
	#ifdef ERRCHECK
	if (rc != MB_SUCCESS)
	{
	   fprintf(stderr, "ERROR: Could not complete sync of 'bank_account_update' board\n");
	   switch(rc) {
			case MB_ERR_INVALID:
			   fprintf(stderr, "\t reason: 'bank_account_update' board is invalid\n");
			   break;
		   case MB_ERR_MEMALLOC:
			   fprintf(stderr, "\t reason: out of memory\n");
			   break;
		   case MB_ERR_INTERNAL:
			   fprintf(stderr, "\t reason: internal error. Recompile libmoard in debug mode for more info \n");
			   break;
		   default:
			   fprintf(stderr, "\t MB_SyncComplete returned error code: %d (see libmboard docs for details)\n", rc);
			   break;
	   }

	   
	   exit(rc);
	}
	#endif
}

    rc = MB_Clear(b_bank_account_update);
    #ifdef ERRCHECK
    if (rc != MB_SUCCESS)
    {
       fprintf(stderr, "ERROR: Could not clear 'bank_account_update' board\n");
       switch(rc) {
           case MB_ERR_INVALID:
               fprintf(stderr, "\t reason: 'bank_account_update' board is invalid\n");
               break;
           case MB_ERR_LOCKED:
               fprintf(stderr, "\t reason: 'bank_account_update' board is locked\n");
               break;
           case MB_ERR_INTERNAL:
               fprintf(stderr, "\t reason: internal error. Recompile libmoard in debug mode for more info \n");
               break;
           default:
               fprintf(stderr, "\t MB_Clear returned error code: %d (see libmboard docs for details)\n", rc);
               break;

       }

       
       exit(rc);
    }
    #endif

if(FLAME_credit_var_update_message_board_read == 0)
{
	/*printf("%d> credit_var_update message board sync complete late as no agents reading any messages of this type\n", node_number);*/
	
	if(FLAME_TEST_PRINT_START_AND_END_OF_LIBMBOARD_CALLS) printf("start MB_SyncComplete(b_credit_var_update)\n");
	rc = MB_SyncComplete(b_credit_var_update);
	if(FLAME_TEST_PRINT_START_AND_END_OF_LIBMBOARD_CALLS) printf("finsh MB_SyncComplete(b_credit_var_update)\n");
	#ifdef ERRCHECK
	if (rc != MB_SUCCESS)
	{
	   fprintf(stderr, "ERROR: Could not complete sync of 'credit_var_update' board\n");
	   switch(rc) {
			case MB_ERR_INVALID:
			   fprintf(stderr, "\t reason: 'credit_var_update' board is invalid\n");
			   break;
		   case MB_ERR_MEMALLOC:
			   fprintf(stderr, "\t reason: out of memory\n");
			   break;
		   case MB_ERR_INTERNAL:
			   fprintf(stderr, "\t reason: internal error. Recompile libmoard in debug mode for more info \n");
			   break;
		   default:
			   fprintf(stderr, "\t MB_SyncComplete returned error code: %d (see libmboard docs for details)\n", rc);
			   break;
	   }

	   
	   exit(rc);
	}
	#endif
}

    rc = MB_Clear(b_credit_var_update);
    #ifdef ERRCHECK
    if (rc != MB_SUCCESS)
    {
       fprintf(stderr, "ERROR: Could not clear 'credit_var_update' board\n");
       switch(rc) {
           case MB_ERR_INVALID:
               fprintf(stderr, "\t reason: 'credit_var_update' board is invalid\n");
               break;
           case MB_ERR_LOCKED:
               fprintf(stderr, "\t reason: 'credit_var_update' board is locked\n");
               break;
           case MB_ERR_INTERNAL:
               fprintf(stderr, "\t reason: internal error. Recompile libmoard in debug mode for more info \n");
               break;
           default:
               fprintf(stderr, "\t MB_Clear returned error code: %d (see libmboard docs for details)\n", rc);
               break;

       }

       
       exit(rc);
    }
    #endif


	if(FLAME_TEST_PRINT_START_AND_END_OF_MODEL_FUNCTIONS) printf("start Bank_accounting\n");
	current_xmachine_Bank_holder = Bank_Bank_06_state->agents;
	while(current_xmachine_Bank_holder)
	{
		temp_xmachine_Bank_holder = current_xmachine_Bank_holder->next;
		current_xmachine_Bank = current_xmachine_Bank_holder->agent;
		current_xmachine_Bank_next_state = Bank_Bank_07_state;
		/* For backwards compatibility set current_xmachine */
		current_xmachine->xmachine_Firm = NULL;
		current_xmachine->xmachine_Household = NULL;
		current_xmachine->xmachine_Mall = NULL;
		current_xmachine->xmachine_IGFirm = NULL;
		current_xmachine->xmachine_Eurostat = NULL;
		current_xmachine->xmachine_Bank = NULL;
		current_xmachine->xmachine_Government = NULL;
		current_xmachine->xmachine_CentralBank = NULL;
		current_xmachine->xmachine_ClearingHouse = NULL;
		current_xmachine->xmachine_Bank = current_xmachine_Bank;

		if(FLAME_condition_Bank_Bank_accounting_Bank_06_Bank_07(current_xmachine_Bank)==1)
		{

		

			i = Bank_accounting();

		

			if(i == 1)
			{
				free_Bank_agent(current_xmachine_Bank_holder, Bank_Bank_06_state);
			}
			else
			{
				transition_Bank_agent(current_xmachine_Bank_holder, Bank_Bank_06_state, Bank_Bank_07_state);
			}
		}

		current_xmachine_Bank = NULL;

		current_xmachine_Bank_holder = temp_xmachine_Bank_holder;
	}
	if(FLAME_TEST_PRINT_START_AND_END_OF_MODEL_FUNCTIONS) printf("finish Bank_accounting\n");

	if(FLAME_tax_payment_message_board_write == 1)
	{

		if(FLAME_TEST_PRINT_START_AND_END_OF_LIBMBOARD_CALLS) printf("start MB_SyncStart(b_tax_payment)\n");
		rc = MB_SyncStart(b_tax_payment);
		if(FLAME_TEST_PRINT_START_AND_END_OF_LIBMBOARD_CALLS) printf("finish MB_SyncStart(b_tax_payment)\n");
		#ifdef ERRCHECK
		if (rc != MB_SUCCESS)
		{
		   fprintf(stderr, "ERROR: Could not start sync of 'tax_payment' board\n");
		   switch(rc) {
			   case MB_ERR_INVALID:
				   fprintf(stderr, "\t reason: 'tax_payment' board is invalid\n");
				   break;
			   case MB_ERR_LOCKED:
				   fprintf(stderr, "\t reason: 'tax_payment' board is locked\n");
				   break;
			   case MB_ERR_MEMALLOC:
				   fprintf(stderr, "\t reason: out of memory\n");
				   break;
			   case MB_ERR_INTERNAL:
				   fprintf(stderr, "\t reason: internal error. Recompile libmoard in debug mode for more info \n");
				   break;
			   default:
				   fprintf(stderr, "\t MB_SyncStart returned error code: %d (see libmboard docs for details)\n", rc);
				   break;
		   }

			
			exit(rc);
		}
		#endif
    }
    


	if(FLAME_TEST_PRINT_START_AND_END_OF_MODEL_FUNCTIONS) printf("start Bank_idle\n");
	current_xmachine_Bank_holder = Bank_Bank_06_state->agents;
	while(current_xmachine_Bank_holder)
	{
		temp_xmachine_Bank_holder = current_xmachine_Bank_holder->next;
		current_xmachine_Bank = current_xmachine_Bank_holder->agent;
		current_xmachine_Bank_next_state = Bank_Bank_07_state;
		/* For backwards compatibility set current_xmachine */
		current_xmachine->xmachine_Firm = NULL;
		current_xmachine->xmachine_Household = NULL;
		current_xmachine->xmachine_Mall = NULL;
		current_xmachine->xmachine_IGFirm = NULL;
		current_xmachine->xmachine_Eurostat = NULL;
		current_xmachine->xmachine_Bank = NULL;
		current_xmachine->xmachine_Government = NULL;
		current_xmachine->xmachine_CentralBank = NULL;
		current_xmachine->xmachine_ClearingHouse = NULL;
		current_xmachine->xmachine_Bank = current_xmachine_Bank;

		if(FLAME_condition_Bank_Bank_idle_Bank_06_Bank_07(current_xmachine_Bank)==1)
		{

		

			i = Bank_idle();

		

			if(i == 1)
			{
				free_Bank_agent(current_xmachine_Bank_holder, Bank_Bank_06_state);
			}
			else
			{
				transition_Bank_agent(current_xmachine_Bank_holder, Bank_Bank_06_state, Bank_Bank_07_state);
			}
		}

		current_xmachine_Bank = NULL;

		current_xmachine_Bank_holder = temp_xmachine_Bank_holder;
	}
	if(FLAME_TEST_PRINT_START_AND_END_OF_MODEL_FUNCTIONS) printf("finish Bank_idle\n");


/* End of layer number 95 */

/* Clear message boards that have finished being used
 * and sync complete if doing late sync complete */


	if(FLAME_TEST_PRINT_START_AND_END_OF_MODEL_FUNCTIONS) printf("start Bank_update_ecb_account\n");
	current_xmachine_Bank_holder = Bank_Bank_07_state->agents;
	while(current_xmachine_Bank_holder)
	{
		temp_xmachine_Bank_holder = current_xmachine_Bank_holder->next;
		current_xmachine_Bank = current_xmachine_Bank_holder->agent;
		current_xmachine_Bank_next_state = Bank_Bank_08_state;
		/* For backwards compatibility set current_xmachine */
		current_xmachine->xmachine_Firm = NULL;
		current_xmachine->xmachine_Household = NULL;
		current_xmachine->xmachine_Mall = NULL;
		current_xmachine->xmachine_IGFirm = NULL;
		current_xmachine->xmachine_Eurostat = NULL;
		current_xmachine->xmachine_Bank = NULL;
		current_xmachine->xmachine_Government = NULL;
		current_xmachine->xmachine_CentralBank = NULL;
		current_xmachine->xmachine_ClearingHouse = NULL;
		current_xmachine->xmachine_Bank = current_xmachine_Bank;

		

		

			i = Bank_update_ecb_account();

		

			if(i == 1)
			{
				free_Bank_agent(current_xmachine_Bank_holder, Bank_Bank_07_state);
			}
			else
			{
				transition_Bank_agent(current_xmachine_Bank_holder, Bank_Bank_07_state, Bank_Bank_08_state);
			}
		

		current_xmachine_Bank = NULL;

		current_xmachine_Bank_holder = temp_xmachine_Bank_holder;
	}
	if(FLAME_TEST_PRINT_START_AND_END_OF_MODEL_FUNCTIONS) printf("finish Bank_update_ecb_account\n");

	if(FLAME_bank_to_central_bank_account_update_message_board_write == 1)
	{

		if(FLAME_TEST_PRINT_START_AND_END_OF_LIBMBOARD_CALLS) printf("start MB_SyncStart(b_bank_to_central_bank_account_update)\n");
		rc = MB_SyncStart(b_bank_to_central_bank_account_update);
		if(FLAME_TEST_PRINT_START_AND_END_OF_LIBMBOARD_CALLS) printf("finish MB_SyncStart(b_bank_to_central_bank_account_update)\n");
		#ifdef ERRCHECK
		if (rc != MB_SUCCESS)
		{
		   fprintf(stderr, "ERROR: Could not start sync of 'bank_to_central_bank_account_update' board\n");
		   switch(rc) {
			   case MB_ERR_INVALID:
				   fprintf(stderr, "\t reason: 'bank_to_central_bank_account_update' board is invalid\n");
				   break;
			   case MB_ERR_LOCKED:
				   fprintf(stderr, "\t reason: 'bank_to_central_bank_account_update' board is locked\n");
				   break;
			   case MB_ERR_MEMALLOC:
				   fprintf(stderr, "\t reason: out of memory\n");
				   break;
			   case MB_ERR_INTERNAL:
				   fprintf(stderr, "\t reason: internal error. Recompile libmoard in debug mode for more info \n");
				   break;
			   default:
				   fprintf(stderr, "\t MB_SyncStart returned error code: %d (see libmboard docs for details)\n", rc);
				   break;
		   }

			
			exit(rc);
		}
		#endif
    }
    


	/* If mb is not read then leave sync complete until last possible moment */
	if(FLAME_unemployment_benefit_restitution_message_board_read == 1)
	{
		if(FLAME_TEST_PRINT_START_AND_END_OF_LIBMBOARD_CALLS) printf("start MB_SyncComplete(b_unemployment_benefit_restitution)\n");
		rc = MB_SyncComplete(b_unemployment_benefit_restitution);
		if(FLAME_TEST_PRINT_START_AND_END_OF_LIBMBOARD_CALLS) printf("finsh MB_SyncComplete(b_unemployment_benefit_restitution)\n");
		#ifdef ERRCHECK
		if (rc != MB_SUCCESS)
		{
		   fprintf(stderr, "ERROR: Could not complete sync of 'unemployment_benefit_restitution' board\n");
		   switch(rc) {
				case MB_ERR_INVALID:
				   fprintf(stderr, "\t reason: 'unemployment_benefit_restitution' board is invalid\n");
				   break;
			   case MB_ERR_MEMALLOC:
				   fprintf(stderr, "\t reason: out of memory\n");
				   break;
			   case MB_ERR_INTERNAL:
				   fprintf(stderr, "\t reason: internal error. Recompile libmoard in debug mode for more info \n");
				   break;
			   default:
				   fprintf(stderr, "\t MB_SyncComplete returned error code: %d (see libmboard docs for details)\n", rc);
				   break;
		   }
	
		   
		   exit(rc);
		}
		#endif
    
	}
	
	/* If mb is not read then leave sync complete until last possible moment */
	if(FLAME_tax_payment_message_board_read == 1)
	{
		if(FLAME_TEST_PRINT_START_AND_END_OF_LIBMBOARD_CALLS) printf("start MB_SyncComplete(b_tax_payment)\n");
		rc = MB_SyncComplete(b_tax_payment);
		if(FLAME_TEST_PRINT_START_AND_END_OF_LIBMBOARD_CALLS) printf("finsh MB_SyncComplete(b_tax_payment)\n");
		#ifdef ERRCHECK
		if (rc != MB_SUCCESS)
		{
		   fprintf(stderr, "ERROR: Could not complete sync of 'tax_payment' board\n");
		   switch(rc) {
				case MB_ERR_INVALID:
				   fprintf(stderr, "\t reason: 'tax_payment' board is invalid\n");
				   break;
			   case MB_ERR_MEMALLOC:
				   fprintf(stderr, "\t reason: out of memory\n");
				   break;
			   case MB_ERR_INTERNAL:
				   fprintf(stderr, "\t reason: internal error. Recompile libmoard in debug mode for more info \n");
				   break;
			   default:
				   fprintf(stderr, "\t MB_SyncComplete returned error code: %d (see libmboard docs for details)\n", rc);
				   break;
		   }
	
		   
		   exit(rc);
		}
		#endif
    
	}
	
	if(FLAME_TEST_PRINT_START_AND_END_OF_MODEL_FUNCTIONS) printf("start Government_read_tax_payments\n");
	current_xmachine_Government_holder = Government_End_Gov_Consumer_Role_state->agents;
	while(current_xmachine_Government_holder)
	{
		temp_xmachine_Government_holder = current_xmachine_Government_holder->next;
		current_xmachine_Government = current_xmachine_Government_holder->agent;
		current_xmachine_Government_next_state = Government_02_state;
		/* For backwards compatibility set current_xmachine */
		current_xmachine->xmachine_Firm = NULL;
		current_xmachine->xmachine_Household = NULL;
		current_xmachine->xmachine_Mall = NULL;
		current_xmachine->xmachine_IGFirm = NULL;
		current_xmachine->xmachine_Eurostat = NULL;
		current_xmachine->xmachine_Bank = NULL;
		current_xmachine->xmachine_Government = NULL;
		current_xmachine->xmachine_CentralBank = NULL;
		current_xmachine->xmachine_ClearingHouse = NULL;
		current_xmachine->xmachine_Government = current_xmachine_Government;

		

		
		rc = MB_Iterator_CreateFiltered(b_tax_payment, &i_tax_payment, &FLAME_filter_Government_Government_read_tax_payments_End_Gov_Consumer_Role_02_tax_payment, current_xmachine_Government);
		
		#ifdef ERRCHECK
		if (rc != MB_SUCCESS)
		{
		   fprintf(stderr, "ERROR: Could not create Iterator for 'tax_payment'\n");
		   switch(rc) {
		       case MB_ERR_INVALID:
		           fprintf(stderr, "\t reason: 'tax_payment' board is invalid\n");
		           break;
		       case MB_ERR_LOCKED:
	               fprintf(stderr, "\t reason: 'tax_payment' board is locked\n");
	               break;
	           case MB_ERR_MEMALLOC:
	               fprintf(stderr, "\t reason: out of memory\n");
	               break;
	           case MB_ERR_INTERNAL:
	               fprintf(stderr, "\t reason: internal error. Recompile libmoard in debug mode for more info \n");
	               break;
	           default:
	           
                   fprintf(stderr, "\t MB_Iterator_CreateFiltered returned error code: %d (see libmboard docs for details)\n", rc);
               
               
                   break;
		   }

		   
           exit(rc);
		}
		#endif
		
		
		rc = MB_Iterator_CreateFiltered(b_unemployment_benefit_restitution, &i_unemployment_benefit_restitution, &FLAME_filter_Government_Government_read_tax_payments_End_Gov_Consumer_Role_02_unemployment_benefit_restitution, current_xmachine_Government);
		
		#ifdef ERRCHECK
		if (rc != MB_SUCCESS)
		{
		   fprintf(stderr, "ERROR: Could not create Iterator for 'unemployment_benefit_restitution'\n");
		   switch(rc) {
		       case MB_ERR_INVALID:
		           fprintf(stderr, "\t reason: 'unemployment_benefit_restitution' board is invalid\n");
		           break;
		       case MB_ERR_LOCKED:
	               fprintf(stderr, "\t reason: 'unemployment_benefit_restitution' board is locked\n");
	               break;
	           case MB_ERR_MEMALLOC:
	               fprintf(stderr, "\t reason: out of memory\n");
	               break;
	           case MB_ERR_INTERNAL:
	               fprintf(stderr, "\t reason: internal error. Recompile libmoard in debug mode for more info \n");
	               break;
	           default:
	           
                   fprintf(stderr, "\t MB_Iterator_CreateFiltered returned error code: %d (see libmboard docs for details)\n", rc);
               
               
                   break;
		   }

		   
           exit(rc);
		}
		#endif
		
		

			i = Government_read_tax_payments();

		
		    rc = MB_Iterator_Delete(&i_tax_payment);
		    #ifdef ERRCHECK
		    if (rc != MB_SUCCESS)
		    {
		       fprintf(stderr, "ERROR: Could not delete 'tax_payment' iterator\n");
		       switch(rc) {
		           case MB_ERR_INVALID:
		               fprintf(stderr, "\t reason: 'tax_payment' iterator is invalid\n");
		               break;
		           case MB_ERR_INTERNAL:
		               fprintf(stderr, "\t reason: internal error. Recompile libmoard in debug mode for more info \n");
		               break;
		           default:
                       fprintf(stderr, "\t MB_Iterator_Delete returned error code: %d (see libmboard docs for details)\n", rc);
                       break;
		       }

		       
               exit(rc);
		    }
		    #endif
		
		    rc = MB_Iterator_Delete(&i_unemployment_benefit_restitution);
		    #ifdef ERRCHECK
		    if (rc != MB_SUCCESS)
		    {
		       fprintf(stderr, "ERROR: Could not delete 'unemployment_benefit_restitution' iterator\n");
		       switch(rc) {
		           case MB_ERR_INVALID:
		               fprintf(stderr, "\t reason: 'unemployment_benefit_restitution' iterator is invalid\n");
		               break;
		           case MB_ERR_INTERNAL:
		               fprintf(stderr, "\t reason: internal error. Recompile libmoard in debug mode for more info \n");
		               break;
		           default:
                       fprintf(stderr, "\t MB_Iterator_Delete returned error code: %d (see libmboard docs for details)\n", rc);
                       break;
		       }

		       
               exit(rc);
		    }
		    #endif
		

			if(i == 1)
			{
				free_Government_agent(current_xmachine_Government_holder, Government_End_Gov_Consumer_Role_state);
			}
			else
			{
				transition_Government_agent(current_xmachine_Government_holder, Government_End_Gov_Consumer_Role_state, Government_02_state);
			}
		

		current_xmachine_Government = NULL;

		current_xmachine_Government_holder = temp_xmachine_Government_holder;
	}
	if(FLAME_TEST_PRINT_START_AND_END_OF_MODEL_FUNCTIONS) printf("finish Government_read_tax_payments\n");


/* End of layer number 96 */

/* Clear message boards that have finished being used
 * and sync complete if doing late sync complete */

if(FLAME_tax_payment_message_board_read == 0)
{
	/*printf("%d> tax_payment message board sync complete late as no agents reading any messages of this type\n", node_number);*/
	
	if(FLAME_TEST_PRINT_START_AND_END_OF_LIBMBOARD_CALLS) printf("start MB_SyncComplete(b_tax_payment)\n");
	rc = MB_SyncComplete(b_tax_payment);
	if(FLAME_TEST_PRINT_START_AND_END_OF_LIBMBOARD_CALLS) printf("finsh MB_SyncComplete(b_tax_payment)\n");
	#ifdef ERRCHECK
	if (rc != MB_SUCCESS)
	{
	   fprintf(stderr, "ERROR: Could not complete sync of 'tax_payment' board\n");
	   switch(rc) {
			case MB_ERR_INVALID:
			   fprintf(stderr, "\t reason: 'tax_payment' board is invalid\n");
			   break;
		   case MB_ERR_MEMALLOC:
			   fprintf(stderr, "\t reason: out of memory\n");
			   break;
		   case MB_ERR_INTERNAL:
			   fprintf(stderr, "\t reason: internal error. Recompile libmoard in debug mode for more info \n");
			   break;
		   default:
			   fprintf(stderr, "\t MB_SyncComplete returned error code: %d (see libmboard docs for details)\n", rc);
			   break;
	   }

	   
	   exit(rc);
	}
	#endif
}

    rc = MB_Clear(b_tax_payment);
    #ifdef ERRCHECK
    if (rc != MB_SUCCESS)
    {
       fprintf(stderr, "ERROR: Could not clear 'tax_payment' board\n");
       switch(rc) {
           case MB_ERR_INVALID:
               fprintf(stderr, "\t reason: 'tax_payment' board is invalid\n");
               break;
           case MB_ERR_LOCKED:
               fprintf(stderr, "\t reason: 'tax_payment' board is locked\n");
               break;
           case MB_ERR_INTERNAL:
               fprintf(stderr, "\t reason: internal error. Recompile libmoard in debug mode for more info \n");
               break;
           default:
               fprintf(stderr, "\t MB_Clear returned error code: %d (see libmboard docs for details)\n", rc);
               break;

       }

       
       exit(rc);
    }
    #endif

if(FLAME_unemployment_benefit_restitution_message_board_read == 0)
{
	/*printf("%d> unemployment_benefit_restitution message board sync complete late as no agents reading any messages of this type\n", node_number);*/
	
	if(FLAME_TEST_PRINT_START_AND_END_OF_LIBMBOARD_CALLS) printf("start MB_SyncComplete(b_unemployment_benefit_restitution)\n");
	rc = MB_SyncComplete(b_unemployment_benefit_restitution);
	if(FLAME_TEST_PRINT_START_AND_END_OF_LIBMBOARD_CALLS) printf("finsh MB_SyncComplete(b_unemployment_benefit_restitution)\n");
	#ifdef ERRCHECK
	if (rc != MB_SUCCESS)
	{
	   fprintf(stderr, "ERROR: Could not complete sync of 'unemployment_benefit_restitution' board\n");
	   switch(rc) {
			case MB_ERR_INVALID:
			   fprintf(stderr, "\t reason: 'unemployment_benefit_restitution' board is invalid\n");
			   break;
		   case MB_ERR_MEMALLOC:
			   fprintf(stderr, "\t reason: out of memory\n");
			   break;
		   case MB_ERR_INTERNAL:
			   fprintf(stderr, "\t reason: internal error. Recompile libmoard in debug mode for more info \n");
			   break;
		   default:
			   fprintf(stderr, "\t MB_SyncComplete returned error code: %d (see libmboard docs for details)\n", rc);
			   break;
	   }

	   
	   exit(rc);
	}
	#endif
}

    rc = MB_Clear(b_unemployment_benefit_restitution);
    #ifdef ERRCHECK
    if (rc != MB_SUCCESS)
    {
       fprintf(stderr, "ERROR: Could not clear 'unemployment_benefit_restitution' board\n");
       switch(rc) {
           case MB_ERR_INVALID:
               fprintf(stderr, "\t reason: 'unemployment_benefit_restitution' board is invalid\n");
               break;
           case MB_ERR_LOCKED:
               fprintf(stderr, "\t reason: 'unemployment_benefit_restitution' board is locked\n");
               break;
           case MB_ERR_INTERNAL:
               fprintf(stderr, "\t reason: internal error. Recompile libmoard in debug mode for more info \n");
               break;
           default:
               fprintf(stderr, "\t MB_Clear returned error code: %d (see libmboard docs for details)\n", rc);
               break;

       }

       
       exit(rc);
    }
    #endif


	if(FLAME_TEST_PRINT_START_AND_END_OF_MODEL_FUNCTIONS) printf("start Bank_stocks_and_flows\n");
	current_xmachine_Bank_holder = Bank_Bank_08_state->agents;
	while(current_xmachine_Bank_holder)
	{
		temp_xmachine_Bank_holder = current_xmachine_Bank_holder->next;
		current_xmachine_Bank = current_xmachine_Bank_holder->agent;
		current_xmachine_Bank_next_state = Bank_end_Bank_state;
		/* For backwards compatibility set current_xmachine */
		current_xmachine->xmachine_Firm = NULL;
		current_xmachine->xmachine_Household = NULL;
		current_xmachine->xmachine_Mall = NULL;
		current_xmachine->xmachine_IGFirm = NULL;
		current_xmachine->xmachine_Eurostat = NULL;
		current_xmachine->xmachine_Bank = NULL;
		current_xmachine->xmachine_Government = NULL;
		current_xmachine->xmachine_CentralBank = NULL;
		current_xmachine->xmachine_ClearingHouse = NULL;
		current_xmachine->xmachine_Bank = current_xmachine_Bank;

		

		

			i = Bank_stocks_and_flows();

		

			if(i == 1)
			{
				free_Bank_agent(current_xmachine_Bank_holder, Bank_Bank_08_state);
			}
			else
			{
				transition_Bank_agent(current_xmachine_Bank_holder, Bank_Bank_08_state, Bank_end_Bank_state);
			}
		

		current_xmachine_Bank = NULL;

		current_xmachine_Bank_holder = temp_xmachine_Bank_holder;
	}
	if(FLAME_TEST_PRINT_START_AND_END_OF_MODEL_FUNCTIONS) printf("finish Bank_stocks_and_flows\n");


	/* If mb is not read then leave sync complete until last possible moment */
	if(FLAME_firm_subsidy_notification_message_board_read == 1)
	{
		if(FLAME_TEST_PRINT_START_AND_END_OF_LIBMBOARD_CALLS) printf("start MB_SyncComplete(b_firm_subsidy_notification)\n");
		rc = MB_SyncComplete(b_firm_subsidy_notification);
		if(FLAME_TEST_PRINT_START_AND_END_OF_LIBMBOARD_CALLS) printf("finsh MB_SyncComplete(b_firm_subsidy_notification)\n");
		#ifdef ERRCHECK
		if (rc != MB_SUCCESS)
		{
		   fprintf(stderr, "ERROR: Could not complete sync of 'firm_subsidy_notification' board\n");
		   switch(rc) {
				case MB_ERR_INVALID:
				   fprintf(stderr, "\t reason: 'firm_subsidy_notification' board is invalid\n");
				   break;
			   case MB_ERR_MEMALLOC:
				   fprintf(stderr, "\t reason: out of memory\n");
				   break;
			   case MB_ERR_INTERNAL:
				   fprintf(stderr, "\t reason: internal error. Recompile libmoard in debug mode for more info \n");
				   break;
			   default:
				   fprintf(stderr, "\t MB_SyncComplete returned error code: %d (see libmboard docs for details)\n", rc);
				   break;
		   }
	
		   
		   exit(rc);
		}
		#endif
    
	}
	
	/* If mb is not read then leave sync complete until last possible moment */
	if(FLAME_hh_subsidy_notification_message_board_read == 1)
	{
		if(FLAME_TEST_PRINT_START_AND_END_OF_LIBMBOARD_CALLS) printf("start MB_SyncComplete(b_hh_subsidy_notification)\n");
		rc = MB_SyncComplete(b_hh_subsidy_notification);
		if(FLAME_TEST_PRINT_START_AND_END_OF_LIBMBOARD_CALLS) printf("finsh MB_SyncComplete(b_hh_subsidy_notification)\n");
		#ifdef ERRCHECK
		if (rc != MB_SUCCESS)
		{
		   fprintf(stderr, "ERROR: Could not complete sync of 'hh_subsidy_notification' board\n");
		   switch(rc) {
				case MB_ERR_INVALID:
				   fprintf(stderr, "\t reason: 'hh_subsidy_notification' board is invalid\n");
				   break;
			   case MB_ERR_MEMALLOC:
				   fprintf(stderr, "\t reason: out of memory\n");
				   break;
			   case MB_ERR_INTERNAL:
				   fprintf(stderr, "\t reason: internal error. Recompile libmoard in debug mode for more info \n");
				   break;
			   default:
				   fprintf(stderr, "\t MB_SyncComplete returned error code: %d (see libmboard docs for details)\n", rc);
				   break;
		   }
	
		   
		   exit(rc);
		}
		#endif
    
	}
	
	if(FLAME_TEST_PRINT_START_AND_END_OF_MODEL_FUNCTIONS) printf("start Government_read_subsidy_notifications\n");
	current_xmachine_Government_holder = Government_02_state->agents;
	while(current_xmachine_Government_holder)
	{
		temp_xmachine_Government_holder = current_xmachine_Government_holder->next;
		current_xmachine_Government = current_xmachine_Government_holder->agent;
		current_xmachine_Government_next_state = Government_03_state;
		/* For backwards compatibility set current_xmachine */
		current_xmachine->xmachine_Firm = NULL;
		current_xmachine->xmachine_Household = NULL;
		current_xmachine->xmachine_Mall = NULL;
		current_xmachine->xmachine_IGFirm = NULL;
		current_xmachine->xmachine_Eurostat = NULL;
		current_xmachine->xmachine_Bank = NULL;
		current_xmachine->xmachine_Government = NULL;
		current_xmachine->xmachine_CentralBank = NULL;
		current_xmachine->xmachine_ClearingHouse = NULL;
		current_xmachine->xmachine_Government = current_xmachine_Government;

		

		
		rc = MB_Iterator_CreateFiltered(b_hh_subsidy_notification, &i_hh_subsidy_notification, &FLAME_filter_Government_Government_read_subsidy_notifications_02_03_hh_subsidy_notification, current_xmachine_Government);
		
		#ifdef ERRCHECK
		if (rc != MB_SUCCESS)
		{
		   fprintf(stderr, "ERROR: Could not create Iterator for 'hh_subsidy_notification'\n");
		   switch(rc) {
		       case MB_ERR_INVALID:
		           fprintf(stderr, "\t reason: 'hh_subsidy_notification' board is invalid\n");
		           break;
		       case MB_ERR_LOCKED:
	               fprintf(stderr, "\t reason: 'hh_subsidy_notification' board is locked\n");
	               break;
	           case MB_ERR_MEMALLOC:
	               fprintf(stderr, "\t reason: out of memory\n");
	               break;
	           case MB_ERR_INTERNAL:
	               fprintf(stderr, "\t reason: internal error. Recompile libmoard in debug mode for more info \n");
	               break;
	           default:
	           
                   fprintf(stderr, "\t MB_Iterator_CreateFiltered returned error code: %d (see libmboard docs for details)\n", rc);
               
               
                   break;
		   }

		   
           exit(rc);
		}
		#endif
		
		
		rc = MB_Iterator_CreateFiltered(b_firm_subsidy_notification, &i_firm_subsidy_notification, &FLAME_filter_Government_Government_read_subsidy_notifications_02_03_firm_subsidy_notification, current_xmachine_Government);
		
		#ifdef ERRCHECK
		if (rc != MB_SUCCESS)
		{
		   fprintf(stderr, "ERROR: Could not create Iterator for 'firm_subsidy_notification'\n");
		   switch(rc) {
		       case MB_ERR_INVALID:
		           fprintf(stderr, "\t reason: 'firm_subsidy_notification' board is invalid\n");
		           break;
		       case MB_ERR_LOCKED:
	               fprintf(stderr, "\t reason: 'firm_subsidy_notification' board is locked\n");
	               break;
	           case MB_ERR_MEMALLOC:
	               fprintf(stderr, "\t reason: out of memory\n");
	               break;
	           case MB_ERR_INTERNAL:
	               fprintf(stderr, "\t reason: internal error. Recompile libmoard in debug mode for more info \n");
	               break;
	           default:
	           
                   fprintf(stderr, "\t MB_Iterator_CreateFiltered returned error code: %d (see libmboard docs for details)\n", rc);
               
               
                   break;
		   }

		   
           exit(rc);
		}
		#endif
		
		

			i = Government_read_subsidy_notifications();

		
		    rc = MB_Iterator_Delete(&i_hh_subsidy_notification);
		    #ifdef ERRCHECK
		    if (rc != MB_SUCCESS)
		    {
		       fprintf(stderr, "ERROR: Could not delete 'hh_subsidy_notification' iterator\n");
		       switch(rc) {
		           case MB_ERR_INVALID:
		               fprintf(stderr, "\t reason: 'hh_subsidy_notification' iterator is invalid\n");
		               break;
		           case MB_ERR_INTERNAL:
		               fprintf(stderr, "\t reason: internal error. Recompile libmoard in debug mode for more info \n");
		               break;
		           default:
                       fprintf(stderr, "\t MB_Iterator_Delete returned error code: %d (see libmboard docs for details)\n", rc);
                       break;
		       }

		       
               exit(rc);
		    }
		    #endif
		
		    rc = MB_Iterator_Delete(&i_firm_subsidy_notification);
		    #ifdef ERRCHECK
		    if (rc != MB_SUCCESS)
		    {
		       fprintf(stderr, "ERROR: Could not delete 'firm_subsidy_notification' iterator\n");
		       switch(rc) {
		           case MB_ERR_INVALID:
		               fprintf(stderr, "\t reason: 'firm_subsidy_notification' iterator is invalid\n");
		               break;
		           case MB_ERR_INTERNAL:
		               fprintf(stderr, "\t reason: internal error. Recompile libmoard in debug mode for more info \n");
		               break;
		           default:
                       fprintf(stderr, "\t MB_Iterator_Delete returned error code: %d (see libmboard docs for details)\n", rc);
                       break;
		       }

		       
               exit(rc);
		    }
		    #endif
		

			if(i == 1)
			{
				free_Government_agent(current_xmachine_Government_holder, Government_02_state);
			}
			else
			{
				transition_Government_agent(current_xmachine_Government_holder, Government_02_state, Government_03_state);
			}
		

		current_xmachine_Government = NULL;

		current_xmachine_Government_holder = temp_xmachine_Government_holder;
	}
	if(FLAME_TEST_PRINT_START_AND_END_OF_MODEL_FUNCTIONS) printf("finish Government_read_subsidy_notifications\n");

	if(FLAME_total_subsidies_message_board_write == 1)
	{

		if(FLAME_TEST_PRINT_START_AND_END_OF_LIBMBOARD_CALLS) printf("start MB_SyncStart(b_total_subsidies)\n");
		rc = MB_SyncStart(b_total_subsidies);
		if(FLAME_TEST_PRINT_START_AND_END_OF_LIBMBOARD_CALLS) printf("finish MB_SyncStart(b_total_subsidies)\n");
		#ifdef ERRCHECK
		if (rc != MB_SUCCESS)
		{
		   fprintf(stderr, "ERROR: Could not start sync of 'total_subsidies' board\n");
		   switch(rc) {
			   case MB_ERR_INVALID:
				   fprintf(stderr, "\t reason: 'total_subsidies' board is invalid\n");
				   break;
			   case MB_ERR_LOCKED:
				   fprintf(stderr, "\t reason: 'total_subsidies' board is locked\n");
				   break;
			   case MB_ERR_MEMALLOC:
				   fprintf(stderr, "\t reason: out of memory\n");
				   break;
			   case MB_ERR_INTERNAL:
				   fprintf(stderr, "\t reason: internal error. Recompile libmoard in debug mode for more info \n");
				   break;
			   default:
				   fprintf(stderr, "\t MB_SyncStart returned error code: %d (see libmboard docs for details)\n", rc);
				   break;
		   }

			
			exit(rc);
		}
		#endif
    }
    


/* End of layer number 97 */

/* Clear message boards that have finished being used
 * and sync complete if doing late sync complete */

if(FLAME_hh_subsidy_notification_message_board_read == 0)
{
	/*printf("%d> hh_subsidy_notification message board sync complete late as no agents reading any messages of this type\n", node_number);*/
	
	if(FLAME_TEST_PRINT_START_AND_END_OF_LIBMBOARD_CALLS) printf("start MB_SyncComplete(b_hh_subsidy_notification)\n");
	rc = MB_SyncComplete(b_hh_subsidy_notification);
	if(FLAME_TEST_PRINT_START_AND_END_OF_LIBMBOARD_CALLS) printf("finsh MB_SyncComplete(b_hh_subsidy_notification)\n");
	#ifdef ERRCHECK
	if (rc != MB_SUCCESS)
	{
	   fprintf(stderr, "ERROR: Could not complete sync of 'hh_subsidy_notification' board\n");
	   switch(rc) {
			case MB_ERR_INVALID:
			   fprintf(stderr, "\t reason: 'hh_subsidy_notification' board is invalid\n");
			   break;
		   case MB_ERR_MEMALLOC:
			   fprintf(stderr, "\t reason: out of memory\n");
			   break;
		   case MB_ERR_INTERNAL:
			   fprintf(stderr, "\t reason: internal error. Recompile libmoard in debug mode for more info \n");
			   break;
		   default:
			   fprintf(stderr, "\t MB_SyncComplete returned error code: %d (see libmboard docs for details)\n", rc);
			   break;
	   }

	   
	   exit(rc);
	}
	#endif
}

    rc = MB_Clear(b_hh_subsidy_notification);
    #ifdef ERRCHECK
    if (rc != MB_SUCCESS)
    {
       fprintf(stderr, "ERROR: Could not clear 'hh_subsidy_notification' board\n");
       switch(rc) {
           case MB_ERR_INVALID:
               fprintf(stderr, "\t reason: 'hh_subsidy_notification' board is invalid\n");
               break;
           case MB_ERR_LOCKED:
               fprintf(stderr, "\t reason: 'hh_subsidy_notification' board is locked\n");
               break;
           case MB_ERR_INTERNAL:
               fprintf(stderr, "\t reason: internal error. Recompile libmoard in debug mode for more info \n");
               break;
           default:
               fprintf(stderr, "\t MB_Clear returned error code: %d (see libmboard docs for details)\n", rc);
               break;

       }

       
       exit(rc);
    }
    #endif

if(FLAME_firm_subsidy_notification_message_board_read == 0)
{
	/*printf("%d> firm_subsidy_notification message board sync complete late as no agents reading any messages of this type\n", node_number);*/
	
	if(FLAME_TEST_PRINT_START_AND_END_OF_LIBMBOARD_CALLS) printf("start MB_SyncComplete(b_firm_subsidy_notification)\n");
	rc = MB_SyncComplete(b_firm_subsidy_notification);
	if(FLAME_TEST_PRINT_START_AND_END_OF_LIBMBOARD_CALLS) printf("finsh MB_SyncComplete(b_firm_subsidy_notification)\n");
	#ifdef ERRCHECK
	if (rc != MB_SUCCESS)
	{
	   fprintf(stderr, "ERROR: Could not complete sync of 'firm_subsidy_notification' board\n");
	   switch(rc) {
			case MB_ERR_INVALID:
			   fprintf(stderr, "\t reason: 'firm_subsidy_notification' board is invalid\n");
			   break;
		   case MB_ERR_MEMALLOC:
			   fprintf(stderr, "\t reason: out of memory\n");
			   break;
		   case MB_ERR_INTERNAL:
			   fprintf(stderr, "\t reason: internal error. Recompile libmoard in debug mode for more info \n");
			   break;
		   default:
			   fprintf(stderr, "\t MB_SyncComplete returned error code: %d (see libmboard docs for details)\n", rc);
			   break;
	   }

	   
	   exit(rc);
	}
	#endif
}

    rc = MB_Clear(b_firm_subsidy_notification);
    #ifdef ERRCHECK
    if (rc != MB_SUCCESS)
    {
       fprintf(stderr, "ERROR: Could not clear 'firm_subsidy_notification' board\n");
       switch(rc) {
           case MB_ERR_INVALID:
               fprintf(stderr, "\t reason: 'firm_subsidy_notification' board is invalid\n");
               break;
           case MB_ERR_LOCKED:
               fprintf(stderr, "\t reason: 'firm_subsidy_notification' board is locked\n");
               break;
           case MB_ERR_INTERNAL:
               fprintf(stderr, "\t reason: internal error. Recompile libmoard in debug mode for more info \n");
               break;
           default:
               fprintf(stderr, "\t MB_Clear returned error code: %d (see libmboard docs for details)\n", rc);
               break;

       }

       
       exit(rc);
    }
    #endif


	/* If mb is not read then leave sync complete until last possible moment */
	if(FLAME_firm_transfer_notification_message_board_read == 1)
	{
		if(FLAME_TEST_PRINT_START_AND_END_OF_LIBMBOARD_CALLS) printf("start MB_SyncComplete(b_firm_transfer_notification)\n");
		rc = MB_SyncComplete(b_firm_transfer_notification);
		if(FLAME_TEST_PRINT_START_AND_END_OF_LIBMBOARD_CALLS) printf("finsh MB_SyncComplete(b_firm_transfer_notification)\n");
		#ifdef ERRCHECK
		if (rc != MB_SUCCESS)
		{
		   fprintf(stderr, "ERROR: Could not complete sync of 'firm_transfer_notification' board\n");
		   switch(rc) {
				case MB_ERR_INVALID:
				   fprintf(stderr, "\t reason: 'firm_transfer_notification' board is invalid\n");
				   break;
			   case MB_ERR_MEMALLOC:
				   fprintf(stderr, "\t reason: out of memory\n");
				   break;
			   case MB_ERR_INTERNAL:
				   fprintf(stderr, "\t reason: internal error. Recompile libmoard in debug mode for more info \n");
				   break;
			   default:
				   fprintf(stderr, "\t MB_SyncComplete returned error code: %d (see libmboard docs for details)\n", rc);
				   break;
		   }
	
		   
		   exit(rc);
		}
		#endif
    
	}
	
	/* If mb is not read then leave sync complete until last possible moment */
	if(FLAME_hh_transfer_notification_message_board_read == 1)
	{
		if(FLAME_TEST_PRINT_START_AND_END_OF_LIBMBOARD_CALLS) printf("start MB_SyncComplete(b_hh_transfer_notification)\n");
		rc = MB_SyncComplete(b_hh_transfer_notification);
		if(FLAME_TEST_PRINT_START_AND_END_OF_LIBMBOARD_CALLS) printf("finsh MB_SyncComplete(b_hh_transfer_notification)\n");
		#ifdef ERRCHECK
		if (rc != MB_SUCCESS)
		{
		   fprintf(stderr, "ERROR: Could not complete sync of 'hh_transfer_notification' board\n");
		   switch(rc) {
				case MB_ERR_INVALID:
				   fprintf(stderr, "\t reason: 'hh_transfer_notification' board is invalid\n");
				   break;
			   case MB_ERR_MEMALLOC:
				   fprintf(stderr, "\t reason: out of memory\n");
				   break;
			   case MB_ERR_INTERNAL:
				   fprintf(stderr, "\t reason: internal error. Recompile libmoard in debug mode for more info \n");
				   break;
			   default:
				   fprintf(stderr, "\t MB_SyncComplete returned error code: %d (see libmboard docs for details)\n", rc);
				   break;
		   }
	
		   
		   exit(rc);
		}
		#endif
    
	}
	
	if(FLAME_TEST_PRINT_START_AND_END_OF_MODEL_FUNCTIONS) printf("start Government_read_transfer_notifications\n");
	current_xmachine_Government_holder = Government_03_state->agents;
	while(current_xmachine_Government_holder)
	{
		temp_xmachine_Government_holder = current_xmachine_Government_holder->next;
		current_xmachine_Government = current_xmachine_Government_holder->agent;
		current_xmachine_Government_next_state = Government_04_state;
		/* For backwards compatibility set current_xmachine */
		current_xmachine->xmachine_Firm = NULL;
		current_xmachine->xmachine_Household = NULL;
		current_xmachine->xmachine_Mall = NULL;
		current_xmachine->xmachine_IGFirm = NULL;
		current_xmachine->xmachine_Eurostat = NULL;
		current_xmachine->xmachine_Bank = NULL;
		current_xmachine->xmachine_Government = NULL;
		current_xmachine->xmachine_CentralBank = NULL;
		current_xmachine->xmachine_ClearingHouse = NULL;
		current_xmachine->xmachine_Government = current_xmachine_Government;

		

		
		rc = MB_Iterator_CreateFiltered(b_hh_transfer_notification, &i_hh_transfer_notification, &FLAME_filter_Government_Government_read_transfer_notifications_03_04_hh_transfer_notification, current_xmachine_Government);
		
		#ifdef ERRCHECK
		if (rc != MB_SUCCESS)
		{
		   fprintf(stderr, "ERROR: Could not create Iterator for 'hh_transfer_notification'\n");
		   switch(rc) {
		       case MB_ERR_INVALID:
		           fprintf(stderr, "\t reason: 'hh_transfer_notification' board is invalid\n");
		           break;
		       case MB_ERR_LOCKED:
	               fprintf(stderr, "\t reason: 'hh_transfer_notification' board is locked\n");
	               break;
	           case MB_ERR_MEMALLOC:
	               fprintf(stderr, "\t reason: out of memory\n");
	               break;
	           case MB_ERR_INTERNAL:
	               fprintf(stderr, "\t reason: internal error. Recompile libmoard in debug mode for more info \n");
	               break;
	           default:
	           
                   fprintf(stderr, "\t MB_Iterator_CreateFiltered returned error code: %d (see libmboard docs for details)\n", rc);
               
               
                   break;
		   }

		   
           exit(rc);
		}
		#endif
		
		
		rc = MB_Iterator_CreateFiltered(b_firm_transfer_notification, &i_firm_transfer_notification, &FLAME_filter_Government_Government_read_transfer_notifications_03_04_firm_transfer_notification, current_xmachine_Government);
		
		#ifdef ERRCHECK
		if (rc != MB_SUCCESS)
		{
		   fprintf(stderr, "ERROR: Could not create Iterator for 'firm_transfer_notification'\n");
		   switch(rc) {
		       case MB_ERR_INVALID:
		           fprintf(stderr, "\t reason: 'firm_transfer_notification' board is invalid\n");
		           break;
		       case MB_ERR_LOCKED:
	               fprintf(stderr, "\t reason: 'firm_transfer_notification' board is locked\n");
	               break;
	           case MB_ERR_MEMALLOC:
	               fprintf(stderr, "\t reason: out of memory\n");
	               break;
	           case MB_ERR_INTERNAL:
	               fprintf(stderr, "\t reason: internal error. Recompile libmoard in debug mode for more info \n");
	               break;
	           default:
	           
                   fprintf(stderr, "\t MB_Iterator_CreateFiltered returned error code: %d (see libmboard docs for details)\n", rc);
               
               
                   break;
		   }

		   
           exit(rc);
		}
		#endif
		
		

			i = Government_read_transfer_notifications();

		
		    rc = MB_Iterator_Delete(&i_hh_transfer_notification);
		    #ifdef ERRCHECK
		    if (rc != MB_SUCCESS)
		    {
		       fprintf(stderr, "ERROR: Could not delete 'hh_transfer_notification' iterator\n");
		       switch(rc) {
		           case MB_ERR_INVALID:
		               fprintf(stderr, "\t reason: 'hh_transfer_notification' iterator is invalid\n");
		               break;
		           case MB_ERR_INTERNAL:
		               fprintf(stderr, "\t reason: internal error. Recompile libmoard in debug mode for more info \n");
		               break;
		           default:
                       fprintf(stderr, "\t MB_Iterator_Delete returned error code: %d (see libmboard docs for details)\n", rc);
                       break;
		       }

		       
               exit(rc);
		    }
		    #endif
		
		    rc = MB_Iterator_Delete(&i_firm_transfer_notification);
		    #ifdef ERRCHECK
		    if (rc != MB_SUCCESS)
		    {
		       fprintf(stderr, "ERROR: Could not delete 'firm_transfer_notification' iterator\n");
		       switch(rc) {
		           case MB_ERR_INVALID:
		               fprintf(stderr, "\t reason: 'firm_transfer_notification' iterator is invalid\n");
		               break;
		           case MB_ERR_INTERNAL:
		               fprintf(stderr, "\t reason: internal error. Recompile libmoard in debug mode for more info \n");
		               break;
		           default:
                       fprintf(stderr, "\t MB_Iterator_Delete returned error code: %d (see libmboard docs for details)\n", rc);
                       break;
		       }

		       
               exit(rc);
		    }
		    #endif
		

			if(i == 1)
			{
				free_Government_agent(current_xmachine_Government_holder, Government_03_state);
			}
			else
			{
				transition_Government_agent(current_xmachine_Government_holder, Government_03_state, Government_04_state);
			}
		

		current_xmachine_Government = NULL;

		current_xmachine_Government_holder = temp_xmachine_Government_holder;
	}
	if(FLAME_TEST_PRINT_START_AND_END_OF_MODEL_FUNCTIONS) printf("finish Government_read_transfer_notifications\n");


/* End of layer number 98 */

/* Clear message boards that have finished being used
 * and sync complete if doing late sync complete */

if(FLAME_hh_transfer_notification_message_board_read == 0)
{
	/*printf("%d> hh_transfer_notification message board sync complete late as no agents reading any messages of this type\n", node_number);*/
	
	if(FLAME_TEST_PRINT_START_AND_END_OF_LIBMBOARD_CALLS) printf("start MB_SyncComplete(b_hh_transfer_notification)\n");
	rc = MB_SyncComplete(b_hh_transfer_notification);
	if(FLAME_TEST_PRINT_START_AND_END_OF_LIBMBOARD_CALLS) printf("finsh MB_SyncComplete(b_hh_transfer_notification)\n");
	#ifdef ERRCHECK
	if (rc != MB_SUCCESS)
	{
	   fprintf(stderr, "ERROR: Could not complete sync of 'hh_transfer_notification' board\n");
	   switch(rc) {
			case MB_ERR_INVALID:
			   fprintf(stderr, "\t reason: 'hh_transfer_notification' board is invalid\n");
			   break;
		   case MB_ERR_MEMALLOC:
			   fprintf(stderr, "\t reason: out of memory\n");
			   break;
		   case MB_ERR_INTERNAL:
			   fprintf(stderr, "\t reason: internal error. Recompile libmoard in debug mode for more info \n");
			   break;
		   default:
			   fprintf(stderr, "\t MB_SyncComplete returned error code: %d (see libmboard docs for details)\n", rc);
			   break;
	   }

	   
	   exit(rc);
	}
	#endif
}

    rc = MB_Clear(b_hh_transfer_notification);
    #ifdef ERRCHECK
    if (rc != MB_SUCCESS)
    {
       fprintf(stderr, "ERROR: Could not clear 'hh_transfer_notification' board\n");
       switch(rc) {
           case MB_ERR_INVALID:
               fprintf(stderr, "\t reason: 'hh_transfer_notification' board is invalid\n");
               break;
           case MB_ERR_LOCKED:
               fprintf(stderr, "\t reason: 'hh_transfer_notification' board is locked\n");
               break;
           case MB_ERR_INTERNAL:
               fprintf(stderr, "\t reason: internal error. Recompile libmoard in debug mode for more info \n");
               break;
           default:
               fprintf(stderr, "\t MB_Clear returned error code: %d (see libmboard docs for details)\n", rc);
               break;

       }

       
       exit(rc);
    }
    #endif

if(FLAME_firm_transfer_notification_message_board_read == 0)
{
	/*printf("%d> firm_transfer_notification message board sync complete late as no agents reading any messages of this type\n", node_number);*/
	
	if(FLAME_TEST_PRINT_START_AND_END_OF_LIBMBOARD_CALLS) printf("start MB_SyncComplete(b_firm_transfer_notification)\n");
	rc = MB_SyncComplete(b_firm_transfer_notification);
	if(FLAME_TEST_PRINT_START_AND_END_OF_LIBMBOARD_CALLS) printf("finsh MB_SyncComplete(b_firm_transfer_notification)\n");
	#ifdef ERRCHECK
	if (rc != MB_SUCCESS)
	{
	   fprintf(stderr, "ERROR: Could not complete sync of 'firm_transfer_notification' board\n");
	   switch(rc) {
			case MB_ERR_INVALID:
			   fprintf(stderr, "\t reason: 'firm_transfer_notification' board is invalid\n");
			   break;
		   case MB_ERR_MEMALLOC:
			   fprintf(stderr, "\t reason: out of memory\n");
			   break;
		   case MB_ERR_INTERNAL:
			   fprintf(stderr, "\t reason: internal error. Recompile libmoard in debug mode for more info \n");
			   break;
		   default:
			   fprintf(stderr, "\t MB_SyncComplete returned error code: %d (see libmboard docs for details)\n", rc);
			   break;
	   }

	   
	   exit(rc);
	}
	#endif
}

    rc = MB_Clear(b_firm_transfer_notification);
    #ifdef ERRCHECK
    if (rc != MB_SUCCESS)
    {
       fprintf(stderr, "ERROR: Could not clear 'firm_transfer_notification' board\n");
       switch(rc) {
           case MB_ERR_INVALID:
               fprintf(stderr, "\t reason: 'firm_transfer_notification' board is invalid\n");
               break;
           case MB_ERR_LOCKED:
               fprintf(stderr, "\t reason: 'firm_transfer_notification' board is locked\n");
               break;
           case MB_ERR_INTERNAL:
               fprintf(stderr, "\t reason: internal error. Recompile libmoard in debug mode for more info \n");
               break;
           default:
               fprintf(stderr, "\t MB_Clear returned error code: %d (see libmboard docs for details)\n", rc);
               break;

       }

       
       exit(rc);
    }
    #endif


	/* If mb is not read then leave sync complete until last possible moment */
	if(FLAME_unemployment_notification_message_board_read == 1)
	{
		if(FLAME_TEST_PRINT_START_AND_END_OF_LIBMBOARD_CALLS) printf("start MB_SyncComplete(b_unemployment_notification)\n");
		rc = MB_SyncComplete(b_unemployment_notification);
		if(FLAME_TEST_PRINT_START_AND_END_OF_LIBMBOARD_CALLS) printf("finsh MB_SyncComplete(b_unemployment_notification)\n");
		#ifdef ERRCHECK
		if (rc != MB_SUCCESS)
		{
		   fprintf(stderr, "ERROR: Could not complete sync of 'unemployment_notification' board\n");
		   switch(rc) {
				case MB_ERR_INVALID:
				   fprintf(stderr, "\t reason: 'unemployment_notification' board is invalid\n");
				   break;
			   case MB_ERR_MEMALLOC:
				   fprintf(stderr, "\t reason: out of memory\n");
				   break;
			   case MB_ERR_INTERNAL:
				   fprintf(stderr, "\t reason: internal error. Recompile libmoard in debug mode for more info \n");
				   break;
			   default:
				   fprintf(stderr, "\t MB_SyncComplete returned error code: %d (see libmboard docs for details)\n", rc);
				   break;
		   }
	
		   
		   exit(rc);
		}
		#endif
    
	}
	
	if(FLAME_TEST_PRINT_START_AND_END_OF_MODEL_FUNCTIONS) printf("start Government_read_unemployment_benefit_notifications\n");
	current_xmachine_Government_holder = Government_04_state->agents;
	while(current_xmachine_Government_holder)
	{
		temp_xmachine_Government_holder = current_xmachine_Government_holder->next;
		current_xmachine_Government = current_xmachine_Government_holder->agent;
		current_xmachine_Government_next_state = Government_Gov_Start_Monthly_Loop_state;
		/* For backwards compatibility set current_xmachine */
		current_xmachine->xmachine_Firm = NULL;
		current_xmachine->xmachine_Household = NULL;
		current_xmachine->xmachine_Mall = NULL;
		current_xmachine->xmachine_IGFirm = NULL;
		current_xmachine->xmachine_Eurostat = NULL;
		current_xmachine->xmachine_Bank = NULL;
		current_xmachine->xmachine_Government = NULL;
		current_xmachine->xmachine_CentralBank = NULL;
		current_xmachine->xmachine_ClearingHouse = NULL;
		current_xmachine->xmachine_Government = current_xmachine_Government;

		

		
		rc = MB_Iterator_CreateFiltered(b_unemployment_notification, &i_unemployment_notification, &FLAME_filter_Government_Government_read_unemployment_benefit_notifications_04_Gov_Start_Monthly_Loop_unemployment_notification, current_xmachine_Government);
		
		#ifdef ERRCHECK
		if (rc != MB_SUCCESS)
		{
		   fprintf(stderr, "ERROR: Could not create Iterator for 'unemployment_notification'\n");
		   switch(rc) {
		       case MB_ERR_INVALID:
		           fprintf(stderr, "\t reason: 'unemployment_notification' board is invalid\n");
		           break;
		       case MB_ERR_LOCKED:
	               fprintf(stderr, "\t reason: 'unemployment_notification' board is locked\n");
	               break;
	           case MB_ERR_MEMALLOC:
	               fprintf(stderr, "\t reason: out of memory\n");
	               break;
	           case MB_ERR_INTERNAL:
	               fprintf(stderr, "\t reason: internal error. Recompile libmoard in debug mode for more info \n");
	               break;
	           default:
	           
                   fprintf(stderr, "\t MB_Iterator_CreateFiltered returned error code: %d (see libmboard docs for details)\n", rc);
               
               
                   break;
		   }

		   
           exit(rc);
		}
		#endif
		
		

			i = Government_read_unemployment_benefit_notifications();

		
		    rc = MB_Iterator_Delete(&i_unemployment_notification);
		    #ifdef ERRCHECK
		    if (rc != MB_SUCCESS)
		    {
		       fprintf(stderr, "ERROR: Could not delete 'unemployment_notification' iterator\n");
		       switch(rc) {
		           case MB_ERR_INVALID:
		               fprintf(stderr, "\t reason: 'unemployment_notification' iterator is invalid\n");
		               break;
		           case MB_ERR_INTERNAL:
		               fprintf(stderr, "\t reason: internal error. Recompile libmoard in debug mode for more info \n");
		               break;
		           default:
                       fprintf(stderr, "\t MB_Iterator_Delete returned error code: %d (see libmboard docs for details)\n", rc);
                       break;
		       }

		       
               exit(rc);
		    }
		    #endif
		

			if(i == 1)
			{
				free_Government_agent(current_xmachine_Government_holder, Government_04_state);
			}
			else
			{
				transition_Government_agent(current_xmachine_Government_holder, Government_04_state, Government_Gov_Start_Monthly_Loop_state);
			}
		

		current_xmachine_Government = NULL;

		current_xmachine_Government_holder = temp_xmachine_Government_holder;
	}
	if(FLAME_TEST_PRINT_START_AND_END_OF_MODEL_FUNCTIONS) printf("finish Government_read_unemployment_benefit_notifications\n");


/* End of layer number 99 */

/* Clear message boards that have finished being used
 * and sync complete if doing late sync complete */

if(FLAME_unemployment_notification_message_board_read == 0)
{
	/*printf("%d> unemployment_notification message board sync complete late as no agents reading any messages of this type\n", node_number);*/
	
	if(FLAME_TEST_PRINT_START_AND_END_OF_LIBMBOARD_CALLS) printf("start MB_SyncComplete(b_unemployment_notification)\n");
	rc = MB_SyncComplete(b_unemployment_notification);
	if(FLAME_TEST_PRINT_START_AND_END_OF_LIBMBOARD_CALLS) printf("finsh MB_SyncComplete(b_unemployment_notification)\n");
	#ifdef ERRCHECK
	if (rc != MB_SUCCESS)
	{
	   fprintf(stderr, "ERROR: Could not complete sync of 'unemployment_notification' board\n");
	   switch(rc) {
			case MB_ERR_INVALID:
			   fprintf(stderr, "\t reason: 'unemployment_notification' board is invalid\n");
			   break;
		   case MB_ERR_MEMALLOC:
			   fprintf(stderr, "\t reason: out of memory\n");
			   break;
		   case MB_ERR_INTERNAL:
			   fprintf(stderr, "\t reason: internal error. Recompile libmoard in debug mode for more info \n");
			   break;
		   default:
			   fprintf(stderr, "\t MB_SyncComplete returned error code: %d (see libmboard docs for details)\n", rc);
			   break;
	   }

	   
	   exit(rc);
	}
	#endif
}

    rc = MB_Clear(b_unemployment_notification);
    #ifdef ERRCHECK
    if (rc != MB_SUCCESS)
    {
       fprintf(stderr, "ERROR: Could not clear 'unemployment_notification' board\n");
       switch(rc) {
           case MB_ERR_INVALID:
               fprintf(stderr, "\t reason: 'unemployment_notification' board is invalid\n");
               break;
           case MB_ERR_LOCKED:
               fprintf(stderr, "\t reason: 'unemployment_notification' board is locked\n");
               break;
           case MB_ERR_INTERNAL:
               fprintf(stderr, "\t reason: internal error. Recompile libmoard in debug mode for more info \n");
               break;
           default:
               fprintf(stderr, "\t MB_Clear returned error code: %d (see libmboard docs for details)\n", rc);
               break;

       }

       
       exit(rc);
    }
    #endif


	if(FLAME_TEST_PRINT_START_AND_END_OF_MODEL_FUNCTIONS) printf("start Government_resolve_unsold_bonds_dummy\n");
	current_xmachine_Government_holder = Government_Gov_Start_Monthly_Loop_state->agents;
	while(current_xmachine_Government_holder)
	{
		temp_xmachine_Government_holder = current_xmachine_Government_holder->next;
		current_xmachine_Government = current_xmachine_Government_holder->agent;
		current_xmachine_Government_next_state = Government_05a_state;
		/* For backwards compatibility set current_xmachine */
		current_xmachine->xmachine_Firm = NULL;
		current_xmachine->xmachine_Household = NULL;
		current_xmachine->xmachine_Mall = NULL;
		current_xmachine->xmachine_IGFirm = NULL;
		current_xmachine->xmachine_Eurostat = NULL;
		current_xmachine->xmachine_Bank = NULL;
		current_xmachine->xmachine_Government = NULL;
		current_xmachine->xmachine_CentralBank = NULL;
		current_xmachine->xmachine_ClearingHouse = NULL;
		current_xmachine->xmachine_Government = current_xmachine_Government;

		if(FLAME_condition_Government_Government_resolve_unsold_bonds_dummy_Gov_Start_Monthly_Loop_05a(current_xmachine_Government)==1)
		{

		

			i = Government_resolve_unsold_bonds_dummy();

		

			if(i == 1)
			{
				free_Government_agent(current_xmachine_Government_holder, Government_Gov_Start_Monthly_Loop_state);
			}
			else
			{
				transition_Government_agent(current_xmachine_Government_holder, Government_Gov_Start_Monthly_Loop_state, Government_05a_state);
			}
		}

		current_xmachine_Government = NULL;

		current_xmachine_Government_holder = temp_xmachine_Government_holder;
	}
	if(FLAME_TEST_PRINT_START_AND_END_OF_MODEL_FUNCTIONS) printf("finish Government_resolve_unsold_bonds_dummy\n");


	if(FLAME_TEST_PRINT_START_AND_END_OF_MODEL_FUNCTIONS) printf("start idle\n");
	current_xmachine_Government_holder = Government_Gov_Start_Monthly_Loop_state->agents;
	while(current_xmachine_Government_holder)
	{
		temp_xmachine_Government_holder = current_xmachine_Government_holder->next;
		current_xmachine_Government = current_xmachine_Government_holder->agent;
		current_xmachine_Government_next_state = Government_06_state;
		/* For backwards compatibility set current_xmachine */
		current_xmachine->xmachine_Firm = NULL;
		current_xmachine->xmachine_Household = NULL;
		current_xmachine->xmachine_Mall = NULL;
		current_xmachine->xmachine_IGFirm = NULL;
		current_xmachine->xmachine_Eurostat = NULL;
		current_xmachine->xmachine_Bank = NULL;
		current_xmachine->xmachine_Government = NULL;
		current_xmachine->xmachine_CentralBank = NULL;
		current_xmachine->xmachine_ClearingHouse = NULL;
		current_xmachine->xmachine_Government = current_xmachine_Government;

		if(FLAME_condition_Government_idle_Gov_Start_Monthly_Loop_06(current_xmachine_Government)==1)
		{

		

			i = idle();

		

			if(i == 1)
			{
				free_Government_agent(current_xmachine_Government_holder, Government_Gov_Start_Monthly_Loop_state);
			}
			else
			{
				transition_Government_agent(current_xmachine_Government_holder, Government_Gov_Start_Monthly_Loop_state, Government_06_state);
			}
		}

		current_xmachine_Government = NULL;

		current_xmachine_Government_holder = temp_xmachine_Government_holder;
	}
	if(FLAME_TEST_PRINT_START_AND_END_OF_MODEL_FUNCTIONS) printf("finish idle\n");


/* End of layer number 100 */

/* Clear message boards that have finished being used
 * and sync complete if doing late sync complete */


	if(FLAME_TEST_PRINT_START_AND_END_OF_MODEL_FUNCTIONS) printf("start Government_monthly_budget_accounting\n");
	current_xmachine_Government_holder = Government_05a_state->agents;
	while(current_xmachine_Government_holder)
	{
		temp_xmachine_Government_holder = current_xmachine_Government_holder->next;
		current_xmachine_Government = current_xmachine_Government_holder->agent;
		current_xmachine_Government_next_state = Government_Gov_bonds_decision_state;
		/* For backwards compatibility set current_xmachine */
		current_xmachine->xmachine_Firm = NULL;
		current_xmachine->xmachine_Household = NULL;
		current_xmachine->xmachine_Mall = NULL;
		current_xmachine->xmachine_IGFirm = NULL;
		current_xmachine->xmachine_Eurostat = NULL;
		current_xmachine->xmachine_Bank = NULL;
		current_xmachine->xmachine_Government = NULL;
		current_xmachine->xmachine_CentralBank = NULL;
		current_xmachine->xmachine_ClearingHouse = NULL;
		current_xmachine->xmachine_Government = current_xmachine_Government;

		

		

			i = Government_monthly_budget_accounting();

		

			if(i == 1)
			{
				free_Government_agent(current_xmachine_Government_holder, Government_05a_state);
			}
			else
			{
				transition_Government_agent(current_xmachine_Government_holder, Government_05a_state, Government_Gov_bonds_decision_state);
			}
		

		current_xmachine_Government = NULL;

		current_xmachine_Government_holder = temp_xmachine_Government_holder;
	}
	if(FLAME_TEST_PRINT_START_AND_END_OF_MODEL_FUNCTIONS) printf("finish Government_monthly_budget_accounting\n");

	if(FLAME_request_fiat_money_message_board_write == 1)
	{

		if(FLAME_TEST_PRINT_START_AND_END_OF_LIBMBOARD_CALLS) printf("start MB_SyncStart(b_request_fiat_money)\n");
		rc = MB_SyncStart(b_request_fiat_money);
		if(FLAME_TEST_PRINT_START_AND_END_OF_LIBMBOARD_CALLS) printf("finish MB_SyncStart(b_request_fiat_money)\n");
		#ifdef ERRCHECK
		if (rc != MB_SUCCESS)
		{
		   fprintf(stderr, "ERROR: Could not start sync of 'request_fiat_money' board\n");
		   switch(rc) {
			   case MB_ERR_INVALID:
				   fprintf(stderr, "\t reason: 'request_fiat_money' board is invalid\n");
				   break;
			   case MB_ERR_LOCKED:
				   fprintf(stderr, "\t reason: 'request_fiat_money' board is locked\n");
				   break;
			   case MB_ERR_MEMALLOC:
				   fprintf(stderr, "\t reason: out of memory\n");
				   break;
			   case MB_ERR_INTERNAL:
				   fprintf(stderr, "\t reason: internal error. Recompile libmoard in debug mode for more info \n");
				   break;
			   default:
				   fprintf(stderr, "\t MB_SyncStart returned error code: %d (see libmboard docs for details)\n", rc);
				   break;
		   }

			
			exit(rc);
		}
		#endif
    }
    


/* End of layer number 101 */

/* Clear message boards that have finished being used
 * and sync complete if doing late sync complete */


	if(FLAME_TEST_PRINT_START_AND_END_OF_MODEL_FUNCTIONS) printf("start idle\n");
	current_xmachine_Government_holder = Government_Gov_bonds_decision_state->agents;
	while(current_xmachine_Government_holder)
	{
		temp_xmachine_Government_holder = current_xmachine_Government_holder->next;
		current_xmachine_Government = current_xmachine_Government_holder->agent;
		current_xmachine_Government_next_state = Government_06_state;
		/* For backwards compatibility set current_xmachine */
		current_xmachine->xmachine_Firm = NULL;
		current_xmachine->xmachine_Household = NULL;
		current_xmachine->xmachine_Mall = NULL;
		current_xmachine->xmachine_IGFirm = NULL;
		current_xmachine->xmachine_Eurostat = NULL;
		current_xmachine->xmachine_Bank = NULL;
		current_xmachine->xmachine_Government = NULL;
		current_xmachine->xmachine_CentralBank = NULL;
		current_xmachine->xmachine_ClearingHouse = NULL;
		current_xmachine->xmachine_Government = current_xmachine_Government;

		if(FLAME_condition_Government_idle_Gov_bonds_decision_06(current_xmachine_Government)==1)
		{

		

			i = idle();

		

			if(i == 1)
			{
				free_Government_agent(current_xmachine_Government_holder, Government_Gov_bonds_decision_state);
			}
			else
			{
				transition_Government_agent(current_xmachine_Government_holder, Government_Gov_bonds_decision_state, Government_06_state);
			}
		}

		current_xmachine_Government = NULL;

		current_xmachine_Government_holder = temp_xmachine_Government_holder;
	}
	if(FLAME_TEST_PRINT_START_AND_END_OF_MODEL_FUNCTIONS) printf("finish idle\n");


	if(FLAME_TEST_PRINT_START_AND_END_OF_MODEL_FUNCTIONS) printf("start Government_bonds_issuing_decision_dummy\n");
	current_xmachine_Government_holder = Government_Gov_bonds_decision_state->agents;
	while(current_xmachine_Government_holder)
	{
		temp_xmachine_Government_holder = current_xmachine_Government_holder->next;
		current_xmachine_Government = current_xmachine_Government_holder->agent;
		current_xmachine_Government_next_state = Government_06_state;
		/* For backwards compatibility set current_xmachine */
		current_xmachine->xmachine_Firm = NULL;
		current_xmachine->xmachine_Household = NULL;
		current_xmachine->xmachine_Mall = NULL;
		current_xmachine->xmachine_IGFirm = NULL;
		current_xmachine->xmachine_Eurostat = NULL;
		current_xmachine->xmachine_Bank = NULL;
		current_xmachine->xmachine_Government = NULL;
		current_xmachine->xmachine_CentralBank = NULL;
		current_xmachine->xmachine_ClearingHouse = NULL;
		current_xmachine->xmachine_Government = current_xmachine_Government;

		if(FLAME_condition_Government_Government_bonds_issuing_decision_dummy_Gov_bonds_decision_06(current_xmachine_Government)==1)
		{

		

			i = Government_bonds_issuing_decision_dummy();

		

			if(i == 1)
			{
				free_Government_agent(current_xmachine_Government_holder, Government_Gov_bonds_decision_state);
			}
			else
			{
				transition_Government_agent(current_xmachine_Government_holder, Government_Gov_bonds_decision_state, Government_06_state);
			}
		}

		current_xmachine_Government = NULL;

		current_xmachine_Government_holder = temp_xmachine_Government_holder;
	}
	if(FLAME_TEST_PRINT_START_AND_END_OF_MODEL_FUNCTIONS) printf("finish Government_bonds_issuing_decision_dummy\n");


	/* If mb is not read then leave sync complete until last possible moment */
	if(FLAME_request_fiat_money_message_board_read == 1)
	{
		if(FLAME_TEST_PRINT_START_AND_END_OF_LIBMBOARD_CALLS) printf("start MB_SyncComplete(b_request_fiat_money)\n");
		rc = MB_SyncComplete(b_request_fiat_money);
		if(FLAME_TEST_PRINT_START_AND_END_OF_LIBMBOARD_CALLS) printf("finsh MB_SyncComplete(b_request_fiat_money)\n");
		#ifdef ERRCHECK
		if (rc != MB_SUCCESS)
		{
		   fprintf(stderr, "ERROR: Could not complete sync of 'request_fiat_money' board\n");
		   switch(rc) {
				case MB_ERR_INVALID:
				   fprintf(stderr, "\t reason: 'request_fiat_money' board is invalid\n");
				   break;
			   case MB_ERR_MEMALLOC:
				   fprintf(stderr, "\t reason: out of memory\n");
				   break;
			   case MB_ERR_INTERNAL:
				   fprintf(stderr, "\t reason: internal error. Recompile libmoard in debug mode for more info \n");
				   break;
			   default:
				   fprintf(stderr, "\t MB_SyncComplete returned error code: %d (see libmboard docs for details)\n", rc);
				   break;
		   }
	
		   
		   exit(rc);
		}
		#endif
    
	}
	
	if(FLAME_TEST_PRINT_START_AND_END_OF_MODEL_FUNCTIONS) printf("start Central_Bank_read_fiat_money_requests\n");
	current_xmachine_CentralBank_holder = CentralBank_CB_financial_operations_end_state->agents;
	while(current_xmachine_CentralBank_holder)
	{
		temp_xmachine_CentralBank_holder = current_xmachine_CentralBank_holder->next;
		current_xmachine_CentralBank = current_xmachine_CentralBank_holder->agent;
		current_xmachine_CentralBank_next_state = CentralBank_00_state;
		/* For backwards compatibility set current_xmachine */
		current_xmachine->xmachine_Firm = NULL;
		current_xmachine->xmachine_Household = NULL;
		current_xmachine->xmachine_Mall = NULL;
		current_xmachine->xmachine_IGFirm = NULL;
		current_xmachine->xmachine_Eurostat = NULL;
		current_xmachine->xmachine_Bank = NULL;
		current_xmachine->xmachine_Government = NULL;
		current_xmachine->xmachine_CentralBank = NULL;
		current_xmachine->xmachine_ClearingHouse = NULL;
		current_xmachine->xmachine_CentralBank = current_xmachine_CentralBank;

		if(FLAME_condition_CentralBank_Central_Bank_read_fiat_money_requests_CB_financial_operations_end_00(current_xmachine_CentralBank)==1)
		{

		
		
		rc = MB_Iterator_Create(b_request_fiat_money, &i_request_fiat_money);
		#ifdef ERRCHECK
		if (rc != MB_SUCCESS)
		{
		   fprintf(stderr, "ERROR: Could not create Iterator for 'request_fiat_money'\n");
		   switch(rc) {
		       case MB_ERR_INVALID:
		           fprintf(stderr, "\t reason: 'request_fiat_money' board is invalid\n");
		           break;
		       case MB_ERR_LOCKED:
	               fprintf(stderr, "\t reason: 'request_fiat_money' board is locked\n");
	               break;
	           case MB_ERR_MEMALLOC:
	               fprintf(stderr, "\t reason: out of memory\n");
	               break;
	           case MB_ERR_INTERNAL:
	               fprintf(stderr, "\t reason: internal error. Recompile libmoard in debug mode for more info \n");
	               break;
	           default:
	           
               
                   fprintf(stderr, "\t MB_Iterator_Create returned error code: %d (see libmboard docs for details)\n", rc);
               
                   break;
		   }

		   
           exit(rc);
		}
		#endif
		
		

			i = Central_Bank_read_fiat_money_requests();

		
		    rc = MB_Iterator_Delete(&i_request_fiat_money);
		    #ifdef ERRCHECK
		    if (rc != MB_SUCCESS)
		    {
		       fprintf(stderr, "ERROR: Could not delete 'request_fiat_money' iterator\n");
		       switch(rc) {
		           case MB_ERR_INVALID:
		               fprintf(stderr, "\t reason: 'request_fiat_money' iterator is invalid\n");
		               break;
		           case MB_ERR_INTERNAL:
		               fprintf(stderr, "\t reason: internal error. Recompile libmoard in debug mode for more info \n");
		               break;
		           default:
                       fprintf(stderr, "\t MB_Iterator_Delete returned error code: %d (see libmboard docs for details)\n", rc);
                       break;
		       }

		       
               exit(rc);
		    }
		    #endif
		

			if(i == 1)
			{
				free_CentralBank_agent(current_xmachine_CentralBank_holder, CentralBank_CB_financial_operations_end_state);
			}
			else
			{
				transition_CentralBank_agent(current_xmachine_CentralBank_holder, CentralBank_CB_financial_operations_end_state, CentralBank_00_state);
			}
		}

		current_xmachine_CentralBank = NULL;

		current_xmachine_CentralBank_holder = temp_xmachine_CentralBank_holder;
	}
	if(FLAME_TEST_PRINT_START_AND_END_OF_MODEL_FUNCTIONS) printf("finish Central_Bank_read_fiat_money_requests\n");


/* End of layer number 102 */

/* Clear message boards that have finished being used
 * and sync complete if doing late sync complete */

if(FLAME_request_fiat_money_message_board_read == 0)
{
	/*printf("%d> request_fiat_money message board sync complete late as no agents reading any messages of this type\n", node_number);*/
	
	if(FLAME_TEST_PRINT_START_AND_END_OF_LIBMBOARD_CALLS) printf("start MB_SyncComplete(b_request_fiat_money)\n");
	rc = MB_SyncComplete(b_request_fiat_money);
	if(FLAME_TEST_PRINT_START_AND_END_OF_LIBMBOARD_CALLS) printf("finsh MB_SyncComplete(b_request_fiat_money)\n");
	#ifdef ERRCHECK
	if (rc != MB_SUCCESS)
	{
	   fprintf(stderr, "ERROR: Could not complete sync of 'request_fiat_money' board\n");
	   switch(rc) {
			case MB_ERR_INVALID:
			   fprintf(stderr, "\t reason: 'request_fiat_money' board is invalid\n");
			   break;
		   case MB_ERR_MEMALLOC:
			   fprintf(stderr, "\t reason: out of memory\n");
			   break;
		   case MB_ERR_INTERNAL:
			   fprintf(stderr, "\t reason: internal error. Recompile libmoard in debug mode for more info \n");
			   break;
		   default:
			   fprintf(stderr, "\t MB_SyncComplete returned error code: %d (see libmboard docs for details)\n", rc);
			   break;
	   }

	   
	   exit(rc);
	}
	#endif
}

    rc = MB_Clear(b_request_fiat_money);
    #ifdef ERRCHECK
    if (rc != MB_SUCCESS)
    {
       fprintf(stderr, "ERROR: Could not clear 'request_fiat_money' board\n");
       switch(rc) {
           case MB_ERR_INVALID:
               fprintf(stderr, "\t reason: 'request_fiat_money' board is invalid\n");
               break;
           case MB_ERR_LOCKED:
               fprintf(stderr, "\t reason: 'request_fiat_money' board is locked\n");
               break;
           case MB_ERR_INTERNAL:
               fprintf(stderr, "\t reason: internal error. Recompile libmoard in debug mode for more info \n");
               break;
           default:
               fprintf(stderr, "\t MB_Clear returned error code: %d (see libmboard docs for details)\n", rc);
               break;

       }

       
       exit(rc);
    }
    #endif


	if(FLAME_TEST_PRINT_START_AND_END_OF_MODEL_FUNCTIONS) printf("start Government_send_account_update\n");
	current_xmachine_Government_holder = Government_06_state->agents;
	while(current_xmachine_Government_holder)
	{
		temp_xmachine_Government_holder = current_xmachine_Government_holder->next;
		current_xmachine_Government = current_xmachine_Government_holder->agent;
		current_xmachine_Government_next_state = Government_07_state;
		/* For backwards compatibility set current_xmachine */
		current_xmachine->xmachine_Firm = NULL;
		current_xmachine->xmachine_Household = NULL;
		current_xmachine->xmachine_Mall = NULL;
		current_xmachine->xmachine_IGFirm = NULL;
		current_xmachine->xmachine_Eurostat = NULL;
		current_xmachine->xmachine_Bank = NULL;
		current_xmachine->xmachine_Government = NULL;
		current_xmachine->xmachine_CentralBank = NULL;
		current_xmachine->xmachine_ClearingHouse = NULL;
		current_xmachine->xmachine_Government = current_xmachine_Government;

		

		

			i = Government_send_account_update();

		

			if(i == 1)
			{
				free_Government_agent(current_xmachine_Government_holder, Government_06_state);
			}
			else
			{
				transition_Government_agent(current_xmachine_Government_holder, Government_06_state, Government_07_state);
			}
		

		current_xmachine_Government = NULL;

		current_xmachine_Government_holder = temp_xmachine_Government_holder;
	}
	if(FLAME_TEST_PRINT_START_AND_END_OF_MODEL_FUNCTIONS) printf("finish Government_send_account_update\n");

	if(FLAME_gov_to_central_bank_account_update_message_board_write == 1)
	{

		if(FLAME_TEST_PRINT_START_AND_END_OF_LIBMBOARD_CALLS) printf("start MB_SyncStart(b_gov_to_central_bank_account_update)\n");
		rc = MB_SyncStart(b_gov_to_central_bank_account_update);
		if(FLAME_TEST_PRINT_START_AND_END_OF_LIBMBOARD_CALLS) printf("finish MB_SyncStart(b_gov_to_central_bank_account_update)\n");
		#ifdef ERRCHECK
		if (rc != MB_SUCCESS)
		{
		   fprintf(stderr, "ERROR: Could not start sync of 'gov_to_central_bank_account_update' board\n");
		   switch(rc) {
			   case MB_ERR_INVALID:
				   fprintf(stderr, "\t reason: 'gov_to_central_bank_account_update' board is invalid\n");
				   break;
			   case MB_ERR_LOCKED:
				   fprintf(stderr, "\t reason: 'gov_to_central_bank_account_update' board is locked\n");
				   break;
			   case MB_ERR_MEMALLOC:
				   fprintf(stderr, "\t reason: out of memory\n");
				   break;
			   case MB_ERR_INTERNAL:
				   fprintf(stderr, "\t reason: internal error. Recompile libmoard in debug mode for more info \n");
				   break;
			   default:
				   fprintf(stderr, "\t MB_SyncStart returned error code: %d (see libmboard docs for details)\n", rc);
				   break;
		   }

			
			exit(rc);
		}
		#endif
    }
    


/* End of layer number 103 */

/* Clear message boards that have finished being used
 * and sync complete if doing late sync complete */


	/* If mb is not read then leave sync complete until last possible moment */
	if(FLAME_bank_interest_payment_message_board_read == 1)
	{
		if(FLAME_TEST_PRINT_START_AND_END_OF_LIBMBOARD_CALLS) printf("start MB_SyncComplete(b_bank_interest_payment)\n");
		rc = MB_SyncComplete(b_bank_interest_payment);
		if(FLAME_TEST_PRINT_START_AND_END_OF_LIBMBOARD_CALLS) printf("finsh MB_SyncComplete(b_bank_interest_payment)\n");
		#ifdef ERRCHECK
		if (rc != MB_SUCCESS)
		{
		   fprintf(stderr, "ERROR: Could not complete sync of 'bank_interest_payment' board\n");
		   switch(rc) {
				case MB_ERR_INVALID:
				   fprintf(stderr, "\t reason: 'bank_interest_payment' board is invalid\n");
				   break;
			   case MB_ERR_MEMALLOC:
				   fprintf(stderr, "\t reason: out of memory\n");
				   break;
			   case MB_ERR_INTERNAL:
				   fprintf(stderr, "\t reason: internal error. Recompile libmoard in debug mode for more info \n");
				   break;
			   default:
				   fprintf(stderr, "\t MB_SyncComplete returned error code: %d (see libmboard docs for details)\n", rc);
				   break;
		   }
	
		   
		   exit(rc);
		}
		#endif
    
	}
	
	/* If mb is not read then leave sync complete until last possible moment */
	if(FLAME_gov_to_central_bank_account_update_message_board_read == 1)
	{
		if(FLAME_TEST_PRINT_START_AND_END_OF_LIBMBOARD_CALLS) printf("start MB_SyncComplete(b_gov_to_central_bank_account_update)\n");
		rc = MB_SyncComplete(b_gov_to_central_bank_account_update);
		if(FLAME_TEST_PRINT_START_AND_END_OF_LIBMBOARD_CALLS) printf("finsh MB_SyncComplete(b_gov_to_central_bank_account_update)\n");
		#ifdef ERRCHECK
		if (rc != MB_SUCCESS)
		{
		   fprintf(stderr, "ERROR: Could not complete sync of 'gov_to_central_bank_account_update' board\n");
		   switch(rc) {
				case MB_ERR_INVALID:
				   fprintf(stderr, "\t reason: 'gov_to_central_bank_account_update' board is invalid\n");
				   break;
			   case MB_ERR_MEMALLOC:
				   fprintf(stderr, "\t reason: out of memory\n");
				   break;
			   case MB_ERR_INTERNAL:
				   fprintf(stderr, "\t reason: internal error. Recompile libmoard in debug mode for more info \n");
				   break;
			   default:
				   fprintf(stderr, "\t MB_SyncComplete returned error code: %d (see libmboard docs for details)\n", rc);
				   break;
		   }
	
		   
		   exit(rc);
		}
		#endif
    
	}
	
	/* If mb is not read then leave sync complete until last possible moment */
	if(FLAME_bank_to_central_bank_account_update_message_board_read == 1)
	{
		if(FLAME_TEST_PRINT_START_AND_END_OF_LIBMBOARD_CALLS) printf("start MB_SyncComplete(b_bank_to_central_bank_account_update)\n");
		rc = MB_SyncComplete(b_bank_to_central_bank_account_update);
		if(FLAME_TEST_PRINT_START_AND_END_OF_LIBMBOARD_CALLS) printf("finsh MB_SyncComplete(b_bank_to_central_bank_account_update)\n");
		#ifdef ERRCHECK
		if (rc != MB_SUCCESS)
		{
		   fprintf(stderr, "ERROR: Could not complete sync of 'bank_to_central_bank_account_update' board\n");
		   switch(rc) {
				case MB_ERR_INVALID:
				   fprintf(stderr, "\t reason: 'bank_to_central_bank_account_update' board is invalid\n");
				   break;
			   case MB_ERR_MEMALLOC:
				   fprintf(stderr, "\t reason: out of memory\n");
				   break;
			   case MB_ERR_INTERNAL:
				   fprintf(stderr, "\t reason: internal error. Recompile libmoard in debug mode for more info \n");
				   break;
			   default:
				   fprintf(stderr, "\t MB_SyncComplete returned error code: %d (see libmboard docs for details)\n", rc);
				   break;
		   }
	
		   
		   exit(rc);
		}
		#endif
    
	}
	
	if(FLAME_TEST_PRINT_START_AND_END_OF_MODEL_FUNCTIONS) printf("start Central_Bank_read_account_update\n");
	current_xmachine_CentralBank_holder = CentralBank_00_state->agents;
	while(current_xmachine_CentralBank_holder)
	{
		temp_xmachine_CentralBank_holder = current_xmachine_CentralBank_holder->next;
		current_xmachine_CentralBank = current_xmachine_CentralBank_holder->agent;
		current_xmachine_CentralBank_next_state = CentralBank_end_Central_Bank_state;
		/* For backwards compatibility set current_xmachine */
		current_xmachine->xmachine_Firm = NULL;
		current_xmachine->xmachine_Household = NULL;
		current_xmachine->xmachine_Mall = NULL;
		current_xmachine->xmachine_IGFirm = NULL;
		current_xmachine->xmachine_Eurostat = NULL;
		current_xmachine->xmachine_Bank = NULL;
		current_xmachine->xmachine_Government = NULL;
		current_xmachine->xmachine_CentralBank = NULL;
		current_xmachine->xmachine_ClearingHouse = NULL;
		current_xmachine->xmachine_CentralBank = current_xmachine_CentralBank;

		

		
		
		rc = MB_Iterator_Create(b_bank_to_central_bank_account_update, &i_bank_to_central_bank_account_update);
		#ifdef ERRCHECK
		if (rc != MB_SUCCESS)
		{
		   fprintf(stderr, "ERROR: Could not create Iterator for 'bank_to_central_bank_account_update'\n");
		   switch(rc) {
		       case MB_ERR_INVALID:
		           fprintf(stderr, "\t reason: 'bank_to_central_bank_account_update' board is invalid\n");
		           break;
		       case MB_ERR_LOCKED:
	               fprintf(stderr, "\t reason: 'bank_to_central_bank_account_update' board is locked\n");
	               break;
	           case MB_ERR_MEMALLOC:
	               fprintf(stderr, "\t reason: out of memory\n");
	               break;
	           case MB_ERR_INTERNAL:
	               fprintf(stderr, "\t reason: internal error. Recompile libmoard in debug mode for more info \n");
	               break;
	           default:
	           
               
                   fprintf(stderr, "\t MB_Iterator_Create returned error code: %d (see libmboard docs for details)\n", rc);
               
                   break;
		   }

		   
           exit(rc);
		}
		#endif
		
		
		
		rc = MB_Iterator_Create(b_gov_to_central_bank_account_update, &i_gov_to_central_bank_account_update);
		#ifdef ERRCHECK
		if (rc != MB_SUCCESS)
		{
		   fprintf(stderr, "ERROR: Could not create Iterator for 'gov_to_central_bank_account_update'\n");
		   switch(rc) {
		       case MB_ERR_INVALID:
		           fprintf(stderr, "\t reason: 'gov_to_central_bank_account_update' board is invalid\n");
		           break;
		       case MB_ERR_LOCKED:
	               fprintf(stderr, "\t reason: 'gov_to_central_bank_account_update' board is locked\n");
	               break;
	           case MB_ERR_MEMALLOC:
	               fprintf(stderr, "\t reason: out of memory\n");
	               break;
	           case MB_ERR_INTERNAL:
	               fprintf(stderr, "\t reason: internal error. Recompile libmoard in debug mode for more info \n");
	               break;
	           default:
	           
               
                   fprintf(stderr, "\t MB_Iterator_Create returned error code: %d (see libmboard docs for details)\n", rc);
               
                   break;
		   }

		   
           exit(rc);
		}
		#endif
		
		
		
		rc = MB_Iterator_Create(b_bank_interest_payment, &i_bank_interest_payment);
		#ifdef ERRCHECK
		if (rc != MB_SUCCESS)
		{
		   fprintf(stderr, "ERROR: Could not create Iterator for 'bank_interest_payment'\n");
		   switch(rc) {
		       case MB_ERR_INVALID:
		           fprintf(stderr, "\t reason: 'bank_interest_payment' board is invalid\n");
		           break;
		       case MB_ERR_LOCKED:
	               fprintf(stderr, "\t reason: 'bank_interest_payment' board is locked\n");
	               break;
	           case MB_ERR_MEMALLOC:
	               fprintf(stderr, "\t reason: out of memory\n");
	               break;
	           case MB_ERR_INTERNAL:
	               fprintf(stderr, "\t reason: internal error. Recompile libmoard in debug mode for more info \n");
	               break;
	           default:
	           
               
                   fprintf(stderr, "\t MB_Iterator_Create returned error code: %d (see libmboard docs for details)\n", rc);
               
                   break;
		   }

		   
           exit(rc);
		}
		#endif
		
		

			i = Central_Bank_read_account_update();

		
		    rc = MB_Iterator_Delete(&i_bank_to_central_bank_account_update);
		    #ifdef ERRCHECK
		    if (rc != MB_SUCCESS)
		    {
		       fprintf(stderr, "ERROR: Could not delete 'bank_to_central_bank_account_update' iterator\n");
		       switch(rc) {
		           case MB_ERR_INVALID:
		               fprintf(stderr, "\t reason: 'bank_to_central_bank_account_update' iterator is invalid\n");
		               break;
		           case MB_ERR_INTERNAL:
		               fprintf(stderr, "\t reason: internal error. Recompile libmoard in debug mode for more info \n");
		               break;
		           default:
                       fprintf(stderr, "\t MB_Iterator_Delete returned error code: %d (see libmboard docs for details)\n", rc);
                       break;
		       }

		       
               exit(rc);
		    }
		    #endif
		
		    rc = MB_Iterator_Delete(&i_gov_to_central_bank_account_update);
		    #ifdef ERRCHECK
		    if (rc != MB_SUCCESS)
		    {
		       fprintf(stderr, "ERROR: Could not delete 'gov_to_central_bank_account_update' iterator\n");
		       switch(rc) {
		           case MB_ERR_INVALID:
		               fprintf(stderr, "\t reason: 'gov_to_central_bank_account_update' iterator is invalid\n");
		               break;
		           case MB_ERR_INTERNAL:
		               fprintf(stderr, "\t reason: internal error. Recompile libmoard in debug mode for more info \n");
		               break;
		           default:
                       fprintf(stderr, "\t MB_Iterator_Delete returned error code: %d (see libmboard docs for details)\n", rc);
                       break;
		       }

		       
               exit(rc);
		    }
		    #endif
		
		    rc = MB_Iterator_Delete(&i_bank_interest_payment);
		    #ifdef ERRCHECK
		    if (rc != MB_SUCCESS)
		    {
		       fprintf(stderr, "ERROR: Could not delete 'bank_interest_payment' iterator\n");
		       switch(rc) {
		           case MB_ERR_INVALID:
		               fprintf(stderr, "\t reason: 'bank_interest_payment' iterator is invalid\n");
		               break;
		           case MB_ERR_INTERNAL:
		               fprintf(stderr, "\t reason: internal error. Recompile libmoard in debug mode for more info \n");
		               break;
		           default:
                       fprintf(stderr, "\t MB_Iterator_Delete returned error code: %d (see libmboard docs for details)\n", rc);
                       break;
		       }

		       
               exit(rc);
		    }
		    #endif
		

			if(i == 1)
			{
				free_CentralBank_agent(current_xmachine_CentralBank_holder, CentralBank_00_state);
			}
			else
			{
				transition_CentralBank_agent(current_xmachine_CentralBank_holder, CentralBank_00_state, CentralBank_end_Central_Bank_state);
			}
		

		current_xmachine_CentralBank = NULL;

		current_xmachine_CentralBank_holder = temp_xmachine_CentralBank_holder;
	}
	if(FLAME_TEST_PRINT_START_AND_END_OF_MODEL_FUNCTIONS) printf("finish Central_Bank_read_account_update\n");

	if(FLAME_ecb_dividend_message_board_write == 1)
	{

		if(FLAME_TEST_PRINT_START_AND_END_OF_LIBMBOARD_CALLS) printf("start MB_SyncStart(b_ecb_dividend)\n");
		rc = MB_SyncStart(b_ecb_dividend);
		if(FLAME_TEST_PRINT_START_AND_END_OF_LIBMBOARD_CALLS) printf("finish MB_SyncStart(b_ecb_dividend)\n");
		#ifdef ERRCHECK
		if (rc != MB_SUCCESS)
		{
		   fprintf(stderr, "ERROR: Could not start sync of 'ecb_dividend' board\n");
		   switch(rc) {
			   case MB_ERR_INVALID:
				   fprintf(stderr, "\t reason: 'ecb_dividend' board is invalid\n");
				   break;
			   case MB_ERR_LOCKED:
				   fprintf(stderr, "\t reason: 'ecb_dividend' board is locked\n");
				   break;
			   case MB_ERR_MEMALLOC:
				   fprintf(stderr, "\t reason: out of memory\n");
				   break;
			   case MB_ERR_INTERNAL:
				   fprintf(stderr, "\t reason: internal error. Recompile libmoard in debug mode for more info \n");
				   break;
			   default:
				   fprintf(stderr, "\t MB_SyncStart returned error code: %d (see libmboard docs for details)\n", rc);
				   break;
		   }

			
			exit(rc);
		}
		#endif
    }
    


/* End of layer number 104 */

/* Clear message boards that have finished being used
 * and sync complete if doing late sync complete */

if(FLAME_bank_to_central_bank_account_update_message_board_read == 0)
{
	/*printf("%d> bank_to_central_bank_account_update message board sync complete late as no agents reading any messages of this type\n", node_number);*/
	
	if(FLAME_TEST_PRINT_START_AND_END_OF_LIBMBOARD_CALLS) printf("start MB_SyncComplete(b_bank_to_central_bank_account_update)\n");
	rc = MB_SyncComplete(b_bank_to_central_bank_account_update);
	if(FLAME_TEST_PRINT_START_AND_END_OF_LIBMBOARD_CALLS) printf("finsh MB_SyncComplete(b_bank_to_central_bank_account_update)\n");
	#ifdef ERRCHECK
	if (rc != MB_SUCCESS)
	{
	   fprintf(stderr, "ERROR: Could not complete sync of 'bank_to_central_bank_account_update' board\n");
	   switch(rc) {
			case MB_ERR_INVALID:
			   fprintf(stderr, "\t reason: 'bank_to_central_bank_account_update' board is invalid\n");
			   break;
		   case MB_ERR_MEMALLOC:
			   fprintf(stderr, "\t reason: out of memory\n");
			   break;
		   case MB_ERR_INTERNAL:
			   fprintf(stderr, "\t reason: internal error. Recompile libmoard in debug mode for more info \n");
			   break;
		   default:
			   fprintf(stderr, "\t MB_SyncComplete returned error code: %d (see libmboard docs for details)\n", rc);
			   break;
	   }

	   
	   exit(rc);
	}
	#endif
}

    rc = MB_Clear(b_bank_to_central_bank_account_update);
    #ifdef ERRCHECK
    if (rc != MB_SUCCESS)
    {
       fprintf(stderr, "ERROR: Could not clear 'bank_to_central_bank_account_update' board\n");
       switch(rc) {
           case MB_ERR_INVALID:
               fprintf(stderr, "\t reason: 'bank_to_central_bank_account_update' board is invalid\n");
               break;
           case MB_ERR_LOCKED:
               fprintf(stderr, "\t reason: 'bank_to_central_bank_account_update' board is locked\n");
               break;
           case MB_ERR_INTERNAL:
               fprintf(stderr, "\t reason: internal error. Recompile libmoard in debug mode for more info \n");
               break;
           default:
               fprintf(stderr, "\t MB_Clear returned error code: %d (see libmboard docs for details)\n", rc);
               break;

       }

       
       exit(rc);
    }
    #endif

if(FLAME_gov_to_central_bank_account_update_message_board_read == 0)
{
	/*printf("%d> gov_to_central_bank_account_update message board sync complete late as no agents reading any messages of this type\n", node_number);*/
	
	if(FLAME_TEST_PRINT_START_AND_END_OF_LIBMBOARD_CALLS) printf("start MB_SyncComplete(b_gov_to_central_bank_account_update)\n");
	rc = MB_SyncComplete(b_gov_to_central_bank_account_update);
	if(FLAME_TEST_PRINT_START_AND_END_OF_LIBMBOARD_CALLS) printf("finsh MB_SyncComplete(b_gov_to_central_bank_account_update)\n");
	#ifdef ERRCHECK
	if (rc != MB_SUCCESS)
	{
	   fprintf(stderr, "ERROR: Could not complete sync of 'gov_to_central_bank_account_update' board\n");
	   switch(rc) {
			case MB_ERR_INVALID:
			   fprintf(stderr, "\t reason: 'gov_to_central_bank_account_update' board is invalid\n");
			   break;
		   case MB_ERR_MEMALLOC:
			   fprintf(stderr, "\t reason: out of memory\n");
			   break;
		   case MB_ERR_INTERNAL:
			   fprintf(stderr, "\t reason: internal error. Recompile libmoard in debug mode for more info \n");
			   break;
		   default:
			   fprintf(stderr, "\t MB_SyncComplete returned error code: %d (see libmboard docs for details)\n", rc);
			   break;
	   }

	   
	   exit(rc);
	}
	#endif
}

    rc = MB_Clear(b_gov_to_central_bank_account_update);
    #ifdef ERRCHECK
    if (rc != MB_SUCCESS)
    {
       fprintf(stderr, "ERROR: Could not clear 'gov_to_central_bank_account_update' board\n");
       switch(rc) {
           case MB_ERR_INVALID:
               fprintf(stderr, "\t reason: 'gov_to_central_bank_account_update' board is invalid\n");
               break;
           case MB_ERR_LOCKED:
               fprintf(stderr, "\t reason: 'gov_to_central_bank_account_update' board is locked\n");
               break;
           case MB_ERR_INTERNAL:
               fprintf(stderr, "\t reason: internal error. Recompile libmoard in debug mode for more info \n");
               break;
           default:
               fprintf(stderr, "\t MB_Clear returned error code: %d (see libmboard docs for details)\n", rc);
               break;

       }

       
       exit(rc);
    }
    #endif

if(FLAME_bank_interest_payment_message_board_read == 0)
{
	/*printf("%d> bank_interest_payment message board sync complete late as no agents reading any messages of this type\n", node_number);*/
	
	if(FLAME_TEST_PRINT_START_AND_END_OF_LIBMBOARD_CALLS) printf("start MB_SyncComplete(b_bank_interest_payment)\n");
	rc = MB_SyncComplete(b_bank_interest_payment);
	if(FLAME_TEST_PRINT_START_AND_END_OF_LIBMBOARD_CALLS) printf("finsh MB_SyncComplete(b_bank_interest_payment)\n");
	#ifdef ERRCHECK
	if (rc != MB_SUCCESS)
	{
	   fprintf(stderr, "ERROR: Could not complete sync of 'bank_interest_payment' board\n");
	   switch(rc) {
			case MB_ERR_INVALID:
			   fprintf(stderr, "\t reason: 'bank_interest_payment' board is invalid\n");
			   break;
		   case MB_ERR_MEMALLOC:
			   fprintf(stderr, "\t reason: out of memory\n");
			   break;
		   case MB_ERR_INTERNAL:
			   fprintf(stderr, "\t reason: internal error. Recompile libmoard in debug mode for more info \n");
			   break;
		   default:
			   fprintf(stderr, "\t MB_SyncComplete returned error code: %d (see libmboard docs for details)\n", rc);
			   break;
	   }

	   
	   exit(rc);
	}
	#endif
}

    rc = MB_Clear(b_bank_interest_payment);
    #ifdef ERRCHECK
    if (rc != MB_SUCCESS)
    {
       fprintf(stderr, "ERROR: Could not clear 'bank_interest_payment' board\n");
       switch(rc) {
           case MB_ERR_INVALID:
               fprintf(stderr, "\t reason: 'bank_interest_payment' board is invalid\n");
               break;
           case MB_ERR_LOCKED:
               fprintf(stderr, "\t reason: 'bank_interest_payment' board is locked\n");
               break;
           case MB_ERR_INTERNAL:
               fprintf(stderr, "\t reason: internal error. Recompile libmoard in debug mode for more info \n");
               break;
           default:
               fprintf(stderr, "\t MB_Clear returned error code: %d (see libmboard docs for details)\n", rc);
               break;

       }

       
       exit(rc);
    }
    #endif


	/* If mb is not read then leave sync complete until last possible moment */
	if(FLAME_ecb_dividend_message_board_read == 1)
	{
		if(FLAME_TEST_PRINT_START_AND_END_OF_LIBMBOARD_CALLS) printf("start MB_SyncComplete(b_ecb_dividend)\n");
		rc = MB_SyncComplete(b_ecb_dividend);
		if(FLAME_TEST_PRINT_START_AND_END_OF_LIBMBOARD_CALLS) printf("finsh MB_SyncComplete(b_ecb_dividend)\n");
		#ifdef ERRCHECK
		if (rc != MB_SUCCESS)
		{
		   fprintf(stderr, "ERROR: Could not complete sync of 'ecb_dividend' board\n");
		   switch(rc) {
				case MB_ERR_INVALID:
				   fprintf(stderr, "\t reason: 'ecb_dividend' board is invalid\n");
				   break;
			   case MB_ERR_MEMALLOC:
				   fprintf(stderr, "\t reason: out of memory\n");
				   break;
			   case MB_ERR_INTERNAL:
				   fprintf(stderr, "\t reason: internal error. Recompile libmoard in debug mode for more info \n");
				   break;
			   default:
				   fprintf(stderr, "\t MB_SyncComplete returned error code: %d (see libmboard docs for details)\n", rc);
				   break;
		   }
	
		   
		   exit(rc);
		}
		#endif
    
	}
	
	if(FLAME_TEST_PRINT_START_AND_END_OF_MODEL_FUNCTIONS) printf("start Government_compute_balance_sheet\n");
	current_xmachine_Government_holder = Government_07_state->agents;
	while(current_xmachine_Government_holder)
	{
		temp_xmachine_Government_holder = current_xmachine_Government_holder->next;
		current_xmachine_Government = current_xmachine_Government_holder->agent;
		current_xmachine_Government_next_state = Government_08_state;
		/* For backwards compatibility set current_xmachine */
		current_xmachine->xmachine_Firm = NULL;
		current_xmachine->xmachine_Household = NULL;
		current_xmachine->xmachine_Mall = NULL;
		current_xmachine->xmachine_IGFirm = NULL;
		current_xmachine->xmachine_Eurostat = NULL;
		current_xmachine->xmachine_Bank = NULL;
		current_xmachine->xmachine_Government = NULL;
		current_xmachine->xmachine_CentralBank = NULL;
		current_xmachine->xmachine_ClearingHouse = NULL;
		current_xmachine->xmachine_Government = current_xmachine_Government;

		

		
		rc = MB_Iterator_CreateFiltered(b_ecb_dividend, &i_ecb_dividend, &FLAME_filter_Government_Government_compute_balance_sheet_07_08_ecb_dividend, current_xmachine_Government);
		
		#ifdef ERRCHECK
		if (rc != MB_SUCCESS)
		{
		   fprintf(stderr, "ERROR: Could not create Iterator for 'ecb_dividend'\n");
		   switch(rc) {
		       case MB_ERR_INVALID:
		           fprintf(stderr, "\t reason: 'ecb_dividend' board is invalid\n");
		           break;
		       case MB_ERR_LOCKED:
	               fprintf(stderr, "\t reason: 'ecb_dividend' board is locked\n");
	               break;
	           case MB_ERR_MEMALLOC:
	               fprintf(stderr, "\t reason: out of memory\n");
	               break;
	           case MB_ERR_INTERNAL:
	               fprintf(stderr, "\t reason: internal error. Recompile libmoard in debug mode for more info \n");
	               break;
	           default:
	           
                   fprintf(stderr, "\t MB_Iterator_CreateFiltered returned error code: %d (see libmboard docs for details)\n", rc);
               
               
                   break;
		   }

		   
           exit(rc);
		}
		#endif
		
		

			i = Government_compute_balance_sheet();

		
		    rc = MB_Iterator_Delete(&i_ecb_dividend);
		    #ifdef ERRCHECK
		    if (rc != MB_SUCCESS)
		    {
		       fprintf(stderr, "ERROR: Could not delete 'ecb_dividend' iterator\n");
		       switch(rc) {
		           case MB_ERR_INVALID:
		               fprintf(stderr, "\t reason: 'ecb_dividend' iterator is invalid\n");
		               break;
		           case MB_ERR_INTERNAL:
		               fprintf(stderr, "\t reason: internal error. Recompile libmoard in debug mode for more info \n");
		               break;
		           default:
                       fprintf(stderr, "\t MB_Iterator_Delete returned error code: %d (see libmboard docs for details)\n", rc);
                       break;
		       }

		       
               exit(rc);
		    }
		    #endif
		

			if(i == 1)
			{
				free_Government_agent(current_xmachine_Government_holder, Government_07_state);
			}
			else
			{
				transition_Government_agent(current_xmachine_Government_holder, Government_07_state, Government_08_state);
			}
		

		current_xmachine_Government = NULL;

		current_xmachine_Government_holder = temp_xmachine_Government_holder;
	}
	if(FLAME_TEST_PRINT_START_AND_END_OF_MODEL_FUNCTIONS) printf("finish Government_compute_balance_sheet\n");


/* End of layer number 105 */

/* Clear message boards that have finished being used
 * and sync complete if doing late sync complete */

if(FLAME_ecb_dividend_message_board_read == 0)
{
	/*printf("%d> ecb_dividend message board sync complete late as no agents reading any messages of this type\n", node_number);*/
	
	if(FLAME_TEST_PRINT_START_AND_END_OF_LIBMBOARD_CALLS) printf("start MB_SyncComplete(b_ecb_dividend)\n");
	rc = MB_SyncComplete(b_ecb_dividend);
	if(FLAME_TEST_PRINT_START_AND_END_OF_LIBMBOARD_CALLS) printf("finsh MB_SyncComplete(b_ecb_dividend)\n");
	#ifdef ERRCHECK
	if (rc != MB_SUCCESS)
	{
	   fprintf(stderr, "ERROR: Could not complete sync of 'ecb_dividend' board\n");
	   switch(rc) {
			case MB_ERR_INVALID:
			   fprintf(stderr, "\t reason: 'ecb_dividend' board is invalid\n");
			   break;
		   case MB_ERR_MEMALLOC:
			   fprintf(stderr, "\t reason: out of memory\n");
			   break;
		   case MB_ERR_INTERNAL:
			   fprintf(stderr, "\t reason: internal error. Recompile libmoard in debug mode for more info \n");
			   break;
		   default:
			   fprintf(stderr, "\t MB_SyncComplete returned error code: %d (see libmboard docs for details)\n", rc);
			   break;
	   }

	   
	   exit(rc);
	}
	#endif
}

    rc = MB_Clear(b_ecb_dividend);
    #ifdef ERRCHECK
    if (rc != MB_SUCCESS)
    {
       fprintf(stderr, "ERROR: Could not clear 'ecb_dividend' board\n");
       switch(rc) {
           case MB_ERR_INVALID:
               fprintf(stderr, "\t reason: 'ecb_dividend' board is invalid\n");
               break;
           case MB_ERR_LOCKED:
               fprintf(stderr, "\t reason: 'ecb_dividend' board is locked\n");
               break;
           case MB_ERR_INTERNAL:
               fprintf(stderr, "\t reason: internal error. Recompile libmoard in debug mode for more info \n");
               break;
           default:
               fprintf(stderr, "\t MB_Clear returned error code: %d (see libmboard docs for details)\n", rc);
               break;

       }

       
       exit(rc);
    }
    #endif


	if(FLAME_TEST_PRINT_START_AND_END_OF_MODEL_FUNCTIONS) printf("start Government_send_data_to_Eurostat\n");
	current_xmachine_Government_holder = Government_08_state->agents;
	while(current_xmachine_Government_holder)
	{
		temp_xmachine_Government_holder = current_xmachine_Government_holder->next;
		current_xmachine_Government = current_xmachine_Government_holder->agent;
		current_xmachine_Government_next_state = Government_Gov_Start_Yearly_Loop_state;
		/* For backwards compatibility set current_xmachine */
		current_xmachine->xmachine_Firm = NULL;
		current_xmachine->xmachine_Household = NULL;
		current_xmachine->xmachine_Mall = NULL;
		current_xmachine->xmachine_IGFirm = NULL;
		current_xmachine->xmachine_Eurostat = NULL;
		current_xmachine->xmachine_Bank = NULL;
		current_xmachine->xmachine_Government = NULL;
		current_xmachine->xmachine_CentralBank = NULL;
		current_xmachine->xmachine_ClearingHouse = NULL;
		current_xmachine->xmachine_Government = current_xmachine_Government;

		if(FLAME_condition_Government_Government_send_data_to_Eurostat_08_Gov_Start_Yearly_Loop(current_xmachine_Government)==1)
		{

		

			i = Government_send_data_to_Eurostat();

		

			if(i == 1)
			{
				free_Government_agent(current_xmachine_Government_holder, Government_08_state);
			}
			else
			{
				transition_Government_agent(current_xmachine_Government_holder, Government_08_state, Government_Gov_Start_Yearly_Loop_state);
			}
		}

		current_xmachine_Government = NULL;

		current_xmachine_Government_holder = temp_xmachine_Government_holder;
	}
	if(FLAME_TEST_PRINT_START_AND_END_OF_MODEL_FUNCTIONS) printf("finish Government_send_data_to_Eurostat\n");

	if(FLAME_government_send_data_message_board_write == 1)
	{

		if(FLAME_TEST_PRINT_START_AND_END_OF_LIBMBOARD_CALLS) printf("start MB_SyncStart(b_government_send_data)\n");
		rc = MB_SyncStart(b_government_send_data);
		if(FLAME_TEST_PRINT_START_AND_END_OF_LIBMBOARD_CALLS) printf("finish MB_SyncStart(b_government_send_data)\n");
		#ifdef ERRCHECK
		if (rc != MB_SUCCESS)
		{
		   fprintf(stderr, "ERROR: Could not start sync of 'government_send_data' board\n");
		   switch(rc) {
			   case MB_ERR_INVALID:
				   fprintf(stderr, "\t reason: 'government_send_data' board is invalid\n");
				   break;
			   case MB_ERR_LOCKED:
				   fprintf(stderr, "\t reason: 'government_send_data' board is locked\n");
				   break;
			   case MB_ERR_MEMALLOC:
				   fprintf(stderr, "\t reason: out of memory\n");
				   break;
			   case MB_ERR_INTERNAL:
				   fprintf(stderr, "\t reason: internal error. Recompile libmoard in debug mode for more info \n");
				   break;
			   default:
				   fprintf(stderr, "\t MB_SyncStart returned error code: %d (see libmboard docs for details)\n", rc);
				   break;
		   }

			
			exit(rc);
		}
		#endif
    }
    


	if(FLAME_TEST_PRINT_START_AND_END_OF_MODEL_FUNCTIONS) printf("start idle\n");
	current_xmachine_Government_holder = Government_08_state->agents;
	while(current_xmachine_Government_holder)
	{
		temp_xmachine_Government_holder = current_xmachine_Government_holder->next;
		current_xmachine_Government = current_xmachine_Government_holder->agent;
		current_xmachine_Government_next_state = Government_Gov_Start_Yearly_Loop_state;
		/* For backwards compatibility set current_xmachine */
		current_xmachine->xmachine_Firm = NULL;
		current_xmachine->xmachine_Household = NULL;
		current_xmachine->xmachine_Mall = NULL;
		current_xmachine->xmachine_IGFirm = NULL;
		current_xmachine->xmachine_Eurostat = NULL;
		current_xmachine->xmachine_Bank = NULL;
		current_xmachine->xmachine_Government = NULL;
		current_xmachine->xmachine_CentralBank = NULL;
		current_xmachine->xmachine_ClearingHouse = NULL;
		current_xmachine->xmachine_Government = current_xmachine_Government;

		if(FLAME_condition_Government_idle_08_Gov_Start_Yearly_Loop(current_xmachine_Government)==1)
		{

		

			i = idle();

		

			if(i == 1)
			{
				free_Government_agent(current_xmachine_Government_holder, Government_08_state);
			}
			else
			{
				transition_Government_agent(current_xmachine_Government_holder, Government_08_state, Government_Gov_Start_Yearly_Loop_state);
			}
		}

		current_xmachine_Government = NULL;

		current_xmachine_Government_holder = temp_xmachine_Government_holder;
	}
	if(FLAME_TEST_PRINT_START_AND_END_OF_MODEL_FUNCTIONS) printf("finish idle\n");


/* End of layer number 106 */

/* Clear message boards that have finished being used
 * and sync complete if doing late sync complete */


	if(FLAME_TEST_PRINT_START_AND_END_OF_MODEL_FUNCTIONS) printf("start Government_yearly_budget_accounting\n");
	current_xmachine_Government_holder = Government_Gov_Start_Yearly_Loop_state->agents;
	while(current_xmachine_Government_holder)
	{
		temp_xmachine_Government_holder = current_xmachine_Government_holder->next;
		current_xmachine_Government = current_xmachine_Government_holder->agent;
		current_xmachine_Government_next_state = Government_end_Government_state;
		/* For backwards compatibility set current_xmachine */
		current_xmachine->xmachine_Firm = NULL;
		current_xmachine->xmachine_Household = NULL;
		current_xmachine->xmachine_Mall = NULL;
		current_xmachine->xmachine_IGFirm = NULL;
		current_xmachine->xmachine_Eurostat = NULL;
		current_xmachine->xmachine_Bank = NULL;
		current_xmachine->xmachine_Government = NULL;
		current_xmachine->xmachine_CentralBank = NULL;
		current_xmachine->xmachine_ClearingHouse = NULL;
		current_xmachine->xmachine_Government = current_xmachine_Government;

		if(FLAME_condition_Government_Government_yearly_budget_accounting_Gov_Start_Yearly_Loop_end_Government(current_xmachine_Government)==1)
		{

		

			i = Government_yearly_budget_accounting();

		

			if(i == 1)
			{
				free_Government_agent(current_xmachine_Government_holder, Government_Gov_Start_Yearly_Loop_state);
			}
			else
			{
				transition_Government_agent(current_xmachine_Government_holder, Government_Gov_Start_Yearly_Loop_state, Government_end_Government_state);
			}
		}

		current_xmachine_Government = NULL;

		current_xmachine_Government_holder = temp_xmachine_Government_holder;
	}
	if(FLAME_TEST_PRINT_START_AND_END_OF_MODEL_FUNCTIONS) printf("finish Government_yearly_budget_accounting\n");


	if(FLAME_TEST_PRINT_START_AND_END_OF_MODEL_FUNCTIONS) printf("start idle\n");
	current_xmachine_Government_holder = Government_Gov_Start_Yearly_Loop_state->agents;
	while(current_xmachine_Government_holder)
	{
		temp_xmachine_Government_holder = current_xmachine_Government_holder->next;
		current_xmachine_Government = current_xmachine_Government_holder->agent;
		current_xmachine_Government_next_state = Government_end_Government_state;
		/* For backwards compatibility set current_xmachine */
		current_xmachine->xmachine_Firm = NULL;
		current_xmachine->xmachine_Household = NULL;
		current_xmachine->xmachine_Mall = NULL;
		current_xmachine->xmachine_IGFirm = NULL;
		current_xmachine->xmachine_Eurostat = NULL;
		current_xmachine->xmachine_Bank = NULL;
		current_xmachine->xmachine_Government = NULL;
		current_xmachine->xmachine_CentralBank = NULL;
		current_xmachine->xmachine_ClearingHouse = NULL;
		current_xmachine->xmachine_Government = current_xmachine_Government;

		if(FLAME_condition_Government_idle_Gov_Start_Yearly_Loop_end_Government(current_xmachine_Government)==1)
		{

		

			i = idle();

		

			if(i == 1)
			{
				free_Government_agent(current_xmachine_Government_holder, Government_Gov_Start_Yearly_Loop_state);
			}
			else
			{
				transition_Government_agent(current_xmachine_Government_holder, Government_Gov_Start_Yearly_Loop_state, Government_end_Government_state);
			}
		}

		current_xmachine_Government = NULL;

		current_xmachine_Government_holder = temp_xmachine_Government_holder;
	}
	if(FLAME_TEST_PRINT_START_AND_END_OF_MODEL_FUNCTIONS) printf("finish idle\n");


	/* If mb is not read then leave sync complete until last possible moment */
	if(FLAME_total_subsidies_message_board_read == 1)
	{
		if(FLAME_TEST_PRINT_START_AND_END_OF_LIBMBOARD_CALLS) printf("start MB_SyncComplete(b_total_subsidies)\n");
		rc = MB_SyncComplete(b_total_subsidies);
		if(FLAME_TEST_PRINT_START_AND_END_OF_LIBMBOARD_CALLS) printf("finsh MB_SyncComplete(b_total_subsidies)\n");
		#ifdef ERRCHECK
		if (rc != MB_SUCCESS)
		{
		   fprintf(stderr, "ERROR: Could not complete sync of 'total_subsidies' board\n");
		   switch(rc) {
				case MB_ERR_INVALID:
				   fprintf(stderr, "\t reason: 'total_subsidies' board is invalid\n");
				   break;
			   case MB_ERR_MEMALLOC:
				   fprintf(stderr, "\t reason: out of memory\n");
				   break;
			   case MB_ERR_INTERNAL:
				   fprintf(stderr, "\t reason: internal error. Recompile libmoard in debug mode for more info \n");
				   break;
			   default:
				   fprintf(stderr, "\t MB_SyncComplete returned error code: %d (see libmboard docs for details)\n", rc);
				   break;
		   }
	
		   
		   exit(rc);
		}
		#endif
    
	}
	
	/* If mb is not read then leave sync complete until last possible moment */
	if(FLAME_mall_data_message_board_read == 1)
	{
		if(FLAME_TEST_PRINT_START_AND_END_OF_LIBMBOARD_CALLS) printf("start MB_SyncComplete(b_mall_data)\n");
		rc = MB_SyncComplete(b_mall_data);
		if(FLAME_TEST_PRINT_START_AND_END_OF_LIBMBOARD_CALLS) printf("finsh MB_SyncComplete(b_mall_data)\n");
		#ifdef ERRCHECK
		if (rc != MB_SUCCESS)
		{
		   fprintf(stderr, "ERROR: Could not complete sync of 'mall_data' board\n");
		   switch(rc) {
				case MB_ERR_INVALID:
				   fprintf(stderr, "\t reason: 'mall_data' board is invalid\n");
				   break;
			   case MB_ERR_MEMALLOC:
				   fprintf(stderr, "\t reason: out of memory\n");
				   break;
			   case MB_ERR_INTERNAL:
				   fprintf(stderr, "\t reason: internal error. Recompile libmoard in debug mode for more info \n");
				   break;
			   default:
				   fprintf(stderr, "\t MB_SyncComplete returned error code: %d (see libmboard docs for details)\n", rc);
				   break;
		   }
	
		   
		   exit(rc);
		}
		#endif
    
	}
	
	/* If mb is not read then leave sync complete until last possible moment */
	if(FLAME_household_send_data_message_board_read == 1)
	{
		if(FLAME_TEST_PRINT_START_AND_END_OF_LIBMBOARD_CALLS) printf("start MB_SyncComplete(b_household_send_data)\n");
		rc = MB_SyncComplete(b_household_send_data);
		if(FLAME_TEST_PRINT_START_AND_END_OF_LIBMBOARD_CALLS) printf("finsh MB_SyncComplete(b_household_send_data)\n");
		#ifdef ERRCHECK
		if (rc != MB_SUCCESS)
		{
		   fprintf(stderr, "ERROR: Could not complete sync of 'household_send_data' board\n");
		   switch(rc) {
				case MB_ERR_INVALID:
				   fprintf(stderr, "\t reason: 'household_send_data' board is invalid\n");
				   break;
			   case MB_ERR_MEMALLOC:
				   fprintf(stderr, "\t reason: out of memory\n");
				   break;
			   case MB_ERR_INTERNAL:
				   fprintf(stderr, "\t reason: internal error. Recompile libmoard in debug mode for more info \n");
				   break;
			   default:
				   fprintf(stderr, "\t MB_SyncComplete returned error code: %d (see libmboard docs for details)\n", rc);
				   break;
		   }
	
		   
		   exit(rc);
		}
		#endif
    
	}
	
	/* If mb is not read then leave sync complete until last possible moment */
	if(FLAME_government_send_data_message_board_read == 1)
	{
		if(FLAME_TEST_PRINT_START_AND_END_OF_LIBMBOARD_CALLS) printf("start MB_SyncComplete(b_government_send_data)\n");
		rc = MB_SyncComplete(b_government_send_data);
		if(FLAME_TEST_PRINT_START_AND_END_OF_LIBMBOARD_CALLS) printf("finsh MB_SyncComplete(b_government_send_data)\n");
		#ifdef ERRCHECK
		if (rc != MB_SUCCESS)
		{
		   fprintf(stderr, "ERROR: Could not complete sync of 'government_send_data' board\n");
		   switch(rc) {
				case MB_ERR_INVALID:
				   fprintf(stderr, "\t reason: 'government_send_data' board is invalid\n");
				   break;
			   case MB_ERR_MEMALLOC:
				   fprintf(stderr, "\t reason: out of memory\n");
				   break;
			   case MB_ERR_INTERNAL:
				   fprintf(stderr, "\t reason: internal error. Recompile libmoard in debug mode for more info \n");
				   break;
			   default:
				   fprintf(stderr, "\t MB_SyncComplete returned error code: %d (see libmboard docs for details)\n", rc);
				   break;
		   }
	
		   
		   exit(rc);
		}
		#endif
    
	}
	
	/* If mb is not read then leave sync complete until last possible moment */
	if(FLAME_firm_send_data_message_board_read == 1)
	{
		if(FLAME_TEST_PRINT_START_AND_END_OF_LIBMBOARD_CALLS) printf("start MB_SyncComplete(b_firm_send_data)\n");
		rc = MB_SyncComplete(b_firm_send_data);
		if(FLAME_TEST_PRINT_START_AND_END_OF_LIBMBOARD_CALLS) printf("finsh MB_SyncComplete(b_firm_send_data)\n");
		#ifdef ERRCHECK
		if (rc != MB_SUCCESS)
		{
		   fprintf(stderr, "ERROR: Could not complete sync of 'firm_send_data' board\n");
		   switch(rc) {
				case MB_ERR_INVALID:
				   fprintf(stderr, "\t reason: 'firm_send_data' board is invalid\n");
				   break;
			   case MB_ERR_MEMALLOC:
				   fprintf(stderr, "\t reason: out of memory\n");
				   break;
			   case MB_ERR_INTERNAL:
				   fprintf(stderr, "\t reason: internal error. Recompile libmoard in debug mode for more info \n");
				   break;
			   default:
				   fprintf(stderr, "\t MB_SyncComplete returned error code: %d (see libmboard docs for details)\n", rc);
				   break;
		   }
	
		   
		   exit(rc);
		}
		#endif
    
	}
	
	if(FLAME_TEST_PRINT_START_AND_END_OF_MODEL_FUNCTIONS) printf("start Eurostat_calculate_data\n");
	current_xmachine_Eurostat_holder = Eurostat_01_state->agents;
	while(current_xmachine_Eurostat_holder)
	{
		temp_xmachine_Eurostat_holder = current_xmachine_Eurostat_holder->next;
		current_xmachine_Eurostat = current_xmachine_Eurostat_holder->agent;
		current_xmachine_Eurostat_next_state = Eurostat_Eurostat_Start_Monthly_Loop_state;
		/* For backwards compatibility set current_xmachine */
		current_xmachine->xmachine_Firm = NULL;
		current_xmachine->xmachine_Household = NULL;
		current_xmachine->xmachine_Mall = NULL;
		current_xmachine->xmachine_IGFirm = NULL;
		current_xmachine->xmachine_Eurostat = NULL;
		current_xmachine->xmachine_Bank = NULL;
		current_xmachine->xmachine_Government = NULL;
		current_xmachine->xmachine_CentralBank = NULL;
		current_xmachine->xmachine_ClearingHouse = NULL;
		current_xmachine->xmachine_Eurostat = current_xmachine_Eurostat;

		if(FLAME_condition_Eurostat_Eurostat_calculate_data_01_Eurostat_Start_Monthly_Loop(current_xmachine_Eurostat)==1)
		{

		
		
		rc = MB_Iterator_Create(b_bankruptcy_illiquidity, &i_bankruptcy_illiquidity);
		#ifdef ERRCHECK
		if (rc != MB_SUCCESS)
		{
		   fprintf(stderr, "ERROR: Could not create Iterator for 'bankruptcy_illiquidity'\n");
		   switch(rc) {
		       case MB_ERR_INVALID:
		           fprintf(stderr, "\t reason: 'bankruptcy_illiquidity' board is invalid\n");
		           break;
		       case MB_ERR_LOCKED:
	               fprintf(stderr, "\t reason: 'bankruptcy_illiquidity' board is locked\n");
	               break;
	           case MB_ERR_MEMALLOC:
	               fprintf(stderr, "\t reason: out of memory\n");
	               break;
	           case MB_ERR_INTERNAL:
	               fprintf(stderr, "\t reason: internal error. Recompile libmoard in debug mode for more info \n");
	               break;
	           default:
	           
               
                   fprintf(stderr, "\t MB_Iterator_Create returned error code: %d (see libmboard docs for details)\n", rc);
               
                   break;
		   }

		   
           exit(rc);
		}
		#endif
		
		
		
		rc = MB_Iterator_Create(b_bankruptcy_insolvency, &i_bankruptcy_insolvency);
		#ifdef ERRCHECK
		if (rc != MB_SUCCESS)
		{
		   fprintf(stderr, "ERROR: Could not create Iterator for 'bankruptcy_insolvency'\n");
		   switch(rc) {
		       case MB_ERR_INVALID:
		           fprintf(stderr, "\t reason: 'bankruptcy_insolvency' board is invalid\n");
		           break;
		       case MB_ERR_LOCKED:
	               fprintf(stderr, "\t reason: 'bankruptcy_insolvency' board is locked\n");
	               break;
	           case MB_ERR_MEMALLOC:
	               fprintf(stderr, "\t reason: out of memory\n");
	               break;
	           case MB_ERR_INTERNAL:
	               fprintf(stderr, "\t reason: internal error. Recompile libmoard in debug mode for more info \n");
	               break;
	           default:
	           
               
                   fprintf(stderr, "\t MB_Iterator_Create returned error code: %d (see libmboard docs for details)\n", rc);
               
                   break;
		   }

		   
           exit(rc);
		}
		#endif
		
		
		
		rc = MB_Iterator_Create(b_firm_send_data, &i_firm_send_data);
		#ifdef ERRCHECK
		if (rc != MB_SUCCESS)
		{
		   fprintf(stderr, "ERROR: Could not create Iterator for 'firm_send_data'\n");
		   switch(rc) {
		       case MB_ERR_INVALID:
		           fprintf(stderr, "\t reason: 'firm_send_data' board is invalid\n");
		           break;
		       case MB_ERR_LOCKED:
	               fprintf(stderr, "\t reason: 'firm_send_data' board is locked\n");
	               break;
	           case MB_ERR_MEMALLOC:
	               fprintf(stderr, "\t reason: out of memory\n");
	               break;
	           case MB_ERR_INTERNAL:
	               fprintf(stderr, "\t reason: internal error. Recompile libmoard in debug mode for more info \n");
	               break;
	           default:
	           
               
                   fprintf(stderr, "\t MB_Iterator_Create returned error code: %d (see libmboard docs for details)\n", rc);
               
                   break;
		   }

		   
           exit(rc);
		}
		#endif
		
		
		
		rc = MB_Iterator_Create(b_household_send_data, &i_household_send_data);
		#ifdef ERRCHECK
		if (rc != MB_SUCCESS)
		{
		   fprintf(stderr, "ERROR: Could not create Iterator for 'household_send_data'\n");
		   switch(rc) {
		       case MB_ERR_INVALID:
		           fprintf(stderr, "\t reason: 'household_send_data' board is invalid\n");
		           break;
		       case MB_ERR_LOCKED:
	               fprintf(stderr, "\t reason: 'household_send_data' board is locked\n");
	               break;
	           case MB_ERR_MEMALLOC:
	               fprintf(stderr, "\t reason: out of memory\n");
	               break;
	           case MB_ERR_INTERNAL:
	               fprintf(stderr, "\t reason: internal error. Recompile libmoard in debug mode for more info \n");
	               break;
	           default:
	           
               
                   fprintf(stderr, "\t MB_Iterator_Create returned error code: %d (see libmboard docs for details)\n", rc);
               
                   break;
		   }

		   
           exit(rc);
		}
		#endif
		
		
		
		rc = MB_Iterator_Create(b_mall_data, &i_mall_data);
		#ifdef ERRCHECK
		if (rc != MB_SUCCESS)
		{
		   fprintf(stderr, "ERROR: Could not create Iterator for 'mall_data'\n");
		   switch(rc) {
		       case MB_ERR_INVALID:
		           fprintf(stderr, "\t reason: 'mall_data' board is invalid\n");
		           break;
		       case MB_ERR_LOCKED:
	               fprintf(stderr, "\t reason: 'mall_data' board is locked\n");
	               break;
	           case MB_ERR_MEMALLOC:
	               fprintf(stderr, "\t reason: out of memory\n");
	               break;
	           case MB_ERR_INTERNAL:
	               fprintf(stderr, "\t reason: internal error. Recompile libmoard in debug mode for more info \n");
	               break;
	           default:
	           
               
                   fprintf(stderr, "\t MB_Iterator_Create returned error code: %d (see libmboard docs for details)\n", rc);
               
                   break;
		   }

		   
           exit(rc);
		}
		#endif
		
		
		
		rc = MB_Iterator_Create(b_total_subsidies, &i_total_subsidies);
		#ifdef ERRCHECK
		if (rc != MB_SUCCESS)
		{
		   fprintf(stderr, "ERROR: Could not create Iterator for 'total_subsidies'\n");
		   switch(rc) {
		       case MB_ERR_INVALID:
		           fprintf(stderr, "\t reason: 'total_subsidies' board is invalid\n");
		           break;
		       case MB_ERR_LOCKED:
	               fprintf(stderr, "\t reason: 'total_subsidies' board is locked\n");
	               break;
	           case MB_ERR_MEMALLOC:
	               fprintf(stderr, "\t reason: out of memory\n");
	               break;
	           case MB_ERR_INTERNAL:
	               fprintf(stderr, "\t reason: internal error. Recompile libmoard in debug mode for more info \n");
	               break;
	           default:
	           
               
                   fprintf(stderr, "\t MB_Iterator_Create returned error code: %d (see libmboard docs for details)\n", rc);
               
                   break;
		   }

		   
           exit(rc);
		}
		#endif
		
		
		
		rc = MB_Iterator_Create(b_government_send_data, &i_government_send_data);
		#ifdef ERRCHECK
		if (rc != MB_SUCCESS)
		{
		   fprintf(stderr, "ERROR: Could not create Iterator for 'government_send_data'\n");
		   switch(rc) {
		       case MB_ERR_INVALID:
		           fprintf(stderr, "\t reason: 'government_send_data' board is invalid\n");
		           break;
		       case MB_ERR_LOCKED:
	               fprintf(stderr, "\t reason: 'government_send_data' board is locked\n");
	               break;
	           case MB_ERR_MEMALLOC:
	               fprintf(stderr, "\t reason: out of memory\n");
	               break;
	           case MB_ERR_INTERNAL:
	               fprintf(stderr, "\t reason: internal error. Recompile libmoard in debug mode for more info \n");
	               break;
	           default:
	           
               
                   fprintf(stderr, "\t MB_Iterator_Create returned error code: %d (see libmboard docs for details)\n", rc);
               
                   break;
		   }

		   
           exit(rc);
		}
		#endif
		
		

			i = Eurostat_calculate_data();

		
		    rc = MB_Iterator_Delete(&i_bankruptcy_illiquidity);
		    #ifdef ERRCHECK
		    if (rc != MB_SUCCESS)
		    {
		       fprintf(stderr, "ERROR: Could not delete 'bankruptcy_illiquidity' iterator\n");
		       switch(rc) {
		           case MB_ERR_INVALID:
		               fprintf(stderr, "\t reason: 'bankruptcy_illiquidity' iterator is invalid\n");
		               break;
		           case MB_ERR_INTERNAL:
		               fprintf(stderr, "\t reason: internal error. Recompile libmoard in debug mode for more info \n");
		               break;
		           default:
                       fprintf(stderr, "\t MB_Iterator_Delete returned error code: %d (see libmboard docs for details)\n", rc);
                       break;
		       }

		       
               exit(rc);
		    }
		    #endif
		
		    rc = MB_Iterator_Delete(&i_bankruptcy_insolvency);
		    #ifdef ERRCHECK
		    if (rc != MB_SUCCESS)
		    {
		       fprintf(stderr, "ERROR: Could not delete 'bankruptcy_insolvency' iterator\n");
		       switch(rc) {
		           case MB_ERR_INVALID:
		               fprintf(stderr, "\t reason: 'bankruptcy_insolvency' iterator is invalid\n");
		               break;
		           case MB_ERR_INTERNAL:
		               fprintf(stderr, "\t reason: internal error. Recompile libmoard in debug mode for more info \n");
		               break;
		           default:
                       fprintf(stderr, "\t MB_Iterator_Delete returned error code: %d (see libmboard docs for details)\n", rc);
                       break;
		       }

		       
               exit(rc);
		    }
		    #endif
		
		    rc = MB_Iterator_Delete(&i_firm_send_data);
		    #ifdef ERRCHECK
		    if (rc != MB_SUCCESS)
		    {
		       fprintf(stderr, "ERROR: Could not delete 'firm_send_data' iterator\n");
		       switch(rc) {
		           case MB_ERR_INVALID:
		               fprintf(stderr, "\t reason: 'firm_send_data' iterator is invalid\n");
		               break;
		           case MB_ERR_INTERNAL:
		               fprintf(stderr, "\t reason: internal error. Recompile libmoard in debug mode for more info \n");
		               break;
		           default:
                       fprintf(stderr, "\t MB_Iterator_Delete returned error code: %d (see libmboard docs for details)\n", rc);
                       break;
		       }

		       
               exit(rc);
		    }
		    #endif
		
		    rc = MB_Iterator_Delete(&i_household_send_data);
		    #ifdef ERRCHECK
		    if (rc != MB_SUCCESS)
		    {
		       fprintf(stderr, "ERROR: Could not delete 'household_send_data' iterator\n");
		       switch(rc) {
		           case MB_ERR_INVALID:
		               fprintf(stderr, "\t reason: 'household_send_data' iterator is invalid\n");
		               break;
		           case MB_ERR_INTERNAL:
		               fprintf(stderr, "\t reason: internal error. Recompile libmoard in debug mode for more info \n");
		               break;
		           default:
                       fprintf(stderr, "\t MB_Iterator_Delete returned error code: %d (see libmboard docs for details)\n", rc);
                       break;
		       }

		       
               exit(rc);
		    }
		    #endif
		
		    rc = MB_Iterator_Delete(&i_mall_data);
		    #ifdef ERRCHECK
		    if (rc != MB_SUCCESS)
		    {
		       fprintf(stderr, "ERROR: Could not delete 'mall_data' iterator\n");
		       switch(rc) {
		           case MB_ERR_INVALID:
		               fprintf(stderr, "\t reason: 'mall_data' iterator is invalid\n");
		               break;
		           case MB_ERR_INTERNAL:
		               fprintf(stderr, "\t reason: internal error. Recompile libmoard in debug mode for more info \n");
		               break;
		           default:
                       fprintf(stderr, "\t MB_Iterator_Delete returned error code: %d (see libmboard docs for details)\n", rc);
                       break;
		       }

		       
               exit(rc);
		    }
		    #endif
		
		    rc = MB_Iterator_Delete(&i_total_subsidies);
		    #ifdef ERRCHECK
		    if (rc != MB_SUCCESS)
		    {
		       fprintf(stderr, "ERROR: Could not delete 'total_subsidies' iterator\n");
		       switch(rc) {
		           case MB_ERR_INVALID:
		               fprintf(stderr, "\t reason: 'total_subsidies' iterator is invalid\n");
		               break;
		           case MB_ERR_INTERNAL:
		               fprintf(stderr, "\t reason: internal error. Recompile libmoard in debug mode for more info \n");
		               break;
		           default:
                       fprintf(stderr, "\t MB_Iterator_Delete returned error code: %d (see libmboard docs for details)\n", rc);
                       break;
		       }

		       
               exit(rc);
		    }
		    #endif
		
		    rc = MB_Iterator_Delete(&i_government_send_data);
		    #ifdef ERRCHECK
		    if (rc != MB_SUCCESS)
		    {
		       fprintf(stderr, "ERROR: Could not delete 'government_send_data' iterator\n");
		       switch(rc) {
		           case MB_ERR_INVALID:
		               fprintf(stderr, "\t reason: 'government_send_data' iterator is invalid\n");
		               break;
		           case MB_ERR_INTERNAL:
		               fprintf(stderr, "\t reason: internal error. Recompile libmoard in debug mode for more info \n");
		               break;
		           default:
                       fprintf(stderr, "\t MB_Iterator_Delete returned error code: %d (see libmboard docs for details)\n", rc);
                       break;
		       }

		       
               exit(rc);
		    }
		    #endif
		

			if(i == 1)
			{
				free_Eurostat_agent(current_xmachine_Eurostat_holder, Eurostat_01_state);
			}
			else
			{
				transition_Eurostat_agent(current_xmachine_Eurostat_holder, Eurostat_01_state, Eurostat_Eurostat_Start_Monthly_Loop_state);
			}
		}

		current_xmachine_Eurostat = NULL;

		current_xmachine_Eurostat_holder = temp_xmachine_Eurostat_holder;
	}
	if(FLAME_TEST_PRINT_START_AND_END_OF_MODEL_FUNCTIONS) printf("finish Eurostat_calculate_data\n");


/* End of layer number 107 */

/* Clear message boards that have finished being used
 * and sync complete if doing late sync complete */

if(FLAME_bankruptcy_illiquidity_message_board_read == 0)
{
	/*printf("%d> bankruptcy_illiquidity message board sync complete late as no agents reading any messages of this type\n", node_number);*/
	
	if(FLAME_TEST_PRINT_START_AND_END_OF_LIBMBOARD_CALLS) printf("start MB_SyncComplete(b_bankruptcy_illiquidity)\n");
	rc = MB_SyncComplete(b_bankruptcy_illiquidity);
	if(FLAME_TEST_PRINT_START_AND_END_OF_LIBMBOARD_CALLS) printf("finsh MB_SyncComplete(b_bankruptcy_illiquidity)\n");
	#ifdef ERRCHECK
	if (rc != MB_SUCCESS)
	{
	   fprintf(stderr, "ERROR: Could not complete sync of 'bankruptcy_illiquidity' board\n");
	   switch(rc) {
			case MB_ERR_INVALID:
			   fprintf(stderr, "\t reason: 'bankruptcy_illiquidity' board is invalid\n");
			   break;
		   case MB_ERR_MEMALLOC:
			   fprintf(stderr, "\t reason: out of memory\n");
			   break;
		   case MB_ERR_INTERNAL:
			   fprintf(stderr, "\t reason: internal error. Recompile libmoard in debug mode for more info \n");
			   break;
		   default:
			   fprintf(stderr, "\t MB_SyncComplete returned error code: %d (see libmboard docs for details)\n", rc);
			   break;
	   }

	   
	   exit(rc);
	}
	#endif
}

    rc = MB_Clear(b_bankruptcy_illiquidity);
    #ifdef ERRCHECK
    if (rc != MB_SUCCESS)
    {
       fprintf(stderr, "ERROR: Could not clear 'bankruptcy_illiquidity' board\n");
       switch(rc) {
           case MB_ERR_INVALID:
               fprintf(stderr, "\t reason: 'bankruptcy_illiquidity' board is invalid\n");
               break;
           case MB_ERR_LOCKED:
               fprintf(stderr, "\t reason: 'bankruptcy_illiquidity' board is locked\n");
               break;
           case MB_ERR_INTERNAL:
               fprintf(stderr, "\t reason: internal error. Recompile libmoard in debug mode for more info \n");
               break;
           default:
               fprintf(stderr, "\t MB_Clear returned error code: %d (see libmboard docs for details)\n", rc);
               break;

       }

       
       exit(rc);
    }
    #endif

if(FLAME_bankruptcy_insolvency_message_board_read == 0)
{
	/*printf("%d> bankruptcy_insolvency message board sync complete late as no agents reading any messages of this type\n", node_number);*/
	
	if(FLAME_TEST_PRINT_START_AND_END_OF_LIBMBOARD_CALLS) printf("start MB_SyncComplete(b_bankruptcy_insolvency)\n");
	rc = MB_SyncComplete(b_bankruptcy_insolvency);
	if(FLAME_TEST_PRINT_START_AND_END_OF_LIBMBOARD_CALLS) printf("finsh MB_SyncComplete(b_bankruptcy_insolvency)\n");
	#ifdef ERRCHECK
	if (rc != MB_SUCCESS)
	{
	   fprintf(stderr, "ERROR: Could not complete sync of 'bankruptcy_insolvency' board\n");
	   switch(rc) {
			case MB_ERR_INVALID:
			   fprintf(stderr, "\t reason: 'bankruptcy_insolvency' board is invalid\n");
			   break;
		   case MB_ERR_MEMALLOC:
			   fprintf(stderr, "\t reason: out of memory\n");
			   break;
		   case MB_ERR_INTERNAL:
			   fprintf(stderr, "\t reason: internal error. Recompile libmoard in debug mode for more info \n");
			   break;
		   default:
			   fprintf(stderr, "\t MB_SyncComplete returned error code: %d (see libmboard docs for details)\n", rc);
			   break;
	   }

	   
	   exit(rc);
	}
	#endif
}

    rc = MB_Clear(b_bankruptcy_insolvency);
    #ifdef ERRCHECK
    if (rc != MB_SUCCESS)
    {
       fprintf(stderr, "ERROR: Could not clear 'bankruptcy_insolvency' board\n");
       switch(rc) {
           case MB_ERR_INVALID:
               fprintf(stderr, "\t reason: 'bankruptcy_insolvency' board is invalid\n");
               break;
           case MB_ERR_LOCKED:
               fprintf(stderr, "\t reason: 'bankruptcy_insolvency' board is locked\n");
               break;
           case MB_ERR_INTERNAL:
               fprintf(stderr, "\t reason: internal error. Recompile libmoard in debug mode for more info \n");
               break;
           default:
               fprintf(stderr, "\t MB_Clear returned error code: %d (see libmboard docs for details)\n", rc);
               break;

       }

       
       exit(rc);
    }
    #endif

if(FLAME_firm_send_data_message_board_read == 0)
{
	/*printf("%d> firm_send_data message board sync complete late as no agents reading any messages of this type\n", node_number);*/
	
	if(FLAME_TEST_PRINT_START_AND_END_OF_LIBMBOARD_CALLS) printf("start MB_SyncComplete(b_firm_send_data)\n");
	rc = MB_SyncComplete(b_firm_send_data);
	if(FLAME_TEST_PRINT_START_AND_END_OF_LIBMBOARD_CALLS) printf("finsh MB_SyncComplete(b_firm_send_data)\n");
	#ifdef ERRCHECK
	if (rc != MB_SUCCESS)
	{
	   fprintf(stderr, "ERROR: Could not complete sync of 'firm_send_data' board\n");
	   switch(rc) {
			case MB_ERR_INVALID:
			   fprintf(stderr, "\t reason: 'firm_send_data' board is invalid\n");
			   break;
		   case MB_ERR_MEMALLOC:
			   fprintf(stderr, "\t reason: out of memory\n");
			   break;
		   case MB_ERR_INTERNAL:
			   fprintf(stderr, "\t reason: internal error. Recompile libmoard in debug mode for more info \n");
			   break;
		   default:
			   fprintf(stderr, "\t MB_SyncComplete returned error code: %d (see libmboard docs for details)\n", rc);
			   break;
	   }

	   
	   exit(rc);
	}
	#endif
}

    rc = MB_Clear(b_firm_send_data);
    #ifdef ERRCHECK
    if (rc != MB_SUCCESS)
    {
       fprintf(stderr, "ERROR: Could not clear 'firm_send_data' board\n");
       switch(rc) {
           case MB_ERR_INVALID:
               fprintf(stderr, "\t reason: 'firm_send_data' board is invalid\n");
               break;
           case MB_ERR_LOCKED:
               fprintf(stderr, "\t reason: 'firm_send_data' board is locked\n");
               break;
           case MB_ERR_INTERNAL:
               fprintf(stderr, "\t reason: internal error. Recompile libmoard in debug mode for more info \n");
               break;
           default:
               fprintf(stderr, "\t MB_Clear returned error code: %d (see libmboard docs for details)\n", rc);
               break;

       }

       
       exit(rc);
    }
    #endif

if(FLAME_government_send_data_message_board_read == 0)
{
	/*printf("%d> government_send_data message board sync complete late as no agents reading any messages of this type\n", node_number);*/
	
	if(FLAME_TEST_PRINT_START_AND_END_OF_LIBMBOARD_CALLS) printf("start MB_SyncComplete(b_government_send_data)\n");
	rc = MB_SyncComplete(b_government_send_data);
	if(FLAME_TEST_PRINT_START_AND_END_OF_LIBMBOARD_CALLS) printf("finsh MB_SyncComplete(b_government_send_data)\n");
	#ifdef ERRCHECK
	if (rc != MB_SUCCESS)
	{
	   fprintf(stderr, "ERROR: Could not complete sync of 'government_send_data' board\n");
	   switch(rc) {
			case MB_ERR_INVALID:
			   fprintf(stderr, "\t reason: 'government_send_data' board is invalid\n");
			   break;
		   case MB_ERR_MEMALLOC:
			   fprintf(stderr, "\t reason: out of memory\n");
			   break;
		   case MB_ERR_INTERNAL:
			   fprintf(stderr, "\t reason: internal error. Recompile libmoard in debug mode for more info \n");
			   break;
		   default:
			   fprintf(stderr, "\t MB_SyncComplete returned error code: %d (see libmboard docs for details)\n", rc);
			   break;
	   }

	   
	   exit(rc);
	}
	#endif
}

    rc = MB_Clear(b_government_send_data);
    #ifdef ERRCHECK
    if (rc != MB_SUCCESS)
    {
       fprintf(stderr, "ERROR: Could not clear 'government_send_data' board\n");
       switch(rc) {
           case MB_ERR_INVALID:
               fprintf(stderr, "\t reason: 'government_send_data' board is invalid\n");
               break;
           case MB_ERR_LOCKED:
               fprintf(stderr, "\t reason: 'government_send_data' board is locked\n");
               break;
           case MB_ERR_INTERNAL:
               fprintf(stderr, "\t reason: internal error. Recompile libmoard in debug mode for more info \n");
               break;
           default:
               fprintf(stderr, "\t MB_Clear returned error code: %d (see libmboard docs for details)\n", rc);
               break;

       }

       
       exit(rc);
    }
    #endif

if(FLAME_household_send_data_message_board_read == 0)
{
	/*printf("%d> household_send_data message board sync complete late as no agents reading any messages of this type\n", node_number);*/
	
	if(FLAME_TEST_PRINT_START_AND_END_OF_LIBMBOARD_CALLS) printf("start MB_SyncComplete(b_household_send_data)\n");
	rc = MB_SyncComplete(b_household_send_data);
	if(FLAME_TEST_PRINT_START_AND_END_OF_LIBMBOARD_CALLS) printf("finsh MB_SyncComplete(b_household_send_data)\n");
	#ifdef ERRCHECK
	if (rc != MB_SUCCESS)
	{
	   fprintf(stderr, "ERROR: Could not complete sync of 'household_send_data' board\n");
	   switch(rc) {
			case MB_ERR_INVALID:
			   fprintf(stderr, "\t reason: 'household_send_data' board is invalid\n");
			   break;
		   case MB_ERR_MEMALLOC:
			   fprintf(stderr, "\t reason: out of memory\n");
			   break;
		   case MB_ERR_INTERNAL:
			   fprintf(stderr, "\t reason: internal error. Recompile libmoard in debug mode for more info \n");
			   break;
		   default:
			   fprintf(stderr, "\t MB_SyncComplete returned error code: %d (see libmboard docs for details)\n", rc);
			   break;
	   }

	   
	   exit(rc);
	}
	#endif
}

    rc = MB_Clear(b_household_send_data);
    #ifdef ERRCHECK
    if (rc != MB_SUCCESS)
    {
       fprintf(stderr, "ERROR: Could not clear 'household_send_data' board\n");
       switch(rc) {
           case MB_ERR_INVALID:
               fprintf(stderr, "\t reason: 'household_send_data' board is invalid\n");
               break;
           case MB_ERR_LOCKED:
               fprintf(stderr, "\t reason: 'household_send_data' board is locked\n");
               break;
           case MB_ERR_INTERNAL:
               fprintf(stderr, "\t reason: internal error. Recompile libmoard in debug mode for more info \n");
               break;
           default:
               fprintf(stderr, "\t MB_Clear returned error code: %d (see libmboard docs for details)\n", rc);
               break;

       }

       
       exit(rc);
    }
    #endif

if(FLAME_mall_data_message_board_read == 0)
{
	/*printf("%d> mall_data message board sync complete late as no agents reading any messages of this type\n", node_number);*/
	
	if(FLAME_TEST_PRINT_START_AND_END_OF_LIBMBOARD_CALLS) printf("start MB_SyncComplete(b_mall_data)\n");
	rc = MB_SyncComplete(b_mall_data);
	if(FLAME_TEST_PRINT_START_AND_END_OF_LIBMBOARD_CALLS) printf("finsh MB_SyncComplete(b_mall_data)\n");
	#ifdef ERRCHECK
	if (rc != MB_SUCCESS)
	{
	   fprintf(stderr, "ERROR: Could not complete sync of 'mall_data' board\n");
	   switch(rc) {
			case MB_ERR_INVALID:
			   fprintf(stderr, "\t reason: 'mall_data' board is invalid\n");
			   break;
		   case MB_ERR_MEMALLOC:
			   fprintf(stderr, "\t reason: out of memory\n");
			   break;
		   case MB_ERR_INTERNAL:
			   fprintf(stderr, "\t reason: internal error. Recompile libmoard in debug mode for more info \n");
			   break;
		   default:
			   fprintf(stderr, "\t MB_SyncComplete returned error code: %d (see libmboard docs for details)\n", rc);
			   break;
	   }

	   
	   exit(rc);
	}
	#endif
}

    rc = MB_Clear(b_mall_data);
    #ifdef ERRCHECK
    if (rc != MB_SUCCESS)
    {
       fprintf(stderr, "ERROR: Could not clear 'mall_data' board\n");
       switch(rc) {
           case MB_ERR_INVALID:
               fprintf(stderr, "\t reason: 'mall_data' board is invalid\n");
               break;
           case MB_ERR_LOCKED:
               fprintf(stderr, "\t reason: 'mall_data' board is locked\n");
               break;
           case MB_ERR_INTERNAL:
               fprintf(stderr, "\t reason: internal error. Recompile libmoard in debug mode for more info \n");
               break;
           default:
               fprintf(stderr, "\t MB_Clear returned error code: %d (see libmboard docs for details)\n", rc);
               break;

       }

       
       exit(rc);
    }
    #endif

if(FLAME_total_subsidies_message_board_read == 0)
{
	/*printf("%d> total_subsidies message board sync complete late as no agents reading any messages of this type\n", node_number);*/
	
	if(FLAME_TEST_PRINT_START_AND_END_OF_LIBMBOARD_CALLS) printf("start MB_SyncComplete(b_total_subsidies)\n");
	rc = MB_SyncComplete(b_total_subsidies);
	if(FLAME_TEST_PRINT_START_AND_END_OF_LIBMBOARD_CALLS) printf("finsh MB_SyncComplete(b_total_subsidies)\n");
	#ifdef ERRCHECK
	if (rc != MB_SUCCESS)
	{
	   fprintf(stderr, "ERROR: Could not complete sync of 'total_subsidies' board\n");
	   switch(rc) {
			case MB_ERR_INVALID:
			   fprintf(stderr, "\t reason: 'total_subsidies' board is invalid\n");
			   break;
		   case MB_ERR_MEMALLOC:
			   fprintf(stderr, "\t reason: out of memory\n");
			   break;
		   case MB_ERR_INTERNAL:
			   fprintf(stderr, "\t reason: internal error. Recompile libmoard in debug mode for more info \n");
			   break;
		   default:
			   fprintf(stderr, "\t MB_SyncComplete returned error code: %d (see libmboard docs for details)\n", rc);
			   break;
	   }

	   
	   exit(rc);
	}
	#endif
}

    rc = MB_Clear(b_total_subsidies);
    #ifdef ERRCHECK
    if (rc != MB_SUCCESS)
    {
       fprintf(stderr, "ERROR: Could not clear 'total_subsidies' board\n");
       switch(rc) {
           case MB_ERR_INVALID:
               fprintf(stderr, "\t reason: 'total_subsidies' board is invalid\n");
               break;
           case MB_ERR_LOCKED:
               fprintf(stderr, "\t reason: 'total_subsidies' board is locked\n");
               break;
           case MB_ERR_INTERNAL:
               fprintf(stderr, "\t reason: internal error. Recompile libmoard in debug mode for more info \n");
               break;
           default:
               fprintf(stderr, "\t MB_Clear returned error code: %d (see libmboard docs for details)\n", rc);
               break;

       }

       
       exit(rc);
    }
    #endif


	if(FLAME_TEST_PRINT_START_AND_END_OF_MODEL_FUNCTIONS) printf("start Eurostat_idle\n");
	current_xmachine_Eurostat_holder = Eurostat_Eurostat_Start_Monthly_Loop_state->agents;
	while(current_xmachine_Eurostat_holder)
	{
		temp_xmachine_Eurostat_holder = current_xmachine_Eurostat_holder->next;
		current_xmachine_Eurostat = current_xmachine_Eurostat_holder->agent;
		current_xmachine_Eurostat_next_state = Eurostat_Eurostat_Start_Quarterly_Loop_state;
		/* For backwards compatibility set current_xmachine */
		current_xmachine->xmachine_Firm = NULL;
		current_xmachine->xmachine_Household = NULL;
		current_xmachine->xmachine_Mall = NULL;
		current_xmachine->xmachine_IGFirm = NULL;
		current_xmachine->xmachine_Eurostat = NULL;
		current_xmachine->xmachine_Bank = NULL;
		current_xmachine->xmachine_Government = NULL;
		current_xmachine->xmachine_CentralBank = NULL;
		current_xmachine->xmachine_ClearingHouse = NULL;
		current_xmachine->xmachine_Eurostat = current_xmachine_Eurostat;

		if(FLAME_condition_Eurostat_Eurostat_idle_Eurostat_Start_Monthly_Loop_Eurostat_Start_Quarterly_Loop(current_xmachine_Eurostat)==1)
		{

		

			i = Eurostat_idle();

		

			if(i == 1)
			{
				free_Eurostat_agent(current_xmachine_Eurostat_holder, Eurostat_Eurostat_Start_Monthly_Loop_state);
			}
			else
			{
				transition_Eurostat_agent(current_xmachine_Eurostat_holder, Eurostat_Eurostat_Start_Monthly_Loop_state, Eurostat_Eurostat_Start_Quarterly_Loop_state);
			}
		}

		current_xmachine_Eurostat = NULL;

		current_xmachine_Eurostat_holder = temp_xmachine_Eurostat_holder;
	}
	if(FLAME_TEST_PRINT_START_AND_END_OF_MODEL_FUNCTIONS) printf("finish Eurostat_idle\n");


	if(FLAME_TEST_PRINT_START_AND_END_OF_MODEL_FUNCTIONS) printf("start Eurostat_store_history_monthly\n");
	current_xmachine_Eurostat_holder = Eurostat_Eurostat_Start_Monthly_Loop_state->agents;
	while(current_xmachine_Eurostat_holder)
	{
		temp_xmachine_Eurostat_holder = current_xmachine_Eurostat_holder->next;
		current_xmachine_Eurostat = current_xmachine_Eurostat_holder->agent;
		current_xmachine_Eurostat_next_state = Eurostat_02_state;
		/* For backwards compatibility set current_xmachine */
		current_xmachine->xmachine_Firm = NULL;
		current_xmachine->xmachine_Household = NULL;
		current_xmachine->xmachine_Mall = NULL;
		current_xmachine->xmachine_IGFirm = NULL;
		current_xmachine->xmachine_Eurostat = NULL;
		current_xmachine->xmachine_Bank = NULL;
		current_xmachine->xmachine_Government = NULL;
		current_xmachine->xmachine_CentralBank = NULL;
		current_xmachine->xmachine_ClearingHouse = NULL;
		current_xmachine->xmachine_Eurostat = current_xmachine_Eurostat;

		if(FLAME_condition_Eurostat_Eurostat_store_history_monthly_Eurostat_Start_Monthly_Loop_02(current_xmachine_Eurostat)==1)
		{

		

			i = Eurostat_store_history_monthly();

		

			if(i == 1)
			{
				free_Eurostat_agent(current_xmachine_Eurostat_holder, Eurostat_Eurostat_Start_Monthly_Loop_state);
			}
			else
			{
				transition_Eurostat_agent(current_xmachine_Eurostat_holder, Eurostat_Eurostat_Start_Monthly_Loop_state, Eurostat_02_state);
			}
		}

		current_xmachine_Eurostat = NULL;

		current_xmachine_Eurostat_holder = temp_xmachine_Eurostat_holder;
	}
	if(FLAME_TEST_PRINT_START_AND_END_OF_MODEL_FUNCTIONS) printf("finish Eurostat_store_history_monthly\n");


/* End of layer number 108 */

/* Clear message boards that have finished being used
 * and sync complete if doing late sync complete */


	if(FLAME_TEST_PRINT_START_AND_END_OF_MODEL_FUNCTIONS) printf("start Eurostat_compute_growth_rates_monthly\n");
	current_xmachine_Eurostat_holder = Eurostat_02_state->agents;
	while(current_xmachine_Eurostat_holder)
	{
		temp_xmachine_Eurostat_holder = current_xmachine_Eurostat_holder->next;
		current_xmachine_Eurostat = current_xmachine_Eurostat_holder->agent;
		current_xmachine_Eurostat_next_state = Eurostat_Eurostat_Start_Quarterly_Loop_state;
		/* For backwards compatibility set current_xmachine */
		current_xmachine->xmachine_Firm = NULL;
		current_xmachine->xmachine_Household = NULL;
		current_xmachine->xmachine_Mall = NULL;
		current_xmachine->xmachine_IGFirm = NULL;
		current_xmachine->xmachine_Eurostat = NULL;
		current_xmachine->xmachine_Bank = NULL;
		current_xmachine->xmachine_Government = NULL;
		current_xmachine->xmachine_CentralBank = NULL;
		current_xmachine->xmachine_ClearingHouse = NULL;
		current_xmachine->xmachine_Eurostat = current_xmachine_Eurostat;

		

		

			i = Eurostat_compute_growth_rates_monthly();

		

			if(i == 1)
			{
				free_Eurostat_agent(current_xmachine_Eurostat_holder, Eurostat_02_state);
			}
			else
			{
				transition_Eurostat_agent(current_xmachine_Eurostat_holder, Eurostat_02_state, Eurostat_Eurostat_Start_Quarterly_Loop_state);
			}
		

		current_xmachine_Eurostat = NULL;

		current_xmachine_Eurostat_holder = temp_xmachine_Eurostat_holder;
	}
	if(FLAME_TEST_PRINT_START_AND_END_OF_MODEL_FUNCTIONS) printf("finish Eurostat_compute_growth_rates_monthly\n");


/* End of layer number 109 */

/* Clear message boards that have finished being used
 * and sync complete if doing late sync complete */


	if(FLAME_TEST_PRINT_START_AND_END_OF_MODEL_FUNCTIONS) printf("start Eurostat_idle\n");
	current_xmachine_Eurostat_holder = Eurostat_Eurostat_Start_Quarterly_Loop_state->agents;
	while(current_xmachine_Eurostat_holder)
	{
		temp_xmachine_Eurostat_holder = current_xmachine_Eurostat_holder->next;
		current_xmachine_Eurostat = current_xmachine_Eurostat_holder->agent;
		current_xmachine_Eurostat_next_state = Eurostat_Eurostat_Start_EndOfYear_Loop_state;
		/* For backwards compatibility set current_xmachine */
		current_xmachine->xmachine_Firm = NULL;
		current_xmachine->xmachine_Household = NULL;
		current_xmachine->xmachine_Mall = NULL;
		current_xmachine->xmachine_IGFirm = NULL;
		current_xmachine->xmachine_Eurostat = NULL;
		current_xmachine->xmachine_Bank = NULL;
		current_xmachine->xmachine_Government = NULL;
		current_xmachine->xmachine_CentralBank = NULL;
		current_xmachine->xmachine_ClearingHouse = NULL;
		current_xmachine->xmachine_Eurostat = current_xmachine_Eurostat;

		if(FLAME_condition_Eurostat_Eurostat_idle_Eurostat_Start_Quarterly_Loop_Eurostat_Start_EndOfYear_Loop(current_xmachine_Eurostat)==1)
		{

		

			i = Eurostat_idle();

		

			if(i == 1)
			{
				free_Eurostat_agent(current_xmachine_Eurostat_holder, Eurostat_Eurostat_Start_Quarterly_Loop_state);
			}
			else
			{
				transition_Eurostat_agent(current_xmachine_Eurostat_holder, Eurostat_Eurostat_Start_Quarterly_Loop_state, Eurostat_Eurostat_Start_EndOfYear_Loop_state);
			}
		}

		current_xmachine_Eurostat = NULL;

		current_xmachine_Eurostat_holder = temp_xmachine_Eurostat_holder;
	}
	if(FLAME_TEST_PRINT_START_AND_END_OF_MODEL_FUNCTIONS) printf("finish Eurostat_idle\n");


	if(FLAME_TEST_PRINT_START_AND_END_OF_MODEL_FUNCTIONS) printf("start Eurostat_store_history_quarterly\n");
	current_xmachine_Eurostat_holder = Eurostat_Eurostat_Start_Quarterly_Loop_state->agents;
	while(current_xmachine_Eurostat_holder)
	{
		temp_xmachine_Eurostat_holder = current_xmachine_Eurostat_holder->next;
		current_xmachine_Eurostat = current_xmachine_Eurostat_holder->agent;
		current_xmachine_Eurostat_next_state = Eurostat_04_state;
		/* For backwards compatibility set current_xmachine */
		current_xmachine->xmachine_Firm = NULL;
		current_xmachine->xmachine_Household = NULL;
		current_xmachine->xmachine_Mall = NULL;
		current_xmachine->xmachine_IGFirm = NULL;
		current_xmachine->xmachine_Eurostat = NULL;
		current_xmachine->xmachine_Bank = NULL;
		current_xmachine->xmachine_Government = NULL;
		current_xmachine->xmachine_CentralBank = NULL;
		current_xmachine->xmachine_ClearingHouse = NULL;
		current_xmachine->xmachine_Eurostat = current_xmachine_Eurostat;

		if(FLAME_condition_Eurostat_Eurostat_store_history_quarterly_Eurostat_Start_Quarterly_Loop_04(current_xmachine_Eurostat)==1)
		{

		

			i = Eurostat_store_history_quarterly();

		

			if(i == 1)
			{
				free_Eurostat_agent(current_xmachine_Eurostat_holder, Eurostat_Eurostat_Start_Quarterly_Loop_state);
			}
			else
			{
				transition_Eurostat_agent(current_xmachine_Eurostat_holder, Eurostat_Eurostat_Start_Quarterly_Loop_state, Eurostat_04_state);
			}
		}

		current_xmachine_Eurostat = NULL;

		current_xmachine_Eurostat_holder = temp_xmachine_Eurostat_holder;
	}
	if(FLAME_TEST_PRINT_START_AND_END_OF_MODEL_FUNCTIONS) printf("finish Eurostat_store_history_quarterly\n");


/* End of layer number 110 */

/* Clear message boards that have finished being used
 * and sync complete if doing late sync complete */


	if(FLAME_TEST_PRINT_START_AND_END_OF_MODEL_FUNCTIONS) printf("start Eurostat_compute_growth_rates_quarterly\n");
	current_xmachine_Eurostat_holder = Eurostat_04_state->agents;
	while(current_xmachine_Eurostat_holder)
	{
		temp_xmachine_Eurostat_holder = current_xmachine_Eurostat_holder->next;
		current_xmachine_Eurostat = current_xmachine_Eurostat_holder->agent;
		current_xmachine_Eurostat_next_state = Eurostat_05_state;
		/* For backwards compatibility set current_xmachine */
		current_xmachine->xmachine_Firm = NULL;
		current_xmachine->xmachine_Household = NULL;
		current_xmachine->xmachine_Mall = NULL;
		current_xmachine->xmachine_IGFirm = NULL;
		current_xmachine->xmachine_Eurostat = NULL;
		current_xmachine->xmachine_Bank = NULL;
		current_xmachine->xmachine_Government = NULL;
		current_xmachine->xmachine_CentralBank = NULL;
		current_xmachine->xmachine_ClearingHouse = NULL;
		current_xmachine->xmachine_Eurostat = current_xmachine_Eurostat;

		

		

			i = Eurostat_compute_growth_rates_quarterly();

		

			if(i == 1)
			{
				free_Eurostat_agent(current_xmachine_Eurostat_holder, Eurostat_04_state);
			}
			else
			{
				transition_Eurostat_agent(current_xmachine_Eurostat_holder, Eurostat_04_state, Eurostat_05_state);
			}
		

		current_xmachine_Eurostat = NULL;

		current_xmachine_Eurostat_holder = temp_xmachine_Eurostat_holder;
	}
	if(FLAME_TEST_PRINT_START_AND_END_OF_MODEL_FUNCTIONS) printf("finish Eurostat_compute_growth_rates_quarterly\n");


/* End of layer number 111 */

/* Clear message boards that have finished being used
 * and sync complete if doing late sync complete */


	if(FLAME_TEST_PRINT_START_AND_END_OF_MODEL_FUNCTIONS) printf("start Eurostat_measure_recession\n");
	current_xmachine_Eurostat_holder = Eurostat_05_state->agents;
	while(current_xmachine_Eurostat_holder)
	{
		temp_xmachine_Eurostat_holder = current_xmachine_Eurostat_holder->next;
		current_xmachine_Eurostat = current_xmachine_Eurostat_holder->agent;
		current_xmachine_Eurostat_next_state = Eurostat_Eurostat_Start_EndOfYear_Loop_state;
		/* For backwards compatibility set current_xmachine */
		current_xmachine->xmachine_Firm = NULL;
		current_xmachine->xmachine_Household = NULL;
		current_xmachine->xmachine_Mall = NULL;
		current_xmachine->xmachine_IGFirm = NULL;
		current_xmachine->xmachine_Eurostat = NULL;
		current_xmachine->xmachine_Bank = NULL;
		current_xmachine->xmachine_Government = NULL;
		current_xmachine->xmachine_CentralBank = NULL;
		current_xmachine->xmachine_ClearingHouse = NULL;
		current_xmachine->xmachine_Eurostat = current_xmachine_Eurostat;

		

		

			i = Eurostat_measure_recession();

		

			if(i == 1)
			{
				free_Eurostat_agent(current_xmachine_Eurostat_holder, Eurostat_05_state);
			}
			else
			{
				transition_Eurostat_agent(current_xmachine_Eurostat_holder, Eurostat_05_state, Eurostat_Eurostat_Start_EndOfYear_Loop_state);
			}
		

		current_xmachine_Eurostat = NULL;

		current_xmachine_Eurostat_holder = temp_xmachine_Eurostat_holder;
	}
	if(FLAME_TEST_PRINT_START_AND_END_OF_MODEL_FUNCTIONS) printf("finish Eurostat_measure_recession\n");


/* End of layer number 112 */

/* Clear message boards that have finished being used
 * and sync complete if doing late sync complete */


	if(FLAME_TEST_PRINT_START_AND_END_OF_MODEL_FUNCTIONS) printf("start idle\n");
	current_xmachine_Eurostat_holder = Eurostat_Eurostat_Start_EndOfYear_Loop_state->agents;
	while(current_xmachine_Eurostat_holder)
	{
		temp_xmachine_Eurostat_holder = current_xmachine_Eurostat_holder->next;
		current_xmachine_Eurostat = current_xmachine_Eurostat_holder->agent;
		current_xmachine_Eurostat_next_state = Eurostat_end_Eurostat_state;
		/* For backwards compatibility set current_xmachine */
		current_xmachine->xmachine_Firm = NULL;
		current_xmachine->xmachine_Household = NULL;
		current_xmachine->xmachine_Mall = NULL;
		current_xmachine->xmachine_IGFirm = NULL;
		current_xmachine->xmachine_Eurostat = NULL;
		current_xmachine->xmachine_Bank = NULL;
		current_xmachine->xmachine_Government = NULL;
		current_xmachine->xmachine_CentralBank = NULL;
		current_xmachine->xmachine_ClearingHouse = NULL;
		current_xmachine->xmachine_Eurostat = current_xmachine_Eurostat;

		if(FLAME_condition_Eurostat_idle_Eurostat_Start_EndOfYear_Loop_end_Eurostat(current_xmachine_Eurostat)==1)
		{

		

			i = idle();

		

			if(i == 1)
			{
				free_Eurostat_agent(current_xmachine_Eurostat_holder, Eurostat_Eurostat_Start_EndOfYear_Loop_state);
			}
			else
			{
				transition_Eurostat_agent(current_xmachine_Eurostat_holder, Eurostat_Eurostat_Start_EndOfYear_Loop_state, Eurostat_end_Eurostat_state);
			}
		}

		current_xmachine_Eurostat = NULL;

		current_xmachine_Eurostat_holder = temp_xmachine_Eurostat_holder;
	}
	if(FLAME_TEST_PRINT_START_AND_END_OF_MODEL_FUNCTIONS) printf("finish idle\n");


	if(FLAME_TEST_PRINT_START_AND_END_OF_MODEL_FUNCTIONS) printf("start Eurostat_idle\n");
	current_xmachine_Eurostat_holder = Eurostat_Eurostat_Start_EndOfYear_Loop_state->agents;
	while(current_xmachine_Eurostat_holder)
	{
		temp_xmachine_Eurostat_holder = current_xmachine_Eurostat_holder->next;
		current_xmachine_Eurostat = current_xmachine_Eurostat_holder->agent;
		current_xmachine_Eurostat_next_state = Eurostat_end_Eurostat_state;
		/* For backwards compatibility set current_xmachine */
		current_xmachine->xmachine_Firm = NULL;
		current_xmachine->xmachine_Household = NULL;
		current_xmachine->xmachine_Mall = NULL;
		current_xmachine->xmachine_IGFirm = NULL;
		current_xmachine->xmachine_Eurostat = NULL;
		current_xmachine->xmachine_Bank = NULL;
		current_xmachine->xmachine_Government = NULL;
		current_xmachine->xmachine_CentralBank = NULL;
		current_xmachine->xmachine_ClearingHouse = NULL;
		current_xmachine->xmachine_Eurostat = current_xmachine_Eurostat;

		if(FLAME_condition_Eurostat_Eurostat_idle_Eurostat_Start_EndOfYear_Loop_end_Eurostat(current_xmachine_Eurostat)==1)
		{

		

			i = Eurostat_idle();

		

			if(i == 1)
			{
				free_Eurostat_agent(current_xmachine_Eurostat_holder, Eurostat_Eurostat_Start_EndOfYear_Loop_state);
			}
			else
			{
				transition_Eurostat_agent(current_xmachine_Eurostat_holder, Eurostat_Eurostat_Start_EndOfYear_Loop_state, Eurostat_end_Eurostat_state);
			}
		}

		current_xmachine_Eurostat = NULL;

		current_xmachine_Eurostat_holder = temp_xmachine_Eurostat_holder;
	}
	if(FLAME_TEST_PRINT_START_AND_END_OF_MODEL_FUNCTIONS) printf("finish Eurostat_idle\n");


/* End of layer number 113 */

/* Clear message boards that have finished being used
 * and sync complete if doing late sync complete */


	if(iteration_loop%output_frequency == output_offset)
	{
		saveiterationdata(iteration_loop);
	}

	/*printf("Firm_MR_01_state->count = %d\n", Firm_MR_01_state->count);*/
	Firm_MR_01_state->count = 0;

	/*printf("Firm_MR_03_state->count = %d\n", Firm_MR_03_state->count);*/
	Firm_MR_03_state->count = 0;

	/*printf("Firm_MR_02_state->count = %d\n", Firm_MR_02_state->count);*/
	Firm_MR_02_state->count = 0;

	/*printf("Firm_MR_6_state->count = %d\n", Firm_MR_6_state->count);*/
	Firm_MR_6_state->count = 0;

	/*printf("Firm_MR_5_state->count = %d\n", Firm_MR_5_state->count);*/
	Firm_MR_5_state->count = 0;

	/*printf("Firm_MR_4a_state->count = %d\n", Firm_MR_4a_state->count);*/
	Firm_MR_4a_state->count = 0;

	/*printf("Firm_MR_4_state->count = %d\n", Firm_MR_4_state->count);*/
	Firm_MR_4_state->count = 0;

	/*printf("Firm_MR_3_state->count = %d\n", Firm_MR_3_state->count);*/
	Firm_MR_3_state->count = 0;

	/*printf("Firm_MR_2_state->count = %d\n", Firm_MR_2_state->count);*/
	Firm_MR_2_state->count = 0;

	/*printf("Firm_MR_1_state->count = %d\n", Firm_MR_1_state->count);*/
	Firm_MR_1_state->count = 0;

	/*printf("Firm_MR_0_state->count = %d\n", Firm_MR_0_state->count);*/
	Firm_MR_0_state->count = 0;

	/*printf("Firm_end_Firm_state->count = %d\n", Firm_end_Firm_state->count);*/
	Firm_end_Firm_state->count = 0;

	/*printf("Firm_Firm_Send_Data_state->count = %d\n", Firm_Firm_Send_Data_state->count);*/
	Firm_Firm_Send_Data_state->count = 0;

	/*printf("Firm_Firm_Start_Market_Research_Role_state->count = %d\n", Firm_Firm_Start_Market_Research_Role_state->count);*/
	Firm_Firm_Start_Market_Research_Role_state->count = 0;

	/*printf("Firm_Firm_init_01_state->count = %d\n", Firm_Firm_init_01_state->count);*/
	Firm_Firm_init_01_state->count = 0;

	/*printf("Firm_Firm_reset_state->count = %d\n", Firm_Firm_reset_state->count);*/
	Firm_Firm_reset_state->count = 0;

	/*printf("Firm_Firm_initialize_state->count = %d\n", Firm_Firm_initialize_state->count);*/
	Firm_Firm_initialize_state->count = 0;

	/*printf("Firm_start_Firm_state->count = %d\n", Firm_start_Firm_state->count);*/
	Firm_start_Firm_state->count = 0;

	/*printf("Firm_10_state->count = %d\n", Firm_10_state->count);*/
	Firm_10_state->count = 0;

	/*printf("Firm_09b_state->count = %d\n", Firm_09b_state->count);*/
	Firm_09b_state->count = 0;

	/*printf("Firm_08_state->count = %d\n", Firm_08_state->count);*/
	Firm_08_state->count = 0;

	/*printf("Firm_07_state->count = %d\n", Firm_07_state->count);*/
	Firm_07_state->count = 0;

	/*printf("Firm_09a_state->count = %d\n", Firm_09a_state->count);*/
	Firm_09a_state->count = 0;

	/*printf("Firm_06_state->count = %d\n", Firm_06_state->count);*/
	Firm_06_state->count = 0;

	/*printf("Firm_03d_state->count = %d\n", Firm_03d_state->count);*/
	Firm_03d_state->count = 0;

	/*printf("Firm_03c_state->count = %d\n", Firm_03c_state->count);*/
	Firm_03c_state->count = 0;

	/*printf("Firm_09c_state->count = %d\n", Firm_09c_state->count);*/
	Firm_09c_state->count = 0;

	/*printf("Firm_05b_state->count = %d\n", Firm_05b_state->count);*/
	Firm_05b_state->count = 0;

	/*printf("Firm_05a_state->count = %d\n", Firm_05a_state->count);*/
	Firm_05a_state->count = 0;

	/*printf("Firm_04_state->count = %d\n", Firm_04_state->count);*/
	Firm_04_state->count = 0;

	/*printf("Firm_03ccc_state->count = %d\n", Firm_03ccc_state->count);*/
	Firm_03ccc_state->count = 0;

	/*printf("Firm_03_state->count = %d\n", Firm_03_state->count);*/
	Firm_03_state->count = 0;

	/*printf("Firm_04ccc_state->count = %d\n", Firm_04ccc_state->count);*/
	Firm_04ccc_state->count = 0;

	/*printf("Firm_011_state->count = %d\n", Firm_011_state->count);*/
	Firm_011_state->count = 0;

	/*printf("Firm_011a_state->count = %d\n", Firm_011a_state->count);*/
	Firm_011a_state->count = 0;

	/*printf("Firm_16_state->count = %d\n", Firm_16_state->count);*/
	Firm_16_state->count = 0;

	/*printf("Firm_15_state->count = %d\n", Firm_15_state->count);*/
	Firm_15_state->count = 0;

	/*printf("Firm_Firm_End_Branches_state->count = %d\n", Firm_Firm_End_Branches_state->count);*/
	Firm_Firm_End_Branches_state->count = 0;

	/*printf("Firm_Firm_bankruptcy_state_4_state->count = %d\n", Firm_Firm_bankruptcy_state_4_state->count);*/
	Firm_Firm_bankruptcy_state_4_state->count = 0;

	/*printf("Firm_Firm_is_active_state->count = %d\n", Firm_Firm_is_active_state->count);*/
	Firm_Firm_is_active_state->count = 0;

	/*printf("Firm_Firm_bankruptcy_state_1_state->count = %d\n", Firm_Firm_bankruptcy_state_1_state->count);*/
	Firm_Firm_bankruptcy_state_1_state->count = 0;

	/*printf("Firm_Firm_bankruptcy_state_01_state->count = %d\n", Firm_Firm_bankruptcy_state_01_state->count);*/
	Firm_Firm_bankruptcy_state_01_state->count = 0;

	/*printf("Firm_Firm_bankruptcy_state_0_state->count = %d\n", Firm_Firm_bankruptcy_state_0_state->count);*/
	Firm_Firm_bankruptcy_state_0_state->count = 0;

	/*printf("Firm_Firm_not_active_state->count = %d\n", Firm_Firm_not_active_state->count);*/
	Firm_Firm_not_active_state->count = 0;

	/*printf("Firm_005_state->count = %d\n", Firm_005_state->count);*/
	Firm_005_state->count = 0;

	/*printf("Firm_Firm_End_External_Financing_state->count = %d\n", Firm_Firm_End_External_Financing_state->count);*/
	Firm_Firm_End_External_Financing_state->count = 0;

	/*printf("Firm_Firm_resolve_financial_crisis_state->count = %d\n", Firm_Firm_resolve_financial_crisis_state->count);*/
	Firm_Firm_resolve_financial_crisis_state->count = 0;

	/*printf("Firm_Firm_checks_financial_crisis_state->count = %d\n", Firm_Firm_checks_financial_crisis_state->count);*/
	Firm_Firm_checks_financial_crisis_state->count = 0;

	/*printf("Firm_Firm_variables_reset2_state->count = %d\n", Firm_Firm_variables_reset2_state->count);*/
	Firm_Firm_variables_reset2_state->count = 0;

	/*printf("Firm_Firm_bankruptcy_checked_state->count = %d\n", Firm_Firm_bankruptcy_checked_state->count);*/
	Firm_Firm_bankruptcy_checked_state->count = 0;

	/*printf("Firm_02b_state->count = %d\n", Firm_02b_state->count);*/
	Firm_02b_state->count = 0;

	/*printf("Firm_Firm_variables_reset_state->count = %d\n", Firm_Firm_variables_reset_state->count);*/
	Firm_Firm_variables_reset_state->count = 0;

	/*printf("Firm_Firm_Bankruptcy_check_state->count = %d\n", Firm_Firm_Bankruptcy_check_state->count);*/
	Firm_Firm_Bankruptcy_check_state->count = 0;

	/*printf("Firm_004_state->count = %d\n", Firm_004_state->count);*/
	Firm_004_state->count = 0;

	/*printf("Firm_003_state->count = %d\n", Firm_003_state->count);*/
	Firm_003_state->count = 0;

	/*printf("Firm_002_state->count = %d\n", Firm_002_state->count);*/
	Firm_002_state->count = 0;

	/*printf("Firm_001_state->count = %d\n", Firm_001_state->count);*/
	Firm_001_state->count = 0;

	/*printf("Firm_Firm_End_Public_Sector_Role_state->count = %d\n", Firm_Firm_End_Public_Sector_Role_state->count);*/
	Firm_Firm_End_Public_Sector_Role_state->count = 0;

	/*printf("Firm_Firm_End_Credit_Role_state->count = %d\n", Firm_Firm_End_Credit_Role_state->count);*/
	Firm_Firm_End_Credit_Role_state->count = 0;

	/*printf("Firm_Firm_Credit_02_state->count = %d\n", Firm_Firm_Credit_02_state->count);*/
	Firm_Firm_Credit_02_state->count = 0;

	/*printf("Firm_Firm_Start_Credit_Role_state->count = %d\n", Firm_Firm_Start_Credit_Role_state->count);*/
	Firm_Firm_Start_Credit_Role_state->count = 0;

	/*printf("Firm_Firm_checks_if_active_state->count = %d\n", Firm_Firm_checks_if_active_state->count);*/
	Firm_Firm_checks_if_active_state->count = 0;

	/*printf("Firm_Firm_interest_state->count = %d\n", Firm_Firm_interest_state->count);*/
	Firm_Firm_interest_state->count = 0;

	/*printf("Firm_Firm_Start_Financial_Management_Role_state->count = %d\n", Firm_Firm_Start_Financial_Management_Role_state->count);*/
	Firm_Firm_Start_Financial_Management_Role_state->count = 0;

	/*printf("Firm_Firm_End_Financial_Management_Role_state->count = %d\n", Firm_Firm_End_Financial_Management_Role_state->count);*/
	Firm_Firm_End_Financial_Management_Role_state->count = 0;

	/*printf("Firm_14_state->count = %d\n", Firm_14_state->count);*/
	Firm_14_state->count = 0;

	/*printf("Firm_Firm_End_Seller_Role_state->count = %d\n", Firm_Firm_End_Seller_Role_state->count);*/
	Firm_Firm_End_Seller_Role_state->count = 0;

	/*printf("Firm_Firm_Start_Seller_Role_state->count = %d\n", Firm_Firm_Start_Seller_Role_state->count);*/
	Firm_Firm_Start_Seller_Role_state->count = 0;

	/*printf("Firm_12_state->count = %d\n", Firm_12_state->count);*/
	Firm_12_state->count = 0;

	/*printf("Firm_11_state->count = %d\n", Firm_11_state->count);*/
	Firm_11_state->count = 0;

	/*printf("Firm_11b_state->count = %d\n", Firm_11b_state->count);*/
	Firm_11b_state->count = 0;

	/*printf("Firm_11a_state->count = %d\n", Firm_11a_state->count);*/
	Firm_11a_state->count = 0;

	/*printf("Firm_Firm_End_Labour_Role_state->count = %d\n", Firm_Firm_End_Labour_Role_state->count);*/
	Firm_Firm_End_Labour_Role_state->count = 0;

	/*printf("Firm_Firm_Start_Labour_Role_state->count = %d\n", Firm_Firm_Start_Labour_Role_state->count);*/
	Firm_Firm_Start_Labour_Role_state->count = 0;

	/*printf("Firm_Firm_End_Financial_Management_state->count = %d\n", Firm_Firm_End_Financial_Management_state->count);*/
	Firm_Firm_End_Financial_Management_state->count = 0;

	/*printf("Firm_02_state->count = %d\n", Firm_02_state->count);*/
	Firm_02_state->count = 0;

	/*printf("Firm_00b_state->count = %d\n", Firm_00b_state->count);*/
	Firm_00b_state->count = 0;

	/*printf("Firm_01_state->count = %d\n", Firm_01_state->count);*/
	Firm_01_state->count = 0;

	/*printf("Firm_Firm_Start_Producer_Role_state->count = %d\n", Firm_Firm_Start_Producer_Role_state->count);*/
	Firm_Firm_Start_Producer_Role_state->count = 0;

	/*printf("Household_HH_MR_2_state->count = %d\n", Household_HH_MR_2_state->count);*/
	Household_HH_MR_2_state->count = 0;

	/*printf("Household_HH_MR_1_state->count = %d\n", Household_HH_MR_1_state->count);*/
	Household_HH_MR_1_state->count = 0;

	/*printf("Household_end_Household_state->count = %d\n", Household_end_Household_state->count);*/
	Household_end_Household_state->count = 0;

	/*printf("Household_17_state->count = %d\n", Household_17_state->count);*/
	Household_17_state->count = 0;

	/*printf("Household_Household_Start_Market_Research_Role_state->count = %d\n", Household_Household_Start_Market_Research_Role_state->count);*/
	Household_Household_Start_Market_Research_Role_state->count = 0;

	/*printf("Household_Household_Start_Policy_Data_state->count = %d\n", Household_Household_Start_Policy_Data_state->count);*/
	Household_Household_Start_Policy_Data_state->count = 0;

	/*printf("Household_Pol_01_state->count = %d\n", Household_Pol_01_state->count);*/
	Household_Pol_01_state->count = 0;

	/*printf("Household_Household_Start_Yearly_Loop_Top_state->count = %d\n", Household_Household_Start_Yearly_Loop_Top_state->count);*/
	Household_Household_Start_Yearly_Loop_Top_state->count = 0;

	/*printf("Household_Household_initialize_state->count = %d\n", Household_Household_initialize_state->count);*/
	Household_Household_initialize_state->count = 0;

	/*printf("Household_start_Household_state->count = %d\n", Household_start_Household_state->count);*/
	Household_start_Household_state->count = 0;

	/*printf("Household_08b_state->count = %d\n", Household_08b_state->count);*/
	Household_08b_state->count = 0;

	/*printf("Household_08_state->count = %d\n", Household_08_state->count);*/
	Household_08_state->count = 0;

	/*printf("Household_07_state->count = %d\n", Household_07_state->count);*/
	Household_07_state->count = 0;

	/*printf("Household_06e_state->count = %d\n", Household_06e_state->count);*/
	Household_06e_state->count = 0;

	/*printf("Household_06d_state->count = %d\n", Household_06d_state->count);*/
	Household_06d_state->count = 0;

	/*printf("Household_06c_state->count = %d\n", Household_06c_state->count);*/
	Household_06c_state->count = 0;

	/*printf("Household_06b_state->count = %d\n", Household_06b_state->count);*/
	Household_06b_state->count = 0;

	/*printf("Household_05_state->count = %d\n", Household_05_state->count);*/
	Household_05_state->count = 0;

	/*printf("Household_04_state->count = %d\n", Household_04_state->count);*/
	Household_04_state->count = 0;

	/*printf("Household_03_state->count = %d\n", Household_03_state->count);*/
	Household_03_state->count = 0;

	/*printf("Household_02_state->count = %d\n", Household_02_state->count);*/
	Household_02_state->count = 0;

	/*printf("Household_06_state->count = %d\n", Household_06_state->count);*/
	Household_06_state->count = 0;

	/*printf("Household_01_state->count = %d\n", Household_01_state->count);*/
	Household_01_state->count = 0;

	/*printf("Household_01a_state->count = %d\n", Household_01a_state->count);*/
	Household_01a_state->count = 0;

	/*printf("Household_01d_state->count = %d\n", Household_01d_state->count);*/
	Household_01d_state->count = 0;

	/*printf("Household_Household_Start_Labour_Role_state->count = %d\n", Household_Household_Start_Labour_Role_state->count);*/
	Household_Household_Start_Labour_Role_state->count = 0;

	/*printf("Household_AFM_002_state->count = %d\n", Household_AFM_002_state->count);*/
	Household_AFM_002_state->count = 0;

	/*printf("Household_AFM_001_state->count = %d\n", Household_AFM_001_state->count);*/
	Household_AFM_001_state->count = 0;

	/*printf("Household_AFM_000_state->count = %d\n", Household_AFM_000_state->count);*/
	Household_AFM_000_state->count = 0;

	/*printf("Household_Household_Start_Financial_Market_Role_state->count = %d\n", Household_Household_Start_Financial_Market_Role_state->count);*/
	Household_Household_Start_Financial_Market_Role_state->count = 0;

	/*printf("Household_16_state->count = %d\n", Household_16_state->count);*/
	Household_16_state->count = 0;

	/*printf("Household_12_state->count = %d\n", Household_12_state->count);*/
	Household_12_state->count = 0;

	/*printf("Household_14_state->count = %d\n", Household_14_state->count);*/
	Household_14_state->count = 0;

	/*printf("Household_11_state->count = %d\n", Household_11_state->count);*/
	Household_11_state->count = 0;

	/*printf("Household_10_state->count = %d\n", Household_10_state->count);*/
	Household_10_state->count = 0;

	/*printf("Household_15_state->count = %d\n", Household_15_state->count);*/
	Household_15_state->count = 0;

	/*printf("Household_09_state->count = %d\n", Household_09_state->count);*/
	Household_09_state->count = 0;

	/*printf("Mall_Mall_initialize_state->count = %d\n", Mall_Mall_initialize_state->count);*/
	Mall_Mall_initialize_state->count = 0;

	/*printf("Mall_start_Mall_state->count = %d\n", Mall_start_Mall_state->count);*/
	Mall_start_Mall_state->count = 0;

	/*printf("Mall_end_Mall_state->count = %d\n", Mall_end_Mall_state->count);*/
	Mall_end_Mall_state->count = 0;

	/*printf("Mall_06_state->count = %d\n", Mall_06_state->count);*/
	Mall_06_state->count = 0;

	/*printf("Mall_05a_state->count = %d\n", Mall_05a_state->count);*/
	Mall_05a_state->count = 0;

	/*printf("Mall_05_state->count = %d\n", Mall_05_state->count);*/
	Mall_05_state->count = 0;

	/*printf("Mall_04_state->count = %d\n", Mall_04_state->count);*/
	Mall_04_state->count = 0;

	/*printf("Mall_03_state->count = %d\n", Mall_03_state->count);*/
	Mall_03_state->count = 0;

	/*printf("Mall_02_state->count = %d\n", Mall_02_state->count);*/
	Mall_02_state->count = 0;

	/*printf("Mall_01_state->count = %d\n", Mall_01_state->count);*/
	Mall_01_state->count = 0;

	/*printf("Mall_001_state->count = %d\n", Mall_001_state->count);*/
	Mall_001_state->count = 0;

	/*printf("IGFirm_end_IGFirm_state->count = %d\n", IGFirm_end_IGFirm_state->count);*/
	IGFirm_end_IGFirm_state->count = 0;

	/*printf("IGFirm_IGFirm_Send_Data_state->count = %d\n", IGFirm_IGFirm_Send_Data_state->count);*/
	IGFirm_IGFirm_Send_Data_state->count = 0;

	/*printf("IGFirm_IGFirm_End_Branches_state->count = %d\n", IGFirm_IGFirm_End_Branches_state->count);*/
	IGFirm_IGFirm_End_Branches_state->count = 0;

	/*printf("IGFirm_IGFirm_init_01_state->count = %d\n", IGFirm_IGFirm_init_01_state->count);*/
	IGFirm_IGFirm_init_01_state->count = 0;

	/*printf("IGFirm_IGFirm_start_state->count = %d\n", IGFirm_IGFirm_start_state->count);*/
	IGFirm_IGFirm_start_state->count = 0;

	/*printf("IGFirm_03_state->count = %d\n", IGFirm_03_state->count);*/
	IGFirm_03_state->count = 0;

	/*printf("IGFirm_02_state->count = %d\n", IGFirm_02_state->count);*/
	IGFirm_02_state->count = 0;

	/*printf("IGFirm_01_state->count = %d\n", IGFirm_01_state->count);*/
	IGFirm_01_state->count = 0;

	/*printf("IGFirm_01a_state->count = %d\n", IGFirm_01a_state->count);*/
	IGFirm_01a_state->count = 0;

	/*printf("IGFirm_Start_IGFirm_Productivity_state->count = %d\n", IGFirm_Start_IGFirm_Productivity_state->count);*/
	IGFirm_Start_IGFirm_Productivity_state->count = 0;

	/*printf("IGFirm_07_state->count = %d\n", IGFirm_07_state->count);*/
	IGFirm_07_state->count = 0;

	/*printf("IGFirm_06_state->count = %d\n", IGFirm_06_state->count);*/
	IGFirm_06_state->count = 0;

	/*printf("IGFirm_004_state->count = %d\n", IGFirm_004_state->count);*/
	IGFirm_004_state->count = 0;

	/*printf("IGFirm_003_state->count = %d\n", IGFirm_003_state->count);*/
	IGFirm_003_state->count = 0;

	/*printf("IGFirm_002_state->count = %d\n", IGFirm_002_state->count);*/
	IGFirm_002_state->count = 0;

	/*printf("IGFirm_IGFirm_End_Public_Sector_Role_state->count = %d\n", IGFirm_IGFirm_End_Public_Sector_Role_state->count);*/
	IGFirm_IGFirm_End_Public_Sector_Role_state->count = 0;

	/*printf("IGFirm_05_state->count = %d\n", IGFirm_05_state->count);*/
	IGFirm_05_state->count = 0;

	/*printf("IGFirm_IGFirm_End_Financial_Management_Role_state->count = %d\n", IGFirm_IGFirm_End_Financial_Management_Role_state->count);*/
	IGFirm_IGFirm_End_Financial_Management_Role_state->count = 0;

	/*printf("IGFirm_IGFirm_Start_Financial_Management_Role_state->count = %d\n", IGFirm_IGFirm_Start_Financial_Management_Role_state->count);*/
	IGFirm_IGFirm_Start_Financial_Management_Role_state->count = 0;

	/*printf("IGFirm_IGFirm_End_Financial_Management_state->count = %d\n", IGFirm_IGFirm_End_Financial_Management_state->count);*/
	IGFirm_IGFirm_End_Financial_Management_state->count = 0;

	/*printf("IGFirm_01kk_state->count = %d\n", IGFirm_01kk_state->count);*/
	IGFirm_01kk_state->count = 0;

	/*printf("IGFirm_IGFirm_is_active_state->count = %d\n", IGFirm_IGFirm_is_active_state->count);*/
	IGFirm_IGFirm_is_active_state->count = 0;

	/*printf("IGFirm_IGFirm_checks_if_active_state->count = %d\n", IGFirm_IGFirm_checks_if_active_state->count);*/
	IGFirm_IGFirm_checks_if_active_state->count = 0;

	/*printf("IGFirm_IGFirm_interest_state->count = %d\n", IGFirm_IGFirm_interest_state->count);*/
	IGFirm_IGFirm_interest_state->count = 0;

	/*printf("Eurostat_start_Eurostat_state->count = %d\n", Eurostat_start_Eurostat_state->count);*/
	Eurostat_start_Eurostat_state->count = 0;

	/*printf("Eurostat_end_Eurostat_state->count = %d\n", Eurostat_end_Eurostat_state->count);*/
	Eurostat_end_Eurostat_state->count = 0;

	/*printf("Eurostat_Eurostat_Start_EndOfYear_Loop_state->count = %d\n", Eurostat_Eurostat_Start_EndOfYear_Loop_state->count);*/
	Eurostat_Eurostat_Start_EndOfYear_Loop_state->count = 0;

	/*printf("Eurostat_05_state->count = %d\n", Eurostat_05_state->count);*/
	Eurostat_05_state->count = 0;

	/*printf("Eurostat_04_state->count = %d\n", Eurostat_04_state->count);*/
	Eurostat_04_state->count = 0;

	/*printf("Eurostat_Eurostat_Start_Quarterly_Loop_state->count = %d\n", Eurostat_Eurostat_Start_Quarterly_Loop_state->count);*/
	Eurostat_Eurostat_Start_Quarterly_Loop_state->count = 0;

	/*printf("Eurostat_02_state->count = %d\n", Eurostat_02_state->count);*/
	Eurostat_02_state->count = 0;

	/*printf("Eurostat_Eurostat_Start_Monthly_Loop_state->count = %d\n", Eurostat_Eurostat_Start_Monthly_Loop_state->count);*/
	Eurostat_Eurostat_Start_Monthly_Loop_state->count = 0;

	/*printf("Eurostat_01_state->count = %d\n", Eurostat_01_state->count);*/
	Eurostat_01_state->count = 0;

	/*printf("Eurostat_00_state->count = %d\n", Eurostat_00_state->count);*/
	Eurostat_00_state->count = 0;

	/*printf("Bank_Bank_reset_state->count = %d\n", Bank_Bank_reset_state->count);*/
	Bank_Bank_reset_state->count = 0;

	/*printf("Bank_start_Bank_state->count = %d\n", Bank_start_Bank_state->count);*/
	Bank_start_Bank_state->count = 0;

	/*printf("Bank_end_Bank_state->count = %d\n", Bank_end_Bank_state->count);*/
	Bank_end_Bank_state->count = 0;

	/*printf("Bank_Bank_08_state->count = %d\n", Bank_Bank_08_state->count);*/
	Bank_Bank_08_state->count = 0;

	/*printf("Bank_Bank_07_state->count = %d\n", Bank_Bank_07_state->count);*/
	Bank_Bank_07_state->count = 0;

	/*printf("Bank_Bank_06_state->count = %d\n", Bank_Bank_06_state->count);*/
	Bank_Bank_06_state->count = 0;

	/*printf("Bank_Bank_05_state->count = %d\n", Bank_Bank_05_state->count);*/
	Bank_Bank_05_state->count = 0;

	/*printf("Bank_Bank_04_state->count = %d\n", Bank_Bank_04_state->count);*/
	Bank_Bank_04_state->count = 0;

	/*printf("Bank_Bank_03_state->count = %d\n", Bank_Bank_03_state->count);*/
	Bank_Bank_03_state->count = 0;

	/*printf("Bank_Bank_021_state->count = %d\n", Bank_Bank_021_state->count);*/
	Bank_Bank_021_state->count = 0;

	/*printf("Bank_Bank_02_state->count = %d\n", Bank_Bank_02_state->count);*/
	Bank_Bank_02_state->count = 0;

	/*printf("Bank_Bank_01b_state->count = %d\n", Bank_Bank_01b_state->count);*/
	Bank_Bank_01b_state->count = 0;

	/*printf("Bank_Bank_01_state->count = %d\n", Bank_Bank_01_state->count);*/
	Bank_Bank_01_state->count = 0;

	/*printf("Bank_Bank_start_credit_market_role_state->count = %d\n", Bank_Bank_start_credit_market_role_state->count);*/
	Bank_Bank_start_credit_market_role_state->count = 0;

	/*printf("Bank_Bank_update_policy_rate_state->count = %d\n", Bank_Bank_update_policy_rate_state->count);*/
	Bank_Bank_update_policy_rate_state->count = 0;

	/*printf("Government_end_Government_state->count = %d\n", Government_end_Government_state->count);*/
	Government_end_Government_state->count = 0;

	/*printf("Government_Gov_Start_Yearly_Loop_state->count = %d\n", Government_Gov_Start_Yearly_Loop_state->count);*/
	Government_Gov_Start_Yearly_Loop_state->count = 0;

	/*printf("Government_08_state->count = %d\n", Government_08_state->count);*/
	Government_08_state->count = 0;

	/*printf("Government_07_state->count = %d\n", Government_07_state->count);*/
	Government_07_state->count = 0;

	/*printf("Government_Gov_bonds_decision_state->count = %d\n", Government_Gov_bonds_decision_state->count);*/
	Government_Gov_bonds_decision_state->count = 0;

	/*printf("Government_05a_state->count = %d\n", Government_05a_state->count);*/
	Government_05a_state->count = 0;

	/*printf("Government_06_state->count = %d\n", Government_06_state->count);*/
	Government_06_state->count = 0;

	/*printf("Government_Gov_Start_Monthly_Loop_state->count = %d\n", Government_Gov_Start_Monthly_Loop_state->count);*/
	Government_Gov_Start_Monthly_Loop_state->count = 0;

	/*printf("Government_04_state->count = %d\n", Government_04_state->count);*/
	Government_04_state->count = 0;

	/*printf("Government_03_state->count = %d\n", Government_03_state->count);*/
	Government_03_state->count = 0;

	/*printf("Government_02_state->count = %d\n", Government_02_state->count);*/
	Government_02_state->count = 0;

	/*printf("Government_End_Gov_Consumer_Role_state->count = %d\n", Government_End_Gov_Consumer_Role_state->count);*/
	Government_End_Gov_Consumer_Role_state->count = 0;

	/*printf("Government_Gov_Cons_5_state->count = %d\n", Government_Gov_Cons_5_state->count);*/
	Government_Gov_Cons_5_state->count = 0;

	/*printf("Government_Gov_Cons_4_state->count = %d\n", Government_Gov_Cons_4_state->count);*/
	Government_Gov_Cons_4_state->count = 0;

	/*printf("Government_Gov_Cons_3_state->count = %d\n", Government_Gov_Cons_3_state->count);*/
	Government_Gov_Cons_3_state->count = 0;

	/*printf("Government_Gov_Cons_2_state->count = %d\n", Government_Gov_Cons_2_state->count);*/
	Government_Gov_Cons_2_state->count = 0;

	/*printf("Government_Gov_Cons_1_state->count = %d\n", Government_Gov_Cons_1_state->count);*/
	Government_Gov_Cons_1_state->count = 0;

	/*printf("Government_003b_state->count = %d\n", Government_003b_state->count);*/
	Government_003b_state->count = 0;

	/*printf("Government_003a_state->count = %d\n", Government_003a_state->count);*/
	Government_003a_state->count = 0;

	/*printf("Government_003_state->count = %d\n", Government_003_state->count);*/
	Government_003_state->count = 0;

	/*printf("Government_002_state->count = %d\n", Government_002_state->count);*/
	Government_002_state->count = 0;

	/*printf("Government_Government_Start_Yearly_Loop_Top_state->count = %d\n", Government_Government_Start_Yearly_Loop_Top_state->count);*/
	Government_Government_Start_Yearly_Loop_Top_state->count = 0;

	/*printf("Government_001_state->count = %d\n", Government_001_state->count);*/
	Government_001_state->count = 0;

	/*printf("Government_Government_Start_Monthly_Loop_Top_state->count = %d\n", Government_Government_Start_Monthly_Loop_Top_state->count);*/
	Government_Government_Start_Monthly_Loop_Top_state->count = 0;

	/*printf("Government_start_Government_state->count = %d\n", Government_start_Government_state->count);*/
	Government_start_Government_state->count = 0;

	/*printf("Government_Start_Gov_Consumer_Role_state->count = %d\n", Government_Start_Gov_Consumer_Role_state->count);*/
	Government_Start_Gov_Consumer_Role_state->count = 0;

	/*printf("Government_Gov_Start_Bond_Market_state->count = %d\n", Government_Gov_Start_Bond_Market_state->count);*/
	Government_Gov_Start_Bond_Market_state->count = 0;

	/*printf("CentralBank_CB_financial_operations_end_state->count = %d\n", CentralBank_CB_financial_operations_end_state->count);*/
	CentralBank_CB_financial_operations_end_state->count = 0;

	/*printf("CentralBank_CB_market_operations_state->count = %d\n", CentralBank_CB_market_operations_state->count);*/
	CentralBank_CB_market_operations_state->count = 0;

	/*printf("CentralBank_CB_reset_state->count = %d\n", CentralBank_CB_reset_state->count);*/
	CentralBank_CB_reset_state->count = 0;

	/*printf("CentralBank_start_Central_Bank_state->count = %d\n", CentralBank_start_Central_Bank_state->count);*/
	CentralBank_start_Central_Bank_state->count = 0;

	/*printf("CentralBank_end_Central_Bank_state->count = %d\n", CentralBank_end_Central_Bank_state->count);*/
	CentralBank_end_Central_Bank_state->count = 0;

	/*printf("CentralBank_00_state->count = %d\n", CentralBank_00_state->count);*/
	CentralBank_00_state->count = 0;

	/*printf("ClearingHouse_end_Clearinghouse_state->count = %d\n", ClearingHouse_end_Clearinghouse_state->count);*/
	ClearingHouse_end_Clearinghouse_state->count = 0;

	/*printf("ClearingHouse_AFM_05_state->count = %d\n", ClearingHouse_AFM_05_state->count);*/
	ClearingHouse_AFM_05_state->count = 0;

	/*printf("ClearingHouse_AFM_04_state->count = %d\n", ClearingHouse_AFM_04_state->count);*/
	ClearingHouse_AFM_04_state->count = 0;

	/*printf("ClearingHouse_AFM_03_state->count = %d\n", ClearingHouse_AFM_03_state->count);*/
	ClearingHouse_AFM_03_state->count = 0;

	/*printf("ClearingHouse_AFM_02_state->count = %d\n", ClearingHouse_AFM_02_state->count);*/
	ClearingHouse_AFM_02_state->count = 0;

	/*printf("ClearingHouse_AFM_01_state->count = %d\n", ClearingHouse_AFM_01_state->count);*/
	ClearingHouse_AFM_01_state->count = 0;

	/*printf("ClearingHouse_AFM_00_state->count = %d\n", ClearingHouse_AFM_00_state->count);*/
	ClearingHouse_AFM_00_state->count = 0;

	/*printf("ClearingHouse_start_Clearinghouse_state->count = %d\n", ClearingHouse_start_Clearinghouse_state->count);*/
	ClearingHouse_start_Clearinghouse_state->count = 0;

	/* Move agents to their start states */

	current_xmachine_Firm_holder = Firm_end_Firm_state->agents;
	while(current_xmachine_Firm_holder)
	{
		temp_xmachine_Firm_holder = current_xmachine_Firm_holder->next;
		transition_Firm_agent(current_xmachine_Firm_holder, Firm_end_Firm_state, Firm_start_Firm_state);

		current_xmachine_Firm_holder = temp_xmachine_Firm_holder;
	}

	current_xmachine_Household_holder = Household_end_Household_state->agents;
	while(current_xmachine_Household_holder)
	{
		temp_xmachine_Household_holder = current_xmachine_Household_holder->next;
		transition_Household_agent(current_xmachine_Household_holder, Household_end_Household_state, Household_start_Household_state);

		current_xmachine_Household_holder = temp_xmachine_Household_holder;
	}

	current_xmachine_Mall_holder = Mall_end_Mall_state->agents;
	while(current_xmachine_Mall_holder)
	{
		temp_xmachine_Mall_holder = current_xmachine_Mall_holder->next;
		transition_Mall_agent(current_xmachine_Mall_holder, Mall_end_Mall_state, Mall_start_Mall_state);

		current_xmachine_Mall_holder = temp_xmachine_Mall_holder;
	}

	current_xmachine_IGFirm_holder = IGFirm_end_IGFirm_state->agents;
	while(current_xmachine_IGFirm_holder)
	{
		temp_xmachine_IGFirm_holder = current_xmachine_IGFirm_holder->next;
		transition_IGFirm_agent(current_xmachine_IGFirm_holder, IGFirm_end_IGFirm_state, IGFirm_IGFirm_start_state);

		current_xmachine_IGFirm_holder = temp_xmachine_IGFirm_holder;
	}

	current_xmachine_Eurostat_holder = Eurostat_end_Eurostat_state->agents;
	while(current_xmachine_Eurostat_holder)
	{
		temp_xmachine_Eurostat_holder = current_xmachine_Eurostat_holder->next;
		transition_Eurostat_agent(current_xmachine_Eurostat_holder, Eurostat_end_Eurostat_state, Eurostat_start_Eurostat_state);

		current_xmachine_Eurostat_holder = temp_xmachine_Eurostat_holder;
	}

	current_xmachine_Bank_holder = Bank_end_Bank_state->agents;
	while(current_xmachine_Bank_holder)
	{
		temp_xmachine_Bank_holder = current_xmachine_Bank_holder->next;
		transition_Bank_agent(current_xmachine_Bank_holder, Bank_end_Bank_state, Bank_start_Bank_state);

		current_xmachine_Bank_holder = temp_xmachine_Bank_holder;
	}

	current_xmachine_Government_holder = Government_end_Government_state->agents;
	while(current_xmachine_Government_holder)
	{
		temp_xmachine_Government_holder = current_xmachine_Government_holder->next;
		transition_Government_agent(current_xmachine_Government_holder, Government_end_Government_state, Government_start_Government_state);

		current_xmachine_Government_holder = temp_xmachine_Government_holder;
	}

	current_xmachine_CentralBank_holder = CentralBank_end_Central_Bank_state->agents;
	while(current_xmachine_CentralBank_holder)
	{
		temp_xmachine_CentralBank_holder = current_xmachine_CentralBank_holder->next;
		transition_CentralBank_agent(current_xmachine_CentralBank_holder, CentralBank_end_Central_Bank_state, CentralBank_start_Central_Bank_state);

		current_xmachine_CentralBank_holder = temp_xmachine_CentralBank_holder;
	}

	current_xmachine_ClearingHouse_holder = ClearingHouse_end_Clearinghouse_state->agents;
	while(current_xmachine_ClearingHouse_holder)
	{
		temp_xmachine_ClearingHouse_holder = current_xmachine_ClearingHouse_holder->next;
		transition_ClearingHouse_agent(current_xmachine_ClearingHouse_holder, ClearingHouse_end_Clearinghouse_state, ClearingHouse_start_Clearinghouse_state);

		current_xmachine_ClearingHouse_holder = temp_xmachine_ClearingHouse_holder;
	}


		/* Calculate if any agents need to jump S.P. */
		/* propagate_agents(); */
	/* Save iteration time to log file */

		if((file = fopen(logfilepath, "a"))==NULL)
		{
			printf("Error: cannot open file '%s' for writing\n", logfilepath);
			exit(0);
		}
		(void)fputs("<iteration><no>", file);
		sprintf(data, "%i", iteration_loop);
		(void)fputs(data, file);
		(void)fputs("</no><time>", file);
		sprintf(data, "%d", (int)((get_time() - interval) * 1000) );
		(void)fputs(data, file);
		(void)fputs("</time></iteration>\n", file);
		(void)fclose(file);

	}

    


	/* Free pointer GSL RNG */
	gsl_rng_free(FLAME_GSL_RNG);



	/* Stop timing and print total time */
	stop = get_time();
	total_time = stop - start;
	printf("Execution time - %d:%02d:%03d [mins:secs:msecs]\n",
       (int)(total_time/60), ((int)total_time)%60, (((int)(total_time * 1000.0)) % 1000));

	clean_up(0);

	/* Exit successfully by returning zero to Operating System */
	return 0;
}
